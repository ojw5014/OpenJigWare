//#define _MONSTER_LIB // 몬스터 라이브러리의 사용여부

#define _VIEW_THE_OUTLINE // 물체의 외곽 라인이 보이게 할 것인지 아닌 것인지를 결정

#define _COPY_FLAG
#define _ENABLE_LED_FONT_COLOR
//#define _CHEKING_AUTO_FOR_DYNAMIXEL
//#define _RPM_TEST
//#define _CHANGE_DEFAULT_FROM_ASE_TO_DAT

//#define _ENABLE_LED_FONT_BOLD
//#define _REMOVE GRIDDRAW

//#define _IS_VAR_GRIDDRAW //
//#define _SET_DEFAULT_PERSPECTIVE // 이걸 살리면 Perspective 모드가 기본 모드로 설정
//#define _ENABLE_PERSPECTIVE => IsPerspectiveMode() 로 바뀜

//#define _USE_LOOKAT

//#define _STL_CW
#define _OLD_PROP
#define _DHF_FILE
//#define _GL_FLAT
using System;
using System.Collections.Generic;
//using System.Linq;
using System.Text;
using System.Drawing;

using System.IO;

using Tao.FreeGlut;
using Tao.OpenGl;
using Tao.Platform.Windows;
using System.Windows.Forms;
using System.Drawing.Imaging;
using System.Runtime.InteropServices;
using System.ComponentModel;
using System.Reflection;
using System.Threading;

namespace OpenJigWare
{
    partial class Ojw
    {
        #region SetCursor - Disable
#if false
        [DllImport("user32.dll")]
        public static extern int SetCursor(int hCursor);
        private const int IDC_APPSTARTING   = 32650; // Arrow/Wait 화살표/모래시계 
        private const int IDC_ARROW         = 32512; // 화살표 
        private const int IDC_CROSS         = 32515; // 십자가 
        private const int IDC_HAND          = 32649; // 손 
        private const int IDC_HELP          = 32651; // 도움말 
        private const int IDC_IBEAM         = 32513; // 텍스트(빔) 
        private const int IDC_ICON          = 32641; // 아이콘 
        private const int IDC_NO            = 32648; // 원형 
        private const int IDC_SIZE          = 32640; // 크기조정 
        private const int IDC_SIZEALL       = 32646; // 크기조정 
        private const int IDC_SIZENESW      = 32643; // 좌우 크기조정 
        private const int IDC_SIZENS        = 32645; // 세로 크기조정 
        private const int IDC_SIZENWSE      = 32642; // 좌우 크기조정 
        private const int IDC_SIZEWE        = 32644; //Size Width 가로 크기조정 
        private const int IDC_UPARROW       = 32516; // Arrow(Up)
        private const int IDC_WAIT          = 32541; // Wait 대기
#endif
        #endregion SetCursor
        public class C3d : SimpleOpenGlControl
        {
            //#region Design 파일 오픈 이벤트
            //public delegate void DEventFileOpened_Design();

            //public event DEventFileOpened_Design Event_FileOpened_Design;
            //public void DoEvent()
            //{
            //    if (Event_FileOpened_Designl
            //}
            //#endregion Design 파일 오픈 이벤트

            #region Etc Controls
            #region Motor Controls
            private const int _CNT_LABEL_TOOLMOTOR = 100;
            private const int _CNT_LABEL_TOOLSTATUS = _CNT_LABEL_TOOLMOTOR;
            private const int _CNT_LABEL_TOOLBACKGROUND = _CNT_LABEL_TOOLMOTOR;
            private const int _CNT_LABEL_KINEMATICS = _CNT_LABEL_TOOLMOTOR;
            private Panel m_pnMotor = new Panel();
            private Panel m_pnStatus = new Panel();
            private Panel m_pnBackground = new Panel();
            private Panel m_pnKinematics = new Panel();
            private Label[] m_albTools_Status = new Label[_CNT_LABEL_TOOLSTATUS];
            private Label[] m_albTools_Background = new Label[_CNT_LABEL_TOOLBACKGROUND];
            private Label[] m_albTools_Kinematics = new Label[_CNT_LABEL_KINEMATICS];
            private Label[] m_albTools_Motor = new Label[_CNT_LABEL_TOOLMOTOR];
            private ComboBox m_cmbAngleLimit = new ComboBox();
            private TextBox m_txtAxisLimit_Up = new TextBox();
            private TextBox m_txtAxisLimit_Down = new TextBox();
            private TextBox m_txtAxisLimit_Id = new TextBox();
            private TextBox m_txtAxisLimit_CenterPos = new TextBox();
            private TextBox m_txtMessage_AxisLimit = new TextBox();

            private TextBox m_txtReserve = new TextBox();

            // Kinematics
            #region Kinematics
            private TextBox m_txtGroupName = new TextBox();
            private ComboBox m_cmbDh = new ComboBox();
            private ComboBox m_cmbSecret = new ComboBox();
            private ComboBox m_cmbKinematicsType = new ComboBox();
            private ComboBox m_cmbPython = new ComboBox();
            private CheckBox m_chkDh = new CheckBox();
            private CheckBox m_chkSkeletonView = new CheckBox();
            private Button m_btnKinematicsCompile = new Button();

            private TabControl m_tabKinematics = new TabControl();
            private TabPage m_tabpgForward = new TabPage("tabpgForward");
            private TabPage m_tabpgInverse = new TabPage("tabpgInverse");
            private TabPage m_tabpgString = new TabPage("tabpgString");
            private TabPage m_tabpgSkeleton = new TabPage("tabpgSkeleton");
            //
            private TextBox m_txtForwardKinematics = new TextBox();
            private TextBox m_txtForwardKinematics_Message = new TextBox();
            private TextBox m_txtInverseKinematics_Message = new TextBox();
            private TextBox m_txtDH_Draw_Size = new TextBox();
            private ComboBox m_cmbDH_AxisDir = new ComboBox();
            private TextBox m_txtDH_Draw_Alpha = new TextBox();
            private TextBox m_txtDH_Draw_Color = new TextBox();
            private Button m_btnDhColor = new Button();
            private Button m_btnCheckDH = new Button();
            private CheckBox m_chkVisible = new CheckBox();
            private TextBox m_txtDH_Caption = new TextBox();

            private TextBox m_txtDH_A = new TextBox();
            private TextBox m_txtDH_D = new TextBox();
            private TextBox m_txtDH_Theta = new TextBox();
            private TextBox m_txtDH_Alpha = new TextBox();
            private TextBox m_txtDH_AxisNum = new TextBox();
            private TextBox m_txtDH_StartGroup = new TextBox();
            private TextBox m_txtDH_Offset_X = new TextBox();
            private TextBox m_txtDH_Offset_Y = new TextBox();
            private TextBox m_txtDH_Offset_Z = new TextBox();
            private ComboBox m_cmbDH_Init = new ComboBox();
            private Button m_btnDHCompile = new Button();
            private TextBox m_txtDhParam = new TextBox();
            ////
            private TextBox m_txtInverseKinematics = new TextBox();
            private ComboBox m_cmbInverseKinematics = new ComboBox();
            private CheckBox m_chkTestObject = new CheckBox();
            private TextBox m_txtTestObjectSize = new TextBox();
            private TextBox m_txtPos_X = new TextBox();
            private TextBox m_txtPos_Y = new TextBox();
            private TextBox m_txtPos_Z = new TextBox();
            private Button m_btnChangePos = new Button();
            private Button m_btnGetForward = new Button();

            private TextBox m_txtKinematicsString = new TextBox();
            private TextBox m_txtKinematicsSkeleton = new TextBox();
            #endregion Kinematics

            public List<int> m_lstIDs_Motion = new List<int>();
            public List<int> m_lstMotorsEn = new List<int>();

            private TextBox m_txtAxis_Mirror = new TextBox();
            private TextBox m_txtAxis_InitAngle = new TextBox();
            private TextBox m_txtAxis_InitAngle2 = new TextBox();
            private TextBox m_txtAxis_MechMov = new TextBox();
            private TextBox m_txtAxis_MechAngle = new TextBox();

            private ComboBox m_cmbMotorDir = new ComboBox();
            private ComboBox m_cmbMotorControlType = new ComboBox();

            private TextBox m_txtGroupNumber = new TextBox();
            private TextBox m_txtAxis_NickName = new TextBox();
            
            private ComboBox m_cmbMotorName = new ComboBox();

            private TextBox m_txtWheel_2 = new TextBox();
            private TextBox m_txtWheel_3 = new TextBox();
            private TextBox m_txtWheel_4 = new TextBox();
            public void m_cmbAxisMotor_SelectedIndexChanged(object sender, EventArgs e)
            {
                if (((System.Windows.Forms.ComboBox)sender) == m_cmbAngleLimit)
                {
                    //MessageBox.Show("kkk");
                    m_txtAxisLimit_Up.Text = Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fLimit_Up, 3));
                    m_txtAxisLimit_Down.Text = Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fLimit_Down, 3));
                    //m_txtAxisLimit_W.Text = Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fW, 3));
                    //m_txtAxisLimit_Left.Text = Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fPos_Left, 3));
                    //m_txtAxisLimit_Right.Text = Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fPos_Right, 3));
                    //m_txtInterference_Axis.Text = Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nInterference_Axis);
                    //m_txtInterference_W.Text = Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fInterference_W, 3));
                    //m_txtInterference_Front.Text = Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fInterference_Pos_Front, 3));
                    //m_txtInterference_Rear.Text = Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fInterference_Pos_Rear, 3));
                    m_txtAxisLimit_Id.Text = Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMotorID);
                    m_txtAxisLimit_CenterPos.Text = Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nCenter_Evd);
                    m_cmbMotorDir.SelectedIndex = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMotorDir;

                    m_txtAxis_InitAngle.Text = Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fInitAngle, 3));
                    m_txtAxis_InitAngle2.Text = Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fInitAngle2, 3));

                    m_txtAxis_MechMov.Text = Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMechMove);
                    m_txtAxis_MechAngle.Text = Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fMechAngle, 3));
                    m_txtAxis_NickName.Text = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].strNickName;

                    m_txtGroupNumber.Text = Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGroupNumber);

                    m_txtAxis_Mirror.Text = Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nAxis_Mirror);

                    string strReserve = String.Format("{0};{1};{2};{3};{4};{5};{6};{7};{8};{9};",
                            Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMotorEnable_For_RPTask) + " // nMotorEnable",
                            Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMotor_Enable),
                            Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMotionEditor_Index), // 0 이면 사용 안함. 1 부터 사용, 0 이상인 경우 여기의 인덱스를 우선적으로 적용, 하나를 세팅했으면 반드시 다른 하나도 세팅할 것
                            Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMotor_HightSpec),
                            Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_4),
                            Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_5),
                            Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_6),
                            Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_7),
                            Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_8),
                            Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_9)
                    );

                    strReserve += String.Format("{0};{1};{2};{3};{4};{5};{6};{7};{8};{9}",
                        Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fGearRatio)) + " // fGearRatio[0 은 기어비 적용 안함]",
                        Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fRobotisConvertingVar)) + " // fRobotisConvertingVar[0 은 적용 안함]",
                        Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_2)),
                        Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_3)),
                        Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_4)),
                        Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_5)),
                        Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_6)),
                        Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_7)),
                        Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_8)),
                        Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_9))
                        );

                    if (m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].afGuide_Pos == null)
                    {
                        m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].afGuide_Pos = new float[6];
                        m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_IDs = new int[6];
                        m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_Dir = new int[6];
                        Array.Clear(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].afGuide_Pos, 0, m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].afGuide_Pos.Length);
                        Array.Clear(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_IDs, 0, m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_IDs.Length);
                        Array.Clear(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_Dir, 0, m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_Dir.Length);
                    }
                    strReserve += String.Format("{0};{1};{2};{3};{4};{5};{6};{7};{8},{9},{10},{11},{12},{13};{14},{15},{16},{17},{18},{19};{20},{21},{22},{23},{24},{25}",
                        Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGuide_Event),
                        Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGuide_AxisType),
                        Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGuide_RingColorType),                        
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fGuide_RingSize),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fGuide_RingThick),                        
                        Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGuide_RingDir),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fGuide_3D_Scale),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fGuide_3D_Alpha),
                        
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].afGuide_Pos[0]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].afGuide_Pos[1]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].afGuide_Pos[2]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].afGuide_Pos[3]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].afGuide_Pos[4]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].afGuide_Pos[5]),
                        
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_IDs[0]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_IDs[1]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_IDs[2]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_IDs[3]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_IDs[4]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_IDs[5]),
                        
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_Dir[0]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_Dir[1]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_Dir[2]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_Dir[3]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_Dir[4]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_Dir[5])
                        );
                    m_txtReserve.Text = String.Empty;
                    foreach(string strLine in strReserve.Split(';'))
                    {
                        m_txtReserve.Text += strLine + "\r\n";
                    }

                    try
                    {
                        m_cmbMotorControlType.SelectedIndex = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMotorControlType;// % 2;
                    }
                    catch (Exception ex)
                    {
                        CMessage.Write_Error("Data Error-{0}", ex.ToString());
                        m_cmbMotorControlType.SelectedIndex = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMotorControlType % m_cmbMotorControlType.Items.Count;
                    }

                    m_cmbMotorName.SelectedIndex = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nHwMotor_Index;
                }
                else if (((System.Windows.Forms.ComboBox)sender) == m_cmbMotorDir)
                {
                    if (m_cmbMotorDir.Focused == true) m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMotorDir = m_cmbMotorDir.SelectedIndex;
                }
                else if (((System.Windows.Forms.ComboBox)sender) == m_cmbMotorControlType)
                {
                    if (m_cmbMotorControlType.Focused == true) m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMotorControlType = m_cmbMotorControlType.SelectedIndex;
                }
                else if (((System.Windows.Forms.ComboBox)sender) == m_cmbMotorName)
                {
                    if ((m_cmbMotorName.Focused == true) && (m_cmbAngleLimit.SelectedIndex >= 0))
                    {

                        m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nHwMotor_Index = m_cmbMotorName.SelectedIndex;
                        if (m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nHwMotor_Index > 0)
                        {
#if !_MONSTER_LIB
                            m_CRobotis.SetParam(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nHwMotor_Index);
#else
                            m_CMonster.SetParam(m_cmbAngleLimit.SelectedIndex, (Ojw.CMonster2.EMonster_t)m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nHwMotor_Index);
#endif
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fRpm = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fRpm;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nLimitRpm_Raw = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nLimitRpm_Raw;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nProtocolVersion = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nProtocolVersion;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nHwMotor_Index = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nHwMotor_Index;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nHwMotor_Key = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nHwMotor_Key;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nAddr_Max = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nAddr_Max;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nAddr_Torq = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nAddr_Torq;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nAddr_Led = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nAddr_Led;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nAddr_Mode = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nAddr_Mode;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nAddr_Speed = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nAddr_Speed;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nAddr_Speed_Size = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nAddr_Speed_Size;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nAddr_Pos_Speed = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nAddr_Pos_Speed;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nAddr_Pos_Speed_Size = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nAddr_Pos_Speed_Size;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nAddr_Pos = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nAddr_Pos;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nAddr_Pos_Size = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nAddr_Pos_Size;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nSerialType = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nSerialType;

                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMotorEnable_For_RPTask = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMotorEnable_For_RPTask;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMotor_Enable = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMotor_Enable;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMotionEditor_Index = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMotionEditor_Index;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMotor_HightSpec = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMotor_HightSpec;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_4 = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_4;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_5 = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_5;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_6 = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_6;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_7 = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_7;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_8 = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_8;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_9 = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_9;

                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fGearRatio = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fGearRatio;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fRobotisConvertingVar = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fRobotisConvertingVar;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_2 = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_2;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_3 = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_3;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_4 = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_4;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_5 = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_5;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_6 = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_6;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_7 = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_7;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_8 = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_8;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_9 = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_9;

                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGuide_Event = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGuide_Event;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGuide_AxisType = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGuide_AxisType;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGuide_RingColorType = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGuide_RingColorType;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fGuide_RingSize = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fGuide_RingSize;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fGuide_RingThick = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fGuide_RingThick;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGuide_RingDir = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGuide_RingDir;
                            if (m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGuide_RingDir == 0) m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGuide_RingDir = 1;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fGuide_3D_Scale = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fGuide_3D_Scale;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fGuide_3D_Alpha = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fGuide_3D_Alpha;

                            if (m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].afGuide_Pos == null)
                            {
                                m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].afGuide_Pos = new float[6];
                                m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_IDs = new int[6];
                                m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_Dir = new int[6];
                                Array.Clear(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].afGuide_Pos, 0, m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].afGuide_Pos.Length);
                                Array.Clear(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_IDs, 0, m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_IDs.Length);
                                Array.Clear(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_Dir, 0, m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_Dir.Length);
                            }

                            for (int nGuide = 0; nGuide < 6; nGuide++) m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].afGuide_Pos[nGuide] = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].afGuide_Pos[nGuide];
                            for (int nGuide = 0; nGuide < 6; nGuide++) m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_IDs[nGuide] = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_IDs[nGuide];
                            for (int nGuide = 0; nGuide < 6; nGuide++) m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_Dir[nGuide] = m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_Dir[nGuide];
                        }
                    }
                }
            }

            public void m_txtKinematics_TextChanged(object sender, EventArgs e)
            {
                if ((((System.Windows.Forms.TextBox)sender) == m_txtGroupName) && (m_cmbDh.SelectedIndex >= 0))
                {
                    if ((m_txtGroupName.Focused == true) && (m_cmbDh.SelectedIndex >= 0))
                    {
                        GetHeader_pstrGroupName()[m_cmbDh.SelectedIndex] = m_txtGroupName.Text;
                    }
                }
                else if ((((System.Windows.Forms.TextBox)sender) == m_txtForwardKinematics) && (m_cmbDh.SelectedIndex >= 0))
                {
                    if (m_txtForwardKinematics.Focused == true)
                    {
                        GetHeader_pstrKinematics()[m_cmbDh.SelectedIndex] = m_txtForwardKinematics.Text;

                        byte[] byteData = Encoding.Default.GetBytes(m_txtForwardKinematics.Text);
                        GetHeader_pSEncryptKinematics_encryption()[m_cmbDh.SelectedIndex].byteEncryption = Ojw.CEncryption.Encryption(true, byteData);
                        byteData = null;
                    }
                }
                else if ((((System.Windows.Forms.TextBox)sender) == m_txtInverseKinematics) && (m_cmbDh.SelectedIndex >= 0))
                {
                    if (m_txtInverseKinematics.Focused == true)
                    {
                        GetHeader_pstrInverseKinematics()[m_cmbDh.SelectedIndex] = m_txtInverseKinematics.Text;

                        byte[] byteData = Encoding.Default.GetBytes(m_txtInverseKinematics.Text);
                        GetHeader_pSEncryptInverseKinematics_encryption()[m_cmbDh.SelectedIndex].byteEncryption = Ojw.CEncryption.Encryption(true, byteData);
                        byteData = null;
                    }
                }
                else if (((System.Windows.Forms.TextBox)sender) == m_txtDH_Draw_Size)
                {
                    SetTestDh_Size(Ojw.CConvert.StrToFloat(m_txtDH_Draw_Size.Text)); 
                }
                else if (((System.Windows.Forms.TextBox)sender) == m_txtDH_Draw_Color)
                {
                    SetTestDh_Color(Color.FromArgb(Ojw.CConvert.StrToInt(m_txtDH_Draw_Color.Text)));    
                }
                else if (((System.Windows.Forms.TextBox)sender) == m_txtTestObjectSize)
                {
                    // 테스트 값 입력
                    SetSize_Test(Ojw.CConvert.StrToFloat(m_txtTestObjectSize.Text));
                }
                else if (((System.Windows.Forms.TextBox)sender) == m_txtDH_Caption)
                {
                }
                else if (((System.Windows.Forms.TextBox)sender) == m_txtDH_Draw_Alpha)
                {
                    SetTestDh_Alpha(Ojw.CConvert.StrToFloat(m_txtDH_Draw_Alpha.Text));
                }
                else if (((System.Windows.Forms.TextBox)sender) == m_txtDH_A)
                {
                    m_COjwDhParam.dA = Ojw.CConvert.StrToDouble(m_txtDH_A.Text);
                }
                else if (((System.Windows.Forms.TextBox)sender) == m_txtDH_D)
                {
                    m_COjwDhParam.dD = Ojw.CConvert.StrToDouble(m_txtDH_D.Text);
                }
                else if (((System.Windows.Forms.TextBox)sender) == m_txtDH_Theta)
                {
                    m_COjwDhParam.dTheta = Ojw.CConvert.StrToDouble(m_txtDH_Theta.Text);
                }
                else if (((System.Windows.Forms.TextBox)sender) == m_txtDH_Alpha)
                {
                    m_COjwDhParam.dAlpha = Ojw.CConvert.StrToDouble(m_txtDH_Alpha.Text);
                }
                else if (((System.Windows.Forms.TextBox)sender) == m_txtDH_AxisNum)
                {
                    m_COjwDhParam.nAxisNum = Ojw.CConvert.StrToInt(m_txtDH_AxisNum.Text);
                }
                else if (((System.Windows.Forms.TextBox)sender) == m_txtDH_StartGroup)
                {
                    //m_COjwDhParam.nStartGroup = Ojw.CConvert.StrToInt(m_txtDH_StartGroup.Text);
                }
                else if (((System.Windows.Forms.TextBox)sender) == m_txtDH_Offset_X)
                {
                    //m_COjwDhParam.dOffset_X = Ojw.CConvert.StrToDouble(m_txtDH_Offset_X.Text);
                }
                else if (((System.Windows.Forms.TextBox)sender) == m_txtDH_Offset_Y)
                {
                    //m_COjwDhParam.dOffset_Y = Ojw.CConvert.StrToDouble(m_txtDH_Offset_Y.Text);
                }
                else if (((System.Windows.Forms.TextBox)sender) == m_txtDH_Offset_Z)
                {
                    //m_COjwDhParam.dOffset_Z = Ojw.CConvert.StrToDouble(m_txtDH_Offset_Z.Text);
                }
                else if (((System.Windows.Forms.TextBox)sender) == m_txtDhParam)
                {

                }
            }
            public void m_txtAxisMotor_TextChanged(object sender, EventArgs e)
            {
                // number of the TextBox 
                try
                {
                    //int nIndex = (int)((System.Windows.Forms.TextBox)sender).Tag;
                    //txtArray[nIndex].Text;
                    if (((System.Windows.Forms.TextBox)sender) == m_txtAxisLimit_Id)
                    {
                        if (m_txtAxisLimit_Id.Focused == true) m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMotorID = Ojw.CConvert.StrToInt(m_txtAxisLimit_Id.Text);
                    }
                    else if (((System.Windows.Forms.TextBox)sender) == m_txtAxisLimit_Up)
                    {
                        if (m_txtAxisLimit_Up.Focused == true) m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fLimit_Up = Ojw.CConvert.StrToFloat(m_txtAxisLimit_Up.Text);
                    }
                    else if (((System.Windows.Forms.TextBox)sender) == m_txtAxisLimit_Down)
                    {
                        if (m_txtAxisLimit_Down.Focused == true) m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fLimit_Down = Ojw.CConvert.StrToFloat(m_txtAxisLimit_Down.Text);
                    }
                    else if (((System.Windows.Forms.TextBox)sender) == m_txtAxisLimit_CenterPos)
                    {
                        if (m_txtAxisLimit_CenterPos.Focused == true) m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nCenter_Evd = Ojw.CConvert.StrToInt(m_txtAxisLimit_CenterPos.Text);
                    }
                    else if (((System.Windows.Forms.TextBox)sender) == m_txtMessage_AxisLimit)
                    {
                        
                    }
                    else if (((System.Windows.Forms.TextBox)sender) == m_txtAxis_Mirror)
                    {
                        if (m_txtAxis_Mirror.Focused == true) m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nAxis_Mirror = Ojw.CConvert.StrToInt(m_txtAxis_Mirror.Text);
                    }
                    else if (((System.Windows.Forms.TextBox)sender) == m_txtReserve)
                    {
                        if (m_txtReserve.Focused == true)
                        {
                            List<string> lstLines = new List<string>();
                            foreach (string strLine in m_txtReserve.Lines) { if (strLine.Length > 0) lstLines.Add(Ojw.CConvert.RemoveCaption(strLine, true, true)); }
                            int i = 0;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMotorEnable_For_RPTask = Ojw.CConvert.StrToInt(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMotor_Enable = Ojw.CConvert.StrToInt(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMotionEditor_Index = Ojw.CConvert.StrToInt(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMotor_HightSpec = Ojw.CConvert.StrToInt(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_4 = Ojw.CConvert.StrToInt(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_5 = Ojw.CConvert.StrToInt(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_6 = Ojw.CConvert.StrToInt(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_7 = Ojw.CConvert.StrToInt(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_8 = Ojw.CConvert.StrToInt(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_9 = Ojw.CConvert.StrToInt(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));

                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fGearRatio = Ojw.CConvert.StrToFloat(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fRobotisConvertingVar = Ojw.CConvert.StrToFloat(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++],true,true));
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_2 = Ojw.CConvert.StrToFloat(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_3 = Ojw.CConvert.StrToFloat(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_4 = Ojw.CConvert.StrToFloat(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_5 = Ojw.CConvert.StrToFloat(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_6 = Ojw.CConvert.StrToFloat(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_7 = Ojw.CConvert.StrToFloat(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_8 = Ojw.CConvert.StrToFloat(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_9 = Ojw.CConvert.StrToFloat(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));

                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGuide_Event = Ojw.CConvert.StrToInt(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGuide_AxisType = Ojw.CConvert.StrToInt(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGuide_RingColorType = Ojw.CConvert.StrToInt(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fGuide_RingSize = Ojw.CConvert.StrToFloat(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fGuide_RingThick = Ojw.CConvert.StrToFloat(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGuide_RingDir = Ojw.CConvert.StrToInt(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                            if (m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGuide_RingDir == 0) m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGuide_RingDir = 1;
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fGuide_3D_Scale = Ojw.CConvert.StrToFloat(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                            m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fGuide_3D_Alpha = Ojw.CConvert.StrToFloat(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));

                            if (m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].afGuide_Pos == null)
                            {
                                m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].afGuide_Pos = new float[6];
                                m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_IDs = new int[6];
                                m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_Dir = new int[6];
                                Array.Clear(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].afGuide_Pos, 0, m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].afGuide_Pos.Length);
                                Array.Clear(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_IDs, 0, m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_IDs.Length);
                                Array.Clear(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_Dir, 0, m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_Dir.Length);
                            }
                            string[] pstrItems = m_txtReserve.Lines[i++].Split(',');
                            for (int nGuide = 0; nGuide < 6; nGuide++) m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].afGuide_Pos[nGuide] = Ojw.CConvert.StrToFloat(Ojw.CConvert.RemoveCaption(pstrItems[nGuide], true, true));
                            pstrItems = m_txtReserve.Lines[i++].Split(',');
                            for (int nGuide = 0; nGuide < 6; nGuide++) m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_IDs[nGuide] = Ojw.CConvert.StrToInt(Ojw.CConvert.RemoveCaption(pstrItems[nGuide], true, true));
                            pstrItems = m_txtReserve.Lines[i++].Split(',');
                            for (int nGuide = 0; nGuide < 6; nGuide++) m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_Dir[nGuide] = Ojw.CConvert.StrToInt(Ojw.CConvert.RemoveCaption(pstrItems[nGuide], true, true));
                        }
                    }
                    else if (((System.Windows.Forms.TextBox)sender) == m_txtAxis_InitAngle)
                    {
                        if (m_txtAxis_InitAngle.Focused == true) m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fInitAngle = Ojw.CConvert.StrToFloat(m_txtAxis_InitAngle.Text);
                    }
                    else if (((System.Windows.Forms.TextBox)sender) == m_txtAxis_InitAngle2)
                    {
                        if (m_txtAxis_InitAngle2.Focused == true) m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fInitAngle2 = Ojw.CConvert.StrToFloat(m_txtAxis_InitAngle2.Text);
                    }
                    else if (((System.Windows.Forms.TextBox)sender) == m_txtAxis_MechMov)
                    {
                        if (m_txtAxis_MechMov.Focused == true) m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMechMove = Ojw.CConvert.StrToInt(m_txtAxis_MechMov.Text);
                    }
                    else if (((System.Windows.Forms.TextBox)sender) == m_txtAxis_MechAngle)
                    {
                        if (m_txtAxis_MechAngle.Focused == true) m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fMechAngle = Ojw.CConvert.StrToFloat(m_txtAxis_MechAngle.Text);
                    }
                    else if (((System.Windows.Forms.TextBox)sender) == m_txtGroupNumber)
                    {
                        if (m_txtGroupNumber.Focused == true) m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGroupNumber = Ojw.CConvert.StrToInt(m_txtGroupNumber.Text);
                    }
                    else if (((System.Windows.Forms.TextBox)sender) == m_txtAxis_NickName)
                    {
                        if (m_txtAxis_NickName.Focused == true) m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].strNickName = m_txtAxis_NickName.Text;
                    }
                    else if (((System.Windows.Forms.TextBox)sender) == m_txtWheel_2)
                    {
                        try
                        {
                            m_CHeader.nWheelCounter_2 = Ojw.CConvert.StrToInt(m_txtWheel_2.Text);
                        }
                        catch// (System.Exception ex)
                        {
                        }
                    }
                    else if (((System.Windows.Forms.TextBox)sender) == m_txtWheel_3)
                    {
                        try
                        {
                            m_CHeader.nWheelCounter_3 = Ojw.CConvert.StrToInt(m_txtWheel_3.Text);
                        }
                        catch// (System.Exception ex)
                        {
                        }
                    }
                    else if (((System.Windows.Forms.TextBox)sender) == m_txtWheel_4)
                    {
                        try
                        {
                            m_CHeader.nWheelCounter_4 = Ojw.CConvert.StrToInt(m_txtWheel_4.Text);
                        }
                        catch// (System.Exception ex)
                        {
                        }
                    }
                    //for (int i = 0; i < 100; i++)
                    //{
                    //    if (sender == m_txtAxisLimit_Id) 
                    //    {
                    //        MessageBox.Show("m_txtAxisLimit_Id");
                    //        break;
                    //    }
                    //}
                }
                catch (Exception ex)
                {
                    Ojw.CMessage.Write_Error(ex.ToString());
                }
            }
            //private TextBox 
            private TextBox m_txtObjectName = new TextBox();
            private TextBox m_txtMotorCnt = new TextBox();
            private TextBox m_txtMotorCnt_Message = new TextBox();
            private TextBox m_txtMotorCnt2 = new TextBox();
            public void InitTools_Status(Panel pnStatus)
            {
                int nTop = 10;
                int nLeft = 220;
                int nSeparation = 10;
                int nWidth = pnStatus.Width - nLeft - 20;
                int nLeftLabel = 10;
                int nGap_H = 26;

                int i = 0;
                for (i = 0; i < _CNT_LABEL_TOOLSTATUS; i++)
                {
                    m_albTools_Status[i] = new Label();
                }
                m_pnStatus = pnStatus;

                i = 0;
                Control[] aCtrl = new Control[_CNT_LABEL_TOOLSTATUS]; // 여유롭게 100
                int[] anSeparation = new int[aCtrl.Length];

                aCtrl[i] = m_txtObjectName;
                m_albTools_Status[i].Text = "Object Name";
                anSeparation[i] = nSeparation;
                i++;
                aCtrl[i] = m_txtMotorCnt;
                m_albTools_Status[i].Text = "Motor0 Count";
                i++;
                aCtrl[i] = m_txtMotorCnt_Message;
                m_albTools_Status[i].Text = "Motor1 Count Message";
                i++;
                aCtrl[i] = m_txtMotorCnt2;
                m_albTools_Status[i].Text = "Motor2 Count(Header)";
                i++;

                int nCnt = i;
                //Array.Resize<Control>(ref aCtrl, i);
                //Array.Resize<Label>(ref m_albTools_Status, i);

                int nGap_Separation = 0;
                for (i = 0; i < nCnt; i++)
                {
                    nGap_Separation += anSeparation[i];
                    aCtrl[i].Left = nLeft;
                    aCtrl[i].Top = nTop + nGap_H * i + nGap_Separation;
                    aCtrl[i].Width = nWidth;
                    m_albTools_Status[i].Top = aCtrl[i].Top;
                    m_albTools_Status[i].Left = nLeftLabel;
                    
                    ((TextBox)aCtrl[i]).ReadOnly = true;
                    m_albTools_Status[i].AutoSize = true;

                    //if (aCtrl[i] is TextBox)//(aCtrl[i].Name.IndexOf("m_txt") >= 0)
                    //{
                    //    ((TextBox)aCtrl[i]).TextChanged += new System.EventHandler(m_txtAxisMotor_TextChanged);
                    //}
                    //else if (aCtrl[i] is ComboBox)//(aCtrl[i].Name.IndexOf("m_cmb") >= 0)
                    //{
                    //    ((ComboBox)aCtrl[i]).SelectedIndexChanged += new System.EventHandler(m_cmbAxisMotor_SelectedIndexChanged);
                    //}

                    m_pnStatus.Controls.Add(aCtrl[i]);
                    m_pnStatus.Controls.Add(m_albTools_Status[i]);
                }
                //m_txtObjectName.Text = "Test0";
                //m_txtMotorCnt.Text = "Test1";
                //m_txtMotorCnt_Message.Text = "Test2";
                //m_txtMotorCnt2.Text = "Test3";
                //m_albTools_Status[0].Text = "0";
                //m_albTools_Status[1].Text = "1";
                //m_albTools_Status[2].Text = "2";
                //m_albTools_Status[3].Text = "3";
                //m_bTools_Status = true;
                //InitToolsStatusVar();
            }
            private ComboBox m_cmbModelNum = new ComboBox();
            private TextBox m_txtTitle = new TextBox();
            private Button m_btnBackColor = new Button();
            private TextBox m_txtBackColor = new TextBox();
            public void InitTools_Background(Panel pnBackground)
            {
                m_pnBackground = pnBackground;
            }

            private TextBox [] m_atxtAngle = new TextBox[256];
            private bool m_bTextBox_ForAngle = false;
            public void SetTextboxes_ForAngle(TextBox[] atxtAngle)
            {
                //m_atxtAngle = null;
                m_atxtAngle = atxtAngle;
                if (m_atxtAngle != null) m_bTextBox_ForAngle = true;
            }
            private bool m_bInitKinematicsFunction = false;
            public void InitTools_Kinematics(Panel pnKinematics)
            {
                bool bInit = false;
                if (m_bInitKinematicsFunction == false) bInit = true;
                m_bInitKinematicsFunction = true;
                int i = 0;
                int nItems = 0;
                for (i = 0; i < _CNT_LABEL_TOOLMOTOR; i++)
                {
                    m_albTools_Kinematics[i] = new Label();
                    m_albTools_Kinematics[i].AutoSize = true;
                }
                m_pnKinematics = pnKinematics;

                m_pnKinematics.Size = new Size(940, 778);
                m_pnKinematics.Location = new Point(6, 9);

                i = 0;
                //Control[] aCtrl = new Control[_CNT_LABEL_TOOLMOTOR]; // 여유롭게 100
                //int[] anSeparation = new int[aCtrl.Length];
                //Array.Resize<Control>(ref aCtrl, i + 1);
                //Array.Resize<Label>(ref m_albTools_Motor, i + 1);
                int nDefaultTop = 10;
                int nGapH = 22;
                m_txtGroupName.Left = 175;
                m_txtGroupName.Top = nDefaultTop + i * nGapH;
                m_txtGroupName.Width = 300;
                m_albTools_Kinematics[nItems].Top = m_txtGroupName.Top;
                m_albTools_Kinematics[nItems].Left = 10;
                m_albTools_Kinematics[nItems].Text = "Function Name(Caption)";
                m_pnKinematics.Controls.Add(m_txtGroupName);
                m_pnKinematics.Controls.Add(m_albTools_Kinematics[nItems]);
                // Event
                if (bInit == true) m_txtGroupName.TextChanged += new System.EventHandler(m_txtKinematics_TextChanged);
                //
                i++; nItems++;

                m_cmbDh.Items.Clear();
                for (int j = 0; j < 512; j++)
                {
                    m_cmbDh.Items.Add(j.ToString());
                }
                m_cmbDh.SelectedIndex = 0;
                m_cmbDh.Left = 175 + 200;
                m_cmbDh.Top = nDefaultTop + i * nGapH;
                m_cmbDh.Width = 100;
                m_albTools_Kinematics[nItems].Top = m_cmbDh.Top;
                m_albTools_Kinematics[nItems].Left = 10;
                m_albTools_Kinematics[nItems].AutoSize = true;
                m_albTools_Kinematics[nItems].Text = "DH(0~255-Manual(For mapping), 256~511:Etc)";
                m_pnKinematics.Controls.Add(m_cmbDh);
                m_pnKinematics.Controls.Add(m_albTools_Kinematics[nItems]);
                //Event
                if (bInit == true) m_cmbDh.SelectedIndexChanged += new EventHandler(m_cmbKinematics_SelectedIndexChanged);
                //
                i++; nItems++;
                m_cmbSecret.Items.Clear();
                m_cmbSecret.Items.Add("0 - No Encryption");
                m_cmbSecret.Items.Add("1 - Run Encryption");
                m_cmbSecret.SelectedIndex = 0;
                m_cmbSecret.Left = 175 + 100;
                m_cmbSecret.Top = nDefaultTop + i * nGapH;
                m_cmbSecret.Width = 200;
                m_albTools_Kinematics[nItems].Top = m_cmbSecret.Top;
                m_albTools_Kinematics[nItems].Left = 10;
                m_albTools_Kinematics[nItems].AutoSize = true;
                m_albTools_Kinematics[nItems].Text = "Encryption";
                m_pnKinematics.Controls.Add(m_cmbSecret);
                m_pnKinematics.Controls.Add(m_albTools_Kinematics[nItems]);
                if (bInit == true) m_cmbSecret.SelectedIndexChanged += new EventHandler(m_cmbKinematics_SelectedIndexChanged);
                //Event
                //
                i++; nItems++;
                m_cmbKinematicsType.Items.Clear();
                m_cmbKinematicsType.Items.Add("0 - Normal");
                m_cmbKinematicsType.Items.Add("1 - Wheel");
                m_cmbKinematicsType.SelectedIndex = 0;
                m_cmbKinematicsType.Left = 175 + 100;
                m_cmbKinematicsType.Top = nDefaultTop + i * nGapH;
                m_cmbKinematicsType.Width = 200;
                m_albTools_Kinematics[nItems].Top = m_cmbKinematicsType.Top;
                m_albTools_Kinematics[nItems].Left = 10;
                m_albTools_Kinematics[nItems].AutoSize = true;
                m_albTools_Kinematics[nItems].Text = "Function Type";
                m_pnKinematics.Controls.Add(m_cmbKinematicsType);
                m_pnKinematics.Controls.Add(m_albTools_Kinematics[nItems]);
                //Event
                if (bInit == true) m_cmbKinematicsType.SelectedIndexChanged += new EventHandler(m_cmbKinematics_SelectedIndexChanged);
                //
                i++; nItems++;

                m_cmbPython.Items.Clear();
                m_cmbPython.Items.Add("0 - No");
                m_cmbPython.Items.Add("1 - Yes");
                m_cmbPython.SelectedIndex = 0;
                m_cmbPython.Left = 175 + 100;
                m_cmbPython.Top = nDefaultTop + i * nGapH;
                m_cmbPython.Width = 200;
                m_albTools_Kinematics[nItems].Top = m_cmbPython.Top;
                m_albTools_Kinematics[nItems].Left = 10;
                m_albTools_Kinematics[nItems].AutoSize = true;
                m_albTools_Kinematics[nItems].Text = "Python Code";
                m_pnKinematics.Controls.Add(m_cmbPython);
                m_pnKinematics.Controls.Add(m_albTools_Kinematics[nItems]);
                //Event
                if (bInit == true) m_cmbPython.SelectedIndexChanged += new EventHandler(m_cmbKinematics_SelectedIndexChanged);
                //
                i++; nItems++;

                m_chkSkeletonView.Text = "View DH-Skeleton";
                m_chkSkeletonView.Checked = false;
                m_chkSkeletonView.Left = 10;
                m_chkSkeletonView.Top = nDefaultTop + i * nGapH;
                m_chkSkeletonView.Width = 200;
                m_pnKinematics.Controls.Add(m_chkSkeletonView);
                //Event
                if (bInit == true) m_chkSkeletonView.CheckedChanged += new EventHandler(m_chkKinematics_CheckedChanged);
                //m_chkSkeletonView SetSkeletonView

                m_chkDh.Text = "DH Object";
                m_chkDh.Checked = false;
                m_chkDh.Left = 175 + 100;
                m_chkDh.Top = nDefaultTop + i * nGapH;
                m_chkDh.Width = 200;
                m_pnKinematics.Controls.Add(m_chkDh);
                //Event
                if (bInit == true) m_chkDh.CheckedChanged += new EventHandler(m_chkKinematics_CheckedChanged);
                i++; nItems++;
                //

                m_btnKinematicsCompile.Text = "Kinematics Compile";
                m_btnKinematicsCompile.Left = 175 + 100;
                m_btnKinematicsCompile.Top = nDefaultTop + i * nGapH;
                m_btnKinematicsCompile.Width = 200;
                m_btnKinematicsCompile.Height = 30;
                m_albTools_Kinematics[nItems].Visible = false;//
                m_pnKinematics.Controls.Add(m_btnKinematicsCompile);
                //Event
                if (bInit == true) m_btnKinematicsCompile.Click += new EventHandler(m_btnKinematics_Click);
                //
                i++; nItems++;

                //m_tabKinematics.Text = "Tab";
                m_tabKinematics.Left = 10;
                m_tabKinematics.Width = m_txtGroupName.Right - m_tabKinematics.Left;//m_pnKinematics.Width - 20;                
                m_tabKinematics.Top = nDefaultTop + i * nGapH;
                m_tabKinematics.Height = m_pnKinematics.Height - m_tabKinematics.Top;
                m_pnKinematics.Controls.Add(m_tabKinematics);
                //Event
                //
                i++; nItems++;

                m_tabKinematics.TabPages.Clear();
                //m_tabpgForward.Left = 10;
                //m_tabKinematics.Width = m_pnKinematics.Width - 20;
                //m_tabKinematics.Top = nDefaultTop + i * nGapH;
                #region Forward
                m_tabpgForward.Text = "Forward";
                m_tabKinematics.TabPages.Add(m_tabpgForward);
                i++; nItems++;

                int nHeight_Message = 200;
                int nHeight_Message_Gap = 10;
                m_txtForwardKinematics.Left = 10;
                m_txtForwardKinematics.Top = 10;
                m_txtForwardKinematics.Multiline = true;
                m_txtForwardKinematics.WordWrap = false;
                m_txtForwardKinematics.ScrollBars = ScrollBars.Both;
                m_txtForwardKinematics.Width = m_tabKinematics.Width - m_txtForwardKinematics.Left * 2 - 10;
                m_txtForwardKinematics.Height = m_tabKinematics.Height - m_txtForwardKinematics.Top * 2 - 30 - nHeight_Message;
                m_tabpgForward.Controls.Add(m_txtForwardKinematics);
                // Event
                if (bInit == true) m_txtForwardKinematics.TextChanged += new System.EventHandler(m_txtKinematics_TextChanged);
                //
                i++; nItems++;


                m_txtForwardKinematics_Message.Left = 10;
                m_txtForwardKinematics_Message.Top = 10 + m_txtForwardKinematics.Height + nHeight_Message_Gap;
                m_txtForwardKinematics_Message.Multiline = true;
                m_txtForwardKinematics_Message.WordWrap = false;
                m_txtForwardKinematics_Message.ScrollBars = ScrollBars.Both;
                m_txtForwardKinematics_Message.Width = m_txtForwardKinematics.Width;// m_tabKinematics.Width - m_txtForwardKinematics_Message.Left * 2 - 10;
                m_txtForwardKinematics_Message.Height = nHeight_Message;
                m_tabpgForward.Controls.Add(m_txtForwardKinematics_Message);
                // Event
                //if (bInit == true) m_txtForwardKinematics_Message.TextChanged += new System.EventHandler(m_txtKinematics_TextChanged);
                //
                i++; nItems++;
                #endregion Forward

                #region Inverse
                m_tabpgInverse.Text = "Inverse";
                m_tabKinematics.TabPages.Add(m_tabpgInverse);
                i++; nItems++;
                //return;

                m_txtInverseKinematics.Left = 10;
                m_txtInverseKinematics.Top = 10;
                m_txtInverseKinematics.Multiline = true;
                m_txtInverseKinematics.WordWrap = false;
                m_txtInverseKinematics.ScrollBars = ScrollBars.Both;
                m_txtInverseKinematics.Width = m_tabKinematics.Width - m_txtInverseKinematics.Left * 2 - 10;
                m_txtInverseKinematics.Height = m_tabKinematics.Height - m_txtInverseKinematics.Top * 2 - 30 - nHeight_Message;
                m_tabpgInverse.Controls.Add(m_txtInverseKinematics);
                // Event
                if (bInit == true) m_txtInverseKinematics.TextChanged += new System.EventHandler(m_txtKinematics_TextChanged);
                //
                i++; nItems++;

                m_txtInverseKinematics_Message.Left = 10;
                m_txtInverseKinematics_Message.Top = 10 + m_txtInverseKinematics.Height + nHeight_Message_Gap;
                m_txtInverseKinematics_Message.Multiline = true;
                m_txtInverseKinematics_Message.WordWrap = false;
                m_txtInverseKinematics_Message.ScrollBars = ScrollBars.Both;
                m_txtInverseKinematics_Message.Width = m_txtInverseKinematics.Width;// m_tabKinematics.Width - m_txtInverseKinematics_Message.Left * 2 - 10;
                m_txtInverseKinematics_Message.Height = nHeight_Message;
                m_tabpgInverse.Controls.Add(m_txtInverseKinematics_Message);
                #endregion Inverse

                #region String
                m_tabpgString.Text = "String";                
                m_tabKinematics.TabPages.Add(m_tabpgString);
                i++; nItems++;

                m_txtKinematicsString.Left = 10;
                m_txtKinematicsString.Top = 10;
                m_txtKinematicsString.Multiline = true;
                m_txtKinematicsString.WordWrap = false;
                m_txtKinematicsString.ScrollBars = ScrollBars.Both;
                m_txtKinematicsString.Width = m_tabKinematics.Width - m_txtKinematicsString.Left * 2 - 10;
                m_txtKinematicsString.Height = m_tabKinematics.Height - m_txtKinematicsString.Top * 2 - 30;
                m_tabpgString.Controls.Add(m_txtKinematicsString);
                // Event
                //if (bInit == true) m_txtKinematicsString.TextChanged += new System.EventHandler(m_txtKinematics_TextChanged);
                //
                i++; nItems++;
                #endregion String

                #region Skeleton
                m_tabpgSkeleton.Text = "Skeleton";
                m_tabKinematics.TabPages.Add(m_tabpgSkeleton);
                i++; nItems++;

                m_txtKinematicsSkeleton.Left = 10;
                m_txtKinematicsSkeleton.Top = 10;
                m_txtKinematicsSkeleton.Multiline = true;
                m_txtKinematicsSkeleton.WordWrap = false;
                m_txtKinematicsSkeleton.ScrollBars = ScrollBars.Both;
                m_txtKinematicsSkeleton.Width = m_tabKinematics.Width - m_txtKinematicsSkeleton.Left * 2 - 10;
                m_txtKinematicsSkeleton.Height = m_tabKinematics.Height - m_txtKinematicsSkeleton.Top * 2 - 30;
                m_tabpgSkeleton.Controls.Add(m_txtKinematicsSkeleton);
                i++; nItems++;                
                #endregion Skeleton
                //////////////////////////////////////////////////////////////////////////////////////////////////////
                GroupBox gbDh = new GroupBox();
                i = 0;
                gbDh.Text = "Kinematics Test";
                gbDh.Left = m_tabKinematics.Right + 10;
                gbDh.Top = 10;
                gbDh.Width = m_pnKinematics.Width - gbDh.Left - 10;
                //gbDh.Width = m_pnKinematics.Width - gbDh.Left;// -m_tabKinematics.Left;// m_tabKinematics.Width - gbDh.Left - 10;
                gbDh.Height = m_pnKinematics.Height - gbDh.Top;
                m_pnKinematics.Controls.Add(gbDh);
                //////////////////////////////////////////////////////////////////////////////////////////////////////
                
                nDefaultTop += 15;

                int nLeft_Second = gbDh.Width / 4 + 10; //gbDh.Width / 2;
                int nSize_Second = gbDh.Width / 4; //gbDh.Width / 2 - 20;
                m_txtDH_Draw_Size.Left = nLeft_Second;
                m_txtDH_Draw_Size.Top = nDefaultTop + i * nGapH;
                m_txtDH_Draw_Size.Width = nSize_Second;
                //m_txtDH_Draw_Size.Height = 300;
                m_albTools_Kinematics[nItems].Top = m_txtDH_Draw_Size.Top;
                m_albTools_Kinematics[nItems].Left = 10;
                m_albTools_Kinematics[nItems].Text = "Size";
                gbDh.Controls.Add(m_txtDH_Draw_Size);
                gbDh.Controls.Add(m_albTools_Kinematics[nItems]);
                // Event
                if (bInit == true) m_txtDH_Draw_Size.TextChanged += new System.EventHandler(m_txtKinematics_TextChanged);
                //
                i++; nItems++;
                m_txtDH_Draw_Color.Left = nLeft_Second;
                m_txtDH_Draw_Color.Top = nDefaultTop + i * nGapH;
                m_txtDH_Draw_Color.Width = nSize_Second;
                m_txtDH_Draw_Color.Height = 15;
                m_albTools_Kinematics[nItems].Top = m_txtDH_Draw_Color.Top;
                m_albTools_Kinematics[nItems].Left = 10;
                m_albTools_Kinematics[nItems].Text = "Color";
                gbDh.Controls.Add(m_txtDH_Draw_Color);
                gbDh.Controls.Add(m_albTools_Kinematics[nItems]);
                // Event
                if (bInit == true) m_txtDH_Draw_Color.TextChanged += new System.EventHandler(m_txtKinematics_TextChanged);
                //
                i++; nItems++;
                m_btnDhColor.Text = "Color";
                m_btnDhColor.Left = nLeft_Second;
                m_btnDhColor.Top = nDefaultTop + i * nGapH;
                m_btnDhColor.Width = nSize_Second;
                gbDh.Controls.Add(m_btnDhColor);
                // Event
                if (bInit == true) m_btnDhColor.Click += new EventHandler(m_btnKinematics_Click);
                //
                i++; nItems++;


                m_cmbDH_AxisDir.Items.Clear();
                m_cmbDH_AxisDir.Items.Add("0 - Forward");
                m_cmbDH_AxisDir.Items.Add("1 - Inverse");
                m_cmbDH_AxisDir.SelectedIndex = 0;

                m_cmbDH_AxisDir.Left = nLeft_Second;
                m_cmbDH_AxisDir.Top = nDefaultTop + i * nGapH;
                m_cmbDH_AxisDir.Width = nSize_Second;
                m_albTools_Kinematics[nItems].Top = m_cmbDH_AxisDir.Top;
                m_albTools_Kinematics[nItems].Left = 10;
                m_albTools_Kinematics[nItems].Text = "Direction";
                gbDh.Controls.Add(m_cmbDH_AxisDir);
                gbDh.Controls.Add(m_albTools_Kinematics[nItems]);
                // Event
                if (bInit == true) m_cmbDH_AxisDir.SelectedIndexChanged += new EventHandler(m_cmbKinematics_SelectedIndexChanged);
                //
                i++; nItems++;

                m_txtDH_Caption.Left = nLeft_Second;
                m_txtDH_Caption.Top = nDefaultTop + i * nGapH;
                m_txtDH_Caption.Width = nSize_Second;
                m_albTools_Kinematics[nItems].Top = m_txtDH_Caption.Top;
                m_albTools_Kinematics[nItems].Left = 10;
                m_albTools_Kinematics[nItems].Text = "Comment";
                gbDh.Controls.Add(m_txtDH_Caption);
                gbDh.Controls.Add(m_albTools_Kinematics[nItems]);
                // Event
                if (bInit == true) m_txtDH_Caption.TextChanged += new System.EventHandler(m_txtKinematics_TextChanged);
                //
                i++; nItems++;
                m_txtDH_Draw_Alpha.Text = "0";
                m_txtDH_Draw_Alpha.Left = nLeft_Second;
                m_txtDH_Draw_Alpha.Top = nDefaultTop + i * nGapH;
                m_txtDH_Draw_Alpha.Width = nSize_Second;
                m_albTools_Kinematics[nItems].Top = m_txtDH_Draw_Alpha.Top;
                m_albTools_Kinematics[nItems].Left = 10;
                m_albTools_Kinematics[nItems].Text = "Alpha(transparency)";
                gbDh.Controls.Add(m_txtDH_Draw_Alpha);
                gbDh.Controls.Add(m_albTools_Kinematics[nItems]);
                // Event
                if (bInit == true) m_txtDH_Draw_Alpha.TextChanged += new System.EventHandler(m_txtKinematics_TextChanged);
                //
                i++; nItems++;

                // 구분선
                m_albTools_Kinematics[nItems].Top = nDefaultTop + i * nGapH;
                m_albTools_Kinematics[nItems].Text = "< D-H Param >";
                gbDh.Controls.Add(m_albTools_Kinematics[nItems]);
                i++; nItems++;

                m_txtDH_A.Left = nLeft_Second;
                m_txtDH_A.Top = nDefaultTop + i * nGapH;
                m_txtDH_A.Width = nSize_Second;
                m_albTools_Kinematics[nItems].Top = m_txtDH_A.Top;
                m_albTools_Kinematics[nItems].Left = 10;
                m_albTools_Kinematics[nItems].Text = "A";
                gbDh.Controls.Add(m_txtDH_A);
                gbDh.Controls.Add(m_albTools_Kinematics[nItems]);
                // Event
                if (bInit == true) m_txtDH_A.TextChanged += new System.EventHandler(m_txtKinematics_TextChanged);
                //


                    nItems++;
                    #region 한줄 더
                    ///////한줄 더
                    m_cmbDH_Init.Left = nLeft_Second + nSize_Second + 100;
                    m_cmbDH_Init.Top = nDefaultTop + i * nGapH;
                    m_cmbDH_Init.Width = nSize_Second;
                    m_albTools_Kinematics[nItems].Top = m_cmbDH_Init.Top;
                    m_albTools_Kinematics[nItems].Left = nLeft_Second + nSize_Second + 5;
                    m_albTools_Kinematics[nItems].Text = "Init(Start Pos)";
                    gbDh.Controls.Add(m_cmbDH_Init);
                    gbDh.Controls.Add(m_albTools_Kinematics[nItems]);

                    m_cmbDH_Init.Items.Clear();
                    m_cmbDH_Init.Items.Add("False(0)");
                    m_cmbDH_Init.Items.Add("True(1)");

                    // Event
                    if (bInit == true) m_cmbDH_Init.SelectedIndexChanged += new EventHandler(m_cmbKinematics_SelectedIndexChanged);//m_cmbDH_Init);
                    //
                    m_cmbDH_Init.SelectedIndex = 0;
                    /////////////////
                    #endregion 한줄 더
                    
                i++; nItems++;

                m_txtDH_D.Left = nLeft_Second;
                m_txtDH_D.Top = nDefaultTop + i * nGapH;
                m_txtDH_D.Width = nSize_Second;
                m_albTools_Kinematics[nItems].Top = m_txtDH_D.Top;
                m_albTools_Kinematics[nItems].Left = 10;
                m_albTools_Kinematics[nItems].Text = "D";
                gbDh.Controls.Add(m_txtDH_D);
                gbDh.Controls.Add(m_albTools_Kinematics[nItems]);
                // Event
                if (bInit == true) m_txtDH_D.TextChanged += new System.EventHandler(m_txtKinematics_TextChanged);
                //
                    nItems++;
                    #region 한줄 더
                    ///////한줄 더
                    m_txtDH_StartGroup.Left = nLeft_Second + nSize_Second + 100;
                    m_txtDH_StartGroup.Top = nDefaultTop + i * nGapH;
                    m_txtDH_StartGroup.Width = nSize_Second;
                    m_albTools_Kinematics[nItems].Top = m_txtDH_StartGroup.Top;
                    m_albTools_Kinematics[nItems].Left = nLeft_Second + nSize_Second + 5;
                    m_albTools_Kinematics[nItems].Text = "Start Group";
                    gbDh.Controls.Add(m_txtDH_StartGroup);
                    gbDh.Controls.Add(m_albTools_Kinematics[nItems]);
                    // Event
                    if (bInit == true) m_txtDH_StartGroup.TextChanged += new System.EventHandler(m_txtKinematics_TextChanged);
                    //
                    /////////////////
                    #endregion 한줄 더
                i++; nItems++;

                    

                m_txtDH_Theta.Left = nLeft_Second;
                m_txtDH_Theta.Top = nDefaultTop + i * nGapH;
                m_txtDH_Theta.Width = nSize_Second;
                m_albTools_Kinematics[nItems].Top = m_txtDH_Theta.Top;
                m_albTools_Kinematics[nItems].Left = 10;
                m_albTools_Kinematics[nItems].Text = "Theta";
                gbDh.Controls.Add(m_txtDH_Theta);
                gbDh.Controls.Add(m_albTools_Kinematics[nItems]);
                // Event
                if (bInit == true) m_txtDH_Theta.TextChanged += new System.EventHandler(m_txtKinematics_TextChanged);
                //
                    nItems++;
                    #region 한줄 더
                    ///////한줄 더
                    m_txtDH_Offset_X.Left = nLeft_Second + nSize_Second + 100;
                    m_txtDH_Offset_X.Top = nDefaultTop + i * nGapH;
                    m_txtDH_Offset_X.Width = nSize_Second;
                    m_albTools_Kinematics[nItems].Top = m_txtDH_Offset_X.Top;
                    m_albTools_Kinematics[nItems].Left = nLeft_Second + nSize_Second + 5;
                    m_albTools_Kinematics[nItems].Text = "Offset(X)";
                    gbDh.Controls.Add(m_txtDH_Offset_X);
                    gbDh.Controls.Add(m_albTools_Kinematics[nItems]);
                    // Event
                    if (bInit == true) m_txtDH_Offset_X.TextChanged += new System.EventHandler(m_txtKinematics_TextChanged);
                    //
                    /////////////////
                    #endregion 한줄 더
                i++; nItems++;

                m_txtDH_Alpha.Left = nLeft_Second;
                m_txtDH_Alpha.Top = nDefaultTop + i * nGapH;
                m_txtDH_Alpha.Width = nSize_Second;
                m_albTools_Kinematics[nItems].Top = m_txtDH_Alpha.Top;
                m_albTools_Kinematics[nItems].Left = 10;
                m_albTools_Kinematics[nItems].Text = "Alpha";
                gbDh.Controls.Add(m_txtDH_Alpha);
                gbDh.Controls.Add(m_albTools_Kinematics[nItems]);
                // Event
                if (bInit == true) m_txtDH_Alpha.TextChanged += new System.EventHandler(m_txtKinematics_TextChanged);
                //
                    nItems++;
                    #region 한줄 더
                    ///////한줄 더
                    m_txtDH_Offset_Y.Left = nLeft_Second + nSize_Second + 100;
                    m_txtDH_Offset_Y.Top = nDefaultTop + i * nGapH;
                    m_txtDH_Offset_Y.Width = nSize_Second;
                    m_albTools_Kinematics[nItems].Top = m_txtDH_Offset_Y.Top;
                    m_albTools_Kinematics[nItems].Left = nLeft_Second + nSize_Second + 5;
                    m_albTools_Kinematics[nItems].Text = "Offset(Y)";
                    gbDh.Controls.Add(m_txtDH_Offset_Y);
                    gbDh.Controls.Add(m_albTools_Kinematics[nItems]);
                    // Event
                    if (bInit == true) m_txtDH_Offset_Y.TextChanged += new System.EventHandler(m_txtKinematics_TextChanged);
                    //
                    /////////////////
                    #endregion 한줄 더
                i++; nItems++;

                m_txtDH_AxisNum.Left = nLeft_Second;
                m_txtDH_AxisNum.Top = nDefaultTop + i * nGapH;
                m_txtDH_AxisNum.Width = nSize_Second;
                m_albTools_Kinematics[nItems].Top = m_txtDH_AxisNum.Top;
                m_albTools_Kinematics[nItems].Left = 10;
                m_albTools_Kinematics[nItems].Text = "Axis";
                gbDh.Controls.Add(m_txtDH_AxisNum);
                gbDh.Controls.Add(m_albTools_Kinematics[nItems]);
                // Event
                if (bInit == true) m_txtDH_AxisNum.TextChanged += new System.EventHandler(m_txtKinematics_TextChanged);
                //
                    nItems++;
                    #region 한줄 더
                    ///////한줄 더
                    m_txtDH_Offset_Z.Left = nLeft_Second + nSize_Second + 100;
                    m_txtDH_Offset_Z.Top = nDefaultTop + i * nGapH;
                    m_txtDH_Offset_Z.Width = nSize_Second;
                    m_albTools_Kinematics[nItems].Top = m_txtDH_Offset_Z.Top;
                    m_albTools_Kinematics[nItems].Left = nLeft_Second + nSize_Second + 5;
                    m_albTools_Kinematics[nItems].Text = "Offset(Z)";
                    gbDh.Controls.Add(m_txtDH_Offset_Z);
                    gbDh.Controls.Add(m_albTools_Kinematics[nItems]);
                    // Event
                    if (bInit == true) m_txtDH_Offset_Z.TextChanged += new System.EventHandler(m_txtKinematics_TextChanged);
                    //
                    /////////////////
                    #endregion 한줄 더
                i++; nItems++;

                m_btnDHCompile.Text = "Add Current D-H Parameter";
                m_btnDHCompile.Left = 10;
                m_btnDHCompile.Top = nDefaultTop + i * nGapH;
                m_btnDHCompile.Width = gbDh.Width - 20;
                m_btnDHCompile.Height = 20;
                gbDh.Controls.Add(m_btnDHCompile);
                // Event
                if (bInit == true) m_btnDHCompile.Click += new EventHandler(m_btnKinematics_Click);
                i++; nItems++;

                m_txtDhParam.Left = 10;
                m_txtDhParam.Top = nDefaultTop + i * nGapH;
                m_txtDhParam.Multiline = true;
                m_txtDhParam.ScrollBars = ScrollBars.Both;
                m_txtDhParam.Width = gbDh.Width - 20;
                m_txtDhParam.Height = gbDh.Height - m_txtDhParam.Top - 20 - 160 - 60;// 60;
                gbDh.Controls.Add(m_txtDhParam);
                // Event
                if (bInit == true) m_txtDhParam.TextChanged += new System.EventHandler(m_txtKinematics_TextChanged);
                //
                i++; nItems++;



                i = 0;
                nDefaultTop = m_txtDhParam.Bottom;// +10;

                m_btnCheckDH.Text = "Move to point";
                m_btnCheckDH.Left = 10;
                m_btnCheckDH.Top = nDefaultTop + i * nGapH;
                m_btnCheckDH.Width = gbDh.Width - 20;
                m_btnCheckDH.Height = 30;
                gbDh.Controls.Add(m_btnCheckDH);
                // Event
                if (bInit == true) m_btnCheckDH.Click += new EventHandler(m_btnKinematics_Click);
                i+=2; nItems++;

                m_chkVisible.Text = "Visible skeleton";
                m_chkVisible.Width = 250;
                m_chkVisible.Left = nLeft_Second;
                m_chkVisible.Top = m_btnCheckDH.Bottom + 5;
                gbDh.Controls.Add(m_chkVisible);
                


                // 구분선
                m_albTools_Kinematics[nItems].Top = nDefaultTop + i * nGapH;
                m_albTools_Kinematics[nItems].Text = "< Inverse >";
                gbDh.Controls.Add(m_albTools_Kinematics[nItems]);
                i++; nItems++;

                m_cmbInverseKinematics.Items.Clear();
                for (int j = 0; j < 512; j++)
                {
                    m_cmbInverseKinematics.Items.Add(j.ToString());
                }
                m_cmbInverseKinematics.SelectedIndex = 0;

                m_cmbInverseKinematics.Left = nLeft_Second;
                m_cmbInverseKinematics.Top = nDefaultTop + i * nGapH;
                m_cmbInverseKinematics.Width = nSize_Second;
                m_albTools_Kinematics[nItems].Top = m_cmbInverseKinematics.Top;
                m_albTools_Kinematics[nItems].Left = 10;
                m_albTools_Kinematics[nItems].Text = "Function Number(Inverse)";
                gbDh.Controls.Add(m_cmbInverseKinematics);
                gbDh.Controls.Add(m_albTools_Kinematics[nItems]);
                // Event
                //if (bInit == true) m_cmbInverseKinematics.SelectedIndexChanged += new EventHandler(m_cmbKinematics_SelectedIndexChanged);
                //
                i++; nItems++;
                
                m_chkTestObject.Text = "Test Object";
                m_chkTestObject.Checked = false;
                m_chkTestObject.Left = m_cmbInverseKinematics.Left;// 175 + 100;
                m_chkTestObject.Top = nDefaultTop + i * nGapH;
                m_chkTestObject.Width = 200;
                gbDh.Controls.Add(m_chkTestObject);
                //Event
                if (bInit == true) m_chkTestObject.CheckedChanged += new EventHandler(m_chkKinematics_CheckedChanged);
                i++; nItems++;
                //

                m_txtTestObjectSize.Left = nLeft_Second;
                m_txtTestObjectSize.Top = nDefaultTop + i * nGapH;
                m_txtTestObjectSize.Width = nSize_Second;
                m_albTools_Kinematics[nItems].Top = m_txtTestObjectSize.Top;
                m_albTools_Kinematics[nItems].Left = 10;
                m_albTools_Kinematics[nItems].Text = "Ball Size";
                gbDh.Controls.Add(m_txtTestObjectSize);
                gbDh.Controls.Add(m_albTools_Kinematics[nItems]);
                m_txtTestObjectSize.BringToFront();
                // Event
                if (bInit == true) m_txtTestObjectSize.TextChanged += new System.EventHandler(m_txtKinematics_TextChanged);
                //
                i++; nItems++;
                int nW = m_txtTestObjectSize.Width / 3;// (gbDh.Width / 2) / 3;// - 20 - 2;
                m_txtPos_X.Left = nLeft_Second;
                m_txtPos_X.Top = nDefaultTop + i * nGapH;
                m_txtPos_X.Width = nW;// (gbDh.Width / 2) / 3 - 20;
                gbDh.Controls.Add(m_txtPos_X);

                m_txtPos_Y.Left = nLeft_Second + nW;
                m_txtPos_Y.Top = nDefaultTop + i * nGapH;
                m_txtPos_Y.Width = nW;// (gbDh.Width / 2) / 3 - 20;
                gbDh.Controls.Add(m_txtPos_Y);

                m_txtPos_Z.Left = nLeft_Second + nW * 2;
                m_txtPos_Z.Top = nDefaultTop + i * nGapH;
                m_txtPos_Z.Width = nW;// (gbDh.Width / 2) / 3 - 20;
                gbDh.Controls.Add(m_txtPos_Z);
                i++; nItems++;


                m_btnChangePos.Text = "Go";
                m_btnChangePos.Top = nDefaultTop + i * nGapH;
                m_btnChangePos.Width = m_txtTestObjectSize.Width / 2 - 10; //m_txtTestObjectSize.Right - m_btnChangePos.Left;// nW * 2;
                m_btnChangePos.Left = m_txtTestObjectSize.Right - m_btnChangePos.Width;//nLeft_Second + nW * 3;
                m_btnChangePos.Height = 30;
                gbDh.Controls.Add(m_btnChangePos);
                // Event
                if (bInit == true) m_btnChangePos.Click += new EventHandler(m_btnKinematics_Click);
                //i++; nItems++;


                m_btnGetForward.Text = "Get";
                m_btnGetForward.Top = nDefaultTop + i * nGapH;
                m_btnGetForward.Width = m_txtTestObjectSize.Width / 2 - 10;// nW * 2;
                m_btnGetForward.Left = m_txtTestObjectSize.Left;//nLeft_Second + (nLeft_Second - 20) - m_btnGetForward.Width; //nW * 3;
                m_btnGetForward.Height = 30;
                gbDh.Controls.Add(m_btnGetForward);
                // Event
                if (bInit == true) m_btnGetForward.Click += new EventHandler(m_btnKinematics_Click);
                i++; nItems++;
                                
                m_albTools_Kinematics[nItems].Top = m_txtPos_X.Top;
                m_albTools_Kinematics[nItems].Left = 10;
                m_albTools_Kinematics[nItems].Text = "X,Y,Z";
                gbDh.Controls.Add(m_albTools_Kinematics[nItems]);
                // Event
                //if (bInit == true) m_txtTestObjectSize.TextChanged += new System.EventHandler(m_txtKinematics_TextChanged);
                //
                i++; nItems++;


                // Init
                m_txtDH_A.Text = "0";
                m_txtDH_D.Text = "0";
                m_txtDH_Theta.Text = "0";
                m_txtDH_Alpha.Text = "0";
                m_txtDH_AxisNum.Text = "-1";
                m_txtTestObjectSize.Text = "10";
                m_txtDH_Draw_Size.Text = "10";
                m_txtPos_X.Text = "0";
                m_txtPos_Y.Text = "0";
                m_txtPos_Z.Text = "0";
                m_txtDH_Draw_Color.Text = Ojw.CConvert.IntToStr(Color.Red.ToArgb());
                m_cmbDH_Init.SelectedIndex = 0;
                m_txtDH_StartGroup.Text = "0";
                m_txtDH_Offset_X.Text = "0";
                m_txtDH_Offset_Y.Text = "0";
                m_txtDH_Offset_Z.Text = "0";
                //m_bTools_Motor_ = true;
                //InitToolsMotorVar_();

            }

            void m_btnKinematics_Click(object sender, EventArgs e)
            {
                //throw new NotImplementedException();
                if (((System.Windows.Forms.Button)sender) == m_btnKinematicsCompile)
                {
                    if (m_btnKinematicsCompile.Focused == true)
                    {
                        CheckForward();
                        CheckInverse();
                    }
                }
                else if (((System.Windows.Forms.Button)sender) == m_btnDhColor)
                {
                    if (m_btnDhColor.Focused == true)
                    {
                        ColorDialog cdDlg = new ColorDialog();
                        cdDlg.AllowFullOpen = true;
                        cdDlg.ShowHelp = true;

                        int nColor = Ojw.CConvert.StrToInt(m_txtDH_Draw_Color.Text);
                        Color cColor = Color.FromArgb(nColor);

                        cdDlg.Color = cColor;
                        if (cdDlg.ShowDialog() == DialogResult.OK)
                            cColor = cdDlg.Color;
                        m_txtDH_Draw_Color.Text = Ojw.CConvert.IntToStr(cColor.ToArgb());
                        cdDlg.Dispose();
                    }
                }
                else if (((System.Windows.Forms.Button)sender) == m_btnDHCompile)
                {
                    int nAxisNum = Ojw.CConvert.StrToInt(m_txtDH_AxisNum.Text);
                    m_COjwDhParam.strCaption = m_txtDH_Caption.Text;
                    if (nAxisNum >= 0) m_COjwDhParam.strCaption += " - Axis" + Ojw.CConvert.IntToStr(nAxisNum);
                    String strData = Ojw.CKinematics.CForward.ClassToString_DHParam(m_COjwDhParam);

                    m_txtDhParam.Text += strData + "\r\n"; //strData + m_COjwDhParam.strCaption + "\r\n";

                    Ojw.CKinematics.CForward.MakeDhParam(m_txtDhParam.Text, out m_COjwDhParamAll);
                    double dX, dY, dZ;
                    double[] colX;
                    double[] colY;
                    double[] colZ;
                    double[] adAngle = Array.ConvertAll(GetData(), element => (double)element);
                    Ojw.CKinematics.CForward.CalcKinematics(m_COjwDhParamAll, adAngle, out colX, out colY, out colZ, out dX, out dY, out dZ);

                    m_COjwDhParam.InitData();
                    // 초기화
                    m_txtDH_A.Text = Ojw.CConvert.DoubleToStr(m_COjwDhParam.dA);
                    m_txtDH_D.Text = Ojw.CConvert.DoubleToStr(m_COjwDhParam.dD);
                    m_txtDH_Theta.Text = Ojw.CConvert.DoubleToStr(m_COjwDhParam.dTheta);
                    m_txtDH_Alpha.Text = Ojw.CConvert.DoubleToStr(m_COjwDhParam.dAlpha);
                    m_txtDH_AxisNum.Text = Ojw.CConvert.IntToStr(m_COjwDhParam.nAxisNum);
                    m_txtDH_Caption.Text = m_COjwDhParam.strCaption;
                    m_cmbDH_AxisDir.SelectedIndex = m_COjwDhParam.nAxisDir;

                    //m_txtDH_StartGroup.Text = Ojw.CConvert.IntToStr(m_COjwDhParam.nStartGroup);
                    //m_txtDH_Offset_X.Text = Ojw.CConvert.DoubleToStr(m_COjwDhParam.dOffset_X);
                    //m_txtDH_Offset_Y.Text = Ojw.CConvert.DoubleToStr(m_COjwDhParam.dOffset_Y);
                    //m_txtDH_Offset_Z.Text = Ojw.CConvert.DoubleToStr(m_COjwDhParam.dOffset_Z);
                    m_cmbDH_Init.SelectedIndex = m_COjwDhParam.nInit;

                    MoveToDhPosition(Ojw.CConvert.StrToFloat(m_txtDH_Draw_Size.Text), 1.0f, Color.FromArgb(Ojw.CConvert.StrToInt(m_txtDH_Draw_Color.Text)));

                    if (m_chkSkeletonView.Checked == true)
                        MakeDHSkeleton(Ojw.CConvert.StrToFloat(m_txtDH_Draw_Size.Text), Color.FromArgb(Ojw.CConvert.StrToInt(m_txtDH_Draw_Color.Text)), m_txtDhParam.Text,
                                Ojw.CConvert.StrToInt(m_txtDH_StartGroup.Text),
                                Ojw.CConvert.StrToFloat(m_txtDH_Offset_X.Text),
                                Ojw.CConvert.StrToFloat(m_txtDH_Offset_Y.Text),
                                Ojw.CConvert.StrToFloat(m_txtDH_Offset_Z.Text)
                                );
                }
                else if (((System.Windows.Forms.Button)sender) == m_btnChangePos) // "Go" 버튼
                {
                    int nNum = Ojw.CConvert.StrToInt(m_cmbInverseKinematics.Text);
                    float fX = Ojw.CConvert.StrToFloat(m_txtPos_X.Text);
                    float fY = Ojw.CConvert.StrToFloat(m_txtPos_Y.Text);
                    float fZ = Ojw.CConvert.StrToFloat(m_txtPos_Z.Text);
                    
                    // 집어넣기 전에 내부 메모리를 클리어 한다.
                    Ojw.CKinematics.CInverse.SetValue_ClearAll(ref GetHeader_pSOjwCode()[nNum]);
                    Ojw.CKinematics.CInverse.SetValue_X(fX);
                    Ojw.CKinematics.CInverse.SetValue_Y(fY);
                    Ojw.CKinematics.CInverse.SetValue_Z(fZ);


                    // 테스트 시작
                    SetTestCircle(m_chkTestObject.Checked);
                    //Settes
                    SetColor_Test(Color.Red);
                    // 테스트 값 입력
                    SetSize_Test(Ojw.CConvert.StrToFloat(m_txtTestObjectSize.Text));
                    SetPos_Test(
                        fX + Ojw.CConvert.StrToFloat(m_txtDH_Offset_X.Text),
                        fY + Ojw.CConvert.StrToFloat(m_txtDH_Offset_Y.Text),
                        fZ + Ojw.CConvert.StrToFloat(m_txtDH_Offset_Z.Text)
                        );

                    // 현재의 모터각을 전부 집어 넣도록 한다.
                    //UpdateMotorCommand();
                    for (int i = 0; i < 256; i++)
                    {
                        // 모터값을 3D에 넣어주고
                        //SetData(i, Ojw.CConvert.StrToFloat(m_txtAngle[i].Text));
                        // 그 값을 꺼내 수식 계산에 넣어준다.
                        Ojw.CKinematics.CInverse.SetValue_Motor(i, GetData(i));
                    }

                    // 실제 수식계산
                    if (GetHeader_pSOjwCode()[nNum].nMotor_Max > 0)
                    {
                        if (Ojw.CKinematics.CInverse.CalcCode(ref GetHeader_pSOjwCode()[nNum]) == false) MessageBox.Show(String.Format("Compile Error - {0}", Ojw.CKinematics.CInverse.GetErrorString_Error_Etc()));
                    }
                    else
                    {
                        CalcInv(nNum, GetHeader_pDhParamAll()[nNum].GetMotors(), (float)fX, (float)fY, (float)fZ, 1000, 0.0001f);
                    }
                    m_txtForwardKinematics_Message.Clear();
                    m_txtInverseKinematics_Message.Clear();
                    //m_lbV.Text = String.Empty;
                    for (int i = 0; i < 10; i++)
                    {
                        Ojw.CMessage.Write("V" + i.ToString() + ":" + Ojw.CConvert.DoubleToStr(Ojw.CKinematics.CInverse.GetValue_V(i)));
                        //m_lbV.Text += "V" + i.ToString() + ":" + Ojw.CConvert.DoubleToStr(Ojw.CKinematics.CInverse.GetValue_V(i)) + ",";
                        Ojw.CMessage.Write(m_txtForwardKinematics_Message, "V" + i.ToString() + ":" + Ojw.CConvert.DoubleToStr(Ojw.CKinematics.CInverse.GetValue_V(i)));
                        Ojw.CMessage.Write(m_txtInverseKinematics_Message, "V" + i.ToString() + ":" + Ojw.CConvert.DoubleToStr(Ojw.CKinematics.CInverse.GetValue_V(i)));                    
                    }
                    // 나온 결과값을 옮긴다.
                    int nMotCnt = GetHeader_pSOjwCode()[nNum].nMotor_Max;
                    for (int i = 0; i < nMotCnt; i++)
                    {
                        int nMotNum = GetHeader_pSOjwCode()[nNum].pnMotor_Number[i];
                        SetData(nMotNum, (float)Ojw.CKinematics.CInverse.GetValue_Motor(nMotNum));
                        
                        m_atxtAngle[nMotNum].Text = Ojw.CConvert.FloatToStr((float)Ojw.CKinematics.CInverse.GetValue_Motor(nMotNum));
                        Ojw.CMessage.Write(m_txtForwardKinematics_Message, "T" + nMotNum.ToString() + ":" + m_atxtAngle[nMotNum].Text);
                        Ojw.CMessage.Write(m_txtInverseKinematics_Message, "T" + nMotNum.ToString() + ":" + m_atxtAngle[nMotNum].Text);
                    }
                    //BlockUpdate(true);
                    //for (int i = 0; i < 256; i++)
                    //{
                    //    m_txtAngle[i].Text = Ojw.CConvert.FloatToStr(GetData(i));
                    //}
                    //BlockUpdate(false);
                }
                else if (((System.Windows.Forms.Button)sender) == m_btnGetForward) // GetButton
                {
                    int nNum = Ojw.CConvert.StrToInt(m_cmbInverseKinematics.Text);
                    
                    int i;
                    //CDhParamAll COjwDhParamAll = new CDhParamAll();
                    //Ojw.CKinematics.CForward.MakeDhParam(m_CHeader.pstrKinematics[nNum], out COjwDhParamAll);

                    double dX, dY, dZ;
                    double[] dcolX;
                    double[] dcolY;
                    double[] dcolZ;

                    double[] adMot = new double[256];
                    Array.Clear(adMot, 0, adMot.Length);
                    for (i = 0; i < GetHeader_nMotorCnt(); i++) adMot[i] = (double)GetData(i);
                    Ojw.CKinematics.CForward.CalcKinematics(m_CHeader.pDhParamAll[nNum], adMot, out dcolX, out dcolY, out dcolZ, out dX, out dY, out dZ);
                    
                    m_txtPos_X.Text = Ojw.CConvert.DoubleToStr(dX);
                    m_txtPos_Y.Text = Ojw.CConvert.DoubleToStr(dY);
                    m_txtPos_Z.Text = Ojw.CConvert.DoubleToStr(dZ);

                    // 테스트 시작
                    SetTestCircle(m_chkTestObject.Checked);
                    //Settes
                    SetColor_Test(Color.Red);
                    // 테스트 값 입력
                    SetSize_Test(Ojw.CConvert.StrToFloat(m_txtTestObjectSize.Text));
                    SetPos_Test((float)dX, (float)dY, (float)dZ);

                    SetTestCircle(m_chkTestObject.Checked);
                }
                else if (((System.Windows.Forms.Button)sender) == m_btnCheckDH)
                {
                    MoveToDhPosition(Ojw.CConvert.StrToFloat(m_txtDH_Draw_Size.Text), 1.0f, Color.FromArgb(Ojw.CConvert.StrToInt(m_txtDH_Draw_Color.Text)));

                    if (m_chkSkeletonView.Checked == true)
                        MakeDHSkeleton(Ojw.CConvert.StrToFloat(m_txtDH_Draw_Size.Text), Color.FromArgb(Ojw.CConvert.StrToInt(m_txtDH_Draw_Color.Text)), m_txtDhParam.Text,
                                Ojw.CConvert.StrToInt(m_txtDH_StartGroup.Text),
                                Ojw.CConvert.StrToFloat(m_txtDH_Offset_X.Text),
                                Ojw.CConvert.StrToFloat(m_txtDH_Offset_Y.Text),
                                Ojw.CConvert.StrToFloat(m_txtDH_Offset_Z.Text)
                                );
                }
            }

            public bool GetData_Forward(int nNum, out double dX, out double dY, out double dZ)
            {                    
                int i;
                double[] dcolX;
                double[] dcolY;
                double[] dcolZ;

                double[] adMot = new double[256];
                Array.Clear(adMot, 0, adMot.Length);
                //for (i = 0; i < GetHeader_nMotorCnt(); i++) adMot[i] = (double)GetData(i);
                for (i = 0; i < 256; i++) adMot[i] = (double)GetData(i);
                return Ojw.CKinematics.CForward.CalcKinematics(m_CHeader.pDhParamAll[nNum], adMot, out dcolX, out dcolY, out dcolZ, out dX, out dY, out dZ);                  
            }
            public bool GetData_Forward_LastOf(int nNum, out double dX, out double dY, out double dZ)
            {
                int i;
                double[] dcolX;
                double[] dcolY;
                double[] dcolZ;

                double[] adMot = new double[256];
                Array.Clear(adMot, 0, adMot.Length);
                //for (i = 0; i < GetHeader_nMotorCnt(); i++) adMot[i] = (double)GetData(i);
                for (i = 0; i < 256; i++) adMot[i] = (double)GetData(i);
                return Ojw.CKinematics.CForward.CalcKinematics_LastOf(m_CHeader.pDhParamAll[nNum], adMot, out dcolX, out dcolY, out dcolZ, out dX, out dY, out dZ);  
            }

            // return MotorCount, and ...
            public int GetData_Inverse(int nNum, double dX, double dY, double dZ, double [] adV, out int[] anMotorID, out double[] adValue)
            {
                // 집어넣기 전에 내부 메모리를 클리어 한다.
                Ojw.CKinematics.CInverse.SetValue_ClearAll(ref GetHeader_pSOjwCode()[nNum]);
                Ojw.CKinematics.CInverse.SetValue_X(dX);
                Ojw.CKinematics.CInverse.SetValue_Y(dY);
                Ojw.CKinematics.CInverse.SetValue_Z(dZ);

                if (adV != null)
                {
                    for (int i = 0; i < adV.Length; i++)
                    {
                        Ojw.CKinematics.CInverse.SetValue_V(i, adV[i]);
                    }
                }

                // 현재의 모터각을 전부 집어 넣도록 한다.
                for (int i = 0; i < m_CHeader.nMotorCnt; i++)
                {
                    // 모터값을 3D에 넣어주고
                    //SetData(i, Ojw.CConvert.StrToFloat(m_txtAngle[i].Text));
                    // 그 값을 꺼내 수식 계산에 넣어준다.
                    Ojw.CKinematics.CInverse.SetValue_Motor(i, GetData(i));
                }

                // 실제 수식계산
                Ojw.CKinematics.CInverse.CalcCode(ref GetHeader_pSOjwCode()[nNum]);


                // 나온 결과값을 옮긴다.
                int nMotCnt = GetHeader_pSOjwCode()[nNum].nMotor_Max;
                if (nMotCnt <= 0)
                {
                    anMotorID = null;
                    adValue = null;
                    return 0;
                }
                anMotorID = new int[nMotCnt];
                adValue = new double[nMotCnt];
                for (int i = 0; i < nMotCnt; i++)
                {
                    anMotorID[i] = GetHeader_pSOjwCode()[nNum].pnMotor_Number[i];
                    adValue[i] = Ojw.CKinematics.CInverse.GetValue_Motor(anMotorID[i]);
                }
                return nMotCnt;
            }
            public int GetData_Inverse(int nNum, double dX, double dY, double dZ, out int [] anMotorID, out double [] adValue)
            {
                return GetData_Inverse(nNum, dX, dY, dZ, null, out anMotorID, out adValue);
#if false
                // 집어넣기 전에 내부 메모리를 클리어 한다.
                Ojw.CKinematics.CInverse.SetValue_ClearAll(ref GetHeader_pSOjwCode()[nNum]);
                Ojw.CKinematics.CInverse.SetValue_X(dX);
                Ojw.CKinematics.CInverse.SetValue_Y(dY);
                Ojw.CKinematics.CInverse.SetValue_Z(dZ);
                                
                // 현재의 모터각을 전부 집어 넣도록 한다.
                for (int i = 0; i < m_CHeader.nMotorCnt; i++)
                {
                    // 모터값을 3D에 넣어주고
                    //SetData(i, Ojw.CConvert.StrToFloat(m_txtAngle[i].Text));
                    // 그 값을 꺼내 수식 계산에 넣어준다.
                    Ojw.CKinematics.CInverse.SetValue_Motor(i, GetData(i));
                }

                // 실제 수식계산
                Ojw.CKinematics.CInverse.CalcCode(ref GetHeader_pSOjwCode()[nNum]);


                // 나온 결과값을 옮긴다.
                int nMotCnt = GetHeader_pSOjwCode()[nNum].nMotor_Max;
                if (nMotCnt <= 0)
                {
                    anMotorID = null;
                    adValue = null;
                    return 0;
                }
                anMotorID = new int[nMotCnt];
                adValue = new double[nMotCnt];
                for (int i = 0; i < nMotCnt; i++)
                {
                    anMotorID[i] = GetHeader_pSOjwCode()[nNum].pnMotor_Number[i];
                    adValue[i] = Ojw.CKinematics.CInverse.GetValue_Motor(anMotorID[i]);
                }
                return nMotCnt;
#endif
            }
            public void SetMot_WIthInverseKinematics(int nInverseFunctionNumber, double dX, double dY, double dZ, int nTime_Milliseconds, double[] adV = null)
            {
                int [] anMotorID = new int[256];
                double [] adValue = new double[256];
                int nCnt = GetData_Inverse(nInverseFunctionNumber, dX, dY, dZ, adV, out anMotorID, out adValue);
                if (m_bDynamixel == true)
                {
#if !_MONSTER_LIB
                    if (m_CRobotis.IsOpen() == true)
                    {
                        for (int i = 0; i < nCnt; i++)
                        {
                            SetData(anMotorID[i], (float)adValue[i]);
                            m_CRobotis.Set_Angle(anMotorID[i], (float)adValue[i], nTime_Milliseconds);
                        }
                        m_CRobotis.Send_Motor();
                    }
                    else if (m_CMonster.IsOpen() == true)
#else
                    if (m_CMonster.IsOpen() == true)
#endif
                    {
                        for (int i = 0; i < nCnt; i++)
                        {
                            SetData(anMotorID[i], (float)adValue[i]);
                            m_CMonster.Set(anMotorID[i], (float)adValue[i]);
                        }
                        m_CMonster.Send_Motor(nTime_Milliseconds);
                    }
                }
                else
                {
                    for (int i = 0; i < nCnt; i++)
                    {
                        SetData(anMotorID[i], (float)adValue[i]);
                        m_CMotor.SetCmd_Angle(anMotorID[i], (float)adValue[i]);
                    }
                    m_CMotor.SetMot(nTime_Milliseconds);
                }
            }
            public void SetMot_WIthInverseKinematics(CDynamixel CMotor, int nInverseFunctionNumber, double dX, double dY, double dZ, int nTime_Milliseconds, double[] adV = null)
            {
                int[] anMotorID = new int[256];
                double[] adValue = new double[256];
                int nCnt = GetData_Inverse(nInverseFunctionNumber, dX, dY, dZ, adV, out anMotorID, out adValue);
                for (int i = 0; i < nCnt; i++)
                {
                    SetData(anMotorID[i], (float)adValue[i]);
                    CMotor.Set_Angle(anMotorID[i], (float)adValue[i], nTime_Milliseconds);
                }
                CMotor.Send_Motor();
            }
            public void SetMot_WIthInverseKinematics(CHerkulex2 CMotor, int nInverseFunctionNumber, double dX, double dY, double dZ, int nTime_Milliseconds, double [] adV = null)
            {
                int[] anMotorID = new int[256];
                double[] adValue = new double[256];
                int nCnt = GetData_Inverse(nInverseFunctionNumber, dX, dY, dZ, adV, out anMotorID, out adValue);
                for (int i = 0; i < nCnt; i++)
                {
                    SetData(anMotorID[i], (float)adValue[i]);
                    CMotor.Set_Angle(anMotorID[i], (float)adValue[i]);
                }
                CMotor.Send_Motor(nTime_Milliseconds);
            }
            public void SetData_XYZ(int nInverseFunctionNumber, double dX, double dY, double dZ, double[] adV=null)
            {
                int[] anMotorID = new int[256];
                double[] adValue = new double[256];
                int nCnt = GetData_Inverse(nInverseFunctionNumber, dX, dY, dZ, adV, out anMotorID, out adValue);
                for (int i = 0; i < nCnt; i++)
                {
                    SetData(anMotorID[i], (float)adValue[i]);
                }
            }
            public void SetData_XYZ(CMonster CMon, int nInverseFunctionNumber, double dX, double dY, double dZ, int nMilliSeconds, double[] adV=null)
            {
                int[] anMotorID = new int[256];
                double[] adValue = new double[256];
                int nCnt = GetData_Inverse(nInverseFunctionNumber, dX, dY, dZ, adV, out anMotorID, out adValue);
                for (int i = 0; i < nCnt; i++)
                {
                    SetData(anMotorID[i], (float)adValue[i]);
                    CMon.Set(anMotorID[i], (float)adValue[i]);
                }
                CMon.Send_Motor(nMilliSeconds);
            }
            public String MakeDHSkeleton(float fSize, Color cColor, string strString)
            {
                return MakeDHSkeleton(fSize, cColor, strString, Ojw.CConvert.StrToInt(m_txtDH_StartGroup.Text),
                                Ojw.CConvert.StrToFloat(m_txtDH_Offset_X.Text),
                                Ojw.CConvert.StrToFloat(m_txtDH_Offset_Y.Text),
                                Ojw.CConvert.StrToFloat(m_txtDH_Offset_Z.Text)
                                );
            }
            public String MakeDHSkeleton(bool bVisible, float fSize, Color cColor, string strString)
            {
                TextBox txt = null;
                return MakeDHSkeleton(bVisible, fSize, cColor, strString, Ojw.CConvert.StrToInt(m_txtDH_StartGroup.Text),
                                Ojw.CConvert.StrToFloat(m_txtDH_Offset_X.Text),
                                Ojw.CConvert.StrToFloat(m_txtDH_Offset_Y.Text),
                                Ojw.CConvert.StrToFloat(m_txtDH_Offset_Z.Text),
                                0, 0, 0, ref txt
                                );
            }
            public void MakeAll(string strDesingPart_For_Calc, string strDesignFull_For_Drawing = "", string strInverse_AfterCalc = "")
            {
                MakeAll(0, strDesingPart_For_Calc, strDesignFull_For_Drawing, 10.0f, 1, strInverse_AfterCalc);
            }
            public void MakeAll(int nKinematicsIndex, string strDesingPart_For_Calc, string strDesignFull_For_Drawing = "", float fSize = 10.0f, int nInverseKinematics_AfterCalc = -1, string strInverse_AfterCalc = "") // 
            {
                m_CHeader.pstrKinematics[nKinematicsIndex] = strDesingPart_For_Calc;
                if (nInverseKinematics_AfterCalc >= 0)
                {
                    m_CHeader.pstrInverseKinematics[nInverseKinematics_AfterCalc] = strInverse_AfterCalc;
                }
                CheckForward();
                CheckInverse();

                //float fSize = 10.0f;
                m_CHeader.strDrawModel = MakeDHSkeleton(false, fSize, Color.Violet, ((strDesignFull_For_Drawing.Length > 0) ? strDesignFull_For_Drawing : strDesingPart_For_Calc));
                CompileDesign();

                //SetHand_Tilt(m_C3d.GetData(4));
            }
            public void MakeAll_Add(string strDesingPart_For_Calc, string strDesignFull_For_Drawing = "", string strInverse_AfterCalc = "")
            {
                MakeAll(0, strDesingPart_For_Calc, strDesignFull_For_Drawing, 10.0f, 1, strInverse_AfterCalc);
            }
            public void MakeAll_Add(int nKinematicsIndex, string strDesingPart_For_Calc, string strDesignFull_For_Drawing = "", float fSize = 10.0f, int nInverseKinematics_AfterCalc = -1, string strInverse_AfterCalc = "") // 
            {
                m_CHeader.pstrKinematics[nKinematicsIndex] += strDesingPart_For_Calc;
                if (nInverseKinematics_AfterCalc >= 0)
                {
                    m_CHeader.pstrInverseKinematics[nInverseKinematics_AfterCalc] += strInverse_AfterCalc;
                }
                CheckForward();
                CheckInverse();

                m_CHeader.strDrawModel += MakeDHSkeleton(false, fSize, Color.Violet, ((strDesignFull_For_Drawing.Length > 0) ? strDesignFull_For_Drawing : strDesingPart_For_Calc));
                CompileDesign();
            }
            public String MakeDHSkeleton(float fSize, Color cColor, string strString, int nStartGroupNumber, float fOffset_X, float fOffset_Y, float fOffset_Z)
            {
                //m_chkVisible.Checked = bVisible;
                TextBox txt = null;
                return MakeDHSkeleton(m_chkVisible.Checked, fSize, cColor, strString, nStartGroupNumber, fOffset_X, fOffset_Y, fOffset_Z, 0, 0, 0, ref txt);
            }
            public String MakeDHSkeleton(float fSize, Color cColor, string strString, int nStartGroupNumber, float fOffset_X, float fOffset_Y, float fOffset_Z, float fOffset_Pan, float fOffset_Tilt, float fOffset_Swing)
            {
                //m_chkVisible.Checked = bVisible;
                TextBox txt = null;
                return MakeDHSkeleton(m_chkVisible.Checked, fSize, cColor, strString, nStartGroupNumber, fOffset_X, fOffset_Y, fOffset_Z, fOffset_Pan, fOffset_Tilt, fOffset_Swing, ref txt);
            }
            public String MakeDHSkeleton(bool bVisible, float fSize, Color cColor, string strString, int nStartGroupNumber, float fOffset_X, float fOffset_Y, float fOffset_Z, float fOffset_Pan, float fOffset_Tilt, float fOffset_Swing, ref TextBox txt)
            {
                return MakeDHSkeleton(true, bVisible, fSize, cColor, strString, nStartGroupNumber, fOffset_X, fOffset_Y, fOffset_Z, fOffset_Pan, fOffset_Tilt, fOffset_Swing, ref txt);
            }
            public String MakeDHSkeleton(bool bInit, bool bVisible, float fSize, Color cColor, string strString, int nStartGroupNumber, float fOffset_X, float fOffset_Y, float fOffset_Z, float fOffset_Pan, float fOffset_Tilt, float fOffset_Swing, ref TextBox txt)
            {
                return MakeDHSkeleton(true, bInit, bVisible, fSize, cColor, strString, nStartGroupNumber, fOffset_X, fOffset_Y, fOffset_Z, fOffset_Pan, fOffset_Tilt, fOffset_Swing, ref txt);
            
            }
            public String MakeDHSkeleton(bool bDrawing, bool bInit, bool bVisible, float fSize, Color cColor, string strString, int nStartGroupNumber, float fOffset_X, float fOffset_Y, float fOffset_Z, float fOffset_Pan, float fOffset_Tilt, float fOffset_Swing, ref TextBox txt)
            {
                // "@" 가 들어간 명령어는 순서데로 [StlFileName, Color, Alpha, GroupA, GroupB, Function, X, Y, Z, P, T, S]
                String strModel_Bar = (bVisible == true) ? "#8" : "#19";
                String strModel_Ball = (bVisible == true) ? "#9" : "#20";
                string strModel_End = (bVisible == true) ? "#8" : "#19";
                String strData = String.Empty;
                String strDisp = String.Empty;
                //SetHeader_strDrawModel(String.Empty);
                String strConvert0 = Ojw.CConvert.RemoveCaption(strString, true, true);
                //String strConvert0 = Ojw.CConvert.RemoveCaption("@", Ojw.CConvert.RemoveCaption("//", strString, true, true), true, true);
                String strConvert1 = Ojw.CConvert.RemoveChar(strConvert0, '[');
                String strConvert2 = Ojw.CConvert.RemoveChar(strConvert1, ']');
                String strConvert3 = Ojw.CConvert.RemoveChar(strConvert2, '\r');
                //String[] pstrLines = strConvert3.Split('\n');
                List<String> lstLines = new List<string>();
                lstLines.Clear();
                String[] pstr = strConvert3.Split('\n');
                foreach (String str in pstr)
                {
                    if (str.Length > 0)
                    {
                        lstLines.Add(str);
                    }
                }
                String[] pstrLines = lstLines.ToArray();
                
                User_Clear();

                //User_Set_Init(true); // 초기점
                if (bInit)
                {
                    User_Set_Init(true); // 초기점
                }
                User_Set_Translation(0, fOffset_X, fOffset_Y, fOffset_Z);
                User_Set_Rotation(0, fOffset_Pan, fOffset_Tilt, fOffset_Swing);

                int nLine = 0;
                bool bEnd = false;
                foreach (string strLine in pstrLines)
                {
                    if (nLine == pstrLines.Length - 1) bEnd = true;
                    else bEnd = false;
                    //if (strLine.Length == 0) continue;

                    nLine++;
                    float fA = 0.0f;
                    float fD = 0.0f;
                    float fTheta = 0.0f;
                    float fAlpha = 0.0f;
                    int nAxis = -1;
                    int nDir = 0;
                    int nInit = 0;

                    #region Items
                    String[] pstrItems = strLine.Split(',');
                    bool bModeling = false;
                    if (strLine.IndexOf('@') == 0)
                    {
                        bModeling = true;
                    }
                    bool bFunction = false;
                    if (strLine.IndexOf('#') == 0)
                    {
                        bFunction = true;
                    }
                    int i = 0;
                    int nFunctionNumber = -1;
                    string strAdd_Model = strModel_Bar;// "#8";
                    Color cAdd_Color = Color.White;
                    float fAdd_Alpha = 1.0f;
                    int nAdd_Type = 0;
                    int nAdd_Num = 255;
                    float[] fTrans = new float[3];
                    float[] fRot = new float[3];
                    foreach (string strItem in pstrItems)
                    {
                        if (bModeling == true)
                        {
                            // [model,color,alpha,type,Num,x,y,z,pan,tilt,swing]
                            try
                            {
                                switch (i)
                                {
                                    case 0: strAdd_Model = strItem.Substring(1); break;
                                    case 1: cAdd_Color = Color.FromArgb(Ojw.CConvert.StrToInt(strItem)); break;
                                    case 2: fAdd_Alpha = Ojw.CConvert.StrToFloat(strItem); break;
                                    case 3: nAdd_Type = Ojw.CConvert.StrToInt(strItem); break;
                                    case 4: nAdd_Num = Ojw.CConvert.StrToInt(strItem); break;
                                    case 5: fTrans[0] = Ojw.CConvert.StrToFloat(strItem); break;
                                    case 6: fTrans[1] = Ojw.CConvert.StrToFloat(strItem); break;
                                    case 7: fTrans[2] = Ojw.CConvert.StrToFloat(strItem); break;
                                    case 8: fRot[0] = Ojw.CConvert.StrToFloat(strItem); break;
                                    case 9: fRot[1] = Ojw.CConvert.StrToFloat(strItem); break;
                                    case 10: fRot[2] = Ojw.CConvert.StrToFloat(strItem); break;
                                }
                            }
                            catch
                            {
                                switch (i)
                                {
                                    case 0: strAdd_Model = "#8"; break;
                                    case 1: cAdd_Color = Color.White; break;
                                    case 2: fAdd_Alpha = 1.0f; break;
                                    case 3: nAdd_Type = 0; break;
                                    case 4: nAdd_Num = 255; break;
                                    case 5: fTrans[0] = 0.0f; break;
                                    case 6: fTrans[1] = 0.0f; break;
                                    case 7: fTrans[2] = 0.0f; break;
                                    case 8: fRot[0] = 0.0f; break;
                                    case 9: fRot[1] = 0.0f; break;
                                    case 10: fRot[2] = 0.0f; break;
                                }
                            }
                        }
                        else if (bFunction == true)
                        {
                            try
                            {
                                switch (i)
                                {
                                    case 0: nFunctionNumber = Ojw.CConvert.StrToInt(strItem.Substring(1)); break;
                                }
                            }
                            catch
                            {
                                switch (i)
                                {
                                    case 0: nFunctionNumber = -1; break;
                                }
                            }
                        }
                        else
                        {
                            try
                            {
                                switch (i)
                                {
                                    case 0: fA = Ojw.CConvert.StrToFloat(strItem); break;
                                    case 1: fD = Ojw.CConvert.StrToFloat(strItem); break;
                                    case 2: fTheta = Ojw.CConvert.StrToFloat(strItem); break;
                                    case 3: fAlpha = Ojw.CConvert.StrToFloat(strItem); break;
                                    case 4: nAxis = Ojw.CConvert.StrToInt(strItem); break;
                                    case 5: nDir = Ojw.CConvert.StrToInt(strItem); break;
                                    case 6: nInit = Ojw.CConvert.StrToInt(strItem); break;
                                    case 7: nAdd_Type = Ojw.CConvert.StrToInt(strItem); break;
                                    case 8: nAdd_Num = Ojw.CConvert.StrToInt(strItem); break;
                                }
                            }
                            catch
                            {
                                switch (i)
                                {
                                    case 0: fA = 0.0f; break;
                                    case 1: fD = 0.0f; break;
                                    case 2: fTheta = 0.0f; break;
                                    case 3: fAlpha = 0.0f; break;
                                    case 4: nAxis = 0; break;
                                    case 5: nDir = 0; break;
                                    case 6: nInit = 0; break;
                                    case 7: nAdd_Type = 0; break;
                                    case 8: nAdd_Num = 255; break;
                                }
                            }
                        }
                        i++;
                    }
                    //if (i != 6) return null; // 해석 에러
                    //if (i != 7) continue; // 해석 에러 => 굳이 초기화 없이도 해석 되게...
                    #endregion Items

                    #region 추가된 모델링
                    if (bModeling == true)
                    {
                        /*
                            strAdd_Model = "#8";  break;
                            cAdd_Color = Color.White; break;
                            fAdd_Alpha = 1.0f; break;
                            nAdd_Type = 0; break;
                            nAdd_Num = 255; break;
                            fTrans[0] = 0.0f; break;
                            fTrans[1] = 0.0f; break;
                            fTrans[2] = 0.0f; break;
                            fRot[0] = 0.0f; break;
                            fRot[1] = 0.0f; break;
                            fRot[2] = 0.0f; break;
                         */
                        if (nInit > 0)
                            User_Set_Init(true);
                        User_Set_Model(strAdd_Model);
                        User_Set_Color(cAdd_Color);
                        User_Set_Alpha(fAdd_Alpha);

                        //User_Set_nPickGroup_A(nStartGroupNumber);
                        if (nAdd_Type == 0)
                        {
                            User_Set_nPickGroup_A(0);
                            User_Set_nPickGroup_B(0);
                        }
                        else if (nAdd_Type == 1)
                        {
                            User_Set_nPickGroup_A(0);
                            User_Set_nPickGroup_B(nAdd_Num);
                        }
                        else if (nAdd_Type == 2)
                        {
                            User_Set_nInverseKinematicsNumber(nAdd_Num);
                        }
                        else if (nAdd_Type == 3)
                        {
                            User_Set_nInverseKinematicsNumber_AfterCalc(nAdd_Num);
                        }
                        //User_Set_nPickGroup_A(nAdd_Num);


                        User_Set_Offset_Translation(fTrans[0], fTrans[1], fTrans[2]);
                        User_Set_Offset_Rotation(fRot[0], fRot[1], fRot[2]);

                        User_Add();
                        continue;//break;//continue;
                    }
                    #endregion 추가된 모델링
                    //Prop_Set_DispObject(strModel_Ball);
                    //Prop_Set_Width_Or_Radius(fSize);
                    //AddVirtualClassToReal();
                    if (nInit > 0)
                    {
                        User_Set_Init(true);
                    }
                    if (fD != 0)
                    {
                        User_Set_Model(strModel_Ball);
                        User_Set_Color(cColor);
                        User_Set_Width_Or_Radius(fSize);

                        //// bModel == true 일때도 하지만... 추가되는 bar 에도 수식 성질이 깃들도록...
                        if (nAdd_Type == 0)
                        {
                            User_Set_nPickGroup_A(0);
                            User_Set_nPickGroup_B(0);
                        }
                        else if (nAdd_Type == 1)
                        {
                            User_Set_nPickGroup_A(0);
                            User_Set_nPickGroup_B(nAdd_Num);
                        }
                        else if (nAdd_Type == 2)
                        {
                            User_Set_nInverseKinematicsNumber(nAdd_Num);
                        }
                        else if (nAdd_Type == 3)
                        {
                            User_Set_nInverseKinematicsNumber_AfterCalc(nAdd_Num);
                        }
                        ////////////////////////////////

                        User_Add();


                        User_Set_Model(strModel_Bar);
                        User_Set_Color(cColor);
                        User_Set_Width_Or_Radius(fSize);
                        if (fD < 0)
                        {
                            User_Set_Offset_Rotation(180, 0, 0);
                            User_Set_Height_Or_Depth(-fD);
                        }
                        else User_Set_Height_Or_Depth(fD);


                        //// bModel == true 일때도 하지만... 추가되는 bar 에도 수식 성질이 깃들도록...
                        if (nAdd_Type == 0)
                        {
                            User_Set_nPickGroup_A(0);
                            User_Set_nPickGroup_B(0);
                        }
                        else if (nAdd_Type == 1)
                        {
                            User_Set_nPickGroup_A(0);
                            User_Set_nPickGroup_B(nAdd_Num);
                        }
                        else if (nAdd_Type == 2)
                        {
                            User_Set_nInverseKinematicsNumber(nAdd_Num);
                        }
                        else if (nAdd_Type == 3)
                        {
                            User_Set_nInverseKinematicsNumber_AfterCalc(nAdd_Num);
                        }
                        ////////////////////////////////


                        User_Add();
                    }
                    if (nAxis >= 0)
                    {
                        User_Set_Model(strModel_Ball);
                        User_Set_Color(cColor);
                        User_Set_Width_Or_Radius(fSize);
                        User_Set_Offset_Translation(0, 0, fD);

                        User_Set_AxisName(nAxis);

                        // [0 ~ 2(Pan, Tilt, Swing), 3~5(x,y,z), 6(cw), 7(ccw)]
                        if ((nDir == 0) || (nDir == 1)) User_Set_AxisMoveType(2);
                        else if ((nDir == 2) || (nDir == 3)) User_Set_AxisMoveType(5);
                        if ((nDir == 0) || (nDir == 2)) User_Set_Dir(0);
                        else if ((nDir == 1) || (nDir == 3)) User_Set_Dir(1);

                        //// bModel == true 일때도 하지만... 추가되는 bar 에도 수식 성질이 깃들도록...
                        if (nAdd_Type == 0)
                        {
                            User_Set_nPickGroup_A(0);
                            User_Set_nPickGroup_B(0);
                        }
                        else if (nAdd_Type == 1)
                        {
                            User_Set_nPickGroup_A(0);
                            User_Set_nPickGroup_B(nAdd_Num);
                        }
                        else if (nAdd_Type == 2)
                        {
                            User_Set_nInverseKinematicsNumber(nAdd_Num);
                        }
                        else if (nAdd_Type == 3)
                        {
                            User_Set_nInverseKinematicsNumber_AfterCalc(nAdd_Num);
                        }
                        ////////////////////////////////

                        User_Add();
                        if ((nDir == 2) || (nDir == 3))
                        {
                            User_Set_Model(strModel_Bar);
                            User_Set_Color(Color.FromArgb(cColor.R / 2, cColor.G / 2, cColor.B / 2));
                            User_Set_Width_Or_Radius(fSize);

                            if (nDir == 2) User_Set_Offset_Rotation(180, 0, 0);

                            User_Set_Height_Or_Depth(GetData(nAxis));



                            //// bModel == true 일때도 하지만... 추가되는 bar 에도 수식 성질이 깃들도록...
                            if (nAdd_Type == 0)
                            {
                                User_Set_nPickGroup_A(0);
                                User_Set_nPickGroup_B(0);
                            }
                            else if (nAdd_Type == 1)
                            {
                                User_Set_nPickGroup_A(0);
                                User_Set_nPickGroup_B(nAdd_Num);
                            }
                            else if (nAdd_Type == 2)
                            {
                                User_Set_nInverseKinematicsNumber(nAdd_Num);
                            }
                            else if (nAdd_Type == 3)
                            {
                                User_Set_nInverseKinematicsNumber_AfterCalc(nAdd_Num);
                            }
                            ////////////////////////////////

                            User_Add();
                        }
                    }

                    if (fA != 0)
                    {
                        User_Set_Model(strModel_Bar);
                        User_Set_Color(cColor);
                        if (fA < 0)
                        {
                            User_Set_Offset_Translation(0, 0, fD);
                            User_Set_Offset_Rotation(-90, fTheta, 0);
                            User_Set_Width_Or_Radius(fSize);
                            User_Set_Height_Or_Depth(-fA);
                        }
                        else
                        {
                            User_Set_Offset_Translation(0, 0, fD);
                            User_Set_Offset_Rotation(90, -fTheta, 0);
                            User_Set_Width_Or_Radius(fSize);
                            User_Set_Height_Or_Depth(fA);
                        }



                        //// bModel == true 일때도 하지만... 추가되는 bar 에도 수식 성질이 깃들도록...
                        if (nAdd_Type == 0)
                        {
                            User_Set_nPickGroup_A(0);
                            User_Set_nPickGroup_B(0);
                        }
                        else if (nAdd_Type == 1)
                        {
                            User_Set_nPickGroup_A(0);
                            User_Set_nPickGroup_B(nAdd_Num);
                        }
                        else if (nAdd_Type == 2)
                        {
                            User_Set_nInverseKinematicsNumber(nAdd_Num);
                        }
                        else if (nAdd_Type == 3)
                        {
                            User_Set_nInverseKinematicsNumber_AfterCalc(nAdd_Num);
                        }
                        ////////////////////////////////

                        User_Add();
                    }

                    //if (bEnd == true)
                    //{
                    //    User_Set_Model(strModel_End);
                    //}
                    //else
                    //{
                    User_Set_Model(strModel_Ball);
                    //}
                    User_Set_Color(cColor);
#if false // end position
                User_Set_Width_Or_Radius(fSize * ((bEnd == true) ? 2.0f : 1.0f));
#else
                    User_Set_Width_Or_Radius(fSize * ((bEnd == true) ? 1.0f : 1.0f));
#endif


                    int nIndex = 0;
                    User_Set_Translation(nIndex, 0, 0, fD);
                    User_Set_Rotation(nIndex, 0, 0, fTheta);
                    nIndex++;
                    User_Set_Translation(nIndex, fA, 0, 0);
                    User_Set_Rotation(nIndex, 0, fAlpha, 0);


                    //// bModel == true 일때도 하지만... 추가되는 bar 에도 수식 성질이 깃들도록...
                    if (nAdd_Type == 0)
                    {
                        User_Set_nPickGroup_A(0);
                        User_Set_nPickGroup_B(0);
                    }
                    else if (nAdd_Type == 1)
                    {
                        User_Set_nPickGroup_A(0);
                        User_Set_nPickGroup_B(nAdd_Num);
                    }
                    else if (nAdd_Type == 2)
                    {
                        User_Set_nInverseKinematicsNumber(nAdd_Num);
                    }
                    else if (nAdd_Type == 3)
                    {
                        User_Set_nInverseKinematicsNumber_AfterCalc(nAdd_Num);
                    }
                    ////////////////////////////////
                    
                    
                    User_Add();




                    //strDisp = GetHeader_strDrawModel();

                }
                #region Skeleton
                StringBuilder sbResult = new StringBuilder();
#if _USING_DOTNET_3_5
                sbResult.Remove(0, sbResult.Length);
#elif _USING_DOTNET_2_0
                sbResult.Remove(0, sbResult.Length);
#else
                sbResult.Clear(); // Dotnet 4.0 이상에서만 사용
#endif
                int nGroupNum = nStartGroupNumber;
                int nMotorNum = -1;
                int nCnt = User_GetCnt();
                Color[] acColor = new Color[7] { Color.Orange, Color.Cyan, Color.Blue, Color.Lime, Color.Yellow, Color.LightGreen, Color.Magenta };
                for (int i = 0; i < nCnt; i++) // Except 3 Directions
                {
                    String strResult = String.Empty;

                    #region
                    Ojw.C3d.COjwDisp CDisp = User_Get(i);
#if true
                    //if (User_Get_AxisName() >= 0)
                    if (CDisp.nName > 0)
                    {
                        nGroupNum++;

                        nMotorNum = CDisp.nName;// User_Get_AxisName();
                        sbResult.Append(String.Format("// Group = {0}, Motor = {1} //////////////////////////\r\n", nGroupNum, nMotorNum));
                    }
#else
                    #region EndPosition                
                if ((User_Get_AxisName() >= 0) || (nCnt - 1 == i))
                {
                    nGroupNum++;

                    if (i < (nCnt - 1))
                    {
                        nMotorNum = User_Get_AxisName();
                        sbResult.Append(String.Format("// Group = {0}, Motor = {1} //////////////////////////\r\n", nGroupNum, nMotorNum));
                    }
                    else sbResult.Append(String.Format("// End Position\r\n"));
                }
                    #endregion EndPosition
#endif


                    if (CDisp.strDispObject.IndexOf('#') == 0)
                    {
                        if (CDisp.bInit == true)
                        {
                            CDisp.SetData_Color(acColor[0]);
                            CDisp.SetData_nPickGroup_A(0);
                            CDisp.SetData_nPickGroup_B(0);
                        }
                        else
                        {
                            if (CDisp.nInverseKinematicsNumber != 255)
                            {
                                CDisp.SetData_Color(Color.Red);
                            }
                            else CDisp.SetData_Color(acColor[nGroupNum % acColor.Length]);
                            CDisp.SetData_nPickGroup_A(nGroupNum);
                            CDisp.SetData_nPickGroup_B(nMotorNum);
                        }
                    }
                    else
                    {
                        CDisp.SetData_nPickGroup_A(nGroupNum);
                        //CDisp.User_Set_nInverseKinematicsNumber(nAdd_Num);
                    }
                    //if (User_Get_Model()


                    //if (bEnd == true)
                    //{
                    //    CDisp.SetData_nInverseKinematicsNumber();
                    //}
                    //User_Set(i, CDisp);
                    #endregion
                    Convert_CDisp_To_String(CDisp, ref strResult);
                    sbResult.Append(strResult);
                }
                if (txt == null) m_txtKinematicsSkeleton.Text = sbResult.ToString();
                else txt.Text = sbResult.ToString();
                //txtDH_Tab_Skeleton.Text = sbResult.ToString();
                //strResult = Ojw.Ojw.CConvert.RemoveString(strResult, "\r\n");
                //AddHeader_strDrawModel(strResult);
                //CompileDesign();
                #endregion Skeleton

                //////////////// Direction
                if (bDrawing) MakeDhSkeleton_Direction(fSize);
                else User_Clear();
                //////////////////////////

                return sbResult.ToString();
            }
            private bool m_bDhSkeleton_Direction_Show = true;
            public void MakeDhSkeleton_Direction_Show(bool bShow) // GroupC == 253, 254, 255
            {
                m_bDhSkeleton_Direction_Show = bShow;
            }
            public void MakeDhSkeleton_Direction(float fSize)
            {
                string strModel_Ball = "#20";
                //String strModel_Ball = (bVisible == true) ? "#9" : "#20";
                //////////////// Direction
                float fMulti = fSize / 10.0f * 2.0f;
                float fLength = 30 * fMulti;

                User_Set_nPickGroup_A(255);
                User_Set_nPickGroup_C(253);
                User_Set_Model(strModel_Ball);
                User_Set_Color(Color.Red);
                User_Set_Width_Or_Radius(fSize);
                User_Set_Offset_Translation(fLength, 0, 0);
                User_Add();

                User_Set_nPickGroup_A(255);
                User_Set_nPickGroup_C(254);
                User_Set_Model(strModel_Ball);
                User_Set_Color(Color.Green);
                User_Set_Width_Or_Radius(fSize);
                User_Set_Offset_Translation(0, fLength, 0);
                User_Add();

                User_Set_nPickGroup_A(255);
                User_Set_nPickGroup_C(255);
                User_Set_Model(strModel_Ball);
                User_Set_Color(Color.Blue);
                User_Set_Width_Or_Radius(fSize);
                User_Set_Offset_Translation(0, 0, fLength);
                User_Add();
            }
            private void MoveToDhPosition(float fSize, float fAlpha, Color cColor)
            {
                ///////////////////
                float fOffset_X = Ojw.CConvert.StrToFloat(m_txtDH_Offset_X.Text);
                float fOffset_Y = Ojw.CConvert.StrToFloat(m_txtDH_Offset_Y.Text);
                float fOffset_Z = Ojw.CConvert.StrToFloat(m_txtDH_Offset_Z.Text);
                ///////////////////

                int i;
                CDhParamAll COjwDhParamAll = new CDhParamAll();
                Ojw.CKinematics.CForward.MakeDhParam(m_txtDhParam.Text, out COjwDhParamAll);
                double dX, dY, dZ;
                double[] dcolX;
                double[] dcolY;
                double[] dcolZ;

                double[] adMot = new double[256];
                Array.Clear(adMot, 0, adMot.Length);
                for (i = 0; i < GetHeader_nMotorCnt(); i++) adMot[i] = (double)GetData(i);// Ojw.CConvert.StrToDouble(m_txtAngle[i].Text);

                Ojw.CKinematics.CForward.CalcKinematics(COjwDhParamAll, adMot, out dcolX, out dcolY, out dcolZ, out dX, out dY, out dZ);
                String strResult;
                Ojw.CKinematics.CForward.CalcKinematics_ToString(COjwDhParamAll, adMot, out strResult);

                //txtError.Text = strResult;
                try
                {
                    m_txtKinematicsString.Text = strResult;
                }
                catch (Exception ex)
                {
                    LogErr(ex.ToString());
                }
                //Ojw.CMessage.Write_Error(strResult);

                //m_afTestPoint[0] = dX;
                //m_afTestPoint[1] = dY;
                //m_afTestPoint[2] = dZ;
                //m_C3d.SetTestDh(true);
                SetTestDh_Size(fSize);
                SetTestDh_Color(cColor);
                SetTestDh_Alpha(fAlpha);
                SetTestDh_Pos((float)dX + fOffset_X, (float)dY + fOffset_Y, (float)dZ + fOffset_Z);
                
                //m_lbTestDh.Text = "[x=" + Ojw.CConvert.DoubleToStr((double)Math.Round(dX, 3)) + ", y=" + Ojw.CConvert.DoubleToStr((double)Math.Round(dY, 3)) + ", z=" + Ojw.CConvert.DoubleToStr((double)Math.Round(dZ, 3)) + "]";

                #region Checking Direction
                // 방향 확인
                float[] afX = new float[3];
                float[] afY = new float[3];
                float[] afZ = new float[3];

#if true
                // X     dcolX[0] dcolY[0] dcolZ[0]   a
                // Y     dcolX[1] dcolY[1] dcolZ[1]   b
                // Z     dcolX[2] dcolY[2] dcolZ[2]   c

                //i = 0;
                //afX[0] = (float)Ojw.CMath.ACos(dcolX[0]);
                //afX[1] = (float)Ojw.CMath.ACos(dcolX[1]);
                //afX[2] = (float)Ojw.CMath.ACos(dcolX[2]);
                ////i++;
                //afY[0] = (float)Ojw.CMath.ACos(dcolY[0]);
                //afY[1] = (float)Ojw.CMath.ACos(dcolY[1]);
                //afY[2] = (float)Ojw.CMath.ACos(dcolY[2]);
                ////i++;
                //afZ[0] = (float)Ojw.CMath.ACos(dcolZ[0]);
                //afZ[1] = (float)Ojw.CMath.ACos(dcolZ[1]);
                //afZ[2] = (float)Ojw.CMath.ACos(dcolZ[2]);
                double dLength = 30.0;
                dX = dLength;
                dY = 0.0f;
                dZ = 0.0f;
                for (i = 0; i < 3; i++) afX[i] = (float)(dcolX[i] * dX + dcolY[i] * dY + dcolZ[i] * dZ);
                dX = 0.0f;
                dY = dLength;
                dZ = 0.0f;
                for (i = 0; i < 3; i++) afY[i] = (float)(dcolX[i] * dX + dcolY[i] * dY + dcolZ[i] * dZ);
                dX = 0.0f;
                dY = 0.0f;
                dZ = dLength;
                for (i = 0; i < 3; i++) afZ[i] = (float)(dcolX[i] * dX + dcolY[i] * dY + dcolZ[i] * dZ);

#else
            afX[0] = (float)Ojw.CMath.ACos(dcolX[0]);
            afX[1] = (float)Ojw.CMath.ACos(dcolY[0]);
            afX[2] = (float)Ojw.CMath.ACos(dcolZ[0]);

            afY[0] = (float)Ojw.CMath.ACos(dcolX[1]);
            afY[1] = (float)Ojw.CMath.ACos(dcolY[1]);
            afY[2] = (float)Ojw.CMath.ACos(dcolZ[1]);

            afZ[0] = (float)Ojw.CMath.ACos(dcolX[2]);
            afZ[1] = (float)Ojw.CMath.ACos(dcolY[2]);
            afZ[2] = (float)Ojw.CMath.ACos(dcolZ[2]);
#endif
                SetTestDh_Angle(afX, afY, afZ);

                #endregion Checking Direction

                dcolX = null;
                dcolY = null;
                dcolZ = null;
                afX = null;
                afY = null;
                afZ = null;
                adMot = null;
            }

            void m_chkKinematics_CheckedChanged(object sender, EventArgs e)
            {
                //throw new NotImplementedException();
                if (((System.Windows.Forms.CheckBox)sender) == m_chkDh)
                {
                    if (m_chkDh.Focused == true)
                    {
                        SetTestDh(m_chkDh.Checked);
                    }
                }
                if (((System.Windows.Forms.CheckBox)sender) == m_chkSkeletonView)
                {
                    if (m_chkSkeletonView.Focused == true)
                    {
                        SetSkeletonView(m_chkSkeletonView.Checked);
                        if (m_chkSkeletonView.Checked == true)
                            MakeDHSkeleton(Ojw.CConvert.StrToFloat(m_txtDH_Draw_Size.Text), Color.FromArgb(Ojw.CConvert.StrToInt(m_txtDH_Draw_Color.Text)), m_txtDhParam.Text,
                                Ojw.CConvert.StrToInt(m_txtDH_StartGroup.Text),
                                Ojw.CConvert.StrToFloat(m_txtDH_Offset_X.Text),
                                Ojw.CConvert.StrToFloat(m_txtDH_Offset_Y.Text),
                                Ojw.CConvert.StrToFloat(m_txtDH_Offset_Z.Text)
                                );
                    }
                }
                if (((System.Windows.Forms.CheckBox)sender) == m_chkTestObject)
                {
                    int nNum = Ojw.CConvert.StrToInt(m_cmbInverseKinematics.Text);
                    float fX = Ojw.CConvert.StrToFloat(m_txtPos_X.Text);
                    float fY = Ojw.CConvert.StrToFloat(m_txtPos_Y.Text);
                    float fZ = Ojw.CConvert.StrToFloat(m_txtPos_Z.Text);

                    // 테스트 시작
                    SetTestCircle(m_chkTestObject.Checked);
                    //Settes
                    SetColor_Test(Color.Red);
                    // 테스트 값 입력
                    SetSize_Test(Ojw.CConvert.StrToFloat(m_txtTestObjectSize.Text));
                    SetPos_Test(fX, fY, fZ);

                    SetTestCircle(m_chkTestObject.Checked);
                }
            }
            private void cmbDhRefresh(int nNum)
            {
                if ((nNum >= 0) && (nNum < m_cmbDh.Items.Count))
                {
                    Ojw.CEncryption.SetEncrypt("OJW5014"); // 암호화 해제는 보안이 필요
                    m_txtForwardKinematics.Text = Encoding.Default.GetString(Ojw.CEncryption.Encryption(false, GetHeader_pSEncryptKinematics_encryption()[nNum].byteEncryption));

                    Ojw.CEncryption.SetEncrypt("OJW5014"); // 암호화 해제는 보안이 필요
                    m_txtInverseKinematics.Text = Encoding.Default.GetString(Ojw.CEncryption.Encryption(false, GetHeader_pSEncryptInverseKinematics_encryption()[nNum].byteEncryption));

                    m_txtGroupName.Text = GetHeader_pstrGroupName()[nNum];
                    m_cmbDh.SelectedIndex = nNum;

                    m_cmbSecret.SelectedIndex = GetHeader_pnSecret()[nNum];
                    m_cmbKinematicsType.SelectedIndex = GetHeader_pnType()[nNum];
                    m_cmbPython.SelectedIndex = Ojw.CConvert.BoolToInt(GetHeader_pbPython()[nNum]);
                }
            }
            private CDhParam m_COjwDhParam = new CDhParam(); // for DH Checking
            private CDhParamAll m_COjwDhParamAll = new CDhParamAll(); // for DH Checking
            void m_cmbKinematics_SelectedIndexChanged(object sender, EventArgs e)
            {
                if (((System.Windows.Forms.ComboBox)sender) == m_cmbDH_Init)
                {
                    m_COjwDhParam.nInit = m_cmbDH_Init.SelectedIndex;
                }
                else if (((System.Windows.Forms.ComboBox)sender) == m_cmbDh)
                {
                    if ((m_cmbDh.Focused == true) && (m_cmbDh.SelectedIndex >= 0))
                    {
                        cmbDhRefresh(m_cmbDh.SelectedIndex);
                    }
                }
                else if (((System.Windows.Forms.ComboBox)sender) == m_cmbSecret)
                {
                    if ((m_cmbSecret.Focused == true) && (m_cmbDh.SelectedIndex >= 0))
                    {
                        GetHeader_pnSecret()[m_cmbDh.SelectedIndex] = m_cmbSecret.SelectedIndex;
                    }
                }
                else if (((System.Windows.Forms.ComboBox)sender) == m_cmbKinematicsType)
                {
                    if ((m_cmbKinematicsType.Focused == true) && (m_cmbDh.SelectedIndex >= 0))
                    {
                        GetHeader_pnType()[m_cmbDh.SelectedIndex] = m_cmbKinematicsType.SelectedIndex;
                    }
                }
                else if (((System.Windows.Forms.ComboBox)sender) == m_cmbDH_AxisDir)
                {
                    if ((m_cmbDH_AxisDir.Focused == true) && (m_cmbDh.SelectedIndex >= 0))
                        m_COjwDhParam.nAxisDir = m_cmbDH_AxisDir.SelectedIndex;
                }
                else if (((System.Windows.Forms.ComboBox)sender) == m_cmbPython)
                {
                    if ((m_cmbPython.Focused == true) && (m_cmbDh.SelectedIndex >= 0))
                    {
                        GetHeader().pSOjwCode[m_cmbDh.SelectedIndex].bPython = GetHeader_pbPython()[m_cmbDh.SelectedIndex] = Ojw.CConvert.IntToBool(m_cmbPython.SelectedIndex);
                        GetHeader().pSOjwCode[m_cmbDh.SelectedIndex].strPython = GetHeader().pstrInverseKinematics[m_cmbDh.SelectedIndex];
                    }
                }
                //throw new NotImplementedException();
            }
            //public void InitTools_InverseKinematics(Panel pnInverse)
            //{
            //    m_pnInverse = pnInverse;
            //}
            private bool m_bTools_Motor = false;           
            
            public void InitTools_Motor(Panel pnMotor)
            {
                int nTop = 10;
                int nLeft = pnMotor.Width / 2;// 120;
                int nSeparation = 10;
                int nWidth = pnMotor.Width - nLeft - 20;
                int nLeftLabel = 10;
                int nGap_H = 26;

                int i = 0;
                for (i = 0; i < _CNT_LABEL_TOOLMOTOR; i++)
                {
                    m_albTools_Motor[i] = new Label();
                    m_albTools_Motor[i].AutoSize = false;
                    m_albTools_Motor[i].Width = nWidth;
                    m_albTools_Motor[i].Height = 27;
                    m_albTools_Motor[i].BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
                }
                m_pnMotor = pnMotor;

                i = 0;
                Control[] aCtrl = new Control[_CNT_LABEL_TOOLMOTOR]; // 여유롭게 100
                int[] anSeparation = new int[aCtrl.Length];
                //Array.Resize<Control>(ref aCtrl, i + 1);
                //Array.Resize<Label>(ref m_albTools_Motor, i + 1);
                aCtrl[i] = m_cmbAngleLimit;
                m_albTools_Motor[i].Text = "AxisLimit";
                i++;
                aCtrl[i] = m_txtAxisLimit_Up;
                m_albTools_Motor[i].Text = "Limit(+)";
                i++;
                aCtrl[i] = m_txtAxisLimit_Down;
                m_albTools_Motor[i].Text = "Limit(-)";
                i++;
                aCtrl[i] = m_txtAxisLimit_Id;
                m_albTools_Motor[i].Text = "ID";
                i++;
                aCtrl[i] = m_txtAxisLimit_CenterPos;
                m_albTools_Motor[i].Text = "Center Pos";
                i++;
                m_txtMessage_AxisLimit.ReadOnly = true;
                //m_txtMessage_AxisLimit.BackColor = Color.LightGray;
                aCtrl[i] = m_txtMessage_AxisLimit;
                m_albTools_Motor[i].Text = "Event Message";
                anSeparation[i] = nSeparation; //
                i++;

                aCtrl[i] = m_txtAxis_Mirror;
                m_albTools_Motor[i].Text = "Mirror Axis";
                i++;
                aCtrl[i] = m_txtAxis_InitAngle;
                m_albTools_Motor[i].Text = "Init Angle";
                i++;
                aCtrl[i] = m_txtAxis_InitAngle2;
                m_albTools_Motor[i].Text = "Init Angle2";
                i++;
                aCtrl[i] = m_txtAxis_MechMov;
                m_albTools_Motor[i].Text = "Mech Move";
                i++;
                aCtrl[i] = m_txtAxis_MechAngle;
                m_albTools_Motor[i].Text = "Mech Angle";
                i++;
                aCtrl[i] = m_cmbMotorDir;
                m_albTools_Motor[i].Text = "Motor Dir";
                i++;
                aCtrl[i] = m_cmbMotorControlType;
                m_albTools_Motor[i].Text = "Control Type";
                i++;
                aCtrl[i] = m_txtGroupNumber;
                m_albTools_Motor[i].Text = "Group Name";
                i++;
                aCtrl[i] = m_txtAxis_NickName;
                m_albTools_Motor[i].Text = "Nick Name";
                i++;

                aCtrl[i] = m_cmbMotorName;
                m_albTools_Motor[i].Text = "Motor Name";
                i++;

                m_txtReserve.Multiline = true;
                m_txtReserve.ScrollBars = ScrollBars.Both;
                m_txtReserve.Height = 100;
                aCtrl[i] = m_txtReserve;
                m_albTools_Motor[i].Text = "Reserve(include -GearRatio, RobotisConvertingVar)";
                i++;

                if (m_cmbMotorName.Focused == true) m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nHwMotor_Index = m_cmbMotorName.SelectedIndex;
                
                int nCnt = i;
                //Array.Resize<Control>(ref aCtrl, i);
                //Array.Resize<Label>(ref m_albTools_Motor, i);

                int nGap_Separation = 0;
                for (i = 0; i < nCnt; i++)
                {
                    nGap_Separation += anSeparation[i];
                    aCtrl[i].Left = nLeft;
                    aCtrl[i].Top = nTop + nGap_H * i + nGap_Separation;
                    aCtrl[i].Width = nWidth;
                    m_albTools_Motor[i].Top = aCtrl[i].Top;
                    m_albTools_Motor[i].Left = nLeftLabel;
                                        
                    if (aCtrl[i] is TextBox)//(aCtrl[i].Name.IndexOf("m_txt") >= 0)
                    {
                        ((TextBox)aCtrl[i]).TextChanged += new System.EventHandler(m_txtAxisMotor_TextChanged);
                    }
                    else if (aCtrl[i] is ComboBox)//(aCtrl[i].Name.IndexOf("m_cmb") >= 0)
                    {
                        ((ComboBox)aCtrl[i]).SelectedIndexChanged += new System.EventHandler(m_cmbAxisMotor_SelectedIndexChanged);
                    }

                    m_pnMotor.Controls.Add(aCtrl[i]);
                    m_pnMotor.Controls.Add(m_albTools_Motor[i]);
                }
                
                m_bTools_Motor = true;
                InitToolsMotorVar();
            }
            private void InitToolsMotorVar()
            {
                if (m_bTools_Motor == true)
                {
                    int i = 0;
                    
                    m_cmbMotorDir.Items.Clear();
                    m_cmbMotorDir.Items.Add("0 - Forward");
                    m_cmbMotorDir.Items.Add("1 - Backward");
                    m_cmbMotorDir.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;

                    m_cmbMotorControlType.Items.Clear();
                    m_cmbMotorControlType.Items.Add("0 - Position");
                    m_cmbMotorControlType.Items.Add("1 - Speed");
                    m_cmbMotorControlType.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;

                    m_cmbMotorName.Items.Clear();
                    foreach (KeyValuePair<int, string> Item in m_CMonster.dicMonster)
                    {
                        m_cmbMotorName.Items.Add(Item.Value);
                    }

                    //m_cmbMotorName.Items.Clear();
                    //m_cmbMotorName.Items.Add("0 - None");
                    //m_cmbMotorName.Items.Add("1 - XL_320");
                    //m_cmbMotorName.Items.Add("2 - XL_430");
                    //m_cmbMotorName.Items.Add("3 - AX_12");
                    //m_cmbMotorName.Items.Add("4 - AX_18");

                    m_cmbMotorName.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;

                    m_cmbAngleLimit.Items.Clear();
                    for (i = 0; i < 256; i++) m_cmbAngleLimit.Items.Add(Ojw.CConvert.IntToStr(i));
                    m_cmbAngleLimit.SelectedIndex = 0;

                    i = 0;
                    m_txtAxisLimit_Up.Text = Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[i].fLimit_Up, 3));
                    m_txtAxisLimit_Down.Text = Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[i].fLimit_Down, 3));
                    //m_txtAxisLimit_W.Text = Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[i].fW, 3));
                    //m_txtAxisLimit_Left.Text = Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[i].fPos_Left, 3));
                    //m_txtAxisLimit_Right.Text = Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[i].fPos_Right, 3));
                    //m_txtInterference_Axis.Text = Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[i].nInterference_Axis);
                    //m_txtInterference_W.Text = Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[i].fInterference_W, 3));
                    //m_txtInterference_Front.Text = Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[i].fInterference_Pos_Front, 3));
                    //m_txtInterference_Rear.Text = Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[i].fInterference_Pos_Rear, 3));
                    m_txtAxisLimit_Id.Text = Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[i].nMotorID);
                    m_txtAxisLimit_CenterPos.Text = Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[i].nCenter_Evd);
                    m_cmbMotorDir.SelectedIndex = m_CHeader.pSMotorInfo[i].nMotorDir;
                    m_cmbMotorControlType.SelectedIndex = m_CHeader.pSMotorInfo[i].nMotorControlType;
                    m_cmbMotorName.SelectedIndex = m_CHeader.pSMotorInfo[i].nHwMotor_Index;

                    m_txtAxis_InitAngle.Text = Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[i].fInitAngle, 3));
                    m_txtAxis_InitAngle2.Text = Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[i].fInitAngle2, 3));
                    m_txtAxis_MechMov.Text = Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[i].nMechMove);
                    m_txtAxis_MechAngle.Text = Ojw.CConvert.FloatToStr((float)Math.Round(m_CHeader.pSMotorInfo[i].fMechAngle, 3));
                    m_txtAxis_NickName.Text = m_CHeader.pSMotorInfo[i].strNickName;
                    m_txtGroupNumber.Text = Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[i].nGroupNumber);
                    m_txtAxis_Mirror.Text = Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[i].nAxis_Mirror);

                    string strReserve = String.Format("{0};{1};{2};{3};{4};{5};{6};{7};{8};{9};",
                            0 + " // nMotorEnable_For_RPTask",
                            0,0,0,0,0,0,0,0,0
                    );  
                    strReserve += String.Format("{0};{1};{2};{3};{4};{5};{6};{7};{8};{9};",
                        1 + " // fGearRatio[0 은 기어비 적용 안함]",
                        1 + " // fRobotisConvertingVar[0 은 적용 안함]",
                        0,0,0,0,0,0,0,0
                        );
                    strReserve += String.Format("{0};{1};{2};{3};{4};{5};{6};{7};{8},{9},{10},{11},{12},{13};{14},{15},{16},{17},{18},{19};{20},{21},{22},{23},{24},{25};",
                        Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[i].nGuide_Event),
                        Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[i].nGuide_AxisType),
                        Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[i].nGuide_RingColorType),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[i].fGuide_RingSize),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[i].fGuide_RingThick),
                        Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[i].nGuide_RingDir),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[i].fGuide_3D_Scale),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[i].fGuide_3D_Alpha),

                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[i].afGuide_Pos[0]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[i].afGuide_Pos[1]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[i].afGuide_Pos[2]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[i].afGuide_Pos[3]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[i].afGuide_Pos[4]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[i].afGuide_Pos[5]),

                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[i].anGuide_Off_IDs[0]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[i].anGuide_Off_IDs[1]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[i].anGuide_Off_IDs[2]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[i].anGuide_Off_IDs[3]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[i].anGuide_Off_IDs[4]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[i].anGuide_Off_IDs[5]),

                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[i].anGuide_Off_Dir[0]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[i].anGuide_Off_Dir[1]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[i].anGuide_Off_Dir[2]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[i].anGuide_Off_Dir[3]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[i].anGuide_Off_Dir[4]),
                        Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[i].anGuide_Off_Dir[5])
                        );
                    m_txtReserve.Text = String.Empty;
                    foreach (string strLine in strReserve.Split(';'))
                    {
                        m_txtReserve.Text += strLine + "\r\n";
                    }
                    //m_txtReserve.Text = strReserve;
                    
                    List<string> lstLines = new List<string>();
                    foreach (string strLine in m_txtReserve.Lines) { if (strLine.Length > 0) lstLines.Add(Ojw.CConvert.RemoveCaption(strLine, true, true)); }
                    i = 0;
                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMotorEnable_For_RPTask = Ojw.CConvert.StrToInt(m_txtReserve.Lines[i++]);
                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMotor_Enable = Ojw.CConvert.StrToInt(m_txtReserve.Lines[i++]);
                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMotionEditor_Index = Ojw.CConvert.StrToInt(m_txtReserve.Lines[i++]);
                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nMotor_HightSpec = Ojw.CConvert.StrToInt(m_txtReserve.Lines[i++]);
                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_4 = Ojw.CConvert.StrToInt(m_txtReserve.Lines[i++]);
                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_5 = Ojw.CConvert.StrToInt(m_txtReserve.Lines[i++]);
                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_6 = Ojw.CConvert.StrToInt(m_txtReserve.Lines[i++]);
                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_7 = Ojw.CConvert.StrToInt(m_txtReserve.Lines[i++]);
                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_8 = Ojw.CConvert.StrToInt(m_txtReserve.Lines[i++]);
                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nReserve_9 = Ojw.CConvert.StrToInt(m_txtReserve.Lines[i++]);

                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fGearRatio = Ojw.CConvert.StrToFloat(m_txtReserve.Lines[i++]);
                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fRobotisConvertingVar = Ojw.CConvert.StrToFloat(m_txtReserve.Lines[i++]);
                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_2 = Ojw.CConvert.StrToFloat(m_txtReserve.Lines[i++]);
                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_3 = Ojw.CConvert.StrToFloat(m_txtReserve.Lines[i++]);
                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_4 = Ojw.CConvert.StrToFloat(m_txtReserve.Lines[i++]);
                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_5 = Ojw.CConvert.StrToFloat(m_txtReserve.Lines[i++]);
                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_6 = Ojw.CConvert.StrToFloat(m_txtReserve.Lines[i++]);
                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_7 = Ojw.CConvert.StrToFloat(m_txtReserve.Lines[i++]);
                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_8 = Ojw.CConvert.StrToFloat(m_txtReserve.Lines[i++]);
                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fReserve_9 = Ojw.CConvert.StrToFloat(m_txtReserve.Lines[i++]);
                     
                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGuide_Event = Ojw.CConvert.StrToInt(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGuide_AxisType = Ojw.CConvert.StrToInt(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGuide_RingColorType = Ojw.CConvert.StrToInt(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fGuide_RingSize = Ojw.CConvert.StrToFloat(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fGuide_RingThick = Ojw.CConvert.StrToFloat(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGuide_RingDir = Ojw.CConvert.StrToInt(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                    if (m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGuide_RingDir == 0) m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].nGuide_RingDir = 1;
                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fGuide_3D_Scale = Ojw.CConvert.StrToFloat(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));
                    m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].fGuide_3D_Alpha = Ojw.CConvert.StrToFloat(Ojw.CConvert.RemoveCaption(m_txtReserve.Lines[i++], true, true));

                    if (m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].afGuide_Pos == null)
                    {
                        m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].afGuide_Pos = new float[6];
                        m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_IDs = new int[6];
                        m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_Dir = new int[6];
                        Array.Clear(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].afGuide_Pos, 0, m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].afGuide_Pos.Length);
                        Array.Clear(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_IDs, 0, m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_IDs.Length);
                        Array.Clear(m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_Dir, 0, m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_Dir.Length);
                    }
                    string [] pstrItems = m_txtReserve.Lines[i++].Split(',');
                    for (int nGuide = 0; nGuide < 6; nGuide++) m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].afGuide_Pos[nGuide] = Ojw.CConvert.StrToFloat(Ojw.CConvert.RemoveCaption(pstrItems[nGuide], true, true));
                    pstrItems = m_txtReserve.Lines[i++].Split(',');
                    for (int nGuide = 0; nGuide < 6; nGuide++) m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_IDs[nGuide] = Ojw.CConvert.StrToInt(Ojw.CConvert.RemoveCaption(pstrItems[nGuide], true, true));
                    pstrItems = m_txtReserve.Lines[i++].Split(',');
                    for (int nGuide = 0; nGuide < 6; nGuide++) m_CHeader.pSMotorInfo[m_cmbAngleLimit.SelectedIndex].anGuide_Off_Dir[nGuide] = Ojw.CConvert.StrToInt(Ojw.CConvert.RemoveCaption(pstrItems[nGuide], true, true));
                }
            }
            #endregion Motor Controls
            #endregion Etc Controls

            #region PropertyGrid(Main)
            private CDynamicProperty m_CDynamicProp = new CDynamicProperty();
            #endregion PropertyGrid(Main)

            #region PropertyGrid
            private CProp_User m_CPropAll = null;//new CProp_User();
            private CProp_Selected m_CPropAll_Selected = null;//new CProp_Selected();

            private CProperty m_CProperty = null;// = new CProperty();
            private CProperty m_CProperty_Selected = null;// = new CProperty();

            //private CProp m_CProp_Main = new CProp();
            public void CreateProb(Panel pnProp)
            {
                m_CDynamicProp.Create(pnProp);
                bool bEn = true;

                Prop_Add("Test", "TestGroup", "TestCaption", (bool)bEn, false, true); 


                //m_CDynamicProp.SetEvent_Changed(Prop_PropertyValueChanged);
            }
            public void Prop_SetEvent_Changed(PropertyValueChangedEventHandler FFunction)
            {
                m_CDynamicProp.SetEvent_Changed(FFunction);
            }
            public void Prop_Add(String strName, String strGroup, String strCaption, object value, bool bReadOnly, bool bVisible)
            {
                m_CDynamicProp.Add(strName, strGroup, strCaption, value, bReadOnly, bVisible);
            }
            public void Prop_Remove(String strName)
            {
                m_CDynamicProp.Remove(strName);
            }

            private class CProp_t
            {
                private class CProp_Sub
                {
                    public CProp_Sub()
                    {
                    }
                    ~CProp_Sub()
                    {
                    }
                    public void Create(COjwDisp OjwDisp)
                    {
                        CDisp = OjwDisp;
                    }
                    COjwDisp CDisp = null;
                    private const string strGroup = "[1]Object";
                    
                    #region Item add : Step 2/4
                    // item add : step 2 / 4
                    [DisplayName(m_pstrProp_0),
                    Browsable(true),
                    CategoryAttribute(strGroup),
                    DescriptionAttribute("Axis Number(-1:None, 0~253)")]
                    public int nAxisName { get { return CDisp.nName; } set { CDisp.nName = value; } }

                    [DisplayName(m_pstrProp_1),
                    Browsable(true),
                    CategoryAttribute(strGroup),
                    DescriptionAttribute("Object Color")]
                    public Color cColor { get { return CDisp.cColor; } set { CDisp.cColor = value; } }

                    private CSlider<float> m_fSliderAlpha = new CSlider<float>(1.0f, 0.0f, 1.0f, 0.1f);
                    [DisplayName(m_pstrProp_Alpha),
                    Browsable(true),
                    CategoryAttribute(strGroup),
                    DescriptionAttribute("~1.0 : Default 1.0")]
                    public float fAlpha { get { return CDisp.fAlpha; } set { CDisp.fAlpha = value; } }
                    
                    [DisplayName(m_pstrProp_2),
                    Browsable(true),
                    CategoryAttribute(strGroup),
                    DescriptionAttribute("#0~#14 : Default, and FileName")]
                    public String strDispObject { get { return CDisp.strDispObject; } set { CDisp.strDispObject = value; } }

                    [DisplayName(m_pstrProp_3),
                    Browsable(true),
                    CategoryAttribute(strGroup),
                    DescriptionAttribute("Fill & Empty")]
                    public bool bFill { get { return CDisp.bFilled; } set { CDisp.bFilled = value; } }

                    [DisplayName(m_pstrProp_4),
                    Browsable(true),
                    //ReadOnlyAttribute(true),
                    CategoryAttribute(strGroup),
                    DescriptionAttribute("Multi(3d)")]
                    public float fMulti { get { return CDisp.fMulti; } set { CDisp.fMulti = value; } }

                    [DisplayName(m_pstrProp_5),
                    Browsable(true),
                    CategoryAttribute(strGroup),
                    DescriptionAttribute("Initialize Position & Angle")]
                    public bool bInit { get { return CDisp.bInit; } set { CDisp.bInit = value; } }

                    [DisplayName(m_pstrProp_6),
                    Browsable(true),
                    CategoryAttribute(strGroup),
                    DescriptionAttribute("")]
                    public float fWidth_Or_Radius { get { return CDisp.fWidth_Or_Radius; } set { CDisp.fWidth_Or_Radius = value; } }

                    [DisplayName(m_pstrProp_7), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                    public float fHeight_Or_Depth { get { return CDisp.fHeight_Or_Depth; } set { CDisp.fHeight_Or_Depth = value; } }
                    [DisplayName(m_pstrProp_8), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                    public float fDepth_Or_Cnt { get { return CDisp.fDepth_Or_Cnt; } set { CDisp.fDepth_Or_Cnt = value; } }
                    [DisplayName(m_pstrProp_9), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                    public float fThickness { get { return CDisp.fThickness; } set { CDisp.fThickness = value; } }
                    [DisplayName(m_pstrProp_10), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                    public float fGap { get { return CDisp.fGap; } set { CDisp.fGap = value; } }
                    [DisplayName(m_pstrProp_11), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                    public string strCaption { get { return CDisp.strCaption; } set { CDisp.strCaption = value; } }
                    [DisplayName(m_pstrProp_12), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                    public int nAxisMoveType { get { return CDisp.nAxisMoveType; } set { CDisp.nAxisMoveType = value; } }
                    [DisplayName(m_pstrProp_13), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                    public int nDir { get { return CDisp.nDir; } set { CDisp.nDir = value; } }
                    [DisplayName(m_pstrProp_14), Browsable(true), ReadOnlyAttribute(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                    public float fAngle { get { return CDisp.fAngle; } set { CDisp.fAngle = value; } }
                    [DisplayName(m_pstrProp_15), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                    public string strAngle_Offset { get { return CDisp.strAngle_Offset; } set { CDisp.strAngle_Offset = value; } }

                    private const string strGroup1 = "[2]Offset Rotation/Translation";
                    [DisplayName(m_pstrProp_16), Browsable(true), CategoryAttribute(strGroup1), DescriptionAttribute("Offset Translation"), TypeConverter(typeof(CVector3DConvert))]
                    public SVector3D_t SOffset_Trans { get { return CDisp.SOffset_Trans; } set { CDisp.SOffset_Trans = value; } }
                    public class CVector3DConvert : TypeConverter
                    {
                        //// http://kindtis.tistory.com/458 참조
                        // string 으로 부터 변환이 가능한가?
                        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
                        {
                            if (sourceType == typeof(string))
                                return true;
                            return base.CanConvertFrom(context, sourceType);
                        }

                        // string 으로 부터 vector3로 변환
                        public override object ConvertFrom(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)
                        {
                            if (value is string)
                            {
                                string[] v = ((string)value).Split(new char[] { ',' });
                                return new SVector3D_t(float.Parse(v[0]), float.Parse(v[1]), float.Parse(v[2]));
                            }
                            return base.ConvertFrom(context, culture, value);
                        }

                        // vector3 에서 string으로 변환
                        public override object ConvertTo(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, Type destinationType)
                        {
                            if (destinationType == typeof(string))
                                return ((SVector3D_t)value).x + "," + ((SVector3D_t)value).y + "," + ((SVector3D_t)value).z;
                            return base.ConvertTo(context, culture, value, destinationType);
                        }
                    }
                    public class CAngle3DConvert : TypeConverter
                    {
                        //// http://kindtis.tistory.com/458 참조
                        // string 으로 부터 변환이 가능한가?
                        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
                        {
                            if (sourceType == typeof(string))
                                return true;
                            return base.CanConvertFrom(context, sourceType);
                        }

                        // string 으로 부터 angle3로 변환
                        public override object ConvertFrom(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)
                        {
                            if (value is string)
                            {
                                string[] v = ((string)value).Split(new char[] { ',' });
                                return new SAngle3D_t(float.Parse(v[0]), float.Parse(v[1]), float.Parse(v[2]));
                            }
                            return base.ConvertFrom(context, culture, value);
                        }

                        // angle3 에서 string으로 변환
                        public override object ConvertTo(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, Type destinationType)
                        {
                            if (destinationType == typeof(string))
                                return ((SAngle3D_t)value).pan + "," + ((SAngle3D_t)value).tilt + "," + ((SAngle3D_t)value).swing;
                            return base.ConvertTo(context, culture, value, destinationType);
                        }
                    }
                    public class CPoint3DConvert : TypeConverter
                    {
                        //// http://kindtis.tistory.com/458 참조
                        // string 으로 부터 변환이 가능한가?
                        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
                        {
                            if (sourceType == typeof(string))
                                return true;
                            return base.CanConvertFrom(context, sourceType);
                        }

                        // string 으로 부터 Point3d로 변환
                        public override object ConvertFrom(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)
                        {
                            if (value is string)
                            {
                                string[] v = ((string)value).Split(new char[] { ',' });
                                return new SPoint3D_t(int.Parse(v[0]), int.Parse(v[1]), int.Parse(v[2]));
                            }
                            return base.ConvertFrom(context, culture, value);
                        }

                        // Point3d 에서 string으로 변환
                        public override object ConvertTo(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, Type destinationType)
                        {
                            if (destinationType == typeof(string))
                                return ((SPoint3D_t)value).x + "," + ((SPoint3D_t)value).y + "," + ((SPoint3D_t)value).z;
                            return base.ConvertTo(context, culture, value, destinationType);
                        }
                    }

                    private const string strGroup2 = strGroup1;//"[2]Offset Rotation";
                    [DisplayName(m_pstrProp_19), Browsable(true), CategoryAttribute(strGroup2), DescriptionAttribute("Offset Rotation"), TypeConverter(typeof(CAngle3DConvert))]
                    public SAngle3D_t SOffset_Rot { get { return CDisp.SOffset_Rot; } set { CDisp.SOffset_Rot = value; } }

                    private const string strGroup3 = "[3]Rotation/Translation";
                    [DisplayName(m_pstrProp_22), Browsable(true), CategoryAttribute(strGroup3), DescriptionAttribute("1\'st Translation"), TypeConverter(typeof(CVector3DConvert))]
                    public SVector3D_t STrans_1 { get { return CDisp.afTrans[0]; } set { CDisp.afTrans[0] = value; } }

                    private const string strGroup4 = strGroup3;//"[3]1\'st Rotation";
                    [DisplayName(m_pstrProp_25), Browsable(true), CategoryAttribute(strGroup4), DescriptionAttribute("1\'st Rotation"), TypeConverter(typeof(CAngle3DConvert))]
                    public SAngle3D_t SRot_1 { get { return CDisp.afRot[0]; } set { CDisp.afRot[0] = value; } }

                    private const string strGroup5 = strGroup3;//"[4]2\'st Translation";
                    [DisplayName(m_pstrProp_28), Browsable(true), CategoryAttribute(strGroup5), DescriptionAttribute("2\'st Translation"), TypeConverter(typeof(CVector3DConvert))]
                    public SVector3D_t STrans_2 { get { return CDisp.afTrans[1]; } set { CDisp.afTrans[1] = value; } }

                    private const string strGroup6 = strGroup3;//"[4]2\'st Rotation";
                    [DisplayName(m_pstrProp_31), Browsable(true), CategoryAttribute(strGroup6), DescriptionAttribute("2\'st Rotation"), TypeConverter(typeof(CAngle3DConvert))]
                    public SAngle3D_t SRot_2 { get { return CDisp.afRot[1]; } set { CDisp.afRot[1] = value; } }

                    private const string strGroup7 = strGroup3;//"[5]3\'st Translation";
                    [DisplayName(m_pstrProp_34), Browsable(true), CategoryAttribute(strGroup7), DescriptionAttribute("3\'st Translation"), TypeConverter(typeof(CVector3DConvert))]
                    public SVector3D_t STrans_3 { get { return CDisp.afTrans[2]; } set { CDisp.afTrans[2] = value; } }

                    private const string strGroup8 = strGroup3;//"[5]3\'st Rotation";
                    [DisplayName(m_pstrProp_37), Browsable(true), CategoryAttribute(strGroup8), DescriptionAttribute("3\'st Rotation"), TypeConverter(typeof(CAngle3DConvert))]
                    public SAngle3D_t SRot_3 { get { return CDisp.afRot[2]; } set { CDisp.afRot[2] = value; } }

                    private const string strGroup9 = strGroup3;//"[6]4\'st Translation";
                    [DisplayName(m_pstrProp_40), Browsable(true), CategoryAttribute(strGroup9), DescriptionAttribute("4\'st Translation"), TypeConverter(typeof(CVector3DConvert))]
                    public SVector3D_t STrans_4 { get { return CDisp.afTrans[3]; } set { CDisp.afTrans[3] = value; } }

                    private const string strGroup10 = strGroup3;//"[6]4\'st Rotation";
                    [DisplayName(m_pstrProp_43), Browsable(true), CategoryAttribute(strGroup10), DescriptionAttribute("4\'st Rotation"), TypeConverter(typeof(CAngle3DConvert))]
                    public SAngle3D_t SRot_4 { get { return CDisp.afRot[3]; } set { CDisp.afRot[3] = value; } }

                    private const string strGroup11 = strGroup3;//"[7]5\'st Translation";
                    [DisplayName(m_pstrProp_46), Browsable(true), CategoryAttribute(strGroup11), DescriptionAttribute("5\'st Translation"), TypeConverter(typeof(CVector3DConvert))]
                    public SVector3D_t STrans_5 { get { return CDisp.afTrans[4]; } set { CDisp.afTrans[4] = value; } }

                    private const string strGroup12 = strGroup3;//"[7]5\'st Rotation";
                    [DisplayName(m_pstrProp_49), Browsable(true), CategoryAttribute(strGroup12), DescriptionAttribute("5\'st Rotation"), TypeConverter(typeof(CAngle3DConvert))]
                    public SAngle3D_t SRot_5 { get { return CDisp.afRot[4]; } set { CDisp.afRot[4] = value; } }

                    [DisplayName(m_pstrProp_52), Browsable(true), CategoryAttribute(strGroupComment), DescriptionAttribute(""), TypeConverter(typeof(CPoint3DConvert))]
                    public SPoint3D_t SPickGroup { get { return new SPoint3D_t(CDisp.nPickGroup_A, CDisp.nPickGroup_B, CDisp.nPickGroup_C); } set { CDisp.nPickGroup_A = value.x; CDisp.nPickGroup_B = value.y; CDisp.nPickGroup_C = value.z; } }

                    [DisplayName(m_pstrProp_55), Browsable(true), CategoryAttribute(strGroupComment), DescriptionAttribute("")]
                    public int nInverseKinematicsNumber { get { return CDisp.nInverseKinematicsNumber; } set { CDisp.nInverseKinematicsNumber = value; } }
                    //[DisplayName(m_pstrProp_61), Browsable(true), CategoryAttribute(strGroupComment), DescriptionAttribute("")]
                    //public int nInverseKinematicsNumber_AfterCalc { get { return CDisp.nInverseKinematicsNumber_AfterCalc; } set { CDisp.nInverseKinematicsNumber_AfterCalc = value; } }

                    [DisplayName(m_pstrProp_56), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                    public float fScale_Serve0 { get { return CDisp.fScale_Serve0; } set { CDisp.fScale_Serve0 = value; } }
                    [DisplayName(m_pstrProp_57), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                    public float fScale_Serve1 { get { return CDisp.fScale_Serve1; } set { CDisp.fScale_Serve1 = value; } }
                    [DisplayName(m_pstrProp_58), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                    public int nMotorType { get { return CDisp.nMotorType; } set { CDisp.nMotorType = value; } }
                    [DisplayName(m_pstrProp_59), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                    public int nMotorControl_MousePoint { get { return CDisp.nMotorControl_MousePoint; } set { CDisp.nMotorControl_MousePoint = value; } }

                    private const string strGroupComment = "[0]Comment";
                    [DisplayName(m_pstrProp_60), Browsable(true), CategoryAttribute(strGroupComment), DescriptionAttribute("")]
                    public String strPickGroup_Comment { get { return CDisp.strPickGroup_Comment; } set { CDisp.strPickGroup_Comment = value; } }

                    //// if you want to add , just do like below ////

                    //[DisplayName(m_pstrProp_), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                    //public { get { return CDisp.; } set { CDisp. = value; } }

                    #endregion Item add : Step 2/4
                    #region Set
                
                
                    #endregion Set
                }
            }
            #region Prop_Selected
            private COjwDisp m_CDisp_Selected = null;// = new COjwDisp();
            //private Panel m_panelSelected = null;
            private Control m_panelSelected = null;
            public void CreateProp_Selected(int nLine)
            {
                if (m_panelSelected != null)
                    CreateProp_Selected(m_panelSelected, OjwDispAll.GetData(nLine));
            }
            public void CreateProp_Selected(COjwDisp CDisp)
            {
                if (m_panelSelected != null)
                    CreateProp_Selected(m_panelSelected, CDisp);
            }
            public void CreateProp_Selected(Control ctrlProp, int nLine)//(Panel pnProp, int nLine)
            {
                CreateProp_Selected(ctrlProp, OjwDispAll.GetData(nLine));
            }
            public void CreateProp_Selected(Control ctrlProp, COjwDisp CDisp)//(Panel pnProp, COjwDisp CDisp)
            {
#if false
                m_CProperty_Selected.Destroy(pnProp); 
                m_CDisp_Selected = null;
                if (CDisp != null)
                {
                    if (CDisp.strDispObject != "#-1")
                    {
                        //m_CPropAll_Selected = null;
                        //CProp_Selected
                        m_CPropAll_Selected.Create(CDisp);//m_CDisp);
                        m_CProperty_Selected.Create(pnProp, m_CPropAll_Selected);//m_CProp_Main);
                        m_CProperty_Selected.SetEvent_Changed(Prop_PropertyValueChanged_Selected);

                        m_CDisp_Selected = CDisp;

                        //Prop_Update_Selected();
                    }
                }
                m_panelSelected = pnProp;
#else
                if (m_CProperty_Selected != null) m_CProperty_Selected.Destroy(ctrlProp);
                if (m_CProperty_Selected == null) m_CProperty_Selected = new CProperty();
                m_CDisp_Selected = null;
                if (CDisp != null)
                {
                    //if (CDisp.strDispObject != "#-1")
                    //{
                        //m_CPropAll_Selected = null;
                        //CProp_Selected
                    if (m_CPropAll_Selected == null) m_CPropAll_Selected = new CProp_Selected();
                    m_CPropAll_Selected.Create(CDisp);//m_CDisp);
                    m_CProperty_Selected.Create(ctrlProp, m_CPropAll_Selected);//m_CProp_Main);
                    m_CProperty_Selected.SetEvent_Changed(Prop_PropertyValueChanged_Selected);

                    m_CDisp_Selected = CDisp;

                        //Prop_Update_Selected();
                    //}
                }
                m_panelSelected = ctrlProp;//pnProp;
#endif
            }

            [DefaultPropertyAttribute("OpenJigWare")]
            [RefreshProperties(RefreshProperties.All)]
            private class CProp_Selected
            {
                public CProp_Selected()
                {
                }
                ~CProp_Selected()
                {
                }
                public void Destroy()
                {
                    CDisp = null;
                }
                public void Create(COjwDisp OjwDisp)
                {
                    CDisp = OjwDisp;
                }
                public void Visible(String strName, bool bVisible)
                {
                    PropertyDescriptor descriptor = TypeDescriptor.GetProperties(this.GetType())[strName];
                    BrowsableAttribute attrib = (BrowsableAttribute)descriptor.Attributes[typeof(BrowsableAttribute)];
                    FieldInfo isBrow = attrib.GetType().GetField("browsable", BindingFlags.NonPublic | BindingFlags.Instance);
                    isBrow.SetValue(attrib, bVisible);
                }

                COjwDisp CDisp = null;
                private const string strGroup = "[1]Object";
                //private int _nTest = 0;
                //[DisplayName("Test"), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("Test Main")]
                //public int nTest { get { return _nTest; } set { _nTest = value; } }

                #region Item add : Step 2/4
                // item add : step 2 / 4
                [DisplayName(m_pstrProp_0),
                Browsable(true),
                CategoryAttribute(strGroup),
                DescriptionAttribute("Axis Number(-1:None, 0~253)")]
                public int nAxisName { get { return (CDisp == null) ? 0 : CDisp.nName; } set { CDisp.nName = value; } }

                [DisplayName(m_pstrProp_1),
                Browsable(true),
                CategoryAttribute(strGroup),
                DescriptionAttribute("Object Color")]
                public Color cColor { get { return (CDisp == null) ? Color.White : CDisp.cColor; } set { CDisp.cColor = value; } }

                private CSlider<float> m_fSliderAlpha = new CSlider<float>(1.0f, 0.0f, 1.0f, 0.1f);
                [DisplayName(m_pstrProp_Alpha),
                Browsable(true),
                CategoryAttribute(strGroup),
                    //Editor(typeof(CSlider<float>), typeof(CSlider<float>)),
                    //Editor(typeof(CustomSlider), typeof(PropertyValueEditor)),
                DescriptionAttribute("~1.0 : Default 1.0")]
                public float fAlpha { get { return (CDisp == null) ? 0.0f : CDisp.fAlpha; } set { CDisp.fAlpha = value; } }
                //                public CSlider<float> fSliderAlpha { get { return m_fSliderAlpha; } set { m_fSliderAlpha = value; } }
                //                public class CustomSlider : ExtendedPropertyValueEditor
                //                {
                //                    public CustomSlider()
                //                    {
                //                        // Template for normal view
                //                        string template1 = @"
                //                        <DataTemplate
                //                            xmlns='http://schemas.microsoft.com/winfx/2006/xaml/presentation'
                //                            xmlns:x='http://schemas.microsoft.com/winfx/2006/xaml'
                //                            xmlns:pe='clr-namespace:System.Activities.Presentation.PropertyEditing;assembly=System.Activities.Presentation' 
                //                            xmlns:wpg='clr-namespace:PropertyGrid;assembly=PropertyGrid' > 
                //                            <DockPanel LastChildFill='True'>
                //                                    <TextBox Text='{Binding Path=Value.Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}' Width='40' TextAlignment='Center' />
                //                                    <Slider x:Name='slider1' Value='{Binding Path=Value.Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}' Margin='2,0,0,0' Minimum='{Binding Value.Min}' Maximum='{Binding Value.Max}' />
                //                            </DockPanel>
                //                        </DataTemplate>";

                //                        // Load templates
                //                        using (var sr = new MemoryStream(Encoding.UTF8.GetBytes(template1)))
                //                        {
                //                            this.InlineEditorTemplate = XamlReader.Load(sr) as DataTemplate;
                //                        }
                //                    }
                //                }

                [DisplayName(m_pstrProp_2),
                Browsable(true),
                CategoryAttribute(strGroup),
                DescriptionAttribute("#0~#14 : Default, and FileName")]
                public String strDispObject { get { return (CDisp == null) ? "" : CDisp.strDispObject; } set { CDisp.strDispObject = value; } }

                [DisplayName(m_pstrProp_3),
                Browsable(true),
                CategoryAttribute(strGroup),
                DescriptionAttribute("Fill & Empty")]
                public bool bFill { get { return (CDisp == null) ? false : CDisp.bFilled; } set { CDisp.bFilled = value; } }

                [DisplayName(m_pstrProp_4),
                Browsable(true),
                //ReadOnlyAttribute(true),
                CategoryAttribute(strGroup),
                DescriptionAttribute("Multi(3d)")]
                public float fMulti { get { return (CDisp == null) ? 0 : CDisp.fMulti; } set { CDisp.fMulti = value; } }

                [DisplayName(m_pstrProp_5),
                Browsable(true),
                CategoryAttribute(strGroup),
                DescriptionAttribute("Initialize Position & Angle")]
                public bool bInit { get { return (CDisp == null) ? false : CDisp.bInit; } set { CDisp.bInit = value; } }

                [DisplayName(m_pstrProp_6),
                Browsable(true),
                CategoryAttribute(strGroup),
                DescriptionAttribute("")]
                public float fWidth_Or_Radius { get { return (CDisp == null) ? 0.0f : CDisp.fWidth_Or_Radius; } set { CDisp.fWidth_Or_Radius = value; } }

                [DisplayName(m_pstrProp_7), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                public float fHeight_Or_Depth { get { return (CDisp == null) ? 0.0f : CDisp.fHeight_Or_Depth; } set { CDisp.fHeight_Or_Depth = value; } }
                [DisplayName(m_pstrProp_8), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                public float fDepth_Or_Cnt { get { return (CDisp == null) ? 0 : CDisp.fDepth_Or_Cnt; } set { CDisp.fDepth_Or_Cnt = value; } }
                [DisplayName(m_pstrProp_9), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                public float fThickness { get { return (CDisp == null) ? 0 : CDisp.fThickness; } set { CDisp.fThickness = value; } }
                [DisplayName(m_pstrProp_10), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                public float fGap { get { return (CDisp == null) ? 0 : CDisp.fGap; } set { CDisp.fGap = value; } }
                [DisplayName(m_pstrProp_11), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                public string strCaption { get { return (CDisp == null) ? "" : CDisp.strCaption; } set { CDisp.strCaption = value; } }
                [DisplayName(m_pstrProp_12), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                public int nAxisMoveType { get { return (CDisp == null) ? 0 : CDisp.nAxisMoveType; } set { CDisp.nAxisMoveType = value; } }
                [DisplayName(m_pstrProp_13), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                public int nDir { get { return (CDisp == null) ? 0 : CDisp.nDir; } set { CDisp.nDir = value; } }
                [DisplayName(m_pstrProp_14), Browsable(true), ReadOnlyAttribute(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                public float fAngle { get { return (CDisp == null) ? 0 : CDisp.fAngle; } set { CDisp.fAngle = value; } }
                [DisplayName(m_pstrProp_15), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                public string strAngle_Offset { get { return (CDisp == null) ? "" : CDisp.strAngle_Offset; } set { CDisp.strAngle_Offset = value; } }

                private const string strGroup1 = "[2]Offset Rotation/Translation";
                [DisplayName(m_pstrProp_16), Browsable(true), CategoryAttribute(strGroup1), DescriptionAttribute("Offset Translation"), TypeConverter(typeof(CVector3DConvert))]
                public SVector3D_t SOffset_Trans { get { return (CDisp == null) ? new SVector3D_t(0.0f, 0.0f, 0.0f) : CDisp.SOffset_Trans; } set { CDisp.SOffset_Trans = value; } }
                public class CVector3DConvert : TypeConverter
                {
                    //// http://kindtis.tistory.com/458 참조
                    // string 으로 부터 변환이 가능한가?
                    public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
                    {
                        if (sourceType == typeof(string))
                            return true;
                        return base.CanConvertFrom(context, sourceType);
                    }

                    // string 으로 부터 vector3로 변환
                    public override object ConvertFrom(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)
                    {
                        if (value is string)
                        {
                            string[] v = ((string)value).Split(new char[] { ',' });
                            return new SVector3D_t(float.Parse(v[0]), float.Parse(v[1]), float.Parse(v[2]));
                        }
                        return base.ConvertFrom(context, culture, value);
                    }

                    // vector3 에서 string으로 변환
                    public override object ConvertTo(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, Type destinationType)
                    {
                        if (destinationType == typeof(string))
                            return ((SVector3D_t)value).x + "," + ((SVector3D_t)value).y + "," + ((SVector3D_t)value).z;
                        return base.ConvertTo(context, culture, value, destinationType);
                    }
                }
                public class CAngle3DConvert : TypeConverter
                {
                    //// http://kindtis.tistory.com/458 참조
                    // string 으로 부터 변환이 가능한가?
                    public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
                    {
                        if (sourceType == typeof(string))
                            return true;
                        return base.CanConvertFrom(context, sourceType);
                    }

                    // string 으로 부터 angle3로 변환
                    public override object ConvertFrom(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)
                    {
                        if (value is string)
                        {
                            string[] v = ((string)value).Split(new char[] { ',' });
                            return new SAngle3D_t(float.Parse(v[0]), float.Parse(v[1]), float.Parse(v[2]));
                        }
                        return base.ConvertFrom(context, culture, value);
                    }

                    // angle3 에서 string으로 변환
                    public override object ConvertTo(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, Type destinationType)
                    {
                        if (destinationType == typeof(string))
                            return ((SAngle3D_t)value).pan + "," + ((SAngle3D_t)value).tilt + "," + ((SAngle3D_t)value).swing;
                        return base.ConvertTo(context, culture, value, destinationType);
                    }
                }
                public class CPoint3DConvert : TypeConverter
                {
                    //// http://kindtis.tistory.com/458 참조
                    // string 으로 부터 변환이 가능한가?
                    public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
                    {
                        if (sourceType == typeof(string))
                            return true;
                        return base.CanConvertFrom(context, sourceType);
                    }

                    // string 으로 부터 Point3d로 변환
                    public override object ConvertFrom(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)
                    {
                        if (value is string)
                        {
                            string[] v = ((string)value).Split(new char[] { ',' });
                            return new SPoint3D_t(int.Parse(v[0]), int.Parse(v[1]), int.Parse(v[2]));
                        }
                        return base.ConvertFrom(context, culture, value);
                    }

                    // Point3d 에서 string으로 변환
                    public override object ConvertTo(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, Type destinationType)
                    {
                        if (destinationType == typeof(string))
                            return ((SPoint3D_t)value).x + "," + ((SPoint3D_t)value).y + "," + ((SPoint3D_t)value).z;
                        return base.ConvertTo(context, culture, value, destinationType);
                    }
                }

                private const string strGroup2 = strGroup1;//"[2]Offset Rotation";
                [DisplayName(m_pstrProp_19), Browsable(true), CategoryAttribute(strGroup2), DescriptionAttribute("Offset Rotation"), TypeConverter(typeof(CAngle3DConvert))]
                public SAngle3D_t SOffset_Rot { get { return (CDisp == null) ? new SAngle3D_t(0.0f, 0.0f, 0.0f) : CDisp.SOffset_Rot; } set { CDisp.SOffset_Rot = value; } }

                private const string strGroup3 = "[3]Rotation/Translation";
                [DisplayName(m_pstrProp_22), Browsable(true), CategoryAttribute(strGroup3), DescriptionAttribute("1\'st Translation"), TypeConverter(typeof(CVector3DConvert))]
                public SVector3D_t STrans_1 { get { return (CDisp == null) ? new SVector3D_t(0.0f, 0.0f, 0.0f) : CDisp.afTrans[0]; } set { CDisp.afTrans[0] = value; } }

                private const string strGroup4 = strGroup3;//"[3]1\'st Rotation";
                [DisplayName(m_pstrProp_25), Browsable(true), CategoryAttribute(strGroup4), DescriptionAttribute("1\'st Rotation"), TypeConverter(typeof(CAngle3DConvert))]
                public SAngle3D_t SRot_1 { get { return (CDisp == null) ? new SAngle3D_t(0.0f, 0.0f, 0.0f) : CDisp.afRot[0]; } set { CDisp.afRot[0] = value; } }

                private const string strGroup5 = strGroup3;//"[4]2\'st Translation";
                [DisplayName(m_pstrProp_28), Browsable(true), CategoryAttribute(strGroup5), DescriptionAttribute("2\'st Translation"), TypeConverter(typeof(CVector3DConvert))]
                public SVector3D_t STrans_2 { get { return (CDisp == null) ? new SVector3D_t(0.0f, 0.0f, 0.0f) : CDisp.afTrans[1]; } set { CDisp.afTrans[1] = value; } }

                private const string strGroup6 = strGroup3;//"[4]2\'st Rotation";
                [DisplayName(m_pstrProp_31), Browsable(true), CategoryAttribute(strGroup6), DescriptionAttribute("2\'st Rotation"), TypeConverter(typeof(CAngle3DConvert))]
                public SAngle3D_t SRot_2 { get { return (CDisp == null) ? new SAngle3D_t(0.0f, 0.0f, 0.0f) : CDisp.afRot[1]; } set { CDisp.afRot[1] = value; } }

                private const string strGroup7 = strGroup3;//"[5]3\'st Translation";
                [DisplayName(m_pstrProp_34), Browsable(true), CategoryAttribute(strGroup7), DescriptionAttribute("3\'st Translation"), TypeConverter(typeof(CVector3DConvert))]
                public SVector3D_t STrans_3 { get { return (CDisp == null) ? new SVector3D_t(0.0f, 0.0f, 0.0f) : CDisp.afTrans[2]; } set { CDisp.afTrans[2] = value; } }

                private const string strGroup8 = strGroup3;//"[5]3\'st Rotation";
                [DisplayName(m_pstrProp_37), Browsable(true), CategoryAttribute(strGroup8), DescriptionAttribute("3\'st Rotation"), TypeConverter(typeof(CAngle3DConvert))]
                public SAngle3D_t SRot_3 { get { return (CDisp == null) ? new SAngle3D_t(0.0f, 0.0f, 0.0f) : CDisp.afRot[2]; } set { CDisp.afRot[2] = value; } }

                private const string strGroup9 = strGroup3;//"[6]4\'st Translation";
                [DisplayName(m_pstrProp_40), Browsable(true), CategoryAttribute(strGroup9), DescriptionAttribute("4\'st Translation"), TypeConverter(typeof(CVector3DConvert))]
                public SVector3D_t STrans_4 { get { return (CDisp == null) ? new SVector3D_t(0.0f, 0.0f, 0.0f) : CDisp.afTrans[3]; } set { CDisp.afTrans[3] = value; } }

                private const string strGroup10 = strGroup3;//"[6]4\'st Rotation";
                [DisplayName(m_pstrProp_43), Browsable(true), CategoryAttribute(strGroup10), DescriptionAttribute("4\'st Rotation"), TypeConverter(typeof(CAngle3DConvert))]
                public SAngle3D_t SRot_4 { get { return (CDisp == null) ? new SAngle3D_t(0.0f, 0.0f, 0.0f) : CDisp.afRot[3]; } set { CDisp.afRot[3] = value; } }

                private const string strGroup11 = strGroup3;//"[7]5\'st Translation";
                [DisplayName(m_pstrProp_46), Browsable(true), CategoryAttribute(strGroup11), DescriptionAttribute("5\'st Translation"), TypeConverter(typeof(CVector3DConvert))]
                public SVector3D_t STrans_5 { get { return (CDisp == null) ? new SVector3D_t(0.0f, 0.0f, 0.0f) : CDisp.afTrans[4]; } set { CDisp.afTrans[4] = value; } }

                private const string strGroup12 = strGroup3;//"[7]5\'st Rotation";
                [DisplayName(m_pstrProp_49), Browsable(true), CategoryAttribute(strGroup12), DescriptionAttribute("5\'st Rotation"), TypeConverter(typeof(CAngle3DConvert))]
                public SAngle3D_t SRot_5 { get { return (CDisp == null) ? new SAngle3D_t(0.0f, 0.0f, 0.0f) : CDisp.afRot[4]; } set { CDisp.afRot[4] = value; } }


                [DisplayName(m_pstrProp_52), Browsable(true), CategoryAttribute(strGroupComment), DescriptionAttribute(""), TypeConverter(typeof(CPoint3DConvert))]
                public SPoint3D_t SPickGroup { get { return (CDisp == null) ? new SPoint3D_t(0, 0, 0) : new SPoint3D_t(CDisp.nPickGroup_A, CDisp.nPickGroup_B, CDisp.nPickGroup_C); } set { CDisp.nPickGroup_A = value.x; CDisp.nPickGroup_B = value.y; CDisp.nPickGroup_C = value.z; } }

                [DisplayName(m_pstrProp_55), Browsable(true), CategoryAttribute(strGroupComment), DescriptionAttribute("")]
                public int nInverseKinematicsNumber { get { return (CDisp == null) ? 0 : CDisp.nInverseKinematicsNumber; } set { CDisp.nInverseKinematicsNumber = value; } }
                //[DisplayName(m_pstrProp_61), Browsable(true), CategoryAttribute(strGroupComment), DescriptionAttribute("")]
                //public int nInverseKinematicsNumber_AfterCalc { get { return (CDisp == null) ? 0 : CDisp.nInverseKinematicsNumber_AfterCalc; } set { CDisp.nInverseKinematicsNumber_AfterCalc = value; } }
                
                
                [DisplayName(m_pstrProp_56), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                public float fScale_Serve0 { get { return (CDisp == null) ? 0 : CDisp.fScale_Serve0; } set { CDisp.fScale_Serve0 = value; } }
                [DisplayName(m_pstrProp_57), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                public float fScale_Serve1 { get { return (CDisp == null) ? 0 : CDisp.fScale_Serve1; } set { CDisp.fScale_Serve1 = value; } }
                [DisplayName(m_pstrProp_58), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                public int nMotorType { get { return (CDisp == null) ? 0 : CDisp.nMotorType; } set { CDisp.nMotorType = value; } }
                [DisplayName(m_pstrProp_59), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                public int nMotorControl_MousePoint { get { return (CDisp == null) ? 0 : CDisp.nMotorControl_MousePoint; } set { CDisp.nMotorControl_MousePoint = value; } }

                private const string strGroupComment = "[0]Comment";
                [DisplayName(m_pstrProp_60), Browsable(true), CategoryAttribute(strGroupComment), DescriptionAttribute("")]
                public String strPickGroup_Comment { get { return (CDisp == null) ? "" : CDisp.strPickGroup_Comment; } set { CDisp.strPickGroup_Comment = value; } }

                //// if you want to add , just do like below ////

                //[DisplayName(m_pstrProp_), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                //public { get { return CDisp.; } set { CDisp. = value; } }

                #endregion Item add : Step 2/4
            }


            private void Prop_PropertyValueChanged_Selected(object s, PropertyValueChangedEventArgs e)
            {
                if (m_CProperty_Selected == null) return;

                // item add : step 4 / 4
                switch (e.ChangedItem.Label)
                {                    
                    #region Selected
                    #region AxisName
                    case m_pstrProp_0:
                        Prop_Set_Name_Selected((int)e.ChangedItem.Value);
                        break;
                    #endregion AxisName
                    #region Color
                    case m_pstrProp_1:
                        Prop_Set_Color_Selected((Color)e.ChangedItem.Value);
                        break;
                    #endregion Color
                    #region Model
                    case m_pstrProp_2: // Model                        
                        Prop_Set_DispObject_Selected((String)e.ChangedItem.Value);
                        break;
                    #endregion Model
                    #region Fill
                    case m_pstrProp_3: // Fill                        
                        Prop_Set_Fill_Selected((bool)e.ChangedItem.Value);
                        break;
                    #endregion Fill
                    #region fMul_3DAngle
                    case m_pstrProp_4: // 3D 동작각에서의 동작 배율(0보다 큰 값)                        
                        Prop_Set_fMul_3DAngle_Selected((float)e.ChangedItem.Value);
                        break;
                    #endregion fMul_3DAngle
                    #region Init
                    case m_pstrProp_5: // Init
                        Prop_Set_Init_Selected((bool)e.ChangedItem.Value);
                        break;
                    #endregion Init
                    #region Width or Radius
                    case m_pstrProp_6:
                        Prop_Set_Width_Or_Radius_Selected((float)e.ChangedItem.Value);
                        break;
                    #endregion Width or Radius
                    #region Width or Radius
                    case m_pstrProp_7:
                        Prop_Set_Height_Or_Depth_Selected((float)e.ChangedItem.Value);
                        break;
                    #endregion Width or Radius
                    #region Depth or Cnt
                    case m_pstrProp_8:
                        Prop_Set_Depth_Or_Cnt_Selected((float)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region Thickness
                    case m_pstrProp_9:
                        Prop_Set_Thickness_Selected((float)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region fGap
                    case m_pstrProp_10:
                        Prop_Set_Gap_Selected((float)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region strCaption
                    case m_pstrProp_11:
                        Prop_Set_Caption_Selected((string)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region nAxisMoveType
                    case m_pstrProp_12:
                        Prop_Set_AxisMoveType_Selected((int)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region nDir
                    case m_pstrProp_13:
                        Prop_Set_Dir_Selected((int)e.ChangedItem.Value);
                        break;
                    #endregion Dir
                    #region fAngle
                    case m_pstrProp_14:
                        Prop_Set_Angle_Selected((float)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region strAngle_Offset
                    case m_pstrProp_15:
                        Prop_Set_Angle_Offset_Selected((string)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region Offset_Trans
                    case m_pstrProp_16:
                        Prop_Set_Offset_Trans_Selected((SVector3D_t)e.ChangedItem.Value);
                        break;
                    //case m_pstrProp_17:
                    //    Prop_Set_Offset_Trans_Y_Selected((float)e.ChangedItem.Value);
                    //    break;
                    //case m_pstrProp_18:
                    //    Prop_Set_Offset_Trans_Z_Selected((float)e.ChangedItem.Value);
                    //    break;
                    #endregion
                    #region Offset_Rot
                    case m_pstrProp_19:
                        ;
                        Prop_Set_Offset_Rot_Selected((SAngle3D_t)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region Trans/Rot 1st
                    case m_pstrProp_22:
                        Prop_Set_Trans_1_Selected((SVector3D_t)e.ChangedItem.Value);
                        break;
                    case m_pstrProp_25:
                        Prop_Set_Rot_1_Selected((SAngle3D_t)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region Trans/Rot 2st
                    case m_pstrProp_28:
                        Prop_Set_Trans_2_Selected((SVector3D_t)e.ChangedItem.Value);
                        break;
                    case m_pstrProp_31:
                        Prop_Set_Rot_2_Selected((SAngle3D_t)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region Trans/Rot 3st
                    case m_pstrProp_34:
                        Prop_Set_Trans_3_Selected((SVector3D_t)e.ChangedItem.Value);
                        break;
                    case m_pstrProp_37:
                        Prop_Set_Rot_3_Selected((SAngle3D_t)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region region Trans/Rot 4st
                    case m_pstrProp_40:
                        Prop_Set_Trans_4_Selected((SVector3D_t)e.ChangedItem.Value);
                        break;
                    case m_pstrProp_43:
                        Prop_Set_Rot_4_Selected((SAngle3D_t)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region region Trans/Rot 5st
                    case m_pstrProp_46:
                        Prop_Set_Trans_5_Selected((SVector3D_t)e.ChangedItem.Value);
                        break;
                    case m_pstrProp_49:
                        Prop_Set_Rot_5_Selected((SAngle3D_t)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region nPickGroup
                    case m_pstrProp_52:
                        Prop_Set_PickGroup_Selected((SPoint3D_t)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region InverseKinematicsNumber
                    case m_pstrProp_55:
                        Prop_Set_InverseKinematicsNumber_Selected((int)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region Scale_Serve
                    case m_pstrProp_56:
                        Prop_Set_Scale_Serve0_Selected((float)e.ChangedItem.Value);
                        break;
                    case m_pstrProp_57:
                        Prop_Set_Scale_Serve1_Selected((float)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region MotorType
                    case m_pstrProp_58:
                        Prop_Set_MotorType_Selected((int)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region MotorControl_MousePoint
                    case m_pstrProp_59:
                        Prop_Set_MotorControl_MousePoint_Selected((int)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region PickGroup_Comment
                    case m_pstrProp_60:
                        Prop_Set_PickGroup_Comment_Selected((string)e.ChangedItem.Value);
                        break;
                    #endregion
                    //case m_pstrProp_:
                    //    OjwVirtualDisp. = ()e.ChangedItem.Value;
                    //    Prop_Set_(OjwVirtualDisp.);
                    //    break;
                    //case m_pstrProp_:
                    //    OjwVirtualDisp. = ()e.ChangedItem.Value;
                    //    Prop_Set_(OjwVirtualDisp.);
                    //    break;
                    #endregion Selected
                }
                
                Prop_Update_Selected();
                //m_CProperty_Selected.
                //if (IsDrawText() == true)
                //{
                //    m_rtxtDraw.Text = GetHeader_strDrawModel();
                //    StringListToGrid();
                //}
                if (IsDrawRText() == true)
                {
                    //m_bItemAdded = true;
                    m_rtxtDraw.Text = GetHeader_strDrawModel();
                    m_rtxtDraw.Select(m_nSelectedItem, 0);
                    StringListToGrid();
                    //m_bItemAdded = false;
                }
            }
            public void Prop_Update_Selected() 
            { 
                m_CProperty_Selected.Update();
                ////////////////////////////////////
                String strDraw = String.Empty;
                for (int i = 0; i < m_rtxtDraw.Lines.Length; i++)
                {
                    if (i == m_nSelectedItem)
                    {
                        strDraw += ClassToString(OjwDispAll.GetData(i));
                    }
                    else
                    {
                        strDraw += m_rtxtDraw.Lines[i];
                    }
                    if (i < m_rtxtDraw.Lines.Length - 1) strDraw += "\r\n";
                }
                if (m_rtxtDraw != null)
                {
                    if (m_rtxtDraw.IsHandleCreated == true)
                        m_rtxtDraw.Text = strDraw;

                    m_rtxtDraw.Select(m_nSelectedItem, 0);
                }
                SetHeader_strDrawModel(strDraw);
                CompileDesign();
                StringListToGrid();
            }
            #region Set
            public void Prop_Set_Name_Selected(int value) { m_CPropAll_Selected.nAxisName = OjwDispAll.GetData(m_nSelectedItem).nName = value; }
            public void Prop_Set_Color_Selected(Color value) { m_CPropAll_Selected.cColor = OjwDispAll.GetData(m_nSelectedItem).cColor = value; }
            public void Prop_Set_DispAlpha_Selected(float value) { m_CPropAll_Selected.fAlpha = OjwDispAll.GetData(m_nSelectedItem).fAlpha = value; }
            public void Prop_Set_DispObject_Selected(string value) { m_CPropAll_Selected.strDispObject = OjwDispAll.GetData(m_nSelectedItem).strDispObject = value; CheckObjectModelFile(m_CPropAll_Selected.strDispObject); }
            public void Prop_Set_Fill_Selected(bool value) { m_CPropAll_Selected.bFill = OjwDispAll.GetData(m_nSelectedItem).bFilled = value; }
            public void Prop_Set_fMul_3DAngle_Selected(float value) { m_CPropAll_Selected.fMulti = OjwDispAll.GetData(m_nSelectedItem).fMulti = value; }
            public void Prop_Set_Init_Selected(bool value) { m_CPropAll_Selected.bInit = OjwDispAll.GetData(m_nSelectedItem).bInit = value; }
            public void Prop_Set_Width_Or_Radius_Selected(float value) { m_CPropAll_Selected.fWidth_Or_Radius = OjwDispAll.GetData(m_nSelectedItem).fWidth_Or_Radius = value; }
            public void Prop_Set_Height_Or_Depth_Selected(float value) { m_CPropAll_Selected.fHeight_Or_Depth = OjwDispAll.GetData(m_nSelectedItem).fHeight_Or_Depth = value; }
            public void Prop_Set_Depth_Or_Cnt_Selected(float value) { m_CPropAll_Selected.fDepth_Or_Cnt = OjwDispAll.GetData(m_nSelectedItem).fDepth_Or_Cnt = value; }
            public void Prop_Set_Thickness_Selected(float value) { m_CPropAll_Selected.fThickness = OjwDispAll.GetData(m_nSelectedItem).fThickness = value; }
            public void Prop_Set_Gap_Selected(float value) { m_CPropAll_Selected.fGap = OjwDispAll.GetData(m_nSelectedItem).fGap = value; }
            public void Prop_Set_Caption_Selected(string value) { m_CPropAll_Selected.strCaption = OjwDispAll.GetData(m_nSelectedItem).strCaption = value; }

            public void Prop_Set_AxisMoveType_Selected(int value) { m_CPropAll_Selected.nAxisMoveType = OjwDispAll.GetData(m_nSelectedItem).nAxisMoveType = value; }
            public void Prop_Set_Dir_Selected(int value) { m_CPropAll_Selected.nDir = OjwDispAll.GetData(m_nSelectedItem).nDir = value; }
            public void Prop_Set_Angle_Selected(float value) { m_CPropAll_Selected.fAngle = OjwDispAll.GetData(m_nSelectedItem).fAngle = value; }
            public void Prop_Set_Angle_Offset_Selected(string value) { m_CPropAll_Selected.strAngle_Offset = OjwDispAll.GetData(m_nSelectedItem).strAngle_Offset = value; }
            //public void Prop_Set_Offset_Trans_X_Selected(float value) { m_CPropAll_Selected.SOffset_Trans_X = OjwDispAll.GetData(m_nSelectedItem).SOffset_Trans.x = value; }
            public void Prop_Set_Offset_Trans_Selected(SVector3D_t value) { m_CPropAll_Selected.SOffset_Trans = OjwDispAll.GetData(m_nSelectedItem).SOffset_Trans = value; }
            public void Prop_Set_Offset_Rot_Selected(SAngle3D_t value) { m_CPropAll_Selected.SOffset_Rot = OjwDispAll.GetData(m_nSelectedItem).SOffset_Rot = value; }

            public void Prop_Set_Trans_1_Selected(SVector3D_t value) { m_CPropAll_Selected.STrans_1 = OjwDispAll.GetData(m_nSelectedItem).afTrans[0] = value; }
            public void Prop_Set_Rot_1_Selected(SAngle3D_t value) { m_CPropAll_Selected.SRot_1 = OjwDispAll.GetData(m_nSelectedItem).afRot[0] = value; }

            public void Prop_Set_Trans_2_Selected(SVector3D_t value) { m_CPropAll_Selected.STrans_2 = OjwDispAll.GetData(m_nSelectedItem).afTrans[1] = value; }
            public void Prop_Set_Rot_2_Selected(SAngle3D_t value) { m_CPropAll_Selected.SRot_2 = OjwDispAll.GetData(m_nSelectedItem).afRot[1] = value; }

            public void Prop_Set_Trans_3_Selected(SVector3D_t value) { m_CPropAll_Selected.STrans_3 = OjwDispAll.GetData(m_nSelectedItem).afTrans[2] = value; }
            public void Prop_Set_Rot_3_Selected(SAngle3D_t value) { m_CPropAll_Selected.SRot_3 = OjwDispAll.GetData(m_nSelectedItem).afRot[2] = value; }

            public void Prop_Set_Trans_4_Selected(SVector3D_t value) { m_CPropAll_Selected.STrans_4 = OjwDispAll.GetData(m_nSelectedItem).afTrans[3] = value; }
            public void Prop_Set_Rot_4_Selected(SAngle3D_t value) { m_CPropAll_Selected.SRot_4 = OjwDispAll.GetData(m_nSelectedItem).afRot[3] = value; }

            public void Prop_Set_Trans_5_Selected(SVector3D_t value) { m_CPropAll_Selected.STrans_5 = OjwDispAll.GetData(m_nSelectedItem).afTrans[4] = value; }
            public void Prop_Set_Rot_5_Selected(SAngle3D_t value) { m_CPropAll_Selected.SRot_5 = OjwDispAll.GetData(m_nSelectedItem).afRot[4] = value; }

            public void Prop_Set_PickGroup_Selected(SPoint3D_t value) { m_CPropAll_Selected.SPickGroup = value; OjwDispAll.GetData(m_nSelectedItem).nPickGroup_A = value.x; OjwDispAll.GetData(m_nSelectedItem).nPickGroup_B = value.y; OjwDispAll.GetData(m_nSelectedItem).nPickGroup_C = value.z; }

            public void Prop_Set_InverseKinematicsNumber_Selected(int value) { m_CPropAll_Selected.nInverseKinematicsNumber = OjwDispAll.GetData(m_nSelectedItem).nInverseKinematicsNumber = value; }
            //public void Prop_Set_InverseKinematicsNumber_Selected_AfterCalc(int value) { m_CPropAll_Selected.nInverseKinematicsNumber_AfterCalc = OjwDispAll.GetData(m_nSelectedItem).nInverseKinematicsNumber_AfterCalc = value; }
            public void Prop_Set_Scale_Serve0_Selected(float value) { m_CPropAll_Selected.fScale_Serve0 = OjwDispAll.GetData(m_nSelectedItem).fScale_Serve0 = value; }
            public void Prop_Set_Scale_Serve1_Selected(float value) { m_CPropAll_Selected.fScale_Serve1 = OjwDispAll.GetData(m_nSelectedItem).fScale_Serve1 = value; }
            public void Prop_Set_MotorType_Selected(int value) { m_CPropAll_Selected.nMotorType = OjwDispAll.GetData(m_nSelectedItem).nMotorType = value; }
            public void Prop_Set_MotorControl_MousePoint_Selected(int value) { m_CPropAll_Selected.nMotorControl_MousePoint = OjwDispAll.GetData(m_nSelectedItem).nMotorControl_MousePoint = value; }
            public void Prop_Set_PickGroup_Comment_Selected(string value) { m_CPropAll_Selected.strPickGroup_Comment = OjwDispAll.GetData(m_nSelectedItem).strPickGroup_Comment = value; }

            //// if you want to add , just do like below ////

            //public void Prop_Set_( value) { m_CPropAll_Selected. = value; }            
            #endregion Set

            #region Get
            public int Prop_Get_Name_Selected() { return m_CPropAll_Selected.nAxisName; }
            public Color Prop_Get_Color_Selected() { return m_CPropAll_Selected.cColor; }
            public float Prop_Get_DispAlpha_Selected() { return m_CPropAll_Selected.fAlpha; }
            public string Prop_Get_DispObject_Selected() { return m_CPropAll_Selected.strDispObject; }
            public bool Prop_Get_Fill_Selected() { return m_CPropAll_Selected.bFill; }
            public float Prop_Get_fMul_3DAngle_Selected() { return m_CPropAll_Selected.fMulti; }
            public bool Prop_Get_Init_Selected() { return m_CPropAll_Selected.bInit; }
            public float Prop_Get_Width_Or_Radius_Selected() { return m_CPropAll_Selected.fWidth_Or_Radius; }
            public float Prop_Get_Height_Or_Depth_Selected() { return m_CPropAll_Selected.fHeight_Or_Depth; }
            public float Prop_Get_Depth_Or_Cnt_Selected() { return m_CPropAll_Selected.fDepth_Or_Cnt; }
            public float Prop_Get_Thickness_Selected() { return m_CPropAll_Selected.fThickness; }
            public float Prop_Get_Gap_Selected() { return m_CPropAll_Selected.fGap; }
            public string Prop_Get_Caption_Selected() { return m_CPropAll_Selected.strCaption; }
            public int Prop_Get_AxisMoveType_Selected() { return m_CPropAll_Selected.nAxisMoveType; }
            public int Prop_Get_Dir_Selected() { return m_CPropAll_Selected.nDir; }
            public float Prop_Get_Angle_Selected() { return m_CPropAll_Selected.fAngle; }
            public string Prop_Get_Angle_Offset_Selected() { return m_CPropAll_Selected.strAngle_Offset; }
            public SVector3D_t Prop_Get_Offset_Trans_Selected() { return m_CPropAll_Selected.SOffset_Trans; }
            public SAngle3D_t Prop_Get_Offset_Rot_Selected() { return m_CPropAll_Selected.SOffset_Rot; }

            public SVector3D_t Prop_Get_Trans_1_Selected() { return m_CPropAll_Selected.STrans_1; }
            public SAngle3D_t Prop_Get_Rot_1_Selected() { return m_CPropAll_Selected.SRot_1; }

            public SVector3D_t Prop_Get_Trans_2_Selected() { return m_CPropAll_Selected.STrans_2; }
            public SAngle3D_t Prop_Get_Rot_2_Selected() { return m_CPropAll_Selected.SRot_2; }

            public SVector3D_t Prop_Get_Trans_3_Selected() { return m_CPropAll_Selected.STrans_3; }
            public SAngle3D_t Prop_Get_Rot_3_Selected() { return m_CPropAll_Selected.SRot_3; }

            public SVector3D_t Prop_Get_Trans_4_Selected() { return m_CPropAll_Selected.STrans_4; }
            public SAngle3D_t Prop_Get_Rot_4_Selected() { return m_CPropAll_Selected.SRot_4; }

            public SVector3D_t Prop_Get_Trans_5_Selected() { return m_CPropAll_Selected.STrans_5; }
            public SAngle3D_t Prop_Get_Rot_5_Selected() { return m_CPropAll_Selected.SRot_5; }
            public SPoint3D_t Prop_Get_PickGroup_A_Selected() { return m_CPropAll_Selected.SPickGroup; }
            public int Prop_Get_InverseKinematicsNumber_Selected() { return m_CPropAll_Selected.nInverseKinematicsNumber; }
            //public int Prop_Get_InverseKinematicsNumber_Selected_AfterCalc() { return m_CPropAll_Selected.nInverseKinematicsNumber_AfterCalc; }
            public float Prop_Get_Scale_Serve0_Selected() { return m_CPropAll_Selected.fScale_Serve0; }
            public float Prop_Get_Scale_Serve1_Selected() { return m_CPropAll_Selected.fScale_Serve1; }
            public int Prop_Get_MotorType_Selected() { return m_CPropAll_Selected.nMotorType; }
            public int Prop_Get_MotorControl_MousePoint_Selected() { return m_CPropAll_Selected.nMotorControl_MousePoint; }
            public string Prop_Get_PickGroup_Comment_Selected() { return m_CPropAll_Selected.strPickGroup_Comment; }
            #endregion Get
            #endregion Prop_Selected
            //void m_pnProperty_MouseClick(object sender, MouseEventArgs e)
            //{
            //    MessageBox.Show("Clicked");
            //    ShowKeyPad_Number(sender);

            //    //throw new NotImplementedException();
            //    //ShowKeyPad_Number(
            //}
            public void VisibleProp(String strName, bool bVisible) { m_CPropAll.Visible(strName, bVisible); }

            private bool m_bProb_Virtual = false;
            public void CreateProb_VirtualObject(Control ctrlProp) { CreateProp_VirtualObject(ctrlProp); }
            public void CreateProp_VirtualObject(Control ctrlProp)//(Panel pnProp)
            {
                m_CPropAll = new CProp_User();
                m_CPropAll.Create(OjwVirtualDisp);//m_CDisp);
                
                if (m_CProperty == null) m_CProperty = new CProperty();

                m_CProperty.Create(ctrlProp, m_CPropAll);//m_CProp_Main);
                m_CProperty.SetEvent_Changed(Prop_PropertyValueChanged);

                m_bProb_Virtual = true;
                //pnProp.MouseClick += new MouseEventHandler(m_pnProperty_MouseClick);
                //foreach (Control c in pnProp.Controls)
                //{
                //    c.MouseClick += new MouseEventHandler(m_pnProperty_MouseClick);
                //}
            }
            private void CheckObjectModelFile(String strName)
            {
                COjwDisp CDisp = GetVirtualClass_Data();
                CDisp.strDispObject = strName;
                // if you never loaded this file. it would be loaded
#if false
                if (OjwAse_GetIndex(CDisp.strDispObject) < 0)
                {
                    this.Cursor = System.Windows.Forms.Cursors.WaitCursor;
                    if (OjwFileOpen_3D_ASE(m_strOrgDirectory + "\\ase\\" + CDisp.strDispObject + ".ase") == false)
                    {
                        Ojw.CMessage.Write_Error("ASE(" + CDisp.strDispObject + ".ase" + ") File Loading Error");
                    }
                    this.Cursor = System.Windows.Forms.Cursors.Default;
                }
#else
                if (CDisp.strDispObject.Length > 0)
                {
                    if (CDisp.strDispObject.IndexOf('#') < 0)
                    {
                        if (OjwAse_GetIndex(CDisp.strDispObject) < 0)
                        {
                            //this.Cursor = System.Windows.Forms.Cursors.WaitCursor;
#if true
                            String strFile = CDisp.strDispObject;
                            if ((strFile.IndexOf('?') >= 0) || (strFile.IndexOf('/') >= 0))
                            {
                                strFile = strFile.Substring(1);
                            }
#if _CHANGE_DEFAULT_FROM_ASE_TO_DAT
                            String strFileName = Application.StartupPath.Trim('\\') + GetAseFile_Path() + strFile + ((strFile.IndexOf('.') < 0) ? ".dat" : "");
#else
                            String strFileName = Application.StartupPath.Trim('\\') + GetAseFile_Path() + strFile + ((strFile.IndexOf('.') < 0) ? ".ase" : "");
#endif

                            FileInfo f;
                            int nOld = strFileName.LastIndexOf('*');
                            //MessageBox.Show(strFileName + "," + strFileName.Length.ToString() + ',' + nOld.ToString());
                            if (nOld == strFileName.Length - 1) f = new FileInfo(strFileName.Substring(0, strFileName.Length - 1));
                            else f = new FileInfo(strFileName);
                            if (f.Exists == true)
                            {
                                if (CFile.GetExe(strFileName).ToUpper() == "ASE")
                                    OjwFileOpen_3D_ASE(strFileName);
                                else if (CFile.GetExe(strFileName).ToUpper() == "SSTL")
                                    OjwFileOpen_3D_SSTL(strFileName);
                                else if ((CFile.GetExe(strFileName).ToUpper() == "STL") || (CFile.GetExe(strFileName).ToUpper() == "STL*"))
                                    OjwFileOpen_3D_STL(strFileName);
                                else if (CFile.GetExe(strFileName).ToUpper() == "DAT")
                                    OjwFileOpen_3D_Dat(strFileName);
                                else if (CFile.GetExe(strFileName).ToUpper() == "OBJ")
                                    OjwFileOpen_3D_OBJ(strFileName);
                            }
#else
                            String strFileName = Application.StartupPath + "\\" + GetAseFile_Path() + CDisp.strDispObject + ".ase";
                            FileInfo f = new FileInfo(strFileName);
                            if (f.Exists == true) OjwFileOpen_3D_ASE(strFileName);
                            else Ojw.CMessage.Write_Error("ASE(" + CDisp.strDispObject + ((CDisp.strDispObject.IndexOf(",") < 0) ? ".ase" : "") + ") File Loading Error");
#endif
                            //this.Cursor = System.Windows.Forms.Cursors.Default;
                        }
                    }
                }
#endif
            }
            private void Prop_PropertyValueChanged(object s, PropertyValueChangedEventArgs e)
            {
                if (m_CProperty == null) return;
                // item add : step 4 / 4
                switch(e.ChangedItem.Label)
                {
                    #region Main
#if _OLD_PROP
                    //case strProp_Main0:
                        //break;
                    case m_strProp_Main0_0: // title
                        Prop_Set_Main_Title((string)e.ChangedItem.Value);
                        m_CHeader.strTitle = Prop_Get_Main_Title();
                        break;
                    case m_strProp_Main0_1: // model number
                        Prop_Set_Main_ModelNum((int)e.ChangedItem.Value);
                        m_CHeader.nModelNum = Prop_Get_Main_ModelNum();
                        break;
                    case m_strProp_Main0_2: // model name
                        Prop_Set_Main_ModelName((string)e.ChangedItem.Value);
                        m_CHeader.strModelName = Prop_Get_Main_ModelName();
                        break;
                    case m_strProp_Main1:
                        Prop_Set_Main_MouseControlMode((int)e.ChangedItem.Value);
                        break;
                    case m_strProp_Main2:
                        Prop_Set_Main_Empty((bool)e.ChangedItem.Value);
                        break;
                    case m_strProp_Main3:
                        Prop_Set_Main_Alpha((float)e.ChangedItem.Value);
                        break;
                    case m_strProp_Main4:
                        Prop_Set_Main_Light((bool)e.ChangedItem.Value);
                        break;
                    case m_strProp_Main5:
                        Prop_Set_Main_ShowStandardAxis((bool)e.ChangedItem.Value);
                        break;
                    case m_strProp_Main6:
                        Prop_Set_Main_ShowVirtualAxis((bool)e.ChangedItem.Value);
                        break;
                    case m_strProp_Main7:
                        Prop_Set_Main_DefaultFunctionNum((int)e.ChangedItem.Value);
                        break;
                    case m_strProp_Main8:
                        Prop_Set_Main_3DView((int)e.ChangedItem.Value);
                        break;
                    case m_strProp_Main9:
                        Prop_Set_Main_Show_Territory((int)e.ChangedItem.Value);
                        break;
                    case m_strProp_Main10:
                        Prop_Set_Main_BackColor((Color)e.ChangedItem.Value);
                        break;
                //        case strProp_Main0 = "Version";
                //private const String strProp_Main1 = "Mouse Mode";
                //private const String strProp_Main2 = "Empty";
                //private const String strProp_Main3 = "Alpha(Main)";
#endif
                    #endregion Main
                    #region Sub
                    #region AxisName
                    case m_pstrProp_0:
                        Prop_Set_Name((int)e.ChangedItem.Value);
                        break;
                    #endregion AxisName
                    #region Color
                    case m_pstrProp_1:                        
                        Prop_Set_Color((Color)e.ChangedItem.Value);
                        break;
                    #endregion Color
                    #region Model
                    case m_pstrProp_2: // Model                        
                        Prop_Set_DispObject((String)e.ChangedItem.Value);
                        break;
                    #endregion Model
                    #region Fill
                    case m_pstrProp_3: // Fill                        
                        Prop_Set_Fill((bool)e.ChangedItem.Value);
                        break;
                    #endregion Fill
                    #region fMul_3DAngle
                    case m_pstrProp_4: // fMul_3DAngle                        
                        Prop_Set_fMul_3DAngle((float)e.ChangedItem.Value);
                        break;
                    #endregion fMul_3DAngle
                    #region Init
                    case m_pstrProp_5: // Init
                        Prop_Set_Init((bool)e.ChangedItem.Value);
                        break;
                    #endregion Init
                    #region Width or Radius
                    case m_pstrProp_6:
                        Prop_Set_Width_Or_Radius((float)e.ChangedItem.Value);
                        break;
                    #endregion Width or Radius
                    #region Width or Radius
                    case m_pstrProp_7:
                        Prop_Set_Height_Or_Depth((float)e.ChangedItem.Value);
                        break;
                    #endregion Width or Radius
                    #region Depth or Cnt
                    case m_pstrProp_8:
                        Prop_Set_Depth_Or_Cnt((float)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region Thickness
                    case m_pstrProp_9:
                        Prop_Set_Thickness((float)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region fGap
                    case m_pstrProp_10:
                        Prop_Set_Gap((float)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region strCaption
                    case m_pstrProp_11:
                        Prop_Set_Caption((string)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region nAxisMoveType
                    case m_pstrProp_12:
                        Prop_Set_AxisMoveType((int)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region nDir
                    case m_pstrProp_13:
                        Prop_Set_Dir((int)e.ChangedItem.Value);
                        break;
                    #endregion Dir
                    #region fAngle
                    case m_pstrProp_14:
                        Prop_Set_Angle((float)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region strAngle_Offset
                    case m_pstrProp_15:
                        Prop_Set_Angle_Offset((string)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region Offset_Trans
                    case m_pstrProp_16:
                        Prop_Set_Offset_Trans((SVector3D_t)e.ChangedItem.Value);
                        break;
                    //case m_pstrProp_17:
                    //    Prop_Set_Offset_Trans_Y((float)e.ChangedItem.Value);
                    //    break;
                    //case m_pstrProp_18:
                    //    Prop_Set_Offset_Trans_Z((float)e.ChangedItem.Value);
                    //    break;
                    #endregion
                    #region Offset_Rot
                    case m_pstrProp_19:
                        ;
                        Prop_Set_Offset_Rot((SAngle3D_t)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region Trans/Rot 1st
                    case m_pstrProp_22:
                        Prop_Set_Trans_1((SVector3D_t)e.ChangedItem.Value);
                        break;
                    case m_pstrProp_25:
                        Prop_Set_Rot_1((SAngle3D_t)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region Trans/Rot 2st
                    case m_pstrProp_28:
                        Prop_Set_Trans_2((SVector3D_t)e.ChangedItem.Value);
                        break;
                    case m_pstrProp_31:
                        Prop_Set_Rot_2((SAngle3D_t)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region Trans/Rot 3st
                    case m_pstrProp_34:
                        Prop_Set_Trans_3((SVector3D_t)e.ChangedItem.Value);
                        break;
                    case m_pstrProp_37:
                        Prop_Set_Rot_3((SAngle3D_t)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region region Trans/Rot 4st
                    case m_pstrProp_40:
                        Prop_Set_Trans_4((SVector3D_t)e.ChangedItem.Value);
                        break;
                    case m_pstrProp_43:
                        Prop_Set_Rot_4((SAngle3D_t)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region region Trans/Rot 5st
                    case m_pstrProp_46:
                        Prop_Set_Trans_5((SVector3D_t)e.ChangedItem.Value);
                        break;
                    case m_pstrProp_49:
                        Prop_Set_Rot_5((SAngle3D_t)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region nPickGroup
                    case m_pstrProp_52:
                        Prop_Set_PickGroup((SPoint3D_t)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region InverseKinematicsNumber
                    case m_pstrProp_55:
                        Prop_Set_InverseKinematicsNumber((int)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region Scale_Serve
                    case m_pstrProp_56:                        
                        Prop_Set_Scale_Serve0((float)e.ChangedItem.Value);
                        break;
                    case m_pstrProp_57:
                        Prop_Set_Scale_Serve1((float)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region MotorType
                    case m_pstrProp_58:
                        Prop_Set_MotorType((int)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region MotorControl_MousePoint
                    case m_pstrProp_59:
                        Prop_Set_MotorControl_MousePoint((int)e.ChangedItem.Value);
                        break;
                    #endregion
                    #region PickGroup_Comment
                    case m_pstrProp_60:
                        Prop_Set_PickGroup_Comment((string)e.ChangedItem.Value);
                        break;
                    #endregion
                    //case m_pstrProp_:
                    //    OjwVirtualDisp. = ()e.ChangedItem.Value;
                    //    Prop_Set_(OjwVirtualDisp.);
                    //    break;
                    //case m_pstrProp_:
                    //    OjwVirtualDisp. = ()e.ChangedItem.Value;
                    //    Prop_Set_(OjwVirtualDisp.);
                    //    break;
                    #endregion Sub
                }
                Prop_Update_VirtualObject();
            }
            public void Prop_SetServe_Test(int nTest) 
            {
                //TypeDescriptor.GetProperties(m_CPropAll)["OpenJigWare"].SetValue(m_CPropAll.nTest, nTest);
                //m_CPropAll.nTest = nTest;
                m_CProperty.Update();
            }
            public void Prop_Update_VirtualObject() { m_CProperty.Update(); }

            #region Item add : Step 3/4
            // Main
            #region Main
#if _OLD_PROP
            public void Prop_Set_Main_Title(string value) { m_CPropAll.strMain_Title = value; }
            public string Prop_Get_Main_Title() { return m_CPropAll.strMain_Title; }
            public void Prop_Set_Main_ModelNum(int value) { m_CPropAll.nMain_ModelNum = value; }
            public int Prop_Get_Main_ModelNum() { return m_CPropAll.nMain_ModelNum; }
            public void Prop_Set_Main_ModelName(string value) { m_CPropAll.strMain_ModelName = value; }
            public string Prop_Get_Main_ModelName() { return m_CPropAll.strMain_ModelName; }
            
            public void Prop_Set_Main_MouseControlMode(int value) { m_CPropAll.nMain_MouseMode = m_nMouseControlMode = value; }
            public int Prop_Get_Main_MouseControlMode() { return m_CPropAll.nMain_MouseMode; }

            public void Prop_Set_Main_3DView(int value) { m_CPropAll.nMain_3DView = m_nPerspectiveMode = value; }
            public int Prop_Get_Main_3DView() { return m_CPropAll.nMain_3DView; }
            
            public void Prop_Set_Main_Show_Territory(int value) { m_CPropAll.nMain_Show_Territory = m_nTerritory = value; }
            public int Prop_Get_Main_Show_Territory() { return m_CPropAll.nMain_Show_Territory; }

            public void Prop_Set_Main_BackColor(Color value) { m_CPropAll.cMain_BackColor = value; SetBackColor(value); }
            public Color Prop_Get_Main_BackColor() { return m_CPropAll.cMain_BackColor; }
                        
            public void Prop_Set_Main_Empty(bool value) { m_CPropAll.bMain_Empty = m_bEmptyBody = value; }
            public bool Prop_Get_Main_Empty() { return m_CPropAll.bMain_Empty; }

            public void Prop_Set_Main_Alpha(float value) { m_CPropAll.fMain_Alpha = value; SetAlpha(value); }
            public float Prop_Get_Main_Alpha() { return m_CPropAll.fMain_Alpha; }

            public void Prop_Set_Main_Light(bool value) { m_CPropAll.bMain_Light = m_bEnable_Light = value; }
            public bool Prop_Get_Main_Light() { return m_CPropAll.bMain_Light; }


            public void Prop_Set_Main_ShowStandardAxis(bool value) { m_CPropAll.bMain_ShowStandardAxis = m_bStandardAxis = value; }
            public bool Prop_Get_Main_ShowStandardAxis() { return m_CPropAll.bMain_ShowStandardAxis; }

            public void Prop_Set_Main_ShowVirtualAxis(bool value) { m_CPropAll.bMain_ShowVirtualAxis = m_bVirtualClass = value; }
            public bool Prop_Get_Main_ShowVirtualAxis() { return m_CPropAll.bMain_ShowVirtualAxis; }

            //public void Prop_Set_Main_DefaultFunctionNum(int value) { m_CPropAll.nMain_DefaultFunctionNum = m_nFunctionNumber = value; }
            public void Prop_Set_Main_DefaultFunctionNum(int value) { m_CPropAll.nMain_DefaultFunctionNum = m_CHeader.nDefaultFunctionNumber = value; }
            public int Prop_Get_Main_DefaultFunctionNum() { return m_CPropAll.nMain_DefaultFunctionNum; }
#endif
            #endregion Main
            // item add : step 3 / 4
            #region Set
            public void Prop_Set_Name(int value) { m_CPropAll.nAxisName = OjwVirtualDisp.nName = value; }
            public void Prop_Set_Color(Color value) { m_CPropAll.cColor = OjwVirtualDisp.cColor = value; }
            public void Prop_Set_DispAlpha(float value) { m_CPropAll.fAlpha = OjwVirtualDisp.fAlpha = value; }
            public void Prop_Set_DispObject(string value) { m_CPropAll.strDispObject = OjwVirtualDisp.strDispObject = value; CheckObjectModelFile(m_CPropAll.strDispObject); }
            public void Prop_Set_Fill(bool value) { m_CPropAll.bFill = OjwVirtualDisp.bFilled = value; }
            public void Prop_Set_fMul_3DAngle(float value) { m_CPropAll.fMulti = OjwVirtualDisp.fMulti = value; }
            public void Prop_Set_Init(bool value) { m_CPropAll.bInit = OjwVirtualDisp.bInit = value; }
            public void Prop_Set_Width_Or_Radius(float value) { m_CPropAll.fWidth_Or_Radius = OjwVirtualDisp.fWidth_Or_Radius = value; }
            public void Prop_Set_Height_Or_Depth(float value) { m_CPropAll.fHeight_Or_Depth = OjwVirtualDisp.fHeight_Or_Depth = value; }
            public void Prop_Set_Depth_Or_Cnt(float value) { m_CPropAll.fDepth_Or_Cnt = OjwVirtualDisp.fDepth_Or_Cnt = value; }
            public void Prop_Set_Thickness(float value) { m_CPropAll.fThickness = OjwVirtualDisp.fThickness = value; }
            public void Prop_Set_Gap(float value) { m_CPropAll.fGap = OjwVirtualDisp.fGap = value; }
            public void Prop_Set_Caption(string value) { m_CPropAll.strCaption = OjwVirtualDisp.strCaption = value; }

            public void Prop_Set_AxisMoveType(int value) { m_CPropAll.nAxisMoveType = OjwVirtualDisp.nAxisMoveType = value; }
            public void Prop_Set_Dir(int value) { m_CPropAll.nDir = OjwVirtualDisp.nDir = value; }
            public void Prop_Set_Angle(float value) { m_CPropAll.fAngle = OjwVirtualDisp.fAngle = value; }
            public void Prop_Set_Angle_Offset(string value) { m_CPropAll.strAngle_Offset = OjwVirtualDisp.strAngle_Offset = value; }
            //public void Prop_Set_Offset_Trans_X(float value) { m_CPropAll.SOffset_Trans_X = OjwVirtualDisp.SOffset_Trans.x = value; }
            public void Prop_Set_Offset_Trans(SVector3D_t value) { m_CPropAll.SOffset_Trans = OjwVirtualDisp.SOffset_Trans = value; }
            public void Prop_Set_Offset_Rot(SAngle3D_t value) { m_CPropAll.SOffset_Rot = OjwVirtualDisp.SOffset_Rot = value; }

            public void Prop_Set_Trans_1(SVector3D_t value) { m_CPropAll.STrans_1 = OjwVirtualDisp.afTrans[0] = value; }
            public void Prop_Set_Rot_1(SAngle3D_t value) { m_CPropAll.SRot_1 = OjwVirtualDisp.afRot[0] = value; }

            public void Prop_Set_Trans_2(SVector3D_t value) { m_CPropAll.STrans_2 = OjwVirtualDisp.afTrans[1] = value; }
            public void Prop_Set_Rot_2(SAngle3D_t value) { m_CPropAll.SRot_2 = OjwVirtualDisp.afRot[1] = value; }

            public void Prop_Set_Trans_3(SVector3D_t value) { m_CPropAll.STrans_3 = OjwVirtualDisp.afTrans[2] = value; }
            public void Prop_Set_Rot_3(SAngle3D_t value) { m_CPropAll.SRot_3 = OjwVirtualDisp.afRot[2] = value; }

            public void Prop_Set_Trans_4(SVector3D_t value) { m_CPropAll.STrans_4 = OjwVirtualDisp.afTrans[3] = value; }
            public void Prop_Set_Rot_4(SAngle3D_t value) { m_CPropAll.SRot_4 = OjwVirtualDisp.afRot[3] = value; }
            
            public void Prop_Set_Trans_5(SVector3D_t value) { m_CPropAll.STrans_5 = OjwVirtualDisp.afTrans[4] = value; }
            public void Prop_Set_Rot_5(SAngle3D_t value) { m_CPropAll.SRot_5 = OjwVirtualDisp.afRot[4] = value; }

            public void Prop_Set_PickGroup(SPoint3D_t value) { m_CPropAll.SPickGroup = value; OjwVirtualDisp.nPickGroup_A = value.x; OjwVirtualDisp.nPickGroup_B = value.y; OjwVirtualDisp.nPickGroup_C = value.z; }
            
            public void Prop_Set_InverseKinematicsNumber(int value) { m_CPropAll.nInverseKinematicsNumber = OjwVirtualDisp.nInverseKinematicsNumber = value; }
            //public void Prop_Set_InverseKinematicsNumber_AfterCalc(int value) { m_CPropAll.nInverseKinematicsNumber_AfterCalc = OjwVirtualDisp.nInverseKinematicsNumber_AfterCalc = value; }
            public void Prop_Set_Scale_Serve0(float value) { m_CPropAll.fScale_Serve0 = OjwVirtualDisp.fScale_Serve0 = value; }
            public void Prop_Set_Scale_Serve1(float value) { m_CPropAll.fScale_Serve1 = OjwVirtualDisp.fScale_Serve1 = value; }
            public void Prop_Set_MotorType(int value) { m_CPropAll.nMotorType = OjwVirtualDisp.nMotorType = value; }
            public void Prop_Set_MotorControl_MousePoint(int value) { m_CPropAll.nMotorControl_MousePoint = OjwVirtualDisp.nMotorControl_MousePoint = value; }
            public void Prop_Set_PickGroup_Comment(string value) { m_CPropAll.strPickGroup_Comment = OjwVirtualDisp.strPickGroup_Comment = value; }

            //// if you want to add , just do like below ////

            //public void Prop_Set_( value) { m_CPropAll. = value; }            
            #endregion Set

            #region Get
            public int Prop_Get_Name() { return m_CPropAll.nAxisName; }
            public Color Prop_Get_Color() { return m_CPropAll.cColor; }
            public float Prop_Get_DispAlpha() { return m_CPropAll.fAlpha; }
            public string Prop_Get_DispObject() { return m_CPropAll.strDispObject; }
            public bool Prop_Get_Fill() { return m_CPropAll.bFill; }
            public float Prop_Get_fMul_3DAngle() { return m_CPropAll.fMulti; }
            public bool Prop_Get_Init() { return m_CPropAll.bInit; }
            public float Prop_Get_Width_Or_Radius() { return m_CPropAll.fWidth_Or_Radius; }
            public float Prop_Get_Height_Or_Depth() { return m_CPropAll.fHeight_Or_Depth; }
            public float Prop_Get_Depth_Or_Cnt() { return m_CPropAll.fDepth_Or_Cnt; }
            public float Prop_Get_Thickness() { return m_CPropAll.fThickness; }
            public float Prop_Get_Gap() { return m_CPropAll.fGap; }
            public string Prop_Get_Caption() { return m_CPropAll.strCaption; }
            public int Prop_Get_AxisMoveType() { return m_CPropAll.nAxisMoveType; }
            public int Prop_Get_Dir() { return m_CPropAll.nDir; }
            public float Prop_Get_Angle() { return m_CPropAll.fAngle; }
            public string Prop_Get_Angle_Offset() { return m_CPropAll.strAngle_Offset; }
            public SVector3D_t Prop_Get_Offset_Trans() { return m_CPropAll.SOffset_Trans; }
            public SAngle3D_t Prop_Get_Offset_Rot() { return m_CPropAll.SOffset_Rot; }

            public SVector3D_t Prop_Get_Trans_1() { return m_CPropAll.STrans_1; }
            public SAngle3D_t Prop_Get_Rot_1() { return m_CPropAll.SRot_1; }

            public SVector3D_t Prop_Get_Trans_2() { return m_CPropAll.STrans_2; }
            public SAngle3D_t Prop_Get_Rot_2() { return m_CPropAll.SRot_2; }

            public SVector3D_t Prop_Get_Trans_3() { return m_CPropAll.STrans_3; }
            public SAngle3D_t Prop_Get_Rot_3() { return m_CPropAll.SRot_3; }

            public SVector3D_t Prop_Get_Trans_4() { return m_CPropAll.STrans_4; }
            public SAngle3D_t Prop_Get_Rot_4() { return m_CPropAll.SRot_4; }

            public SVector3D_t Prop_Get_Trans_5() { return m_CPropAll.STrans_5; }
            public SAngle3D_t Prop_Get_Rot_5() { return m_CPropAll.SRot_5; }
            public SPoint3D_t Prop_Get_PickGroup_A() { return m_CPropAll.SPickGroup; }
            public int Prop_Get_InverseKinematicsNumber() { return m_CPropAll.nInverseKinematicsNumber; }
            //public int Prop_Get_InverseKinematicsNumber_AfterCalc() { return m_CPropAll.nInverseKinematicsNumber_AfterCalc; }
            public float Prop_Get_Scale_Serve0() { return m_CPropAll.fScale_Serve0; }
            public float Prop_Get_Scale_Serve1() { return m_CPropAll.fScale_Serve1; }
            public int Prop_Get_MotorType() { return m_CPropAll.nMotorType; }
            public int Prop_Get_MotorControl_MousePoint() { return m_CPropAll.nMotorControl_MousePoint; }
            public string Prop_Get_PickGroup_Comment() { return m_CPropAll.strPickGroup_Comment; }
            #endregion Get
            //// if you want to add , just do like below ////

            //public  Prop_Get_() { return m_CPropAll.; }
            #endregion Item add : Step 3/4
#if true
            #region Prop Name
            #region Item add : Step 1/4
            // item add : step 1 / 4
            private const string m_pstrProp_0 = "Name(Axis Number)";
            private const string m_pstrProp_1 = "Color";
            private const string m_pstrProp_Alpha = "Alpha";
            private const string m_pstrProp_2 = "DispObject";
            private const string m_pstrProp_3 = "Fill";
            private const string m_pstrProp_4 = "fMul(3D Angle)";
            private const string m_pstrProp_5 = "Init";
            private const string m_pstrProp_6 = "Width_Or_Radius";
            private const string m_pstrProp_7 = "Height_Or_Depth";
            private const string m_pstrProp_8 = "Depth_Or_Cnt";
            private const string m_pstrProp_9 = "Thickness";
            private const string m_pstrProp_10 = "Gap";
            private const string m_pstrProp_11 = "Caption";
            private const string m_pstrProp_12 = "AxisMoveType";
            private const string m_pstrProp_13 = "Dir";
            private const string m_pstrProp_14 = "Angle";
            private const string m_pstrProp_15 = "Angle_Offset";
            private const string m_pstrProp_16 = "Offset_Trans(X,Y,Z)";
            private const string m_pstrProp_19 = "Offset_Rot(Pan,Tilt,Swing)";
            private const string m_pstrProp_22 = "1st Trans(X,Y,Z)";
            private const string m_pstrProp_25 = "1st Rot(Pan,Tilt,Swing)";
            private const string m_pstrProp_28 = "2st Trans(X,Y,Z)";
            private const string m_pstrProp_31 = "2st Rot(Pan,Tilt,Swing)";
            private const string m_pstrProp_34 = "3st Trans(X,Y,Z)";
            private const string m_pstrProp_37 = "3st Rot(Pan,Tilt,Swing)";
            private const string m_pstrProp_40 = "4st Trans(X,Y,Z)";
            private const string m_pstrProp_43 = "4st Rot(Pan,Tilt,Swing)";
            private const string m_pstrProp_46 = "5st Trans(X,Y,Z)";
            private const string m_pstrProp_49 = "5st Rot(Pan,Tilt,Swing)";
            private const string m_pstrProp_52 = "PickGroup(A,B,C)";
            private const string m_pstrProp_55 = "InverseKinematicsNumber";
            private const string m_pstrProp_56 = "fScale_Serve0";
            private const string m_pstrProp_57 = "fScale_Serve1";
            private const string m_pstrProp_58 = "nMotorType";
            private const string m_pstrProp_59 = "nMotorControl_MousePoint";
            private const string m_pstrProp_60 = "Comment";//"strPickGroup_Comment";
            //private const string m_pstrProp_61 = "InverseKinematicsNumber(AfterCalc)";
            #endregion Item add : Step 1/4
            #endregion Prop Name

            public class CSlider<T>
            {
                public CSlider(T value, T min, T max, T step)
                {
                    Value = value;
                    Min = min;
                    Max = max;
                    Step = step;
                }

                public T Value { get; set; }
                public T Max { get; set; }
                public T Min { get; set; }
                public T Step { get; set; }
            }

            [DefaultPropertyAttribute("OpenJigWare")]
            [RefreshProperties(RefreshProperties.All)]
#if _OLD_PROP
            private  class CProp_User: CProp_Main
#else
            private  class CProp_User
#endif
            {
                public CProp_User()
                {
                    //m_fSliderAlpha.Max = 1.0f;
                    //m_fSliderAlpha.Min = 0.0f;
                    //m_fSliderAlpha.Step = 0.1f;
                }
                ~CProp_User()
                {
                }
                public void Create(COjwDisp OjwDisp)
                {
                    CDisp = OjwDisp;
                }
                public void Visible(String strName, bool bVisible)
                {
                    PropertyDescriptor descriptor = TypeDescriptor.GetProperties(this.GetType())[strName];
                    BrowsableAttribute attrib = (BrowsableAttribute)descriptor.Attributes[typeof(BrowsableAttribute)];
                    FieldInfo isBrow = attrib.GetType().GetField("browsable", BindingFlags.NonPublic | BindingFlags.Instance);
                    isBrow.SetValue(attrib, bVisible);
                }

                COjwDisp CDisp = null;
                private const string strGroup = "[1]Object";
                //private int _nTest = 0;
                //[DisplayName("Test"), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("Test Main")]
                //public int nTest { get { return _nTest; } set { _nTest = value; } }
                
                #region Item add : Step 2/4
                // item add : step 2 / 4
                [DisplayName(m_pstrProp_0), 
                Browsable(true), 
                CategoryAttribute(strGroup), 
                DescriptionAttribute("Axis Number(-1:None, 0~253)")]
                public int nAxisName { get { return CDisp.nName; } set { CDisp.nName = value; } }



                [DisplayName(m_pstrProp_52), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute(""), TypeConverter(typeof(CPoint3DConvert))]
                public SPoint3D_t SPickGroup { get { return new SPoint3D_t(CDisp.nPickGroup_A, CDisp.nPickGroup_B, CDisp.nPickGroup_C); } set { CDisp.nPickGroup_A = value.x; CDisp.nPickGroup_B = value.y; CDisp.nPickGroup_C = value.z; } }

                [DisplayName(m_pstrProp_55), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                public int nInverseKinematicsNumber { get { return CDisp.nInverseKinematicsNumber; } set { CDisp.nInverseKinematicsNumber = value; } }
                //[DisplayName(m_pstrProp_61), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                //public int nInverseKinematicsNumber { get { return CDisp.nInverseKinematicsNumber; } set { CDisp.nInverseKinematicsNumber = value; } }
                

                [DisplayName(m_pstrProp_1), 
                Browsable(true), 
                CategoryAttribute(strGroup), 
                DescriptionAttribute("Object Color")]
                public Color cColor { get { return CDisp.cColor; } set { CDisp.cColor = value; } }

                private CSlider<float> m_fSliderAlpha = new CSlider<float>(1.0f, 0.0f, 1.0f, 0.1f);
                [DisplayName(m_pstrProp_Alpha), 
                Browsable(true),
                CategoryAttribute(strGroup),
                //Editor(typeof(CSlider<float>), typeof(CSlider<float>)),
                //Editor(typeof(CustomSlider), typeof(PropertyValueEditor)),
                DescriptionAttribute("~1.0 : Default 1.0")]
                public float fAlpha { get { return CDisp.fAlpha; } set { CDisp.fAlpha = value; } }
//                public CSlider<float> fSliderAlpha { get { return m_fSliderAlpha; } set { m_fSliderAlpha = value; } }
//                public class CustomSlider : ExtendedPropertyValueEditor
//                {
//                    public CustomSlider()
//                    {
//                        // Template for normal view
//                        string template1 = @"
//                        <DataTemplate
//                            xmlns='http://schemas.microsoft.com/winfx/2006/xaml/presentation'
//                            xmlns:x='http://schemas.microsoft.com/winfx/2006/xaml'
//                            xmlns:pe='clr-namespace:System.Activities.Presentation.PropertyEditing;assembly=System.Activities.Presentation' 
//                            xmlns:wpg='clr-namespace:PropertyGrid;assembly=PropertyGrid' > 
//                            <DockPanel LastChildFill='True'>
//                                    <TextBox Text='{Binding Path=Value.Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}' Width='40' TextAlignment='Center' />
//                                    <Slider x:Name='slider1' Value='{Binding Path=Value.Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}' Margin='2,0,0,0' Minimum='{Binding Value.Min}' Maximum='{Binding Value.Max}' />
//                            </DockPanel>
//                        </DataTemplate>";

//                        // Load templates
//                        using (var sr = new MemoryStream(Encoding.UTF8.GetBytes(template1)))
//                        {
//                            this.InlineEditorTemplate = XamlReader.Load(sr) as DataTemplate;
//                        }
//                    }
//                }
                
                [DisplayName(m_pstrProp_2), 
                Browsable(true), 
                CategoryAttribute(strGroup), 
                DescriptionAttribute("#0~#14 : Default, and FileName")]                
                public String strDispObject { get { return CDisp.strDispObject; } set { CDisp.strDispObject = value; } }

                [DisplayName(m_pstrProp_3), 
                Browsable(true), 
                CategoryAttribute(strGroup), 
                DescriptionAttribute("Fill & Empty")]
                public bool bFill { get { return CDisp.bFilled; } set { CDisp.bFilled = value; } }

                [DisplayName(m_pstrProp_4), 
                Browsable(true), 
                //ReadOnlyAttribute(true), 
                CategoryAttribute(strGroup),
                DescriptionAttribute("Multi(3d)")]
                public float fMulti { get { return CDisp.fMulti; } set { CDisp.fMulti = value; } }

                [DisplayName(m_pstrProp_5),
                Browsable(true), 
                CategoryAttribute(strGroup),
                DescriptionAttribute("Initialize Position & Angle")]
                public bool bInit { get { return CDisp.bInit; } set { CDisp.bInit = value; } }

                [DisplayName(m_pstrProp_6), 
                Browsable(true), 
                CategoryAttribute(strGroup), 
                DescriptionAttribute("")]
                public float fWidth_Or_Radius { get { return CDisp.fWidth_Or_Radius; } set { CDisp.fWidth_Or_Radius = value; } }

                [DisplayName(m_pstrProp_7), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                public float fHeight_Or_Depth{ get { return CDisp.fHeight_Or_Depth; } set { CDisp.fHeight_Or_Depth = value; } }
                [DisplayName(m_pstrProp_8), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                public float fDepth_Or_Cnt{ get { return CDisp.fDepth_Or_Cnt; } set { CDisp.fDepth_Or_Cnt = value; } }
                [DisplayName(m_pstrProp_9), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                public float fThickness{ get { return CDisp.fThickness; } set { CDisp.fThickness = value; } }
                [DisplayName(m_pstrProp_10), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                public float fGap{ get { return CDisp.fGap; } set { CDisp.fGap = value; } }
                [DisplayName(m_pstrProp_11), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                public string strCaption{ get { return CDisp.strCaption; } set { CDisp.strCaption = value; } }
                [DisplayName(m_pstrProp_12), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                public int nAxisMoveType { get { return CDisp.nAxisMoveType; } set { CDisp.nAxisMoveType = value; } }
                [DisplayName(m_pstrProp_13), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("Direction : 0 = Forward, 1 = Backward")]
                public int nDir{ get { return CDisp.nDir; } set { CDisp.nDir = value; } }
                [DisplayName(m_pstrProp_14), Browsable(true), ReadOnlyAttribute(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                public float fAngle{ get { return CDisp.fAngle; } set { CDisp.fAngle = value; } }
                [DisplayName(m_pstrProp_15), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                public string strAngle_Offset{ get { return CDisp.strAngle_Offset; } set { CDisp.strAngle_Offset = value; } }

                private const string strGroup1 = "[2]Offset Rotation/Translation";
                [DisplayName(m_pstrProp_16), Browsable(true), CategoryAttribute(strGroup1), DescriptionAttribute("Offset Translation"), TypeConverter(typeof(CVector3DConvert))]
                public SVector3D_t SOffset_Trans { get { return CDisp.SOffset_Trans; } set { CDisp.SOffset_Trans = value; } }
                public class CVector3DConvert : TypeConverter
                {
                    //// http://kindtis.tistory.com/458 참조
                    // string 으로 부터 변환이 가능한가?
                    public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
                    {
                        if (sourceType == typeof(string))
                            return true;
                        return base.CanConvertFrom(context, sourceType);
                    }

                    // string 으로 부터 vector3로 변환
                    public override object ConvertFrom(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)
                    {
                        if (value is string)
                        {
                            string[] v = ((string)value).Split(new char[] { ',' });
                            return new SVector3D_t(float.Parse(v[0]), float.Parse(v[1]), float.Parse(v[2]));
                        }
                        return base.ConvertFrom(context, culture, value);
                    }

                    // vector3 에서 string으로 변환
                    public override object ConvertTo(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, Type destinationType)
                    {
                        if (destinationType == typeof(string))
                            return ((SVector3D_t)value).x + "," + ((SVector3D_t)value).y + "," + ((SVector3D_t)value).z;
                        return base.ConvertTo(context, culture, value, destinationType);
                    }
                }
                public class CAngle3DConvert : TypeConverter
                {
                    //// http://kindtis.tistory.com/458 참조
                    // string 으로 부터 변환이 가능한가?
                    public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
                    {
                        if (sourceType == typeof(string))
                            return true;
                        return base.CanConvertFrom(context, sourceType);
                    }

                    // string 으로 부터 angle3로 변환
                    public override object ConvertFrom(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)
                    {
                        if (value is string)
                        {
                            string[] v = ((string)value).Split(new char[] { ',' });
                            return new SAngle3D_t(float.Parse(v[0]), float.Parse(v[1]), float.Parse(v[2]));
                        }
                        return base.ConvertFrom(context, culture, value);
                    }

                    // angle3 에서 string으로 변환
                    public override object ConvertTo(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, Type destinationType)
                    {
                        if (destinationType == typeof(string))
                            return ((SAngle3D_t)value).pan + "," + ((SAngle3D_t)value).tilt + "," + ((SAngle3D_t)value).swing;
                        return base.ConvertTo(context, culture, value, destinationType);
                    }
                }
                public class CPoint3DConvert : TypeConverter
                {
                    //// http://kindtis.tistory.com/458 참조
                    // string 으로 부터 변환이 가능한가?
                    public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
                    {
                        if (sourceType == typeof(string))
                            return true;
                        return base.CanConvertFrom(context, sourceType);
                    }

                    // string 으로 부터 Point3d로 변환
                    public override object ConvertFrom(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)
                    {
                        if (value is string)
                        {
                            string[] v = ((string)value).Split(new char[] { ',' });
                            return new SPoint3D_t(int.Parse(v[0]), int.Parse(v[1]), int.Parse(v[2]));
                        }
                        return base.ConvertFrom(context, culture, value);
                    }

                    // Point3d 에서 string으로 변환
                    public override object ConvertTo(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, Type destinationType)
                    {
                        if (destinationType == typeof(string))
                            return ((SPoint3D_t)value).x + "," + ((SPoint3D_t)value).y + "," + ((SPoint3D_t)value).z;
                        return base.ConvertTo(context, culture, value, destinationType);
                    }
                }
                
                private const string strGroup2 = strGroup1;//"[2]Offset Rotation";
                [DisplayName(m_pstrProp_19), Browsable(true), CategoryAttribute(strGroup2), DescriptionAttribute("Offset Rotation"), TypeConverter(typeof(CAngle3DConvert))]
                public SAngle3D_t SOffset_Rot{ get { return CDisp.SOffset_Rot; } set { CDisp.SOffset_Rot = value; } }

                private const string strGroup3 = "[3]Rotation/Translation";
                [DisplayName(m_pstrProp_22), Browsable(true), CategoryAttribute(strGroup3), DescriptionAttribute("1\'st Translation"), TypeConverter(typeof(CVector3DConvert))]
                public SVector3D_t STrans_1 { get { return CDisp.afTrans[0]; } set { CDisp.afTrans[0] = value; } }
                
                private const string strGroup4 = strGroup3;//"[3]1\'st Rotation";
                [DisplayName(m_pstrProp_25), Browsable(true), CategoryAttribute(strGroup4), DescriptionAttribute("1\'st Rotation"), TypeConverter(typeof(CAngle3DConvert))]
                public SAngle3D_t SRot_1 { get { return CDisp.afRot[0]; } set { CDisp.afRot[0] = value; } }

                private const string strGroup5 = strGroup3;//"[4]2\'st Translation";
                [DisplayName(m_pstrProp_28), Browsable(true), CategoryAttribute(strGroup5), DescriptionAttribute("2\'st Translation"), TypeConverter(typeof(CVector3DConvert))]
                public SVector3D_t STrans_2 { get { return CDisp.afTrans[1]; } set { CDisp.afTrans[1] = value; } }

                private const string strGroup6 = strGroup3;//"[4]2\'st Rotation";
                [DisplayName(m_pstrProp_31), Browsable(true), CategoryAttribute(strGroup6), DescriptionAttribute("2\'st Rotation"), TypeConverter(typeof(CAngle3DConvert))]
                public SAngle3D_t SRot_2 { get { return CDisp.afRot[1]; } set { CDisp.afRot[1] = value; } }

                private const string strGroup7 = strGroup3;//"[5]3\'st Translation";
                [DisplayName(m_pstrProp_34), Browsable(true), CategoryAttribute(strGroup7), DescriptionAttribute("3\'st Translation"), TypeConverter(typeof(CVector3DConvert))]
                public SVector3D_t STrans_3 { get { return CDisp.afTrans[2]; } set { CDisp.afTrans[2] = value; } }

                private const string strGroup8 = strGroup3;//"[5]3\'st Rotation";
                [DisplayName(m_pstrProp_37), Browsable(true), CategoryAttribute(strGroup8), DescriptionAttribute("3\'st Rotation"), TypeConverter(typeof(CAngle3DConvert))]
                public SAngle3D_t SRot_3 { get { return CDisp.afRot[2]; } set { CDisp.afRot[2] = value; } }

                private const string strGroup9 = strGroup3;//"[6]4\'st Translation";
                [DisplayName(m_pstrProp_40), Browsable(true), CategoryAttribute(strGroup9), DescriptionAttribute("4\'st Translation"), TypeConverter(typeof(CVector3DConvert))]
                public SVector3D_t STrans_4 { get { return CDisp.afTrans[3]; } set { CDisp.afTrans[3] = value; } }

                private const string strGroup10 = strGroup3;//"[6]4\'st Rotation";
                [DisplayName(m_pstrProp_43), Browsable(true), CategoryAttribute(strGroup10), DescriptionAttribute("4\'st Rotation"), TypeConverter(typeof(CAngle3DConvert))]
                public SAngle3D_t SRot_4 { get { return CDisp.afRot[3]; } set { CDisp.afRot[3] = value; } }

                private const string strGroup11 = strGroup3;//"[7]5\'st Translation";
                [DisplayName(m_pstrProp_46), Browsable(true), CategoryAttribute(strGroup11), DescriptionAttribute("5\'st Translation"), TypeConverter(typeof(CVector3DConvert))]
                public SVector3D_t STrans_5 { get { return CDisp.afTrans[4]; } set { CDisp.afTrans[4] = value; } }

                private const string strGroup12 = strGroup3;//"[7]5\'st Rotation";
                [DisplayName(m_pstrProp_49), Browsable(true), CategoryAttribute(strGroup12), DescriptionAttribute("5\'st Rotation"), TypeConverter(typeof(CAngle3DConvert))]
                public SAngle3D_t SRot_5{ get { return CDisp.afRot[4]; } set { CDisp.afRot[4] = value; } }
                
                [DisplayName(m_pstrProp_56), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                public float fScale_Serve0 { get { return CDisp.fScale_Serve0; } set { CDisp.fScale_Serve0 = value; } }
                [DisplayName(m_pstrProp_57), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                public float fScale_Serve1 { get { return CDisp.fScale_Serve1; } set { CDisp.fScale_Serve1 = value; } }
                [DisplayName(m_pstrProp_58), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                public int nMotorType { get { return CDisp.nMotorType; } set { CDisp.nMotorType = value; } }
                [DisplayName(m_pstrProp_59), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                public int nMotorControl_MousePoint { get { return CDisp.nMotorControl_MousePoint; } set { CDisp.nMotorControl_MousePoint = value; } }
                [DisplayName(m_pstrProp_60), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                public String strPickGroup_Comment { get { return CDisp.strPickGroup_Comment; } set { CDisp.strPickGroup_Comment = value; } }

                //// if you want to add , just do like below ////
                
                //[DisplayName(m_pstrProp_), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("")]
                //public { get { return CDisp.; } set { CDisp. = value; } }

                #endregion Item add : Step 2/4
#if false
                #region Set
                
                
                #endregion Set
#endif
            }

            private const String m_strProp_Main0 = "Version";
            private const string m_strProp_Main8 = "3D View";
            private const String m_strProp_Main0_0 = "Title";
            private const String m_strProp_Main0_1 = "ModelNum";
            private const String m_strProp_Main0_2 = "ModelName";
            private const String m_strProp_Main1 = "Mouse Mode";
            private const String m_strProp_Main2 = "Empty";
            private const String m_strProp_Main3 = "Alpha(Main)";
            private const String m_strProp_Main4 = "Light";
            private const String m_strProp_Main5 = "Show StandardAxis";
            private const String m_strProp_Main6 = "Show VirtualAxis";
            private const string m_strProp_Main7 = "DefaultFunction";
            private const string m_strProp_Main9 = "Territory";
            private const string m_strProp_Main10 = "BackColor";
            [DefaultPropertyAttribute("OpenJigWare")]
            private class CProp_Main
            {
                private const String strGroup = "[0]Main";

                public CProp_Main()
                {
                }
                ~CProp_Main()
                {
                }
                #region #### Var(Group0) ####
                private string _strVersion = "1.1.0";
                private string _strTitle = "";
                private int _nModelNum = -1;
                private string _strModelName = "";
                private int _nMouseMode = 1; // m_nMouseControlMode 변수의 셋팅값을 따라갈 것
                private int _n3DView = 0; // 0 - Default, 1 - Perpective
                private int _nTerritoryView = 0; // 0 - Default, 1 - Show
                private bool _bEmpty = false;
                private bool _bLight = true;
                private bool _bShowStandardAxis = false; // m_bStandardAxis 변수의 셋팅값을 따라갈 것
                private bool _bShowVirtualAxis = false; // m_bVirtualClass 변수의 셋팅값을 따라갈 것
                private int _nDefaultFunctionNum = -1;
                private float _fAlpha_All = 1.0f;
                private Color _cBackColor = Color.DarkGray;
                // Robot Rot, Mov
                // Display Rot, Mov
                // Display Scale
                // Background Color
                // BackGround Light- Position[4], Diffuse[4], Specular[4], Ambient[4], Spot, Shiness, Exponent, Direction[3], Diffuse_Mat[4], Specular_Mat[4], Ambient_Mat[4]
                #endregion #### Var(Group0) ####

                #region #### Group0 ####
                [DisplayName(m_strProp_Main0), Browsable(true), CategoryAttribute(strGroup), ReadOnlyAttribute(true), DescriptionAttribute("Version(Open Jig Ware)")]
                public string strMain_Version { get { return _strVersion; } set { _strVersion = value; } }

#region 새로추가
                #region Title("")
                [DisplayName(m_strProp_Main0_0), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("Title")]
                public string strMain_Title { get { return _strTitle; } set { _strTitle = value; } }
                #endregion Title

                #region ModelNum(-1)
                [DisplayName(m_strProp_Main0_1), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("ModelNum")]
                public int nMain_ModelNum { get { return _nModelNum; } set { _nModelNum = value; } }
                #endregion ModelNum

                #region ModelName("")
                [DisplayName(m_strProp_Main0_2), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("ModelName")]
                public string strMain_ModelName { get { return _strModelName; } set { _strModelName = value; } }
                #endregion ModelName

                //private string _strTitle = "";
                //private int nModelNum = -1;
                //private string _strModelName = "";
#endregion 새로추가
                #region MouseMode(false)
                [DisplayName(m_strProp_Main1), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("Mouse Mode")]
                public int nMain_MouseMode { get { return _nMouseMode; } set { _nMouseMode = value; } }
                #endregion MouseMode
                #region Empty(false)
                [DisplayName(m_strProp_Main2), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("Empty"),
                TypeConverter(typeof(CEmptyOrNot))]
                public bool bMain_Empty { get { return _bEmpty; } set { _bEmpty = value; } }
                class CEmptyOrNot : BooleanConverter
                {
                    public override object  ConvertTo(ITypeDescriptorContext context, 
                        System.Globalization.CultureInfo culture, 
                        object value, 
                        Type destinationType)
                    {
                        return (bool)value ? "Empty" : "Fill";
                        //return base.ConvertTo(context, culture, value, destinationType);
                    }
                    public override object ConvertFrom(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)
                    {
                        return ((string)value == "Empty");
                        //return base.ConvertFrom(context, culture, value);
                    }
                }
                #endregion Empty
                #region Alpha(1.0f)
                [DisplayName(m_strProp_Main3), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("Alpha(1.0f")]
                public float fMain_Alpha { get { return _fAlpha_All; } set { _fAlpha_All = value; } }
                #endregion Alpha

                #region Light(true)
                [DisplayName(m_strProp_Main4), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("Light"),
                TypeConverter(typeof(CTrueOrNot))]
                public bool bMain_Light { get { return _bLight; } set { _bLight = value; } }
                class CTrueOrNot : BooleanConverter
                {
                    public override object ConvertTo(ITypeDescriptorContext context,
                        System.Globalization.CultureInfo culture,
                        object value,
                        Type destinationType)
                    {
                        return (bool)value ? "true" : "false";
                    }
                    public override object ConvertFrom(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)
                    {
                        return ((string)value == "true");
                    }
                }
                #endregion Light(true)
                #region ShowStandardAxis(false)
                [DisplayName(m_strProp_Main5), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("Show StandardAxis"),
                TypeConverter(typeof(CTrueOrNot))]
                public bool bMain_ShowStandardAxis { get { return _bShowStandardAxis; } set { _bShowStandardAxis = value; } }
                #endregion ShowStandardAxis(false)
                #region ShowVirtualAxis(false)
                [DisplayName(m_strProp_Main6), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("Show VirtualAxis"),
                TypeConverter(typeof(CTrueOrNot))]
                public bool bMain_ShowVirtualAxis { get { return _bShowVirtualAxis; } set { _bShowVirtualAxis = value; } }
                #endregion ShowStandardAxis(false)
                #region ShowVirtualAxis(false)
                [DisplayName(m_strProp_Main7), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("Default Function(-1: None, 0 ~ 511)")]
                public int nMain_DefaultFunctionNum { get { return _nDefaultFunctionNum; } set { _nDefaultFunctionNum = value; } }
                #endregion ShowStandardAxis(false)
                #region 3DView(0)
                [DisplayName(m_strProp_Main8), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("3D View\r\n -> Default : 0(Normal View), 1(Perspective View)")]
                public int nMain_3DView { get { return _n3DView; } set { _n3DView = value; } }
                #endregion 3DView
                #region Territory
                [DisplayName(m_strProp_Main9), Browsable(true), CategoryAttribute(strGroup), DescriptionAttribute("Territory\r\n -> Default : 0, 1(Show)")]
                public int nMain_Show_Territory { get { return _nTerritoryView; } set { _nTerritoryView = value; } }
                #endregion Territory
                
                #region BackColor
                [DisplayName(m_strProp_Main10),
                Browsable(true),
                CategoryAttribute(strGroup),
                DescriptionAttribute("BackGround Color")]
                public Color cMain_BackColor { get { return _cBackColor; } set { _cBackColor = value; } }

                private CSlider<float> m_fSliderAlpha = new CSlider<float>(1.0f, 0.0f, 1.0f, 0.1f);
                #endregion BackColor

                #endregion #### Group0 ####
            }

#if false
            [DefaultPropertyAttribute("OpenJigWare(Serv0)")]
            private class CProp_Serve0
            {
                private const String strGroup = "Model";
                public CProp_Serve0()
                {
                }
                ~CProp_Serve0()
                {
                }

                #region region #### Var(Group1) ####
                private int _nAxisNumber = -1;
                private Color _cColor = Color.Green;
                private float _fAlpha = 1.0f;
                private String _strModelName = "#0";
                #endregion #### Var(Group1) ####

                #region #### Group1 ####
                #region AxisNumber(-1)
                [CategoryAttribute(strGroup), DescriptionAttribute("Axis Number(-1:None, 0~253)")]
                public int nAxisNumber { get { return _nAxisNumber; } set { _nAxisNumber = value; } }
                //enum EAxisNum_t
                //{
                //    [Description("None")]
                //    _None = -1,
                //    [Description("Axis0")]
                //    _Axis0 = 0,
                //    [Description("Axis1")]
                //    _Axis1,
                //    [Description("Axis2")]
                //    _Axis2,
                //    [Description("Axis3")]
                //    _Axis3,
                //}
                #endregion AxisNumber
#if false
                //CDisp.SetData(-1, Color.White, 1.0f, "#0", 
                ("Fill(0:Empty, 1:Filled") true, 
                ("fMul_3DAngle (0보다 작음:사용안함,")-1, 
                ("Init Coordinate")false, 
                10, 10, 20, 4, 0, "", -1, 0, 0, 0, pSVector[0], pSAngle[0], pSVector, pSAngle, 0, 0, 0, 255, 0.35f, 0.35f, 0, 0, "");
#endif
            #region Color(Green)
                [CategoryAttribute(strGroup), DescriptionAttribute("Color")]
                public Color cColor { get { return _cColor; } set { _cColor = value; } }
            #endregion Color
            #region Alpha(1.0f)
                [CategoryAttribute(strGroup), DescriptionAttribute("Alpha Value ( 0 ~ 1.0)")]
                public float fAlpha { get { return _fAlpha; } set { _fAlpha = value; } }
            #endregion Alpha
            #region ModelName("#0")
                [CategoryAttribute(strGroup),
                DescriptionAttribute("Model Name (Default: #0 ~ #14, FileName)"),
                DefaultValueAttribute("#0")]
                public String strModelName { get { return _strModelName; } set { _strModelName = value; } }
            #endregion ModelName
                #endregion #### Group1 ####
            }
            
            [DefaultPropertyAttribute("OpenJigWare")]
            private class CProp
            {
                public CProp()
                {
                    //_nAxisNumber = -1;
                    //_cColor = Color.Green;
                    //_fAlpha = 1.0f;
                    //_strModelName = "#0";
                }
                ~CProp()
                {
                }

            #region Property

            #region GroupName
                private const String strGroup0 = "Main";
                private const String strGroup1 = "Model";
                #endregion GroupName

            #region Var
            #region #### Var(Group0) ####
                private string _strVersion = "1.0.0";
                private bool _bMouseMode = false;
                private bool _bEmpty = false;
                private float _fAlpha_All = 1.0f;
            #endregion #### Var(Group0) ####

            #region region #### Var(Group1) ####
                private int _nAxisNumber = -1;
                private Color _cColor = Color.Green;
                private float _fAlpha = 1.0f;
                private String _strModelName = "#0";
                #endregion #### Var(Group1) ####
                #endregion Var

            #region #### Group0 ####
                [CategoryAttribute(strGroup0), ReadOnlyAttribute(true), DescriptionAttribute("Version(Open Jig Ware)")]
                public string strVersion { get { return _strVersion; } set { _strVersion = value; } }
            #region MouseMode(false)
                [CategoryAttribute(strGroup0), DescriptionAttribute("Mouse Mode")]
                public bool bMouseMode { get { return _bMouseMode; } set { _bMouseMode = value; } }
                #endregion MouseMode
            #region Empty(false)
                [CategoryAttribute(strGroup0), DescriptionAttribute("Empty")]
                public bool bEmpty { get { return _bEmpty; } set { _bEmpty = value; } }
            #endregion Empty
            #region Alpha(1.0f)
                [CategoryAttribute(strGroup0), DescriptionAttribute("Alpha(1.0f")]
                public float fAlpha_All { get { return _fAlpha_All; } set { _fAlpha_All = value; } }
            #endregion Alpha
                #endregion #### Group0 ####

            #region #### Group1 ####
            #region AxisNumber(-1)
                [CategoryAttribute(strGroup1), DescriptionAttribute("Axis Number(-1:None, 0~253)")]
                public int nAxisNumber { get { return _nAxisNumber; } set { _nAxisNumber = value; } }
            #endregion AxisNumber
#if false
                //CDisp.SetData(-1, Color.White, 1.0f, "#0", 
                ("Fill(0:Empty, 1:Filled") true, 
                ("fMul_3DAngle (0보다작음:사용안함")-1, 
                ("Init Coordinate")false, 
                10, 10, 20, 4, 0, "", -1, 0, 0, 0, pSVector[0], pSAngle[0], pSVector, pSAngle, 0, 0, 0, 255, 0.35f, 0.35f, 0, 0, "");
#endif
            #region Color(Green)
                [CategoryAttribute(strGroup1), DescriptionAttribute("Color")]
                public Color cColor { get { return _cColor; } set { _cColor = value; } }
            #endregion Color
            #region Alpha(1.0f)
                [CategoryAttribute(strGroup1), DescriptionAttribute("Alpha Value ( 0 ~ 1.0)")]
                public float fAlpha { get { return _fAlpha; } set { _fAlpha = value; } }
            #endregion Alpha
            #region ModelName("#0")
                [CategoryAttribute(strGroup1),
                DescriptionAttribute("Model Name (Default: #0 ~ #14, FileName)"),
                DefaultValueAttribute("#0")]
                public String strModelName { get { return _strModelName; } set { _strModelName = value; } }
            #endregion ModelName
            #endregion #### Group1 ####

            #endregion Property
                //m_lstMenu.Add;
                //m_lstMenu.Add("Width/[Radius]");
                //m_lstMenu.Add("Height/[Depth]");
                //m_lstMenu.Add("Depth/[Line Count]");
                //m_lstMenu.Add("Thickness");
                //m_lstMenu.Add("Gap");
                //m_lstMenu.Add("Rotation Axis(0:Pan, 1:Tilt, 2: Swing, 3: Linear X, 4: Linear Y, 5: Linear Z");
                //m_lstMenu.Add("[Rotation Direction] 0(Forward), 1(Inverse)");
                //m_lstMenu.Add("[Real Angle Offset] - Don't use");
                //m_lstMenu.Add("[Rotation Angle for Display(Offset)]");
                //m_lstMenu.Add("[Offset XYZ] X");
                //m_lstMenu.Add("[Offset XYZ] Y");
                //m_lstMenu.Add("[Offset XYZ] Z");
                //m_lstMenu.Add("[Offset Angle] Pan");
                //m_lstMenu.Add("[Offset Angle] Tilt");
                //m_lstMenu.Add("[Offset Angle] Swing");
                //m_lstMenu.Add("[Translation] X_0");
                //m_lstMenu.Add("[Translation] Y_0");
                //m_lstMenu.Add("[Translation] Z_0");
                //m_lstMenu.Add("[Rotation] Pan_0");
                //m_lstMenu.Add("[Rotation] Tilt_0");
                //m_lstMenu.Add("[Rotation] Swing_0");
                //m_lstMenu.Add("[Translation] X_1");
                //m_lstMenu.Add("[Translation] Y_1");
                //m_lstMenu.Add("[Translation] Z_1");
                //m_lstMenu.Add("[Rotation] Pan_1");
                //m_lstMenu.Add("[Rotation] Tilt_1");
                //m_lstMenu.Add("[Rotation] Swing_1");
                //m_lstMenu.Add("[Translation] X_2");
                //m_lstMenu.Add("[Translation] Y_2");
                //m_lstMenu.Add("[Translation] Z_2");
                //m_lstMenu.Add("[Rotation] Pan_2");
                //m_lstMenu.Add("[Rotation] Tilt_2");
                //m_lstMenu.Add("[Rotation] Swing_2");
                //m_lstMenu.Add("[1\'st Sub-Translation] X");
                //m_lstMenu.Add("[1\'st Sub-Translation] Y");
                //m_lstMenu.Add("[1\'st Sub-Translation] Z");
                //m_lstMenu.Add("[1\'st Sub-Rotation] Pan");
                //m_lstMenu.Add("[1\'st Sub-Rotation] Tilt");
                //m_lstMenu.Add("[1\'st Sub-Rotation] Swing");
                //m_lstMenu.Add("[2\'st Sub-Translation] X");
                //m_lstMenu.Add("[2\'st Sub-Translation] Y");
                //m_lstMenu.Add("[2\'st Sub-Translation] Z");
                //m_lstMenu.Add("[2\'st Sub-Rotation] Pan");
                //m_lstMenu.Add("[2\'st Sub-Rotation] Tilt");
                //m_lstMenu.Add("[2\'st Sub-Rotation] Swing");
                //m_lstMenu.Add("[Group A]");
                //m_lstMenu.Add("[Group B]");
                //m_lstMenu.Add("[Group C]");
                //m_lstMenu.Add("[Connected Kinematics Group]");
                //m_lstMenu.Add("[1\'st Group Scale] Max=1");
                //m_lstMenu.Add("[2\'st Group Scale] Max=1");
                //m_lstMenu.Add("[Motor Type] 0(Position Control), 1(Speed Control)");
                //m_lstMenu.Add("[Mouse Drag Direction]0(x+),1(x-),2(y+),3(y-)");
                //m_lstMenu.Add("[Comment]");







#if false


                public bool _bTest = true;
                private string _strTest = "응용 프로그램을 시작합니다.";
                private int _nTest = 4;
                private float _fTest = 10.0f;
                //private bool settingsChanged = false;
                //[CategoryAttribute("ID Settings"), DescriptionAttribute("the customer2")]
                //private string appVersion = "1.0";
                [CategoryAttribute("테스트 1"), DescriptionAttribute("the customer1")]
                public bool _1_bTest
                {
                    get { return _bTest; }
                    set { _bTest = value; }
                }
                [CategoryAttribute("테스트 1"), DescriptionAttribute("the customer2")]
                public string _2_strTest
                {
                    get { return _strTest; }
                    set { _strTest = value; }
                }
                [CategoryAttribute("테스트 2"), DescriptionAttribute("the customer3")]
                public int _3_nTest
                {
                    get { return _nTest; }
                    set { _nTest = value; }
                }
                [CategoryAttribute("테스트 2"), DescriptionAttribute("the customer4")]
                public float _4_fTest
                {
                    get { return _fTest; }
                    set { _fTest = value; }
                }
#endif
            }
#endif
#endif
            #endregion PropertyGrid

            protected override bool ProcessCmdKey(ref Message msg, Keys keyData)
            {
                switch (keyData)
                {
                    #region Keys.Up
                    case Keys.Up:
                        {                            
                            int nDir = 1;
                            m_afLookat_Dir[nDir] += 0.1f;
                            if (m_afLookat_Dir[nDir] > 1.0f) m_afLookat_Dir[nDir] = 1.0f;                         
                        }
                        break;
                    #endregion Keys.Up
                    #region Keys.Down
                    case Keys.Down:
                        {
                            int nDir = 1;
                            m_afLookat_Dir[nDir] -= 0.1f;
                            if (m_afLookat_Dir[nDir] <= -1.0f) m_afLookat_Dir[nDir] = -1.0f;
                        }
                        break;
                    #endregion Keys.Down

                    #region Keys.Left
                    case Keys.Left:
                        {
                            int nDir = 0;
                            m_afLookat_Dir[nDir] += 0.1f;
                            if (m_afLookat_Dir[nDir] > 1.0f) m_afLookat_Dir[nDir] = 1.0f;
                        }
                        break;
                    #endregion Keys.Left
                    #region Keys.Right
                    case Keys.Right:
                        {
                            int nDir = 0;
                            m_afLookat_Dir[nDir] -= 0.1f;
                            if (m_afLookat_Dir[nDir] <= -1.0f) m_afLookat_Dir[nDir] = -1.0f;
                        }
                        break;
                    #endregion Keys.Right
                }
                return base.ProcessCmdKey(ref msg, keyData);
#if false
                int nKey = e.KeyValue;

                    //if (e.Control == true) m_bKey_Ctrl = true; else m_bKey_Ctrl = false;
                    //if (e.Alt == true) m_bKey_Alt = true; else m_bKey_Alt = false;
                    //if (e.Shift == true) m_bKey_Shift = true; else m_bKey_Shift = false;

                    switch (e.KeyCode)
                    {
                #region Keys.Up
                        case Keys.Up:
                            {
                                if (e.Control)
                                {
                                }
                                else
                                {
                                    int nDir = 1;
                                    m_afLookat_Dir[nDir] += 0.1f;
                                    if (m_afLookat_Dir[nDir] > 1.0f) m_afLookat_Dir[nDir] = 1.0f;
                                }
                            }
                            break;
                        #endregion Keys.Up
                #region Keys.Down
                        case Keys.Down:
                            {
                                if (e.Control)
                                {
                                }
                                else
                                {
                                    int nDir = 1;
                                    m_afLookat_Dir[nDir] -= 0.1f;
                                    if (m_afLookat_Dir[nDir] <= 0.0f) m_afLookat_Dir[nDir] = 0.0f;
                                }
                            }
                            break;
                #endregion Keys.Down
                            
                #region Keys.Left
                        case Keys.Left:
                            {
                                if (e.Control)
                                {
                                }
                                else
                                {
                                    int nDir = 0;
                                    m_afLookat_Dir[nDir] += 0.1f;
                                    if (m_afLookat_Dir[nDir] > 1.0f) m_afLookat_Dir[nDir] = 1.0f;
                                }
                            }
                            break;
                        #endregion Keys.Left
                #region Keys.Right
                        case Keys.Right:
                            {
                                if (e.Control)
                                {
                                }
                                else
                                {
                                    int nDir = 0;
                                    m_afLookat_Dir[nDir] -= 0.1f;
                                    if (m_afLookat_Dir[nDir] <= 0.0f) m_afLookat_Dir[nDir] = 0.0f;
                                }
                            }
                            break;
                #endregion Keys.Right
                #region Keys.Escape - ESC : 긴급정지
                        //case Keys.Escape:
                        //    {
                        //        Stop();
                        //        //Cmd_Stop(m_nCurrentRobot);
                        //    }
                        //    break;
                #endregion Keys.Escape - ESC : 긴급정지
                #region Keys.Delete: - 삭제하기
                        case Keys.Delete:
                            {
                                if (e.Control)
                                {
                                }
                                else
                                {
                                }
                            }
                            break;
                #endregion Keys.Delete: - 삭제하기
                    }
#if false
                    float fDelta2 = 0.1f;// 1.0f;
                    //m_fMouse_W_Left -= (float)((e.Delta > 0) ? -fDelta2 : fDelta2);
                    m_fMouse_W_Left = (float)((e.Delta > 0) ? -fDelta2 : fDelta2);

                    //if (m_fMouse_W_Left < 0) m_fMouse_W_Left = 0.0f;

                    double dPos_X = 0;// (e.X - m_nMouse_X_Left);
                    double dPos_Y = 0;// (m_nMouse_Y_Left - e.Y);
                    double dPos_Z = (double)m_fMouse_W_Left;// (m_fMouse_W_Left - e.Y);
                    float fAngle_X, fAngle_Y, fAngle_Z;
                    GetAngle_Display(out fAngle_Y, out fAngle_X, out fAngle_Z);
                    //GetAngle_(out m_afLookat[0], out m_afLookat[1], out m_afLookat[2]);

                    CMath.CalcRot(0, 0, (double)(-fAngle_Z), ref dPos_X, ref dPos_Y, ref dPos_Z);
                    CMath.CalcRot(0, (double)(-fAngle_Y), 0, ref dPos_X, ref dPos_Y, ref dPos_Z);
                    CMath.CalcRot((double)(-fAngle_X), 0, 0, ref dPos_X, ref dPos_Y, ref dPos_Z);

                    //if (
                    //((m_afLookat[0] + dPos_X) > 0) &&
                    //((m_afLookat[1] + dPos_Y) > 0) &&
                    //((m_afLookat[2] + dPos_Z) > 0)
                    //)
                    {
                        m_afLookat[0] += (float)dPos_X;
                        m_afLookat[1] += (float)dPos_Y;
                        m_afLookat[2] += (float)dPos_Z;
                    }
                    //    int nMotCnt = m_CHeader.nMotorCnt;
                    //for (int i = 0; i < nMotCnt; i++)
                    //{
                    //    SetData(i, (float)CKinematics.CInverse.GetValue_Motor(i));
                    //}
                    //Glu.gluLookAt(m_afLookat[0], m_afLookat[1], m_afLookat[2], 0, 0, 0, 0, 1, 0);
                    //Glu.
#endif
#endif
            }

            public void SetAlpha_Display_Enalbe(bool bEn) { m_bAlpha = bEn; }
            public bool GetAlpha_Display_Enalbe() { return m_bAlpha; }
            private bool m_bAlpha = true;
            private float m_fAlpha = 1.0f;
            // The higher this number, the boundary line becomes dark.
            // Kor: 이 숫자를 높일수록 경계라인이 진해진다.
            private const int _COLOR_GAP = 30;

            public COjwDesignerHeader m_CHeader = new COjwDesignerHeader();
            private const int _SIZE_MAX_MOT = 256;
            private float[] m_afMot = new float[_SIZE_MAX_MOT];
            //private String[] m_astrMot = new String[_SIZE_MAX_MOT]; // 생성자에서 초기화

            private SAngle3D_t[] m_pSRot = new SAngle3D_t[_SIZE_MAX_MOT];
            //private CTimer[] m_pSTmrTrack = new CTimer[_SIZE_MAX_MOT];
            private CTimer m_CTmrDraw = new CTimer();
            private long m_lTmrTrack = 0;
            private float[] m_afTrack = new float[_SIZE_MAX_MOT];
            public float CalcLimit(int nMot, float fValue) 
            {
#if false
                if (IsLimit(nMot, fValue) == true)
                {
                    if ((m_CHeader.pSMotorInfo[nMot].fLimit_Down != 0) && (m_CHeader.pSMotorInfo[nMot].fLimit_Down >= fValue)) fValue = m_CHeader.pSMotorInfo[nMot].fLimit_Down;
                    if ((m_CHeader.pSMotorInfo[nMot].fLimit_Up != 0) && (m_CHeader.pSMotorInfo[nMot].fLimit_Up <= fValue)) fValue = m_CHeader.pSMotorInfo[nMot].fLimit_Up;
                }
                return fValue;
#else
                try
                {
                    if (m_CHeader.pSMotorInfo == null) return fValue;
                    if (m_CHeader.pSMotorInfo.Length <= nMot) return fValue;
                    if ((m_CHeader.pSMotorInfo[nMot].fLimit_Down != 0) && (m_CHeader.pSMotorInfo[nMot].fLimit_Down >= fValue)) fValue = m_CHeader.pSMotorInfo[nMot].fLimit_Down;
                    if ((m_CHeader.pSMotorInfo[nMot].fLimit_Up != 0) && (m_CHeader.pSMotorInfo[nMot].fLimit_Up <= fValue)) fValue = m_CHeader.pSMotorInfo[nMot].fLimit_Up;
                    return fValue;
                }
                catch //(Exception ex)
                {
                    //CMessage.Write_Error();
                }
                return fValue;
#endif
            }
            public bool IsLimit(int nMot, float fValue)
            {
                try
                {
                    if (m_CHeader.pSMotorInfo == null) return false;
                    if (m_CHeader.pSMotorInfo.Length <= nMot) return false;
                    if ((m_CHeader.pSMotorInfo[nMot].fLimit_Down != 0) && (m_CHeader.pSMotorInfo[nMot].fLimit_Down >= fValue)) return true;
                    if ((m_CHeader.pSMotorInfo[nMot].fLimit_Up != 0) && (m_CHeader.pSMotorInfo[nMot].fLimit_Up <= fValue)) return true;
                    return false;
                }
                catch //(Exception ex)
                {
                    //CMessage.Write_Error();
                }
                return false;
            }
            public void SetData(int nMot, float fValue) { if ((nMot >= 0) && (nMot < m_afMot.Length)) m_afMot[nMot] = CalcLimit(nMot, fValue); }
            public float GetData(int nMot) { if ((nMot >= 0) && (nMot < m_afMot.Length)) return m_afMot[nMot]; return 0; }
            public float [] GetData() { return m_afMot; }

            #region CsGL Class / The actual drawing and initialization functions are all based here.(Kor: CsGL Class / 실제 그리기 및 초기화(즉, Main) 함수 모음)

                private List<COjwAse> m_lstOjwAse = new List<COjwAse>();
                private List<String> m_lstModel = new List<string>();
                public List<string> GetModelingFiles() { return m_lstModel; }
                public int GetModelingFiles_Count() { return m_lstModel.Count; }

                #region BaseVar

                #region Variable and init value(Kor: 기본 변수 & 초기값)
                private float m_fX = 0.0f;
                private float m_fY = 0.0f;
                private float m_fZ = 0.0f;
                private float m_fPan = -10.0f;
                private float m_fTilt = 10.0f;
                private float m_fSwing = 0.0f;

                private float m_fX_Robot = 0.0f;
                private float m_fY_Robot = 0.0f;
                private float m_fZ_Robot = 0.0f;
                private float m_fPan_Robot = 0.0f;
                private float m_fTilt_Robot = 0.0f;
                private float m_fSwing_Robot = 0.0f;

                private float m_fScale = 0.2f;//0.35f;    // 1.0 = 100%

                private Color m_Color = Color.Red;
                private Color m_BackColor = Color.DarkGray;

                private float[] m_fColor = new float[4];
                private float[] m_fColor_Back = new float[3];
                #endregion

                public void SetRobot_Trans_X(float fValue) { m_fX_Robot = fValue; }
                public void SetRobot_Trans_Y(float fValue) { m_fY_Robot = fValue; }
                public void SetRobot_Trans_Z(float fValue) { m_fZ_Robot = fValue; }
                public void SetRobot_Trans(float fX, float fY, float fZ) { m_fX_Robot = fX; m_fY_Robot = fY; m_fZ_Robot = fZ; }
                public void SetRobot_Rot_Pan(float fValue) { m_fPan_Robot = fValue; }
                public void SetRobot_Rot_Tilt(float fValue) { m_fTilt_Robot = fValue; }
                public void SetRobot_Rot_Swing(float fValue) { m_fSwing_Robot = fValue; }
                public void SetRobot_Rot(float fPan, float fTilt, float fSwing) { m_fPan_Robot = fPan; m_fTilt_Robot = fTilt; m_fSwing_Robot = fSwing; }

                public float GetRobot_Trans_X() { return m_fX_Robot; }
                public float GetRobot_Trans_Y() { return m_fY_Robot; }
                public float GetRobot_Trans_Z() { return m_fZ_Robot; }
                public void GetRobot_Trans(out float fX, out float fY, out float fZ) { fX = m_fX_Robot; fY = m_fY_Robot; fZ = m_fZ_Robot; }
                public float GetRobot_Rot_Pan() { return m_fPan_Robot; }
                public float GetRobot_Rot_Tilt() { return m_fTilt_Robot; }
                public float GetRobot_Rot_Swing() { return m_fSwing_Robot; }
                public void GetRobot_Rot(out float fPan, out float fTilt, out float fSwing) { fPan = m_fPan_Robot; fTilt = m_fTilt_Robot; fSwing = m_fSwing_Robot; }
            
                #region Set function settings for the entire screen(Kor: 전체화면의 설정을 Set/Get 하는 함수)
                // Set rotation/translation settings for the entire screen(Kor: 화면 전체의 회전각/위치값 결정)
                public void SetAngle_Display(float fPan, float fTilt, float fSwing) { m_fPan = fPan; m_fTilt = fTilt; m_fSwing = fSwing; }
                public void SetPos_Display(float fX, float fY, float fZ) { m_fX = fX; m_fY = fY; m_fZ = fZ; }

                public void GetAngle_Display(out float fPan, out float fTilt, out float fSwing) { fPan = m_fPan; fTilt = m_fTilt; fSwing = m_fSwing; }
                public void GetPos_Display(out float fX, out float fY, out float fZ) { fX = m_fX; fY = m_fY; fZ = m_fZ; }
            
                // Get the rotation of the entire screen(Kor: 화면 전체의 회전각을 가져오기)
                public float GetPan() { return m_fPan; }
                public float GetTilt() { return m_fTilt; }
                public float GetSwing() { return m_fSwing; }
            
                // Set the magnification of the entire screen(Kor: 화면 전체의 확대비율 결정)
                public void SetScale(float fScale) { m_fScale = fScale; }
                // Get the magnification of the entire screen(Kor: 화면 전체의 확대비율을 가져오기)
                public float GetScale() { return m_fScale; }

                // Set transparent percentage of the whole screen(Kor: 화면 전체의 투명비율 결정)
                public void SetAlpha(float fAlpha) { m_bAlpha = true; m_fAlpha = fAlpha; }
                // Import transparent percentage of the whole screen(Kor: 화면 전체의 투명비율 가져오기)
                public float GetAlpha(float fAlpha) { return m_fAlpha; }

                // Color
                public void SetColor(Color cData) { m_Color = cData; }
                public void SetBackColor(Color cData) { m_BackColor = cData; }

                public Color GetColor() { return m_Color; }
                public Color GetBackColor() { return m_BackColor; }
                #endregion Set function settings for the entire screen(Kor: 전체화면의 설정을 Set/Get 하는 함수)

                #endregion BaseVar

                #region Mouse Control
                //// Mouse Control ////
                // It is possible to control up to 10(Kor: 10개 까지 컨트롤 가능) //
                private bool m_bMouseClick = false;
                private bool m_bMouseLeftClick = true;
                private int m_nMouse_X_Left = 0;
                private int m_nMouse_Y_Left = 0;
                private int m_nMouse_X_Right = 0;
                private int m_nMouse_Y_Right = 0;
                private int m_nMouse_W_Right = 0;

                private float m_fMouse_W_Left = 0.0f;

                private bool m_bPickMouseClick = false;
                private bool m_bPickMouseClick_Reserve = false;
                public void SetPickCheck_OneShot(int nX, int nY) { m_nMouse_X_Left = nX; m_nMouse_Y_Left = nY; m_bPickMouseClick_Reserve = true; }
                public void OjwMouseDown(object sender, MouseEventArgs e) { OjwMouseDown(e); }
                public double m_dPos_X = 0.0f;
                public double m_dPos_Y = 0.0f;
                public double m_dPos_Z = 0.0f;
                private int m_nSeq_MouseDown_Back = 0;
                private int m_nSeq_MouseDown = 0;
                private int m_nSeq_MouseUp_Back = 0;
                private int m_nSeq_MouseUp = 0;
                public bool IsMouseDown()
                {
                    if (m_nSeq_MouseDown != m_nSeq_MouseDown_Back)
                    {
                        m_nSeq_MouseDown = m_nSeq_MouseDown_Back;
                        // Etc
                        //m_nSeq_MouseUp = m_nSeq_MouseUp_Back;
                        return true;
                    }
                    return false;
                }
                public bool IsMouseUp()
                {
                    if (m_nSeq_MouseUp != m_nSeq_MouseUp_Back)
                    {
                        m_nSeq_MouseUp = m_nSeq_MouseUp_Back;
                        // Etc
                        //m_nSeq_MouseDown = m_nSeq_MouseDown_Back;
                        return true;
                    }
                    return false;
                }
                public void OjwMouseDown(MouseEventArgs e)
                {
                    m_nSeq_MouseDown++;
                    if (m_bMouseClick == false)
                    {
                        //OjwDraw();
                        SelectObject_Clear();
                        m_bMouseClick = true;
                        if (e.Button == MouseButtons.Left)
                        {
                            SetPickCheck_OneShot(e.X, e.Y);
                            
                            OjwDraw();

                            m_bMouseLeftClick = true;
                            m_nMouse_X_Left = e.X;
                            m_nMouse_Y_Left = e.Y;
                            //Ojw.CMessage.Write("MouseDown(Left) InverseNum={0}, X[{1}], Y[{2}]", m_nSelected_InverseKinematicsNumber, m_nMouse_X_Left, m_nMouse_Y_Left);
                        }
                        else
                        {
                            m_bMouseLeftClick = false;
                            m_nMouse_X_Right = e.X;
                            m_nMouse_Y_Right = e.Y;
                            // mousecontrol mode 인 경우에만...
                            //if ((GetMouseMode() == 0) && (e.Button == MouseButtons.Right)) m_nMenuStatus = 1;

                            //Ojw.CMessage.Write("MouseDown(Right) InverseNum={0}, X[{1}], Y[{2}]", m_nSelected_InverseKinematicsNumber, m_nMouse_X_Right, m_nMouse_Y_Right);

                            if (e.Button == MouseButtons.Right) m_nMenuStatus = 1;
                        }
                        int nInverseNum = m_nSelected_InverseKinematicsNumber;// m_nStatus_InverseKinematicsNumber;
                                                
                        #region Forward
                        double[] adMot = new double[m_afMot.Length];
                        for (int i = 0; i < m_afMot.Length; i++) adMot[i] = (double)m_afMot[i];
#if false
                        if (m_CHeader != null)
                            CKinematics.CForward.CalcKinematics(m_CHeader.pDhParamAll[nInverseNum], adMot, out m_dPos_X, out m_dPos_Y, out m_dPos_Z);
                        //CMessage.Write("(MouseDown - Forward={0}, {1}, {2}", m_dPos_X, m_dPos_Y, m_dPos_Z);
                        //if (e.Button == MouseButtons.Right) PopupMenu();
#else
                        if (m_CHeader != null)
                        {
                            float fX, fY, fZ;
                            CalcF(nInverseNum, -1, true, out fX, out fY, out fZ);
                            m_dPos_X = (double)fX;
                            m_dPos_Y = (double)fY;
                            m_dPos_Z = (double)fZ;
                        }

#endif

                        adMot = null;
                        #endregion Forward


                        if ((m_CGridMotionEditor !=null) && (m_CGridMotionEditor.m_nGridMode == 1))
                        {
                            if (m_CHeader != null)
                            {
                                //m_CGridMotionEditor.SelectMotor(
                                for (int i = 0; i < m_CHeader.nMotorCnt; i++)
                                {
                                    int nID = m_CHeader.anMotorIDs[i];
                                    float fValue = GetData(nID);
                                    int nIndex = m_lstIDs_Motion.FindIndex(x => x == nID);
                                    if (nID < 0) continue;
                                    if ((m_CHeader.pSMotorInfo[nID].nMotor_Enable < 0) || (m_CHeader.pSMotorInfo[nID].nMotor_Enable > 1))
                                        continue;
                                    try
                                    {
                                        GridMotionEditor_SetMotor(GridMotionEditor_GetCurrentLine(), nIndex, fValue);
                                        //SetData(nID, GridMotionEditor_GetMotor(GridMotionEditor_GetCurrentLine(), nID));
                                        //SetData(nID, GridMotionEditor_GetMotor(GridMotionEditor_GetCurrentLine(), nID));
                                    }
                                    catch
                                    {
                                        fValue = GetData(nID);
                                        SetData(nID, fValue);
                                    }
                                }
                            }
                        }
                    }
                }
                public void OjwMouseUp(object sender, MouseEventArgs e) { OjwMouseUp(e); }
                //public void OjwKeyDown(object sender, KeyEventArgs e) { OjwKeyDown(e); }
                //public void OjwKeyUp(object sender, KeyEventArgs e) { OjwKeyUp(e); }
                ContextMenuStrip m_ctxmenuMouse = new ContextMenuStrip();
                //private int m_nMenu = -1;
                private const int _MENU_FILE = 0;
                private const int _MENU_ITEM = 1;
                private const int _MENU_SUB_OPEN = 0;
                private const int _MENU_SUB_SAVE = 1;
                private const int _MENU_SUB_CLOSE = 2;
                private const int _MENU_SUB_EXPORT = 4;
                private const int _MENU_SUB_IMPORT = 5;
                private const int _MENU_SUB_MAKE_JSON = 7;
                private const int _MENU_SUB_ITEM_ADD = 0;

                public CUserEvent Event_FileOpen = new CUserEvent();
                public CUserEvent Event_ItemAdd = new CUserEvent();
                public CUserEvent Event_Compile = new CUserEvent();
                //private void EventAdd()
                //{
                //    try
                //    {
                //        Event_ItemAdd.UserEvent += ItemAdded;                        
                //    }
                //    catch (Exception ex)
                //    {
                //        Ojw.CMessage.Write_Error(ex.ToString());
                //        //throw;
                //    }
                //}
                private void Compiled(object sender, EventArgs e)
                {
                    if (m_CMonster != null) m_CMonster.SetHeader(m_CHeader);
                    //Log("Monster Library Header Setting");
                }

                public void CalcF(int nFunctionNumber, bool bLimitFunction, out float fX, out float fY, out float fZ)
                {
#if false
                    if (bLimitFunction)
                        Ojw.CKinematics.CForward.SetCalcLimit_FunctionNumber(nFunctionNumber);

                    double dX, dY, dZ;
                    GetData_Forward(nFunctionNumber, out dX, out dY, out dZ);
                    fX = (float)dX; fY = (float)dY; fZ = (float)dZ;
#else
                    CalcF(nFunctionNumber, -1, false, out fX, out fY, out fZ);
#endif
                }
                public void CalcF(int nFunctionNumber, int nAxis, out float fX, out float fY, out float fZ)
                {
#if false
                    Ojw.CKinematics.CForward.SetCalcLimit_Axis(nAxis); // nAxis 번 모터까지의 위치값 확인

                    double dX, dY, dZ;
                    GetData_Forward(nFunctionNumber, out dX, out dY, out dZ);
                    fX = (float)dX; fY = (float)dY; fZ = (float)dZ;
#else
                    CalcF(nFunctionNumber, nAxis, false, out fX, out fY, out fZ);
#endif
                }
                public void CalcF(int nFunctionNumber, int nAxis, bool bLimitFunctionNumber, out float fX, out float fY, out float fZ)
                {
                    Ojw.CKinematics.CForward.SetCalcLimit_Axis(nAxis); // nAxis 번 모터까지의 위치값 확인
                    if (bLimitFunctionNumber == true) Ojw.CKinematics.CForward.SetCalcLimit_FunctionNumber(nFunctionNumber);

                    double dX, dY, dZ;
                    GetData_Forward(nFunctionNumber, out dX, out dY, out dZ);
                    fX = (float)dX; fY = (float)dY; fZ = (float)dZ;
                    //Ojw.CMessage.Write("[{0}]Calc X[{1}], Y[{2}], Z[{3}]", nAxis, Ojw.CMath.Round(fX, 1), Ojw.CMath.Round(fY, 1), Ojw.CMath.Round(fZ, 1));
                }
                // 특정 모터, 혹은 FunctionNumber 까지를 a, d 를 다 0 으로 초기화 한 위치 + 초기위치 를 시작 위치로, 거기부터 마지막까지를 최종위치로 하는 함수

                public List<int> m_lstCalcInv_Endpoint = new List<int>();
                public void CalcInv_Endpoint_Clear()
                {
                    m_lstCalcInv_Endpoint.Clear();
                }
                public void CalcInv_Endpoint_Add(int nAxis) { m_lstCalcInv_Endpoint.Add(nAxis); }
                public bool CalcInv_Endpoint_Check() { return (m_lstCalcInv_Endpoint.Count > 1) ? true : false; }
                public float CalcInv_Endpoint_Result()
                {
                    float fRes = 0.0f;
                    int nID = 0;
                    if (CalcInv_Endpoint_Check() == true)
                    {
                        for (int i = 0; i < m_lstCalcInv_Endpoint.Count; i++)
                        {
                            nID = Math.Abs(m_lstCalcInv_Endpoint[i]);
                            fRes += ((m_lstCalcInv_Endpoint[i] < 0) ? -1 : 1) * GetData(nID);
                        }
                    }
                    return fRes;
                }

                public int m_nCalcInv_Mode = 0; // 0 : auto, 1 : Inverse, 2 : Inverse & Reverse, 3 : Inverse & Motor
                public void CalcInv_SetMode(int nMode) { m_nCalcInv_Mode = nMode; }
                public void CalcF_LastOf(int nFunctionNumber, int nAxis, bool bLimitFunctionNumber, out float fX, out float fY, out float fZ)
                {
                    Ojw.CKinematics.CForward.SetCalcLimit_Axis(nAxis); // nAxis 번 모터까지의 위치값 확인
                    if (bLimitFunctionNumber == true) Ojw.CKinematics.CForward.SetCalcLimit_FunctionNumber(nFunctionNumber);

                    double dX, dY, dZ;
                    GetData_Forward_LastOf(nFunctionNumber, out dX, out dY, out dZ);
                    fX = (float)dX; fY = (float)dY; fZ = (float)dZ;
                    //Ojw.CMessage.Write("[{0}]Calc X[{1}], Y[{2}], Z[{3}]", nAxis, Ojw.CMath.Round(fX, 1), Ojw.CMath.Round(fY, 1), Ojw.CMath.Round(fZ, 1));
                }
                public int[] CalcInv_MotorIDs(int nFunctionNumber) { return GetHeader_pDhParamAll()[nFunctionNumber].GetMotors(); }
                // 결과값은 m_C3d.GetData(ID) 로 가져오면 됨
                public float [] CalcInv(int nFunctionNumber, float fX, float fY, float fZ, int nRepeat = 10000, float fCutline = 0.001f) { return CalcInv(nFunctionNumber, GetHeader_pDhParamAll()[nFunctionNumber].GetMotors(), fX, fY, fZ, nRepeat, fCutline); }
                //public void CalcInv(int nFunctionNumber, int[] anMotorIDs, float fX, float fY, float fZ, int nRepeat = 1000, float fCutline = 0.001f)
                //{
                //    float[] afRes_Angles;
                //    CalcInv(nFunctionNumber, anMotorIDs, fX, fY, fZ, out afRes_Angles, nRepeat, fCutline);
                //}
                public float[] CalcInv(int nFunctionNumber, int[] anMotorIDs, float fX, float fY, float fZ, int nRepeat = 10000, float fCutline = 0.001f)
                {
                    return CalcInv(nFunctionNumber, true, anMotorIDs, fX, fY, fZ, nRepeat, fCutline);
                }
                public float[] CalcInv(int nFunctionNumber, bool bLimitFunctionNumber, int[] anMotorIDs, float fX, float fY, float fZ, int nRepeat = 10000, float fCutline = 0.001f)
                {

                    int nID;
                    int nCnt = anMotorIDs.Length;
                                        
                    //float [] afRes_Angles = new float[nCnt];
                    int nPos = nCnt;
                    float fX0 = fX, fY0 = fY, fZ0 = fZ;
                    float fXc, fYc, fZc;
                    float fXp, fYp, fZp;
                    float fAngle0 = 0;
                    float fP, fN, fC;
                    float fAngle, fAngle1, fAngle2;
                    List<float> lstAngles = new List<float>();
                    for (int i = 0; i < nCnt; i++)
                        lstAngles.Add(GetData(anMotorIDs[i]));
                    float fRes = 0.0f;

                    float fX1, fY1, fZ1;
                    float fX2, fY2, fZ2;
                    CalcF(nFunctionNumber, -1, true, out fX1, out fY1, out fZ1);

                    if (m_bIgnoreCheckInit_CalcInv == false)
                    {
                        // 방향 제한 확인
                        CalcF(nFunctionNumber, -1, false, out fX0, out fY0, out fZ0);
                        bool bX = false;
                        bool bY = false;
                        bool bZ = false;
                        for (int i = 0; i < anMotorIDs.Length; i++)
                        {
                            if ((bX == true) && (bY == true) && (bZ == true)) break;

                            float fVal = GetData(anMotorIDs[i]);
                            SetData(anMotorIDs[i], fVal + 10);
                            CalcF(nFunctionNumber, -1, false, out fXp, out fYp, out fZp);
                            if (bX == false) { if (fX0 != fXp) { bX = true; } }
                            if (bY == false) { if (fY0 != fYp) { bY = true; } }
                            if (bZ == false) { if (fZ0 != fZp) { bZ = true; } }
                            SetData(anMotorIDs[i], fVal - 10);
                            CalcF(nFunctionNumber, -1, false, out fXp, out fYp, out fZp);
                            if (bX == false) { if (fX0 != fXp) { bX = true; } }
                            if (bY == false) { if (fY0 != fYp) { bY = true; } }
                            if (bZ == false) { if (fZ0 != fZp) { bZ = true; } }
                            SetData(anMotorIDs[i], fVal);
                        }
                        if (bX == false) fX = fX0;
                        if (bY == false) fY = fY0;
                        if (bZ == false) fZ = fZ0;
                    }
                    if (m_bIgnoreCheckInit_CalcInv == true) m_bIgnoreCheckInit_CalcInv = false;
                    for (int nCalc = 0; nCalc < nRepeat; nCalc++)
                    {
                        fRes = 1.0f;
                        nPos = nCnt - 1;
                        while (nPos - 1 >= 0)
                        {
                            nID = anMotorIDs[nPos - 1];
                            fAngle0 = GetData(nID);

                            CalcF(nFunctionNumber, -1, bLimitFunctionNumber, out fXc, out fYc, out fZc);
                            CalcF(nFunctionNumber, nID, bLimitFunctionNumber, out fXp, out fYp, out fZp);

                            fP = (float)Math.Sqrt(
                                Math.Pow(fX - fXc, 2) +
                                Math.Pow(fY - fYc, 2) +
                                Math.Pow(fZ - fZc, 2)
                                );
                            fN = (float)Math.Sqrt(
                                (float)Math.Pow(fXc - fXp, 2) +
                                (float)Math.Pow(fYc - fYp, 2) +
                                (float)Math.Pow(fZc - fZp, 2)
                                );
                            fC = (float)Math.Sqrt(
                                (float)Math.Pow(fX - fXp, 2) +
                                (float)Math.Pow(fY - fYp, 2) +
                                (float)Math.Pow(fZ - fZp, 2)
                                );
                            //float fAngle = 180.0f - (float)Ojw.CMath.ACos((fP * fP + fN * fN - fC * fC) / (2.0f * fP * fN)) - fAngle0;

                            fAngle1 = fAngle0 + (float)Ojw.CMath.ACos((fC * fC + fN * fN - fP * fP) / (2.0f * fC * fN));
                            fAngle2 = fAngle0 - ((float)Ojw.CMath.ACos((fC * fC + fN * fN - fP * fP) / (2.0f * fC * fN)));
                            bool bNon1 = false;
                            bool bNon2 = false;
                            if (Single.IsNaN(fAngle1)) { fAngle1 = fAngle0; bNon1 = true; }
                            else
                            {
                                float fTmp = fAngle1 % 360;
                                if (fTmp > 180) fTmp -= 360.0f;
                                else if (fTmp < -180) fTmp += 360.0f;
                                fAngle1 = CalcLimit(nID, fTmp);
                            }
                            if (Single.IsNaN(fAngle2)) { fAngle2 = fAngle0; bNon2 = true; }
                            else
                            {
                                float fTmp = fAngle2 % 360;
                                if (fTmp > 180) fTmp -= 360.0f;
                                else if (fTmp < -180) fTmp += 360.0f;
                                fAngle2 = CalcLimit(nID, fTmp);
                            }
                            //if ((bNon1 == true) && (bNon2 == true))
                            //{
                            //    nPos--;
                            //    continue;
                            //}
                            
#if true
#if true
                            if (bNon1 == false)
                            {
                                // Distance 계산
                                SetData(nID, fAngle1);
                                CalcF(nFunctionNumber, -1, bLimitFunctionNumber, out fXc, out fYc, out fZc);
                                fC = (float)Math.Sqrt(
                                    (float)Math.Pow(fX - fXc, 2) +
                                    (float)Math.Pow(fY - fYc, 2) +
                                    (float)Math.Pow(fZ - fZc, 2)
                                    );
                            }
                            else fC = 99999999f;

                            if (bNon2 == false)
                            {
                                SetData(nID, fAngle2);
                                CalcF(nFunctionNumber, -1, bLimitFunctionNumber, out fXp, out fYp, out fZp);
                                fP = (float)Math.Sqrt(
                                    (float)Math.Pow(fX - fXp, 2) +
                                    (float)Math.Pow(fY - fYp, 2) +
                                    (float)Math.Pow(fZ - fZp, 2)
                                    );
                            }
                            else fP = 99999999f;

                            
                            //float fVal1 = Math.Abs(fAngle0 - fAngle1);
                            //float fVal2 = Math.Abs(fAngle0 - fAngle2);
                            //if (fVal1 > fVal2)
                            //{
                            //    fAngle = 
                            //}
                            
                            
                            
                            //if ((fAngle1 < 0) && (fAngle2 > 0))
                            //{
                            //    if (fAngle0 > 0) fAngle = fAngle2;
                            //    else fAngle = fAngle1;
                            //}
                            //else if ((fAngle2 < 0) && (fAngle1 > 0))
                            //{
                            //    if (fAngle0 > 0) fAngle = fAngle1;
                            //    else fAngle = fAngle2;
                            //}
                            //else
                            //{
                                //float fVal1 = Math.Abs(fAngle0 - fAngle1);
                                //float fVal2 = Math.Abs(fAngle0 - fAngle2);
                                fAngle = CalcLimit(nID, (fP < fC) ? fAngle2 : fAngle1);
                                //fAngle = CalcLimit(nID, (fVal1 < fVal2) ? fAngle1 : fAngle2);
                            //}

#else
                            if ((IsLimit(nID, fAngle1) == false) && (IsLimit(nID, fAngle2) == false))
                            {
                                // Distance 계산
                                SetData(nID, fAngle1);
                                CalcF(nFunctionNumber, -1, out fXc, out fYc, out fZc);
                                fC = (float)Math.Sqrt(
                                    (float)Math.Pow(fX - fXc, 2) +
                                    (float)Math.Pow(fY - fYc, 2) +
                                    (float)Math.Pow(fZ - fZc, 2)
                                    );

                                SetData(nID, fAngle2);
                                CalcF(nFunctionNumber, -1, out fXp, out fYp, out fZp);
                                fP = (float)Math.Sqrt(
                                    (float)Math.Pow(fX - fXp, 2) +
                                    (float)Math.Pow(fY - fYp, 2) +
                                    (float)Math.Pow(fZ - fZp, 2)
                                    );
                                fAngle = (fC < fP) ? fAngle1 : fAngle2;
                            }
                            else if (IsLimit(nID, fAngle1) == false)
                            {
                                SetData(nID, fAngle1);
                                CalcF(nFunctionNumber, -1, out fXc, out fYc, out fZc);
                                fAngle = (float)Math.Sqrt(
                                    (float)Math.Pow(fX - fXc, 2) +
                                    (float)Math.Pow(fY - fYc, 2) +
                                    (float)Math.Pow(fZ - fZc, 2)
                                    );
                            }
                            else// if (IsLimit(nID, fAngle2) == false)
                            {
                                SetData(nID, fAngle2);
                                CalcF(nFunctionNumber, -1, out fXp, out fYp, out fZp);
                                fAngle = (float)Math.Sqrt(
                                    (float)Math.Pow(fX - fXp, 2) +
                                    (float)Math.Pow(fY - fYp, 2) +
                                    (float)Math.Pow(fZ - fZp, 2)
                                    );
                            }
                            //fAngle1 = CalcLimit(nID, fAngle1);
                            //fAngle2 = CalcLimit(nID, fAngle2);
#endif
                            


                            
#else

                            if (Math.Abs(fAngle0 - fAngle1) < Math.Abs(fAngle0 - fAngle2))
                                fAngle = fAngle1;
                            else fAngle = fAngle2;
#endif
                            SetData(nID, fAngle);

                            fRes = 0;
                            for (int i = 0; i < nCnt; i++)
                            {
                                fRes += (float)Math.Abs(GetData(anMotorIDs[i]) - lstAngles[i]);
                                lstAngles[i] = GetData(anMotorIDs[i]);
                            }
                            nPos--;
                        }

                        if (fRes < fCutline) break;
                    }
                    //CalcF(nFunctionNumber, -1, false, out fX0, out fY0, out fZ0);
                    //lstAngles.AddRange(CalcInv_LastOf(true, nFunctionNumber, bLimitFunctionNumber, anMotorIDs, fX, fY, fZ, nRepeat, fCutline));


                    if ((m_nCalcInv_Mode == 2) || (m_nCalcInv_Mode == 0))
                    {
                        lstAngles.Clear();
                        CalcF(nFunctionNumber, -1, true, out fX2, out fY2, out fZ2);

                        double [] adV = (double [])Ojw.CKinematics.CInverse.GetValue_V().Clone();
                        //lstAngles.AddRange(CalcInv2(nFunctionNumber, bLimitFunctionNumber, anMotorIDs, fX0 - (fX2 - fX1), fY0 - (fY2 - fY1), fZ0 - (fZ2 - fZ1), nRepeat, fCutline));
                        lstAngles.AddRange(CalcInv2(nFunctionNumber, bLimitFunctionNumber, anMotorIDs, fX0, fY0, fZ0, adV, nRepeat, fCutline));
                    }
                    else
                    {
                    }

                    return lstAngles.ToArray();
                }


                public float[] CalcInv2(int nFunctionNumber, bool bLimitFunctionNumber, int[] anMotorIDs, float fX, float fY, float fZ, int nRepeat = 1000, float fCutline = 0.001f)
                {
                    return CalcInv2(nFunctionNumber, bLimitFunctionNumber, anMotorIDs, fX, fY, fZ, null, nRepeat, fCutline);
                }
                public float[] CalcInv2(int nFunctionNumber, bool bLimitFunctionNumber, int[] anMotorIDs, float fX, float fY, float fZ, double [] adV = null, int nRepeat = 1000, float fCutline = 0.001f)
                {
                    int nID;
                    int nCnt = anMotorIDs.Length;
                    int nPos = nCnt;
                    float fX0 = fX, fY0 = fY, fZ0 = fZ;
                    float fXc = 0, fYc = 0, fZc = 0;
                    float fXp = 0, fYp = 0, fZp = 0;
                    float fX_Start, fY_Start, fZ_Start;
                    float fX_End, fY_End, fZ_End;
                    float fAngle0 = 0;
                    float fP = 0, fN = 0, fC = 0;
                    float fAngle, fAngle1, fAngle2;
                    List<float> lstAngles = new List<float>();
                    for (int i = 0; i < nCnt; i++)
                        lstAngles.Add(GetData(anMotorIDs[i]));
                    float fRes = 0.0f;

                    // End Point 획득
                    //CalcF(nFunctionNumber, -1, false, out fX_End, out fY_End, out fZ_End);

                    for (int nCalc = 0; nCalc < nRepeat; nCalc++)
                    {
                        fRes = 1.0f;
                        nPos = nCnt;
                        while (nPos - 1 >= 0)
                        {
                            nID = anMotorIDs[nPos - 1];
                            fAngle0 = GetData(nID);

                            CalcF(nFunctionNumber, -1, false, out fXc, out fYc, out fZc);
                            //fXc = fX; fYc = fY; fZc = fZ;
                            CalcF(nFunctionNumber, nID, false, out fXp, out fYp, out fZp);

                            CalcF(nFunctionNumber, nID, true, out fX_Start, out fY_Start, out fZ_Start);
                            if (Ojw.CKinematics.CForward.CheckCalc() != 2) break;
 
                            fP = (float)Math.Sqrt(
                                Math.Pow(fX - fXc, 2) +
                                Math.Pow(fY - fYc, 2) +
                                Math.Pow(fZ - fZc, 2)
                                );
                            fN = (float)Math.Sqrt(
                                (float)Math.Pow(fXc - fXp, 2) +
                                (float)Math.Pow(fYc - fYp, 2) +
                                (float)Math.Pow(fZc - fZp, 2)
                                );
                            fC = (float)Math.Sqrt(
                                (float)Math.Pow(fX - fXp, 2) +
                                (float)Math.Pow(fY - fYp, 2) +
                                (float)Math.Pow(fZ - fZp, 2)
                                );
                            //float fAngle = 180.0f - (float)Ojw.CMath.ACos((fP * fP + fN * fN - fC * fC) / (2.0f * fP * fN)) - fAngle0;

                            fAngle1 = fAngle0 + (float)Ojw.CMath.ACos((fC * fC + fN * fN - fP * fP) / (2.0f * fC * fN));
                            fAngle2 = fAngle0 - ((float)Ojw.CMath.ACos((fC * fC + fN * fN - fP * fP) / (2.0f * fC * fN)));
                            bool bNon1 = false;
                            bool bNon2 = false;
                            if (Single.IsNaN(fAngle1)) { fAngle1 = fAngle0; bNon1 = true; }
                            if (Single.IsNaN(fAngle2)) { fAngle2 = fAngle0; bNon2 = true; }

                            fAngle1 = CalcLimit(nID, fAngle1);
                            fAngle2 = CalcLimit(nID, fAngle2);

                            if (bNon1 == false)
                            {
                                // Distance 계산
                                SetData(nID, fAngle1);
                                CalcF(nFunctionNumber, -1, false, out fXc, out fYc, out fZc);
                                fC = (float)Math.Sqrt(
                                    (float)Math.Pow(fX - fXc, 2) +
                                    (float)Math.Pow(fY - fYc, 2) +
                                    (float)Math.Pow(fZ - fZc, 2)
                                    );
                            }
                            else fC = 99999999f;

                            if (bNon2 == false)
                            {
                                SetData(nID, fAngle2);
                                CalcF(nFunctionNumber, -1, false, out fXp, out fYp, out fZp);
                                fP = (float)Math.Sqrt(
                                    (float)Math.Pow(fX - fXp, 2) +
                                    (float)Math.Pow(fY - fYp, 2) +
                                    (float)Math.Pow(fZ - fZp, 2)
                                    );
                            }
                            else fP = 99999999f;


                            if ((fAngle1 < 0) && (fAngle2 > 0))
                            {
                                if (fAngle0 > 0) fAngle = fAngle2;
                                else fAngle = fAngle1;
                            }
                            else if ((fAngle2 < 0) && (fAngle1 > 0))
                            {
                                if (fAngle0 > 0) fAngle = fAngle1;
                                else fAngle = fAngle2;
                            }
                            else fAngle = CalcLimit(nID, (fC < fP) ? fAngle1 : fAngle2);

                            SetData(nID, fAngle);

                            fRes = 0;
                            for (int i = 0; i < nCnt; i++)
                            {
                                fRes += (float)Math.Abs(GetData(anMotorIDs[i]) - lstAngles[i]);
                                lstAngles[i] = GetData(anMotorIDs[i]);
                            }
                            nPos--;
                        }

                        if (fRes < fCutline)
                        {
                            if (fC < fP)
                            {
                                fX_End = fXc;
                                fY_End = fYc;
                                fZ_End = fZc;
                            }
                            else
                            {
                                fX_End = fXp;
                                fY_End = fYp;
                                fZ_End = fZp;
                            }
                            break;
                        }
                    }
                    //CalcF(nFunctionNumber, -1, false, out fX0, out fY0, out fZ0);
                    //lstAngles.AddRange(CalcInv_LastOf(true, nFunctionNumber, bLimitFunctionNumber, anMotorIDs, fX, fY, fZ, nRepeat, fCutline));



                    // 2차 함수 계산 ////////////////////////////////////////
                    int[] anMotorID = new int[256];
                    double[] adValue = new double[256];
                    int nGetCnt_Lines = m_CHeader.pDhParamAll[nFunctionNumber].GetCount();
                    // int[] anFunctions = m_CHeader.pDhParamAll[nFunctionNumber].GetFunctions();// GetHeader_pDhParamAll()[nFunctionNumber].GetFunctions_AfterCalc(); // m_CHeader.pDhParamAll[nFunctionNumber].GetFunctions_AfterCalc();
                    if (nGetCnt_Lines > 0) // CDhParam 데이터의 갯수가 있을 경우
                    {
                        //double[] adV = Ojw.CKinematics.CInverse.GetValue_V();
                        for (int nT = nGetCnt_Lines - 1; nT >= 0; nT--) // 마지막 데이터만...
                        {
                            int nFunction_AfterCalc = m_CHeader.pDhParamAll[nFunctionNumber].GetData(nT).nFunctionNumber_AfterCalc;
                            if ((nFunction_AfterCalc >= 0) && (nFunction_AfterCalc < 255))
                            {
                                int nCntT = GetData_Inverse(nFunction_AfterCalc, fX, fY, fZ, adV, out anMotorID, out adValue);
                                for (int i = 0; i < nCntT; i++)
                                {
                                    SetData(anMotorID[i], (float)adValue[i]);
                                }
                                break;
                            }
                        }
                    }
                    // 2차 함수 계산 ////////////////////////////////////////

                    return lstAngles.ToArray();
                }


                private bool m_bIgnoreCheckInit_CalcInv = false;
                private void IgnoreCheckInit_CalcInv(bool bIgnore = true)
                {
                    m_bIgnoreCheckInit_CalcInv = bIgnore;
                }
                public float[] CalcInv_LastOf(bool bIgnoreCheckInit, int nFunctionNumber, bool bLimitFunctionNumber, int[] anMotorIDs, float fX, float fY, float fZ, int nRepeat = 1000, float fCutline = 0.001f)
                {
                    IgnoreCheckInit_CalcInv();
                    return CalcInv_LastOf(nFunctionNumber, bLimitFunctionNumber, anMotorIDs, fX, fY, fZ, nRepeat, fCutline);
                }
                public float[] CalcInv_LastOf(int nFunctionNumber, bool bLimitFunctionNumber, int[] anMotorIDs, float fX, float fY, float fZ, int nRepeat = 1000, float fCutline = 0.001f)
                {
                    int nID;
                    int nCnt = anMotorIDs.Length;
                    
                    Array.Reverse(anMotorIDs);
                    
                    int nPos = nCnt;
                    float fXc, fYc, fZc;
                    float fXp, fYp, fZp;
                    float fAngle0 = 0;
                    float fP, fN, fC;
                    float fAngle, fAngle1, fAngle2;
                    List<float> lstAngles = new List<float>();
                    for (int i = 0; i < nCnt; i++)
                        lstAngles.Add(GetData(anMotorIDs[i]));
                    float fRes = 0.0f;

                    if (m_bIgnoreCheckInit_CalcInv == false)
                    {
                        // 방향 제한 확인
                        CalcF(nFunctionNumber, -1, false, out fXc, out fYc, out fZc);
                        bool bX = false;
                        bool bY = false;
                        bool bZ = false;
                        for (int i = 0; i < anMotorIDs.Length; i++)
                        {
                            if ((bX == true) && (bY == true) && (bZ == true)) break;

                            float fVal = GetData(anMotorIDs[i]);
                            SetData(anMotorIDs[i], fVal + 10);
                            CalcF(nFunctionNumber, -1, false, out fXp, out fYp, out fZp);
                            if (bX == false) { if (fXc != fXp) { bX = true; } }
                            if (bY == false) { if (fYc != fYp) { bY = true; } }
                            if (bZ == false) { if (fZc != fZp) { bZ = true; } }
                            SetData(anMotorIDs[i], fVal - 10);
                            CalcF(nFunctionNumber, -1, false, out fXp, out fYp, out fZp);
                            if (bX == false) { if (fXc != fXp) { bX = true; } }
                            if (bY == false) { if (fYc != fYp) { bY = true; } }
                            if (bZ == false) { if (fZc != fZp) { bZ = true; } }
                            SetData(anMotorIDs[i], fVal);
                        }
                        if (bX == false) fX = fXc;
                        if (bY == false) fY = fYc;
                        if (bZ == false) fZ = fZc;
                    }
                    if (m_bIgnoreCheckInit_CalcInv == true) m_bIgnoreCheckInit_CalcInv = false;
                    //////////////////////////////////////////////////////////////////
                    for (int nCalc = 0; nCalc < nRepeat; nCalc++)
                    {
                        fRes = 1.0f;
                        nPos = nCnt;
                        while (nPos - 1 >= 0)
                        {
                            nID = anMotorIDs[nPos - 1];
                            fAngle0 = GetData(nID);

                            CalcF_LastOf(nFunctionNumber, -1, bLimitFunctionNumber, out fXc, out fYc, out fZc);
                            CalcF_LastOf(nFunctionNumber, nID, bLimitFunctionNumber, out fXp, out fYp, out fZp);

                            fP = (float)Math.Sqrt(
                                Math.Pow(fX - fXc, 2) +
                                Math.Pow(fY - fYc, 2) +
                                Math.Pow(fZ - fZc, 2)
                                );
                            fN = (float)Math.Sqrt(
                                (float)Math.Pow(fXc - fXp, 2) +
                                (float)Math.Pow(fYc - fYp, 2) +
                                (float)Math.Pow(fZc - fZp, 2)
                                );
                            fC = (float)Math.Sqrt(
                                (float)Math.Pow(fX - fXp, 2) +
                                (float)Math.Pow(fY - fYp, 2) +
                                (float)Math.Pow(fZ - fZp, 2)
                                );
                            fAngle1 = fAngle0 + (float)Ojw.CMath.ACos((fC * fC + fN * fN - fP * fP) / (2.0f * fC * fN));
                            fAngle2 = fAngle0 - ((float)Ojw.CMath.ACos((fC * fC + fN * fN - fP * fP) / (2.0f * fC * fN)));
                            bool bNon1 = false;
                            bool bNon2 = false;
                            if (Single.IsNaN(fAngle1)) { fAngle1 = fAngle0; bNon1 = true; }
                            if (Single.IsNaN(fAngle2)) { fAngle2 = fAngle0; bNon2 = true; }

                            if (bNon1 == false)
                            {
                                // Distance 계산
                                SetData(nID, fAngle1);
                                CalcF_LastOf(nFunctionNumber, -1, bLimitFunctionNumber, out fXc, out fYc, out fZc);
                                fC = (float)Math.Sqrt(
                                    (float)Math.Pow(fX - fXc, 2) +
                                    (float)Math.Pow(fY - fYc, 2) +
                                    (float)Math.Pow(fZ - fZc, 2)
                                    );
                            }
                            else fC = 99999999f;

                            if (bNon2 == false)
                            {
                                SetData(nID, fAngle2);
                                CalcF_LastOf(nFunctionNumber, -1, bLimitFunctionNumber, out fXp, out fYp, out fZp);
                                fP = (float)Math.Sqrt(
                                    (float)Math.Pow(fX - fXp, 2) +
                                    (float)Math.Pow(fY - fYp, 2) +
                                    (float)Math.Pow(fZ - fZp, 2)
                                    );
                            }
                            else fP = 99999999f;


                            if ((fAngle1 < 0) && (fAngle2 > 0))
                            {
                                if (fAngle0 > 0) fAngle = fAngle2;
                                else fAngle = fAngle1;
                            }
                            else if ((fAngle2 < 0) && (fAngle1 > 0))
                            {
                                if (fAngle0 > 0) fAngle = fAngle1;
                                else fAngle = fAngle2;
                            }
                            else fAngle = CalcLimit(nID, (fC < fP) ? fAngle1 : fAngle2);

                            SetData(nID, fAngle);

                            fRes = 0;
                            for (int i = 0; i < nCnt; i++)
                            {
                                fRes += (float)Math.Abs(GetData(anMotorIDs[i]) - lstAngles[i]);
                                lstAngles[i] = GetData(anMotorIDs[i]);
                            }
                            nPos--;
                        }

                        if (fRes < fCutline) break;
                    }
                    float[] afRes = lstAngles.ToArray();
                    Array.Reverse(afRes);
                    return afRes;
                }
                private bool m_bItemAdded = false;
                private void ItemAdded(object sender, EventArgs e)
                {
                    // 이벤트 발생시 동작 기능들...
                    //if (IsDrawText() == true)
                    //{
                    //    m_bItemAdded = true;
                    //    m_rtxtDraw.Text = GetHeader_strDrawModel();
                    //    m_rtxtDraw.Select(m_nSelectedItem, 0);
                    //    StringListToGrid();
                    //    m_bItemAdded = false;
                    //}
                    if (IsDrawRText() == true)
                    {
                        m_bItemAdded = true;
                        m_rtxtDraw.Text = GetHeader_strDrawModel();
                        m_rtxtDraw.Select(m_nSelectedItem, 0);
                        //StringListToGrid();
                        m_bItemAdded = false;
                    }
                }

                private bool m_bModelOpened = false;
                public static readonly String _STR_BACKUP_FILE = "\\ojwbackup.back";
                private void FileRestore(object sender, EventArgs e)
                {
                    //FileRestore();
                    Ojw.CMessage.Write("FileOpened");
                    for (int i = 0; i < m_CHeader.nMotorCnt; i++)
                    {
#if !_MONSTER_LIB
                        m_CRobotis.Read_Motor_Push(m_CHeader.pSMotorInfo[i].nMotorID);
#else
                        //m_CMonster.
#endif
                    }                    
                }
                public void FileRestore()//(object sender, EventArgs e)
                {
                    //MessageBox.Show("FileOpened");
                    //StringListToGrid();
                    #region Restore
                    if (m_bGridInit == true)
                    {
                        if (m_bModelOpened == true)//false)
                        {
                            #region 정상적인 프로그램 종료시 백업한 파일 지우기
                            FileInfo fileBack = new FileInfo(Application.StartupPath + _STR_BACKUP_FILE);
                            if (fileBack.Exists) // 백업할 파일이 있는지 체크
                            {
                                // 있다면 비정상 종료이므로 물어보고 복구한다.
                                DialogResult dlgRet = MessageBox.Show("비정상 종료 전 백업된 파일이 있습니다.\r\n\r\n복구 하시겠습니까?", "모션파일 복구", MessageBoxButtons.OKCancel, MessageBoxIcon.Warning);
                                if (dlgRet == DialogResult.OK)
                                {
                                    if (DataFileOpen(Application.StartupPath + _STR_BACKUP_FILE, null) == false)
                                    {
                                        MessageBox.Show("dmt 모션 파일이 아닙니다.");
                                    }
                                    else
                                    {
                                        //Modify(false);
                                        //Grid_DisplayTime();
                                    }
                                }
                            }
                            #endregion 정상적인 프로그램 종료시 백업한 파일 지우기
                        }
                        //m_bModelOpened = true;
                    }
                    #endregion Restore
                }
            
                #region MotionFile
                            
                public string m_strMotionFile_FileName = String.Empty;
                public string m_strMotionFile_TableName = String.Empty;
                private int m_nMotionFile_StartPosition = 0;
                public string m_strMotionFile_Comment = String.Empty;
                public String GetMotionFile_Title() { return m_strMotionFile_TableName; }
                public String GetMotionFile_Comment() { return m_strMotionFile_Comment; }
                public int GetMotionFile_StartPosition() { return m_nMotionFile_StartPosition; }
                public void SetMotionFile_Title(string strTableName) { m_strMotionFile_TableName = strTableName; }
                public void SetMotionFile_Comment(string strComment) { m_strMotionFile_Comment = strComment; }
                public void SetMotionFile_StartPosition(int nStartPosition) { m_nMotionFile_StartPosition = nStartPosition; }
            
                private string m_strMotionFile_FileAndTitle = String.Empty; 
                private string GetMotionFile_FileAndTitle() { return m_strMotionFile_FileAndTitle; }

#if true
                // DataFileOpen 과 같으나 MotionEditor 테이블 없이 파일만 로딩
                public bool BinaryFileOpen(String strFileName, out SMotion_t SMotion) 
                {
                    for (int nID = 0; nID < _SIZE_MAX_MOT; nID++)
                    {
                        m_pSRot[nID].pan = 0.0f;
                        m_pSRot[nID].tilt = 0.0f;
                        m_pSRot[nID].swing = 0.0f;
                        //m_pSTmrTrack[nID].Set();
                    }

                    //SMotion.nCount = 0;
                    SMotion.strTableName = String.Empty;
                    SMotion.strFileName = strFileName;

                    SMotion.strVersion = String.Empty;
                    SMotion.strComment = String.Empty;
                    SMotion.nStartPosition = 0;
                    SMotion.nFrameSize = 0;
                    SMotion.nCommentSize = 0;
                    SMotion.nCnt_LineComment = 0;
                    SMotion.nPlayTime = 0;
                    SMotion.nRobotModelNum = 0;
                    SMotion.nMotorCnt = 0;
                    SMotion.STable = null;

                    //SMotion.STable = new SMotionTable_t[999];
                    //Array.Clear(SMotion.STable, 0, SMotion.STable.Length);
                    bool bFileOpened = false;
                    String _STR_EXT = "dmt";
                    String _STR_VER_V_12 = "1.2";
                    String _STR_VER_V_11 = "1.1";
                    String _STR_VER_V_10 = "1.0";

                    FileInfo f = null;
                    FileStream fs = null;

                    try
                    {
                        int i, j;
                        byte[] byteData;
                        string strFileName2 = "";
                        
                        f = new FileInfo(strFileName);
                        fs = f.OpenRead();
                        byteData = new byte[fs.Length];
                        fs.Read(byteData, 0, byteData.Length);
                        strFileName2 = f.Name;
                            
                        fs.Close();
                        f = null;
                        
                        // 데이타 형식 구분
                        String strTmp = "";
                        strTmp += (char)byteData[0];
                        strTmp += (char)byteData[1];
                        strTmp += (char)byteData[2];
                        strTmp += (char)byteData[3];
                        strTmp += (char)byteData[4];
                        strTmp += (char)byteData[5];
                        SMotion.strVersion = strTmp;

                        int nPos = 6;   // 앞의 6개는 Version ['DMT1.0~2'] 에 할당

                        if (strTmp.ToUpper() == _STR_EXT.ToUpper() + _STR_VER_V_10)
                        {
                            #region FileOpen V1.0
                            //int nPos = 6;   // 앞의 6개는 'DMT1.0' 에 할당

                            #region Header

                            #region 타이틀(21)
                            byte[] byteGetData = new byte[21];
                            for (i = 0; i < 21; i++) byteGetData[i] = 0;
                            for (i = 0; i < 21; i++)
                            {
                                if (byteData[i + nPos] == 0) break;
                                byteGetData[i] = byteData[i + nPos];
                            }
                            SMotion.strTableName = System.Text.Encoding.Default.GetString(byteGetData);
                            nPos += 21;
                            byteGetData = null;
                            #endregion 타이틀(21)

                            #region Start Position(1)
                            int nStartPosition = (int)(byteData[nPos++]);
                            SMotion.nStartPosition = (nStartPosition >= 0) ? nStartPosition : 0;
                            #endregion Start Position(1)

                            #region Size - MotionFrame(2), Comment(2), Caption(2), PlayTime(4), RobotModelNumber(2), MotorCnt(1)
                            // Size
                            SMotion.nFrameSize = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                            SMotion.nCommentSize = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                            SMotion.nCnt_LineComment = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                            SMotion.nPlayTime = (int)(byteData[nPos] + byteData[nPos + 1] * 256 + byteData[nPos + 2] * 256 * 256 + byteData[nPos + 3] * 256 * 256 * 256); nPos += 4;
                            SMotion.nRobotModelNum = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                            SMotion.nMotorCnt = (int)(byteData[nPos++]);
                            #endregion Size - MotionFrame, Comment, Caption, PlayTime
                            
                            #endregion Header

                            // nRobotModelNum 를 읽고 해당 파일을 읽어들인다.
                            #region Header 검증
#if false
                            if (SMotion.nMotorCnt != m_CHeader.nMotorCnt)
                            {
                                //if (bFile == true)
                                //{
                                //    fs.Close();
                                //    f = null;
                                //}
                                this.Cursor = System.Windows.Forms.Cursors.Default;
                                //MessageBox.Show("디자이너 파일의 모터 수량과 맞지 않습니다.(요구모터수량=" + Ojw.CConvert.IntToStr(m_CHeader.nMotorCnt) + ", 모션파일에 정의된 모터수량=" + Ojw.CConvert.IntToStr(nMotorCnt) + ")\n");// 해당 모델에 맞는 모션을 로드하십시오.");
                                //DialogResult dlgRet = MessageBox.Show("무시하고 계속 열겠습니까?", "파일열기", MessageBoxButtons.OKCancel, MessageBoxIcon.Warning);
                                MessageBox.Show("Motor quantity error.(Motors in 3D Modeling =" + Ojw.CConvert.IntToStr(m_CHeader.nMotorCnt) + ", Motors in File =" + Ojw.CConvert.IntToStr(nMotorCnt) + ")\n");// 해당 모델에 맞는 모션을 로드하십시오.");
                                DialogResult dlgRet = MessageBox.Show("Do you want to continue?", "File Open", MessageBoxButtons.OKCancel, MessageBoxIcon.Warning);
                                if (dlgRet == DialogResult.OK)
                                {
                                    //MessageBox.Show("Yes");
                                    //return;
                                }
                                else return false;
                            }
#endif
                            #endregion Header 검증

                            #region 실제 모션
                            SMotion.STable = new SMotionTable_t[SMotion.nFrameSize];
                            for(j = 0; j < SMotion.nFrameSize; j++)
                            {
                                SMotion.STable[j].anMot = new int[SMotion.nMotorCnt];
                                SMotion.STable[j].anLed = new int[SMotion.nMotorCnt];
                                SMotion.STable[j].abEn = new bool[SMotion.nMotorCnt];
                                SMotion.STable[j].abType = new bool[SMotion.nMotorCnt];
                            }

                            int nH = SMotion.nFrameSize;
                            int nData;
                            short sData;
                            //float fValue;
                            for (j = 0; j < nH; j++)
                            {
                                //En
                                #region Enable
                                int nEn = byteData[nPos++];
                                SMotion.STable[j].bEn = ((nEn & 0x01) != 0) ? true : false;
                                #endregion Enable
                                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                #region Motor
                                int nMotorCntMax = (int)Math.Max(SMotion.nMotorCnt, m_CHeader.nMotorCnt);
                                // 0-Index, 1-En, 2 ~ 24, 25 - speed, 26 - delay, 27,28,29,30 - Data0-3, 31 - time, 32 - caption
                                for (int nAxis = 0; nAxis < nMotorCntMax; nAxis++)
                                {
                                    if (nAxis >= m_CHeader.nMotorCnt) nPos += 2;
                                    else if (nAxis >= SMotion.nMotorCnt) SMotion.STable[j].anMot[nAxis] = 0;//0.0f;// 실 모터수량과 맞지 않다면 그 부분을 0 으로 채울 것
                                    else
                                    {
                                        nData = (int)(BitConverter.ToInt16(byteData, nPos)); nPos += 2;
                                        sData = (short)(nData & 0x0fff);
                                        if ((sData & 0x800) != 0) sData -= 0x1000;
                                        
                                        SMotion.STable[j].anLed[nAxis] = (int)((nData >> 12) & 0x07);
                                        SMotion.STable[j].abType[nAxis] = (bool)(((nData & 0x8000) != 0) ? true : false);
                                        SMotion.STable[j].abEn[nAxis] = (bool)((sData == 0x7ff) ? false : true);

                                        if (sData == 0x7ff)
                                            SMotion.STable[j].anMot[nAxis] = 0;//0.0f;
                                        else
                                            SMotion.STable[j].anMot[nAxis] = (int)sData;//CalcEvd2Angle(nAxis, (int)sData);
                                    }
                                }
                                #endregion Motor
                                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                #region Speed(2), Delay(2), Group(1), Command(1), Data0(2), Data1(2)
                                // Speed  
                                SMotion.STable[j].nTime = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;

                                // Delay  
                                SMotion.STable[j].nDelay = (int)BitConverter.ToInt16(byteData, nPos); nPos += 2;

                                // Group  
                                SMotion.STable[j].nGroup = (int)(byteData[nPos++]);

                                // Command  
                                SMotion.STable[j].nCmd = (int)(byteData[nPos++]);

                                // Data0  
                                SMotion.STable[j].nData0 = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                                // Data1  
                                SMotion.STable[j].nData1 = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                                //
                                SMotion.STable[j].nData2 = 0;
                                SMotion.STable[j].nData3 = 0;
                                SMotion.STable[j].nData4 = 0;
                                SMotion.STable[j].nData5 = 0;
                                #endregion Speed(2), Delay(2), Group(1), Command(1), Data0(2), Data1(2)
                                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                #region 추가한 Frame 위치 및 자세
                                nPos += 24;
                                //nPos += 4;
                                //nPos += 4;
                                //nPos += 4;

                                //nPos += 4;
                                //nPos += 4;
                                //nPos += 4;
                                #endregion 추가한 Frame 위치 및 자세
                            }
                            #endregion 실제 모션
#if true
                            string strData_ME = "";
                            string strData_FE = "";

                            // 'M' 'E'
                            strData_ME += (char)(byteData[nPos++]);
                            strData_ME += (char)(byteData[nPos++]);

                            #region Comment Data
                            // Comment
                            byte[] pstrComment = new byte[SMotion.nCommentSize];
                            for (j = 0; j < SMotion.nCommentSize; j++)
                                pstrComment[j] = (byte)(byteData[nPos++]);
                            m_strMotionFile_Comment = System.Text.Encoding.Default.GetString(pstrComment);
                            SMotion.strComment = m_strMotionFile_Comment;
                            pstrComment = null;
                            #endregion Comment Data

                            #region Caption
                            int nLineNum = 0;
                            string strLineComment;
                            byte[] byLine = new byte[46];
                            for (j = 0; j < SMotion.nCnt_LineComment; j++)
                            {
                                nLineNum = (short)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                                for (int k = 0; k < 46; k++)
                                    byLine[k] = (byte)(byteData[nPos++]);
                                strLineComment = System.Text.Encoding.Default.GetString(byLine);
                                strLineComment = strLineComment.Trim((char)0);
                                m_CGridMotionEditor.SetCaption(nLineNum, strLineComment);
                            }
                            byLine = null;
                            #endregion Caption

                            // 'T' 'E'
                            strData_FE += (char)(byteData[nPos++]);
                            strData_FE += (char)(byteData[nPos++]);
#endif

                            bFileOpened = true;
                            #endregion FileOpen V1.0
                        }
                        else if (strTmp.ToUpper() == _STR_EXT.ToUpper() + _STR_VER_V_11)
                        {
                            #region FileOpen V1.1
                            //int nPos = 6;   // 앞의 6개는 'DMT1.0' 에 할당

                            #region Header

                            #region 타이틀(21)
                            byte[] byteGetData = new byte[21];
                            for (i = 0; i < 21; i++) byteGetData[i] = 0;
                            for (i = 0; i < 21; i++)
                            {
                                if (byteData[i + nPos] == 0) break;
                                byteGetData[i] = byteData[i + nPos];
                            }
                            SMotion.strTableName = System.Text.Encoding.Default.GetString(byteGetData);
                            nPos += 21;
                            byteGetData = null;
                            #endregion 타이틀(21)

                            #region Start Position(1)
                            int nStartPosition = (int)(byteData[nPos++]);
                            SMotion.nStartPosition = (nStartPosition >= 0) ? nStartPosition : 0;
                            #endregion Start Position(1)

                            #region Size - MotionFrame(2), Comment(2), Caption(2), PlayTime(4), RobotModelNumber(2), MotorCnt(1)
                            // Size
                            SMotion.nFrameSize = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                            SMotion.nCommentSize = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                            SMotion.nCnt_LineComment = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                            SMotion.nPlayTime = (int)(byteData[nPos] + byteData[nPos + 1] * 256 + byteData[nPos + 2] * 256 * 256 + byteData[nPos + 3] * 256 * 256 * 256); nPos += 4;
                            SMotion.nRobotModelNum = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                            SMotion.nMotorCnt = (int)(byteData[nPos++]);
                            #endregion Size - MotionFrame, Comment, Caption, PlayTime

                            #endregion Header

                            // nRobotModelNum 를 읽고 해당 파일을 읽어들인다.
                            #region Header 검증
#if false
                            if (SMotion.nMotorCnt != m_CHeader.nMotorCnt)
                            {
                                //if (bFile == true)
                                //{
                                //    fs.Close();
                                //    f = null;
                                //}
                                this.Cursor = System.Windows.Forms.Cursors.Default;
                                MessageBox.Show("디자이너 파일의 모터 수량과 맞지 않습니다.(요구모터수량=" + Ojw.CConvert.IntToStr(m_CHeader.nMotorCnt) + ", 모션파일에 정의된 모터수량=" + Ojw.CConvert.IntToStr(nMotorCnt) + ")\n");// 해당 모델에 맞는 모션을 로드하십시오.");
                                DialogResult dlgRet = MessageBox.Show("무시하고 계속 열겠습니까?", "파일열기", MessageBoxButtons.OKCancel, MessageBoxIcon.Warning);
                                if (dlgRet == DialogResult.OK)
                                {
                                    //MessageBox.Show("Yes");
                                    //return;
                                }
                                else return false;
                            }
#endif
                            #endregion Header 검증

                            #region 실제 모션
                            SMotion.STable = new SMotionTable_t[SMotion.nFrameSize];
                            for (j = 0; j < SMotion.nFrameSize; j++)
                            {
                                SMotion.STable[j].anMot = new int[SMotion.nMotorCnt];
                                SMotion.STable[j].anLed = new int[SMotion.nMotorCnt];
                                SMotion.STable[j].abEn = new bool[SMotion.nMotorCnt];
                                SMotion.STable[j].abType = new bool[SMotion.nMotorCnt];
                            }

                            int nH = SMotion.nFrameSize;
                            int nData, nData2;
                            //short sData;
                            //float fValue;
                            for (j = 0; j < nH; j++)
                            {
                                //En
                                #region Enable
                                int nEn = byteData[nPos++];
                                SMotion.STable[j].bEn = ((nEn & 0x01) != 0) ? true : false;
                                #endregion Enable
                                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                #region Motor
                                int nMotorCntMax = (int)Math.Max(SMotion.nMotorCnt, m_CHeader.nMotorCnt);
                                // 0-Index, 1-En, 2 ~ 24, 25 - speed, 26 - delay, 27,28,29,30 - Data0-3, 31 - time, 32 - caption
                                for (int nAxis = 0; nAxis < nMotorCntMax; nAxis++)
                                {
                                    if (nAxis >= m_CHeader.nMotorCnt) nPos += 3;
                                    else if (nAxis >= SMotion.nMotorCnt) SMotion.STable[j].anMot[nAxis] = 0;// 실 모터수량과 맞지 않다면 그 부분을 0 으로 채울 것
                                    else
                                    {
                                        nData = byteData[nPos++];
                                        nData += byteData[nPos++] * 256;
                                        nData += byteData[nPos++] * 256 * 256;
                                        nData2 = nData & 0x3fff;
                                        if ((nData & 0x4000) != 0) nData2 *= -1; // 부호비트 검사

                                        // 엔코더 타입정의
                                        // 일단 넘어간다.

                                        // Stop Bit
                                        // 넘어간다.

                                        // Mode
#if false
                                        //Grid_SetFlag_Type(j, nAxis, (((nData & 0x20000) != 0) ? true : false));

                                        //Grid_SetFlag_Led(j, nAxis, ((nData >> 18) & 0x07));
                                        //Grid_SetFlag_En(j, nAxis, ((nData == 0x200000) ? false : true));

                                        if (m_CGridMotionEditor.GetEnable(j, nAxis) == false)
                                        {
                                            m_CGridMotionEditor.SetData(j, nAxis, 0);
                                        }
                                        else
#endif
                                        {
                                            SMotion.STable[j].anMot[nAxis] = nData2;// CalcEvd2Angle(nAxis, (int)nData2);
                                        }



                                        /* - Save
                                        fValue = GridMotionEditor_GetMotor(i, j);
                                        sData = (short)(OjwMotor.CalcAngle2Evd(j, fValue) & 0x03ff);
                                        //sData |= 0x0400; // 속도모드인때 정(0-0x0000), 역(1-0x0400)
                                        //sData |= LED;  // 00 - 0ff, 0x0800 - Red(01), 0x1000 - Blue(10), 0x1800 - Green(11)
                                        //sData |= 제어타입 // 0 - 위치, 0x2000 - 속도
                                        sData |= 0x4000; //Enable // 개별 Enable (0 - Disable, 0x4000 - Enable)
                                         */


                                        //fValue = GridMotionEditor_GetMotor(i, j);
                                        //nData = (int)(((Grid_GetFlag_En(i, j) == true) ? CalcAngle2Evd(j, fValue) : 0x07ff) & 0x0fff);

                                        //nData |= (int)(((j >= 6) && (j <= 8)) ? 0x8000 : 0x0000);
                                        //nData |= (int)((Grid_GetFlag_Type(i, j) == true) ? 0x20000 : 0x0000); // 제어타입 // 0 - 위치, 0x20000 - 속도

                                        //nData |= (int)((Grid_GetFlag_Led(i, j) & 0x07) << 18);
                                        //nData |= (int)((Grid_GetFlag_Type(i, j) == true) ? 0x8000 : 0x0000);
                                        //nData |= (int)((Grid_GetFlag_En(i, j) == false) ? 0x200000 : 0x00000);

                                        ////byteData = BitConverter.GetBytes((Int32)nData);
                                        ////fs.Write(byteData, 0, 3);
                                    }
                                }
                                #endregion Motor
                                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                #region Speed(2), Delay(2), Group(1), Command(1), Data0(2), Data1(2)
                                // Speed  
                                SMotion.STable[j].nTime = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;

                                // Delay  
                                SMotion.STable[j].nDelay = BitConverter.ToInt16(byteData, nPos); nPos += 2;

                                // Group  
                                SMotion.STable[j].nGroup = (int)(byteData[nPos++]);

                                // Command  
                                SMotion.STable[j].nCmd = (int)(byteData[nPos++]);

                                // Data0  
                                SMotion.STable[j].nData0 = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                                // Data1  
                                SMotion.STable[j].nData1 = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                                SMotion.STable[j].nData2 = 0;
                                SMotion.STable[j].nData3 = 0;
                                SMotion.STable[j].nData4 = 0;
                                SMotion.STable[j].nData5 = 0;
                                #endregion Speed(2), Delay(2), Group(1), Command(1), Data0(2), Data1(2)
                                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                #region 추가한 Frame 위치 및 자세
                                nPos += 24;
                                //nPos += 4;
                                //nPos += 4;
                                //nPos += 4;

                                //nPos += 4;
                                //nPos += 4;
                                //nPos += 4;
                                #endregion 추가한 Frame 위치 및 자세
                            }
                            #endregion 실제 모션
#if true
                            string strData_ME = "";
                            string strData_FE = "";

                            // 'M' 'E'
                            strData_ME += (char)(byteData[nPos++]);
                            strData_ME += (char)(byteData[nPos++]);

                            #region Comment Data
                            // Comment
                            byte[] pstrComment = new byte[SMotion.nCommentSize];
                            for (j = 0; j < SMotion.nCommentSize; j++)
                                pstrComment[j] = (byte)(byteData[nPos++]);
                            m_strMotionFile_Comment = System.Text.Encoding.Default.GetString(pstrComment);
                            SMotion.strComment = m_strMotionFile_Comment;
                            pstrComment = null;
                            #endregion Comment Data

                            #region Caption
                            int nLineNum = 0;
                            string strLineComment;
                            byte[] byLine = new byte[46];
                            for (j = 0; j < SMotion.nCnt_LineComment; j++)
                            {
                                nLineNum = (short)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                                for (int k = 0; k < 46; k++)
                                    byLine[k] = (byte)(byteData[nPos++]);
                                strLineComment = System.Text.Encoding.Default.GetString(byLine);
                                strLineComment = strLineComment.Trim((char)0);
                                m_CGridMotionEditor.SetCaption(nLineNum, strLineComment);
                            }
                            byLine = null;
                            #endregion Caption

                            // 'T' 'E'
                            strData_FE += (char)(byteData[nPos++]);
                            strData_FE += (char)(byteData[nPos++]);

                            //                     if (bMessage == true)
                            //                     {
                            //                         if (strData_ME != "ME") OjwMessage("Motion Table Error\r\n");
                            //                         else OjwMessage("Table Loaded");
                            //                         if (strData_FE != "TE") OjwMessage("File Error\r\n");
                            //                         else OjwMessage("Table Loaded");
                            //                     }
#endif
                            bFileOpened = true;
                            #endregion FileOpen V1.1
                        }
                        else if (strTmp.ToUpper() == _STR_EXT.ToUpper() + _STR_VER_V_12)
                        {
                            #region FileOpen V1.2
                            //int nPos = 6;   // 앞의 6개는 'DMT1.2' 에 할당

                            #region Header

                            #region 타이틀(21)
                            byte[] byteGetData = new byte[21];
                            for (i = 0; i < 21; i++) byteGetData[i] = 0;
                            for (i = 0; i < 21; i++)
                            {
                                if (byteData[i + nPos] == 0) break;
                                byteGetData[i] = byteData[i + nPos];
                            }
                            SMotion.strTableName = System.Text.Encoding.Default.GetString(byteGetData);
                            nPos += 21;
                            byteGetData = null;
                            #endregion 타이틀(21)

                            #region Start Position(1)
                            int nStartPosition = (int)(byteData[nPos++]);
                            SMotion.nStartPosition = (nStartPosition >= 0) ? nStartPosition : 0;
                            #endregion Start Position(1)

                            #region Size - MotionFrame(2), Comment(2), Caption(2), PlayTime(4), RobotModelNumber(2), MotorCnt(1), Motor Index(MC), Mirror Index(MC)
                            // Size
                            SMotion.nFrameSize = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                            SMotion.nCommentSize = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                            SMotion.nCnt_LineComment = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                            SMotion.nPlayTime = (int)(byteData[nPos] + byteData[nPos + 1] * 256 + byteData[nPos + 2] * 256 * 256 + byteData[nPos + 3] * 256 * 256 * 256); nPos += 4;
                            SMotion.nRobotModelNum = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                            SMotion.nMotorCnt = (int)(byteData[nPos++]);

                            // 모터의 인덱스
                            byte[] pbyteMotorIndex = new byte[SMotion.nMotorCnt];
                            for (int nIndex = 0; nIndex < SMotion.nMotorCnt; nIndex++) pbyteMotorIndex[nIndex] = byteData[nPos++];

                            // 모터의 Mirror 인덱스
                            byte[] pbyteMirrorIndex = new byte[SMotion.nMotorCnt];
                            for (int nIndex = 0; nIndex < SMotion.nMotorCnt; nIndex++) pbyteMirrorIndex[nIndex] = byteData[nPos++];

                            #endregion Size - MotionFrame(2), Comment(2), Caption(2), PlayTime(4), RobotModelNumber(2), MotorCnt(1), Motor Index(MC), Mirror Index(MC)

                            #endregion Header

                            // nRobotModelNum 를 읽고 해당 파일을 읽어들인다.
                            #region Header 검증
#if false
                            if (SMotion.nMotorCnt != m_CHeader.nMotorCnt)
                            {
                                this.Cursor = System.Windows.Forms.Cursors.Default;
                                MessageBox.Show("디자이너 파일의 모터 수량과 맞지 않습니다.(요구모터수량=" + Ojw.CConvert.IntToStr(m_CHeader.nMotorCnt) + ", 모션파일에 정의된 모터수량=" + Ojw.CConvert.IntToStr(nMotorCnt) + ")\n");// 해당 모델에 맞는 모션을 로드하십시오.");
                                DialogResult dlgRet = MessageBox.Show("무시하고 계속 열겠습니까?", "파일열기", MessageBoxButtons.OKCancel, MessageBoxIcon.Warning);
                                if (dlgRet == DialogResult.OK)
                                {
                                    //MessageBox.Show("Yes");
                                    //return;
                                }
                                else return false;
                            }
#endif
                            #endregion Header 검증

                            for (i = SMotion.nFrameSize; i < m_CGridMotionEditor.GetLineCount() - SMotion.nFrameSize; i++) m_CGridMotionEditor.Clear(i);

                            #region 실제 모션
                            SMotion.STable = new SMotionTable_t[SMotion.nFrameSize];
                            for (j = 0; j < SMotion.nFrameSize; j++)
                            {
                                SMotion.STable[j].anMot = new int[SMotion.nMotorCnt];
                                SMotion.STable[j].anLed = new int[SMotion.nMotorCnt];
                                SMotion.STable[j].abEn = new bool[SMotion.nMotorCnt];
                                SMotion.STable[j].abType = new bool[SMotion.nMotorCnt];
                            }

                            int nH = SMotion.nFrameSize;
                            int nData;
                            short sData;
                            //float fValue;
                            for (j = 0; j < nH; j++)
                            {
                                //En
                                #region Enable
                                int nEn = byteData[nPos++];
                                SMotion.STable[j].bEn = ((nEn & 0x01) != 0) ? true : false;
                                #endregion Enable
                                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                #region Motor
                                int nMotorCntMax = (int)Math.Max(SMotion.nMotorCnt, m_CHeader.nMotorCnt);
                                // 0-Index, 1-En, 2 ~ 24, 25 - speed, 26 - delay, 27,28,29,30 - Data0-3, 31 - time, 32 - caption
                                for (int nAxis = 0; nAxis < nMotorCntMax; nAxis++)
                                {
                                    if (nAxis >= m_CHeader.nMotorCnt) nPos += 3;
                                    else if (nAxis >= SMotion.nMotorCnt) SMotion.STable[j].anMot[nAxis] = 0;// 실 모터수량과 맞지 않다면 그 부분을 0 으로 채울 것
                                    else
                                    {
                                        nData = (int)(BitConverter.ToInt16(byteData, nPos)); nPos += 2;
                                        sData = (short)(nData & 0x3fff);
                                        if ((nData & 0x4000) != 0) sData -= 0x1000;
                                        // 엔코더 타입((0x8000) != 0)
                                        
                                        ///////////////////////////
                                        // Reserve(2), Noaction(1), LED(3-Red Blue Green), Mode(1), Stop Bit(1)
                                        int byteTmp = byteData[nPos++];
                                        ///////////////////////////

                                        //Grid_SetFlag_Led(j, nAxis, ((nData >> 12) & 0x07));
                                        //Grid_SetFlag_Type(j, nAxis, (((nData & 0x8000) != 0) ? true : false));
                                        //Grid_SetFlag_En(j, nAxis, ((sData == 0x7ff) ? false : true));

                                        if (sData == 0x7ff)
                                        {
                                            SMotion.STable[j].anMot[nAxis] = 0;
                                        }
                                        else
                                        {
                                            SMotion.STable[j].anMot[nAxis] = (int)sData;// CalcEvd2Angle(nAxis, (int)sData);
                                        }



                                        /* - Save
                                        fValue = GridMotionEditor_GetMotor(i, j);
                                        sData = (short)(OjwMotor.CalcAngle2Evd(j, fValue) & 0x03ff);
                                        //sData |= 0x0400; // 속도모드인때 정(0-0x0000), 역(1-0x0400)
                                        //sData |= LED;  // 00 - 0ff, 0x0800 - Red(01), 0x1000 - Blue(10), 0x1800 - Green(11)
                                        //sData |= 제어타입 // 0 - 위치, 0x2000 - 속도
                                        sData |= 0x4000; //Enable // 개별 Enable (0 - Disable, 0x4000 - Enable)
                                         */
                                    }
                                }
                                #endregion Motor
                                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                #region Speed(2), Delay(2), Group(1), Command(1), Data0(2), Data1(2)
                                // Speed  
                                SMotion.STable[j].nTime = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;

                                // Delay  
                                SMotion.STable[j].nDelay = BitConverter.ToInt16(byteData, nPos); nPos += 2;

                                // Group  
                                SMotion.STable[j].nGroup = (int)(byteData[nPos++]);

                                // Command  
                                SMotion.STable[j].nCmd = (int)(byteData[nPos++]);

                                // Data0  
                                SMotion.STable[j].nData0 = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                                // Data1  
                                SMotion.STable[j].nData1 = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                                SMotion.STable[j].nData2 = 0;
                                SMotion.STable[j].nData3 = 0;
                                SMotion.STable[j].nData4 = 0;
                                SMotion.STable[j].nData5 = 0;
                                #endregion Speed(2), Delay(2), Group(1), Command(1), Data0(2), Data1(2)
                                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                #region 추가한 Frame 위치 및 자세
                                nPos += 24;
                                //nPos += 4;
                                //nPos += 4;
                                //nPos += 4;

                                //nPos += 4;
                                //nPos += 4;
                                //nPos += 4;
                                #endregion 추가한 Frame 위치 및 자세
                            }
                            #endregion 실제 모션
#if true
                            string strData_ME = "";
                            string strData_FE = "";

                            // 'M' 'E'
                            strData_ME += (char)(byteData[nPos++]);
                            strData_ME += (char)(byteData[nPos++]);

                            #region Comment Data
                            // Comment
                            byte[] pstrComment = new byte[SMotion.nCommentSize];
                            for (j = 0; j < SMotion.nCommentSize; j++)
                                pstrComment[j] = (byte)(byteData[nPos++]);
                            m_strMotionFile_Comment = System.Text.Encoding.Default.GetString(pstrComment);
                            SMotion.strComment = m_strMotionFile_Comment;
                            pstrComment = null;
                            #endregion Comment Data

                            #region Caption
                            int nLineNum = 0;
                            string strLineComment;
                            byte[] byLine = new byte[46];
                            for (j = 0; j < SMotion.nCnt_LineComment; j++)
                            {
                                nLineNum = (short)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                                for (int k = 0; k < 46; k++)
                                    byLine[k] = (byte)(byteData[nPos++]);
                                strLineComment = System.Text.Encoding.Default.GetString(byLine);
                                strLineComment = strLineComment.Trim((char)0);
                                m_CGridMotionEditor.SetCaption(nLineNum, strLineComment);
                            }
                            byLine = null;
                            #endregion Caption

                            // 'T' 'E'
                            strData_FE += (char)(byteData[nPos++]);
                            strData_FE += (char)(byteData[nPos++]);
#endif

                            //                     if (bMessage == true)
                            //                     {
                            //                         if (strData_ME != "ME") OjwMessage("Motion Table Error\r\n");
                            //                         else OjwMessage("Table Loaded");
                            //                         if (strData_FE != "TE") OjwMessage("File Error\r\n");
                            //                         else OjwMessage("Table Loaded");
                            //                     }

                            pbyteMotorIndex = null;
                            pbyteMirrorIndex = null;
                            bFileOpened = true;
                            #endregion FileOpen V1.0
                        }
                        ////////////////////////////////////////////////////////////////////////////

                        if (bFileOpened == true)
                        {
                            #region Comment Data
                            // Comment
                            byte[] pstrComment = new byte[SMotion.nCommentSize];
                            for (j = 0; j < SMotion.nCommentSize; j++)
                                pstrComment[j] = (byte)(byteData[nPos++]);
                            m_strMotionFile_Comment = System.Text.Encoding.Default.GetString(pstrComment);
                            pstrComment = null;
                            #endregion Comment Data

                            return true;
                        }
                        return false;
                    }
                    catch
                    {
                        this.Cursor = System.Windows.Forms.Cursors.Default;
                        //if (bFile == true)
                        //{
                        //    fs.Close();
                        //    f = null;
                        //}
                        return false;
                    }
                }
                public bool RmtFileOpen(String strFileName)
                {
                    //ojw5014_v11
                    this.Cursor = System.Windows.Forms.Cursors.WaitCursor;
                    //int i, j;

                    //SMotionTable_t SMotion = new SMotionTable_t();

                    // 캡션 클리어
                    
                    for (int i = 0; i < m_CGridMotionEditor.GetLineCount(); i++)
                        if (m_CGridMotionEditor.GetCaption(i) != "") m_CGridMotionEditor.SetCaption(i, "");

                    //bool bFileOpened = false;

                    FileInfo f = new FileInfo(strFileName);
                    StreamReader fs = f.OpenText();
                    try
                    {



                        //RichTextBox rtxtFile = new RichTextBox();
                                                
                        //rtxtFile.LoadFile(strFileName);

                        int nFrameSize = 0, nCnt_LineComment, nPlayTime, nCommentSize, nRobotModelNum, nMotorCnt;
                        int nLine = 0;
                        int nGroup = 1;
                        bool bMatchError_ID = false;
                        //foreach (string strLine in rtxtFile.Lines)
                        String strLine;
                        while(String.IsNullOrEmpty(strLine = fs.ReadLine()) == false)
                        {
                            string[] pstrItems = Ojw.CConvert.RemoveCaption(strLine, false, true).Split('=');
                            int i = 0;
                            int nCmd = -1;
                            foreach (string strItem in pstrItems)
                            {
                                if (i == 0)
                                {
                                    string strData = Ojw.CConvert.RemoveChar(strItem.Trim().ToLower(), ' ');
                                    switch (strData)
                                    {
                                        case "filetype": nCmd = 0; break;
                                        case "herkulex": nCmd = 1; break;
                                        case "totalmotors": nCmd = 2; break;
                                        case "parameter1": nCmd = 3; break;
                                        case "parameter2": nCmd = 4; break;
                                        case "parameter3": nCmd = 5; break;
                                        case "parameter4": nCmd = 6; break;
                                        case "motorlist": nCmd = 7; break;
                                        case "locationx": nCmd = 8; break;
                                        case "locationy": nCmd = 9; break;
                                        case "start": nCmd = 10; break;
                                        case "motionbegin": nCmd = 11; nGroup = nGroup % 3 + 1; break;
                                        case "name": nCmd = 12; break;
                                        case "count": nCmd = 13; break;
                                        case "step":
                                            {
                                                nCmd = 14;
                                                //nLine = 0;
                                            }
                                            break;
                                        case "time": nCmd = 15; break;
                                        case "motionend": nCmd = 16; break;
                                    }
                                }
                                else
                                {
                                    //m_strMotionFile_TableName
                                    //m_nMotionFile_StartPosition
                                    switch (nCmd)
                                    {
                                        case 2: // Motor Count
                                            {
                                                //m_strMotionFile_TableName = strItem;
                                                nMotorCnt = Ojw.CConvert.StrToInt(strItem);



                                                #region Header 검증
                                                if (nMotorCnt != m_CHeader.nMotorCnt)
                                                {
                                                    this.Cursor = System.Windows.Forms.Cursors.Default;
                                                    MessageBox.Show("Motor quantity error.(Motors in 3D Modeling =" + Ojw.CConvert.IntToStr(m_CHeader.nMotorCnt) + ", Motors in File =" + Ojw.CConvert.IntToStr(nMotorCnt) + ")\n");// 해당 모델에 맞는 모션을 로드하십시오.");
                                                    DialogResult dlgRet = MessageBox.Show("Do you want to continue?", "File Open", MessageBoxButtons.OKCancel, MessageBoxIcon.Warning);
                                                    if (dlgRet == DialogResult.OK)
                                                    {
                                                    }
                                                    else return false;
                                                }
                                                #endregion Header 검증

                                            }
                                            break;
                                        case 7: // motor list
                                            {
                                                string[] pstrDatas = strItem.Split(',');
                                                //SMotion.nTime = Ojw.CConvert.StrToInt(pstrDatas[0]);
                                                //SMotion.nDelay = Ojw.CConvert.StrToInt(pstrDatas[1]);
                                                bool bChange = false;
                                                for (int k = 0; k < pstrDatas.Length; k++)
                                                {
                                                    SParam_Axis_t SParam = m_CMotor.GetParam_Axis(k);
                                                    int nID = Ojw.CConvert.StrToInt(pstrDatas[k]);
                                                    if ((bMatchError_ID == false) || (bChange == true))
                                                    {
                                                        bMatchError_ID = true;
                                                        if (SParam.nID != nID)
                                                        {
                                                            DialogResult dlgRet = MessageBox.Show("We found a mismatch point with ID from here. Do you want it to Change?.\r\n\r\nIs it Ok?", "ID Mismatch", MessageBoxButtons.OKCancel, MessageBoxIcon.Warning);
                                                            if (dlgRet == DialogResult.OK)
                                                            {
                                                                bChange = true;

                                                                SParam.nID = nID;
                                                                m_CMotor.SetParam_Axis(k, SParam);
                                                                m_CMotor2.SetParam_RealID(k, SParam.nID);
                                                                //m_CMotor.SetPa
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            break;
                                        case 12: // Name - Caption
                                            {
                                                //SMotion.strCaption = strItem;
                                                m_CGridMotionEditor.SetCaption(nLine, strItem);
                                                m_CGridMotionEditor.SetEnable(nLine, false);
                                                nLine++;
                                            }
                                            break;
                                        case 13: // Count - Frame Count
                                            {
                                                nFrameSize += Ojw.CConvert.StrToInt(strItem);
                                            }
                                            break;
                                        case 14: // Step - Frame
                                            {
                                                string[] pstrDatas = strItem.Split(',');
                                                
                                                m_CGridMotionEditor.SetEnable(nLine, true);

                                                int nTime = Ojw.CConvert.StrToInt(pstrDatas[0]);
                                                int nDelay = Ojw.CConvert.StrToInt(pstrDatas[1]) - nTime;
                                                m_CGridMotionEditor.SetTime(nLine, nTime);
                                                m_CGridMotionEditor.SetDelay(nLine, nDelay);

                                                for (int k = 2; k < pstrDatas.Length - 1; k++)
                                                {
                                                    m_CGridMotionEditor.SetData(nLine, k - 2, m_CMotor.CalcEvd2Angle(k - 2, Ojw.CConvert.StrToInt(pstrDatas[k])));

                                                }
                                                string strCaption = Ojw.CConvert.RemoveChar(pstrDatas[pstrDatas.Length - 1], '(');
                                                strCaption = Ojw.CConvert.RemoveChar(strCaption, ')');
                                                strCaption = Ojw.CConvert.RemoveChar(strCaption, '\t');
                                                strCaption = Ojw.CConvert.RemoveChar(strCaption, '\r');
                                                strCaption = Ojw.CConvert.RemoveChar(strCaption, '\n');
                                                m_CGridMotionEditor.SetCaption(nLine, strCaption);
                                                m_CGridMotionEditor.SetGroup(nLine, nGroup);
                                                nLine++;
                                            }
                                            break;
                                    }
                                }
                                i++;
                            }
                        }

                        fs.Close();

                        //for (int i = nFrameSize; i < m_CGridMotionEditor.GetLineCount() - nFrameSize; i++) m_CGridMotionEditor.Clear(i);

                        CheckFlag(0);
                        m_CGridMotionEditor.SetColorGrid(0, nLine);//nFrameSize);

                        this.Cursor = System.Windows.Forms.Cursors.Default;
                    }
                    catch (Exception ex)
                    {
                        fs.Close();
                        Ojw.CMessage.Write_Error(ex.ToString());
                        this.Cursor = System.Windows.Forms.Cursors.Default;                     
                    }
                    return true;
                }
                private bool m_bDynamixel = false;
                public void SetDynamixel(bool bDynamixel)
                {                    
                    m_bDynamixel = bDynamixel;
                }
                public bool DataFileOpen(String strFileName, byte[] byteArrayData)
                {
                    return DataFileOpen(false, strFileName, byteArrayData);
                }
                public bool DataFileOpen(bool bSavedAngle, String strFileName, byte[] byteArrayData)//, bool bMessage)//, bool bTableOut)
                {
                    //ojw5014_v11
                    this.Cursor = System.Windows.Forms.Cursors.WaitCursor;

                    // 캡션 클리어
                    for (int i = 0; i < m_CGridMotionEditor.GetLineCount(); i++)
                        if (m_CGridMotionEditor.GetCaption(i) != "") m_CGridMotionEditor.SetCaption(i, "");
                    
                    bool bFile = false;

                    if (byteArrayData == null) bFile = true;
                    else bFile = false;

                    bool bFileOpened = false;
                    String _STR_EXT = "dmt";
                    String _STR_VER_V_12 = "1.2";
                    String _STR_VER_V_11 = "1.1";
                    String _STR_VER_V_10 = "1.0";

                    FileInfo f = null;
                    FileStream fs = null;

                    try
                    {
                        int i, j;
                        byte[] byteData;
                        string strFileName2 = "";
                        if (bFile == true)
                        {
                            f = new FileInfo(strFileName);
                            fs = f.OpenRead();
                            byteData = new byte[fs.Length];
                            fs.Read(byteData, 0, byteData.Length);
                            strFileName2 = f.Name;
                            
                            fs.Close();
                            f = null;
                        }
                        else
                        {
                            if (byteArrayData.Length <= 6)
                            {
                                //OjwMessage("FileSize Error(Size[" + byteArrayData.Length.ToString() + "] <= 6)");
                                return false;
                            }
                            byteData = new byte[byteArrayData.Length];
                            byteData = byteArrayData;
                            strFileName2 = strFileName;
                        }

                        // 데이타 형식 구분
                        String strTmp = "";
                        strTmp += (char)byteData[0];
                        strTmp += (char)byteData[1];
                        strTmp += (char)byteData[2];
                        strTmp += (char)byteData[3];
                        strTmp += (char)byteData[4];
                        strTmp += (char)byteData[5];

                        //lbTitle.Text = m_strTitle + "[" + strTmp + "]" + strFileName;
                        m_strMotionFile_FileName = strFileName;

                        m_strMotionFile_TableName = "";

                        if (strTmp.ToUpper() == _STR_EXT.ToUpper() + _STR_VER_V_10)
                        {
                            //chkFileVersionForSave_1_0.Checked = true;
                            //chkFileVersionForSave.Checked = false;
                            #region FileOpen V1.0
                            //if (bMessage == true) OjwMessage("[" + _STR_EXT.ToUpper() + _STR_VER.ToUpper() + " Binary File Data(" + strTmp + ")]");
                            int nPos = 6;   // 앞의 6개는 'DMT1.0' 에 할당

                            #region Header

                            #region 타이틀(21)
                            byte[] byteGetData = new byte[21];
                            for (i = 0; i < 21; i++) byteGetData[i] = 0;
                            for (i = 0; i < 21; i++)
                            {
                                if (byteData[i + nPos] == 0) break;
                                byteGetData[i] = byteData[i + nPos];
                            }
                            m_strMotionFile_TableName = System.Text.Encoding.Default.GetString(byteGetData);
                            nPos += 21;
                            byteGetData = null;
                            #endregion 타이틀(21)

                            #region Start Position(1)
                            int nStartPosition = (int)(byteData[nPos++]);
                            nStartPosition = (nStartPosition >= 0) ? nStartPosition : 0;
                            m_nMotionFile_StartPosition = ((nStartPosition > 0) ? nStartPosition : 0);
                            #endregion Start Position(1)

                            #region Size - MotionFrame(2), Comment(2), Caption(2), PlayTime(4), RobotModelNumber(2), MotorCnt(1)
                            // Size
                            int nFrameSize, nCnt_LineComment, nPlayTime, nCommentSize, nRobotModelNum, nMotorCnt;
                            nFrameSize = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                            nCommentSize = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                            nCnt_LineComment = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                            nPlayTime = (int)(byteData[nPos] + byteData[nPos + 1] * 256 + byteData[nPos + 2] * 256 * 256 + byteData[nPos + 3] * 256 * 256 * 256); nPos += 4;
                            nRobotModelNum = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                            nMotorCnt = (int)(byteData[nPos++]);
                            #endregion Size - MotionFrame, Comment, Caption, PlayTime

                            #endregion Header

                            // nRobotModelNum 를 읽고 해당 파일을 읽어들인다.
                            #region Header 검증
                            if (nMotorCnt != m_CHeader.nMotorCnt)
                            {
                                //if (bFile == true)
                                //{
                                //    fs.Close();
                                //    f = null;
                                //}
                                this.Cursor = System.Windows.Forms.Cursors.Default;
                                //MessageBox.Show("디자이너 파일의 모터 수량과 맞지 않습니다.(요구모터수량=" + Ojw.CConvert.IntToStr(m_CHeader.nMotorCnt) + ", 모션파일에 정의된 모터수량=" + Ojw.CConvert.IntToStr(nMotorCnt) + ")\n");// 해당 모델에 맞는 모션을 로드하십시오.");
                                //DialogResult dlgRet = MessageBox.Show("무시하고 계속 열겠습니까?", "파일열기", MessageBoxButtons.OKCancel, MessageBoxIcon.Warning);
                                MessageBox.Show("Motor quantity error.(Motors in 3D Modeling =" + Ojw.CConvert.IntToStr(m_CHeader.nMotorCnt) + ", Motors in File =" + Ojw.CConvert.IntToStr(nMotorCnt) + ")\n");// 해당 모델에 맞는 모션을 로드하십시오.");
                                DialogResult dlgRet = MessageBox.Show("Do you want to continue?", "File Open", MessageBoxButtons.OKCancel, MessageBoxIcon.Warning);
                                if (dlgRet == DialogResult.OK)
                                {
                                    //MessageBox.Show("Yes");
                                    //return;
                                }
                                else return false;
                            }
                            #endregion Header 검증

                            //Grid_ChangePos(dgAngle, 0, 0);
                            //Grid_ChangePos(dgKinematics, 0, 0);
                            //GridInit(nMotorCnt, nFrameSize, false);// + 50);
                            //GridInit(nMotorCnt, _SIZE_FRAME, false);

                            for (i = nFrameSize; i < m_CGridMotionEditor.GetLineCount() - nFrameSize; i++) m_CGridMotionEditor.Clear(i);

                            #region 실제 모션
                            int nH = nFrameSize;
                            int nData;
                            short sData;
                            float fValue;
                            for (j = 0; j < nH; j++)
                            {
                                //En
                                #region Enable
                                int nEn = byteData[nPos++];
                                bool bEn = ((nEn & 0x01) != 0) ? true : false;
                                m_CGridMotionEditor.SetEnable(j, bEn);
                                #endregion Enable
                                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                #region Motor
                                int nMotorCntMax = (int)Math.Max(nMotorCnt, m_CHeader.nMotorCnt);
                                // 0-Index, 1-En, 2 ~ 24, 25 - speed, 26 - delay, 27,28,29,30 - Data0-3, 31 - time, 32 - caption
                                for (int nAxis = 0; nAxis < nMotorCntMax; nAxis++)
                                {
                                    if (nAxis >= m_CHeader.nMotorCnt) nPos += 2;
                                    else if (nAxis >= nMotorCnt) m_CGridMotionEditor.SetData(j, nAxis, 0.0f);// 실 모터수량과 맞지 않다면 그 부분을 0 으로 채울 것
                                    else
                                    {
                                        nData = (int)(BitConverter.ToInt16(byteData, nPos)); nPos += 2;
                                        if (m_bDynamixel == true)
                                        {
                                            //sData = (short)(nData & 0x0fff);
                                            //if ((sData & 0x800) != 0) sData -= 0x1000;

                                            //Grid_SetFlag_Led(j, nAxis, ((nData >> 12) & 0x07));
                                            //Grid_SetFlag_Type(j, nAxis, (((nData & 0x8000) != 0) ? true : false));
                                            //Grid_SetFlag_En(j, nAxis, ((sData == 0x7ff) ? false : true));

                                            if (bSavedAngle)
                                            {
                                                // 2 바이트 연산이라 float 을 표현하기는 어려우니 100 채배를 한 각도값을 사용
                                                fValue = (float)(nData / 100);
                                                fValue *= ((m_CHeader.pSMotorInfo[j].nMotorDir == 0) ? 1.0f : -1.0f);
                                            }
                                            else
                                                fValue = (float)Math.Round(CalcEvd2Angle(nAxis, nData), 1);
                                            //m_CGridMotionEditor.SetData(j, nAxis, fValue);
                                            GridMotionEditor_SetMotor(j, nAxis, fValue);
                                        }
                                        else
                                        {
                                            sData = (short)(nData & 0x0fff);
                                            if ((sData & 0x800) != 0) sData -= 0x1000;

                                            Grid_SetFlag_Led(j, nAxis, ((nData >> 12) & 0x07));
                                            Grid_SetFlag_Type(j, nAxis, (((nData & 0x8000) != 0) ? true : false));
                                            Grid_SetFlag_En(j, nAxis, ((sData == 0x7ff) ? false : true));

                                            if (sData == 0x7ff)
                                            {
                                                //m_CGridMotionEditor.SetData(j, nAxis, 0);
                                                GridMotionEditor_SetMotor(j, nAxis, 0);
                                            }
                                            else
                                            {
                                                fValue = (float)Math.Round(CalcEvd2Angle(nAxis, (int)sData), 1);
                                                //m_CGridMotionEditor.SetData(j, nAxis, fValue);
                                                GridMotionEditor_SetMotor(j, nAxis, fValue);
                                            }
                                        }


                                        /* - Save
                                        fValue = GridMotionEditor_GetMotor(i, j);
                                        sData = (short)(OjwMotor.CalcAngle2Evd(j, fValue) & 0x03ff);
                                        //sData |= 0x0400; // 속도모드인때 정(0-0x0000), 역(1-0x0400)
                                        //sData |= LED;  // 00 - 0ff, 0x0800 - Red(01), 0x1000 - Blue(10), 0x1800 - Green(11)
                                        //sData |= 제어타입 // 0 - 위치, 0x2000 - 속도
                                        sData |= 0x4000; //Enable // 개별 Enable (0 - Disable, 0x4000 - Enable)
                                         */
                                    }
                                }
                                #endregion Motor
                                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                #region Speed(2), Delay(2), Group(1), Command(1), Data0(2), Data1(2)
                                // Speed  
                                nData = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                                //m_CGridMotionEditor.SetSpeed(j, nData);
                                GridMotionEditor_SetTime(j, nData);

                                // Delay  
                                nData = BitConverter.ToInt16(byteData, nPos); nPos += 2;
                                //m_CGridMotionEditor.SetDelay(j, nData);
                                GridMotionEditor_SetDelay(j, nData);

                                // Group  
                                nData = (int)(byteData[nPos++]);
                                //m_CGridMotionEditor.SetGroup(j, nData);
                                GridMotionEditor_SetGroup(j, nData);

                                // Command  
                                nData = (int)(byteData[nPos++]);
                                GridMotionEditor_SetCommand(j, nData);// m_CGridMotionEditor.SetData2(j, nData);//SetCommand(j, nData);
                                

                                // Data0  
                                nData = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                                //m_CGridMotionEditor.SetData0(j, nData);
                                //GridMotionEditor_SetData3(j, nData);
                                GridMotionEditor_SetData0(j, nData);
                                // Data1  
                                nData = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                                //Grid_SetData1(j, nData);
                                //GridMotionEditor_SetData4(j, nData);
                                GridMotionEditor_SetData1(j, nData);
                                #endregion Speed(2), Delay(2), Group(1), Command(1), Data0(2), Data1(2)
                                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                #region 추가한 Frame 위치 및 자세
                                nPos += 4;//SetFrame_X(j, (float)BitConverter.ToSingle(byteData, nPos)); nPos += 4;
                                nPos += 4;//SetFrame_Y(j, (float)BitConverter.ToSingle(byteData, nPos)); nPos += 4;
                                nPos += 4;//SetFrame_Z(j, (float)BitConverter.ToSingle(byteData, nPos)); nPos += 4;

                                nPos += 4;//SetFrame_Pan(j, (float)BitConverter.ToSingle(byteData, nPos)); nPos += 4;
                                nPos += 4;//SetFrame_Tilt(j, (float)BitConverter.ToSingle(byteData, nPos)); nPos += 4;
                                nPos += 4;//SetFrame_Swing(j, (float)BitConverter.ToSingle(byteData, nPos)); nPos += 4;
                                #endregion 추가한 Frame 위치 및 자세
                            }
                            #endregion 실제 모션

#if !_COLOR_GRID_IN_PAINT
                            m_CGridMotionEditor.SetColorGrid(0, nFrameSize);
                            //Grid_SetColorGrid(0, nFrameSize);
#endif
                            string strData_ME = "";
                            string strData_FE = "";

                            // 'M' 'E'
                            strData_ME += (char)(byteData[nPos++]);
                            strData_ME += (char)(byteData[nPos++]);

                            #region Comment Data
                            // Comment
                            byte[] pstrComment = new byte[nCommentSize];
                            for (j = 0; j < nCommentSize; j++)
                                pstrComment[j] = (byte)(byteData[nPos++]);
                            m_strMotionFile_Comment = System.Text.Encoding.Default.GetString(pstrComment);
                            pstrComment = null;
                            #endregion Comment Data

                            #region Caption
                            int nLineNum = 0;
                            string strLineComment;
                            byte[] byLine = new byte[46];
                            for (j = 0; j < nCnt_LineComment; j++)
                            {
                                nLineNum = (short)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                                for (int k = 0; k < 46; k++)
                                    byLine[k] = (byte)(byteData[nPos++]);
                                strLineComment = System.Text.Encoding.Default.GetString(byLine);
                                strLineComment = strLineComment.Trim((char)0);
                                m_CGridMotionEditor.SetCaption(nLineNum, strLineComment);
                            }
                            byLine = null;
                            #endregion Caption

                            // 'T' 'E'
                            strData_FE += (char)(byteData[nPos++]);
                            strData_FE += (char)(byteData[nPos++]);

                            //                     if (bMessage == true)
                            //                     {
                            //                         if (strData_ME != "ME") OjwMessage("Motion Table Error\r\n");
                            //                         else OjwMessage("Table Loaded");
                            //                         if (strData_FE != "TE") OjwMessage("File Error\r\n");
                            //                         else OjwMessage("Table Loaded");
                            //                     }

                            bFileOpened = true;
                            #endregion FileOpen V1.0
                        }
                        else if (strTmp.ToUpper() == _STR_EXT.ToUpper() + _STR_VER_V_11)
                        {
                            //chkFileVersionForSave_1_0.Checked = false;
                            //chkFileVersionForSave.Checked = true;
                            #region FileOpen V1.1
                            //if (bMessage == true) OjwMessage("[" + _STR_EXT.ToUpper() + _STR_VER.ToUpper() + " Binary File Data(" + strTmp + ")]");
                            int nPos = 6;   // 앞의 6개는 'DMT1.0' 에 할당

                            #region Header

                            #region 타이틀(21)
                            byte[] byteGetData = new byte[21];
                            for (i = 0; i < 21; i++) byteGetData[i] = 0;
                            for (i = 0; i < 21; i++)
                            {
                                if (byteData[i + nPos] == 0) break;
                                byteGetData[i] = byteData[i + nPos];
                            }
                            m_strMotionFile_TableName = System.Text.Encoding.Default.GetString(byteGetData);
                            nPos += 21;
                            byteGetData = null;
                            #endregion 타이틀(21)

                            #region Start Position(1)
                            int nStartPosition = (int)(byteData[nPos++]);
                            nStartPosition = (nStartPosition >= 0) ? nStartPosition : 0;
                            m_nMotionFile_StartPosition = ((nStartPosition > 0) ? nStartPosition : 0);
                            #endregion Start Position(1)

                            #region Size - MotionFrame(2), Comment(2), Caption(2), PlayTime(4), RobotModelNumber(2), MotorCnt(1)
                            // Size
                            int nFrameSize, nCnt_LineComment, nPlayTime, nCommentSize, nRobotModelNum, nMotorCnt;
                            nFrameSize = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                            nCommentSize = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                            nCnt_LineComment = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                            nPlayTime = (int)(byteData[nPos] + byteData[nPos + 1] * 256 + byteData[nPos + 2] * 256 * 256 + byteData[nPos + 3] * 256 * 256 * 256); nPos += 4;
                            nRobotModelNum = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                            nMotorCnt = (int)(byteData[nPos++]);
                            #endregion Size - MotionFrame, Comment, Caption, PlayTime

                            #endregion Header

                            // nRobotModelNum 를 읽고 해당 파일을 읽어들인다.
                            #region Header 검증
                            if (nMotorCnt != m_CHeader.nMotorCnt)
                            {
                                //if (bFile == true)
                                //{
                                //    fs.Close();
                                //    f = null;
                                //}
                                this.Cursor = System.Windows.Forms.Cursors.Default;
                                MessageBox.Show("디자이너 파일의 모터 수량과 맞지 않습니다.(요구모터수량=" + Ojw.CConvert.IntToStr(m_CHeader.nMotorCnt) + ", 모션파일에 정의된 모터수량=" + Ojw.CConvert.IntToStr(nMotorCnt) + ")\n");// 해당 모델에 맞는 모션을 로드하십시오.");
                                DialogResult dlgRet = MessageBox.Show("무시하고 계속 열겠습니까?", "파일열기", MessageBoxButtons.OKCancel, MessageBoxIcon.Warning);
                                if (dlgRet == DialogResult.OK)
                                {
                                    //MessageBox.Show("Yes");
                                    //return;
                                }
                                else return false;
                            }
                            #endregion Header 검증

                            //Grid_ChangePos(dgAngle, 0, 0);
                            //Grid_ChangePos(dgKinematics, 0, 0);
                            //GridInit(nMotorCnt, nFrameSize, false);// + 50);
                            //GridInit(nMotorCnt, _SIZE_FRAME, false);

                            for (i = nFrameSize; i < m_CGridMotionEditor.GetLineCount() - nFrameSize; i++) m_CGridMotionEditor.Clear(i);

                            #region 실제 모션
                            int nH = nFrameSize;
                            int nData, nData2;
                            //short sData;
                            float fValue;
                            for (j = 0; j < nH; j++)
                            {
                                //En
                                #region Enable
                                int nEn = byteData[nPos++];
                                bool bEn = ((nEn & 0x01) != 0) ? true : false;
                                m_CGridMotionEditor.SetEnable(j, bEn);
                                #endregion Enable
                                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                #region Motor
                                int nMotorCntMax = (int)Math.Max(nMotorCnt, m_CHeader.nMotorCnt);
                                // 0-Index, 1-En, 2 ~ 24, 25 - speed, 26 - delay, 27,28,29,30 - Data0-3, 31 - time, 32 - caption
                                for (int nAxis = 0; nAxis < nMotorCntMax; nAxis++)
                                {
                                    if (nAxis >= m_CHeader.nMotorCnt) nPos += 3;
                                    else if (nAxis >= nMotorCnt) m_CGridMotionEditor.SetData(j, nAxis, 0.0f);// 실 모터수량과 맞지 않다면 그 부분을 0 으로 채울 것
                                    else
                                    {
                                        nData = byteData[nPos++];
                                        nData += byteData[nPos++] * 256;
                                        nData += byteData[nPos++] * 256 * 256;
                                        //nData = (int)(BitConverter.ToInt(byteData, nPos)); nPos += 3;
                                        //sData = (short)(nData & 0x0fff);
                                        nData2 = nData & 0x3fff;
                                        if ((nData & 0x4000) != 0) nData2 *= -1; // 부호비트 검사

                                        // 엔코더 타입정의
                                        // 일단 넘어간다.

                                        // Stop Bit
                                        // 넘어간다.

                                        // Mode
#if false
                                        //Grid_SetFlag_Type(j, nAxis, (((nData & 0x20000) != 0) ? true : false));

                                        //Grid_SetFlag_Led(j, nAxis, ((nData >> 18) & 0x07));
                                        //Grid_SetFlag_En(j, nAxis, ((nData == 0x200000) ? false : true));

                                        if (m_CGridMotionEditor.GetEnable(j, nAxis) == false)
                                        {
                                            m_CGridMotionEditor.SetData(j, nAxis, 0);
                                        }
                                        else
#endif
                                        {
                                            fValue = (float)Math.Round(CalcEvd2Angle(nAxis, (int)nData2), 1);
                                            m_CGridMotionEditor.SetData(j, nAxis, fValue);
                                        }



                                        /* - Save
                                        fValue = GridMotionEditor_GetMotor(i, j);
                                        sData = (short)(OjwMotor.CalcAngle2Evd(j, fValue) & 0x03ff);
                                        //sData |= 0x0400; // 속도모드인때 정(0-0x0000), 역(1-0x0400)
                                        //sData |= LED;  // 00 - 0ff, 0x0800 - Red(01), 0x1000 - Blue(10), 0x1800 - Green(11)
                                        //sData |= 제어타입 // 0 - 위치, 0x2000 - 속도
                                        sData |= 0x4000; //Enable // 개별 Enable (0 - Disable, 0x4000 - Enable)
                                         */


                                        //fValue = GridMotionEditor_GetMotor(i, j);
                                        //nData = (int)(((Grid_GetFlag_En(i, j) == true) ? CalcAngle2Evd(j, fValue) : 0x07ff) & 0x0fff);

                                        //nData |= (int)(((j >= 6) && (j <= 8)) ? 0x8000 : 0x0000);
                                        //nData |= (int)((Grid_GetFlag_Type(i, j) == true) ? 0x20000 : 0x0000); // 제어타입 // 0 - 위치, 0x20000 - 속도

                                        //nData |= (int)((Grid_GetFlag_Led(i, j) & 0x07) << 18);
                                        //nData |= (int)((Grid_GetFlag_Type(i, j) == true) ? 0x8000 : 0x0000);
                                        //nData |= (int)((Grid_GetFlag_En(i, j) == false) ? 0x200000 : 0x00000);

                                        ////byteData = BitConverter.GetBytes((Int32)nData);
                                        ////fs.Write(byteData, 0, 3);
                                    }
                                }
                                #endregion Motor
                                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                #region Speed(2), Delay(2), Group(1), Command(1), Data0(2), Data1(2)
                                // Speed  
                                nData = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                                GridMotionEditor_SetTime(j, nData);

                                // Delay  
                                nData = BitConverter.ToInt16(byteData, nPos); nPos += 2;
                                GridMotionEditor_SetDelay(j, nData);

                                // Group  
                                nData = (int)(byteData[nPos++]);
                                GridMotionEditor_SetGroup(j, nData);

                                // Command  
                                nData = (int)(byteData[nPos++]);
                                GridMotionEditor_SetCommand(j, nData);

                                // Data0  
                                nData = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                                GridMotionEditor_SetData0(j, nData);
                                // Data1  
                                nData = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                                GridMotionEditor_SetData1(j, nData);
                                #endregion Speed(2), Delay(2), Group(1), Command(1), Data0(2), Data1(2)
                                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                #region 추가한 Frame 위치 및 자세
                                nPos += 4;//SetFrame_X(j, (float)BitConverter.ToSingle(byteData, nPos)); nPos += 4;
                                nPos += 4;//SetFrame_Y(j, (float)BitConverter.ToSingle(byteData, nPos)); nPos += 4;
                                nPos += 4;//SetFrame_Z(j, (float)BitConverter.ToSingle(byteData, nPos)); nPos += 4;

                                nPos += 4;//SetFrame_Pan(j, (float)BitConverter.ToSingle(byteData, nPos)); nPos += 4;
                                nPos += 4;//SetFrame_Tilt(j, (float)BitConverter.ToSingle(byteData, nPos)); nPos += 4;
                                nPos += 4;//SetFrame_Swing(j, (float)BitConverter.ToSingle(byteData, nPos)); nPos += 4;
                                #endregion 추가한 Frame 위치 및 자세
                            }
                            #endregion 실제 모션

#if !_COLOR_GRID_IN_PAINT
                            m_CGridMotionEditor.SetColorGrid(0, nFrameSize);
#endif

                            string strData_ME = "";
                            string strData_FE = "";

                            // 'M' 'E'
                            strData_ME += (char)(byteData[nPos++]);
                            strData_ME += (char)(byteData[nPos++]);

                            #region Comment Data
                            // Comment
                            byte[] pstrComment = new byte[nCommentSize];
                            for (j = 0; j < nCommentSize; j++)
                                pstrComment[j] = (byte)(byteData[nPos++]);
                            m_strMotionFile_Comment = System.Text.Encoding.Default.GetString(pstrComment);
                            pstrComment = null;
                            #endregion Comment Data

                            #region Caption
                            int nLineNum = 0;
                            string strLineComment;
                            byte[] byLine = new byte[46];
                            for (j = 0; j < nCnt_LineComment; j++)
                            {
                                nLineNum = (short)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                                for (int k = 0; k < 46; k++)
                                    byLine[k] = (byte)(byteData[nPos++]);
                                strLineComment = System.Text.Encoding.Default.GetString(byLine);
                                strLineComment = strLineComment.Trim((char)0);
                                m_CGridMotionEditor.SetCaption(nLineNum, strLineComment);
                            }
                            byLine = null;
                            #endregion Caption

                            // 'T' 'E'
                            strData_FE += (char)(byteData[nPos++]);
                            strData_FE += (char)(byteData[nPos++]);

                            //                     if (bMessage == true)
                            //                     {
                            //                         if (strData_ME != "ME") OjwMessage("Motion Table Error\r\n");
                            //                         else OjwMessage("Table Loaded");
                            //                         if (strData_FE != "TE") OjwMessage("File Error\r\n");
                            //                         else OjwMessage("Table Loaded");
                            //                     }

                            bFileOpened = true;
                            #endregion FileOpen V1.1
                        }
                        else if (strTmp.ToUpper() == _STR_EXT.ToUpper() + _STR_VER_V_12)
                        {
                            //chkFileVersionForSave_1_0.Checked = false;
                            //chkFileVersionForSave.Checked = false;
                            #region FileOpen V1.2
                            int nPos = 6;   // 앞의 6개는 'DMT1.2' 에 할당

                            #region Header

                            #region 타이틀(21)
                            byte[] byteGetData = new byte[21];
                            for (i = 0; i < 21; i++) byteGetData[i] = 0;
                            for (i = 0; i < 21; i++)
                            {
                                if (byteData[i + nPos] == 0) break;
                                byteGetData[i] = byteData[i + nPos];
                            }
                            m_strMotionFile_TableName = System.Text.Encoding.Default.GetString(byteGetData);
                            nPos += 21;
                            byteGetData = null;
                            #endregion 타이틀(21)

                            #region Start Position(1)
                            int nStartPosition = (int)(byteData[nPos++]);
                            nStartPosition = (nStartPosition >= 0) ? nStartPosition : 0;
                            m_nMotionFile_StartPosition = ((nStartPosition > 0) ? nStartPosition : 0);
                            #endregion Start Position(1)

                            #region Size - MotionFrame(2), Comment(2), Caption(2), PlayTime(4), RobotModelNumber(2), MotorCnt(1), Motor Index(MC), Mirror Index(MC)
                            // Size
                            int nFrameSize, nCnt_LineComment, nPlayTime, nCommentSize, nRobotModelNum, nMotorCnt;
                            nFrameSize = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                            nCommentSize = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                            nCnt_LineComment = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                            nPlayTime = (int)(byteData[nPos] + byteData[nPos + 1] * 256 + byteData[nPos + 2] * 256 * 256 + byteData[nPos + 3] * 256 * 256 * 256); nPos += 4;
                            nRobotModelNum = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                            nMotorCnt = (int)(byteData[nPos++]);

                            // 모터의 인덱스
                            byte[] pbyteMotorIndex = new byte[nMotorCnt];
                            for (int nIndex = 0; nIndex < nMotorCnt; nIndex++) pbyteMotorIndex[nIndex] = byteData[nPos++];

                            // 모터의 Mirror 인덱스
                            byte[] pbyteMirrorIndex = new byte[nMotorCnt];
                            for (int nIndex = 0; nIndex < nMotorCnt; nIndex++) pbyteMirrorIndex[nIndex] = byteData[nPos++];

                            #endregion Size - MotionFrame(2), Comment(2), Caption(2), PlayTime(4), RobotModelNumber(2), MotorCnt(1), Motor Index(MC), Mirror Index(MC)

                            #endregion Header

                            // nRobotModelNum 를 읽고 해당 파일을 읽어들인다.
                            #region Header 검증
                            if (nMotorCnt != m_CHeader.nMotorCnt)
                            {
                                //if (bFile == true)
                                //{
                                //    fs.Close();
                                //    f = null;
                                //}
                                this.Cursor = System.Windows.Forms.Cursors.Default;
                                MessageBox.Show("디자이너 파일의 모터 수량과 맞지 않습니다.(요구모터수량=" + Ojw.CConvert.IntToStr(m_CHeader.nMotorCnt) + ", 모션파일에 정의된 모터수량=" + Ojw.CConvert.IntToStr(nMotorCnt) + ")\n");// 해당 모델에 맞는 모션을 로드하십시오.");
                                DialogResult dlgRet = MessageBox.Show("무시하고 계속 열겠습니까?", "파일열기", MessageBoxButtons.OKCancel, MessageBoxIcon.Warning);
                                if (dlgRet == DialogResult.OK)
                                {
                                    //MessageBox.Show("Yes");
                                    //return;
                                }
                                else return false;
                            }
                            #endregion Header 검증

                            //Grid_ChangePos(dgAngle, 0, 0);
                            //Grid_ChangePos(dgKinematics, 0, 0);
                            //GridInit(nMotorCnt, nFrameSize, false);// + 50);
                            //GridInit(nMotorCnt, _SIZE_FRAME, false);

                            for (i = nFrameSize; i < m_CGridMotionEditor.GetLineCount() - nFrameSize; i++) m_CGridMotionEditor.Clear(i);

                            #region 실제 모션
                            int nH = nFrameSize;
                            int nData;
                            short sData;
                            float fValue;
                            for (j = 0; j < nH; j++)
                            {
                                //En
                                #region Enable
                                int nEn = byteData[nPos++];
                                bool bEn = ((nEn & 0x01) != 0) ? true : false;
                                m_CGridMotionEditor.SetEnable(j, bEn);
                                #endregion Enable
                                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                #region Motor
                                int nMotorCntMax = (int)Math.Max(nMotorCnt, m_CHeader.nMotorCnt);
                                // 0-Index, 1-En, 2 ~ 24, 25 - speed, 26 - delay, 27,28,29,30 - Data0-3, 31 - time, 32 - caption
                                for (int nAxis = 0; nAxis < nMotorCntMax; nAxis++)
                                {
                                    if (nAxis >= m_CHeader.nMotorCnt) nPos += 3;
                                    else if (nAxis >= nMotorCnt) m_CGridMotionEditor.SetData(j, nAxis, 0.0f);// 실 모터수량과 맞지 않다면 그 부분을 0 으로 채울 것
                                    else
                                    {
                                        nData = (int)(BitConverter.ToInt16(byteData, nPos)); nPos += 2;
                                        sData = (short)(nData & 0x3fff);
                                        if ((nData & 0x4000) != 0) sData -= 0x1000;
                                        // 엔코더 타입((0x8000) != 0)


                                        ///////////////////////////
                                        // Reserve(2), Noaction(1), LED(3-Red Blue Green), Mode(1), Stop Bit(1)
                                        int byteTmp = byteData[nPos++];


                                        ///////////////////////////












                                        //Grid_SetFlag_Led(j, nAxis, ((nData >> 12) & 0x07));
                                        //Grid_SetFlag_Type(j, nAxis, (((nData & 0x8000) != 0) ? true : false));
                                        //Grid_SetFlag_En(j, nAxis, ((sData == 0x7ff) ? false : true));

                                        if (sData == 0x7ff)
                                        {
                                            m_CGridMotionEditor.SetData(j, nAxis, 0);
                                        }
                                        else
                                        {
                                            fValue = (float)Math.Round(CalcEvd2Angle(nAxis, (int)sData), 1);
                                            m_CGridMotionEditor.SetData(j, nAxis, fValue);
                                        }



                                        /* - Save
                                        fValue = GridMotionEditor_GetMotor(i, j);
                                        sData = (short)(OjwMotor.CalcAngle2Evd(j, fValue) & 0x03ff);
                                        //sData |= 0x0400; // 속도모드인때 정(0-0x0000), 역(1-0x0400)
                                        //sData |= LED;  // 00 - 0ff, 0x0800 - Red(01), 0x1000 - Blue(10), 0x1800 - Green(11)
                                        //sData |= 제어타입 // 0 - 위치, 0x2000 - 속도
                                        sData |= 0x4000; //Enable // 개별 Enable (0 - Disable, 0x4000 - Enable)
                                         */
                                    }
                                }
                                #endregion Motor
                                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                #region Speed(2), Delay(2), Group(1), Command(1), Data0(2), Data1(2)
                                // Speed  
                                nData = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                                GridMotionEditor_SetTime(j, nData);

                                // Delay  
                                nData = BitConverter.ToInt16(byteData, nPos); nPos += 2;
                                GridMotionEditor_SetDelay(j, nData);

                                // Group  
                                nData = (int)(byteData[nPos++]);
                                GridMotionEditor_SetGroup(j, nData);

                                // Command  
                                nData = (int)(byteData[nPos++]);
                                GridMotionEditor_SetCommand(j, nData);

                                // Data0  
                                nData = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                                GridMotionEditor_SetData0(j, nData);
                                // Data1  
                                nData = (int)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                                GridMotionEditor_SetData1(j, nData);
                                #endregion Speed(2), Delay(2), Group(1), Command(1), Data0(2), Data1(2)
                                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                #region 추가한 Frame 위치 및 자세
                                nPos += 4;//SetFrame_X(j, (float)BitConverter.ToSingle(byteData, nPos)); nPos += 4;
                                nPos += 4;//SetFrame_Y(j, (float)BitConverter.ToSingle(byteData, nPos)); nPos += 4;
                                nPos += 4;//SetFrame_Z(j, (float)BitConverter.ToSingle(byteData, nPos)); nPos += 4;

                                nPos += 4;//SetFrame_Pan(j, (float)BitConverter.ToSingle(byteData, nPos)); nPos += 4;
                                nPos += 4;//SetFrame_Tilt(j, (float)BitConverter.ToSingle(byteData, nPos)); nPos += 4;
                                nPos += 4;//SetFrame_Swing(j, (float)BitConverter.ToSingle(byteData, nPos)); nPos += 4;
                                #endregion 추가한 Frame 위치 및 자세
                            }
                            #endregion 실제 모션

#if !_COLOR_GRID_IN_PAINT
                            m_CGridMotionEditor.SetColorGrid(0, nFrameSize);
#endif
                            string strData_ME = "";
                            string strData_FE = "";

                            // 'M' 'E'
                            strData_ME += (char)(byteData[nPos++]);
                            strData_ME += (char)(byteData[nPos++]);

                            #region Comment Data
                            // Comment
                            byte[] pstrComment = new byte[nCommentSize];
                            for (j = 0; j < nCommentSize; j++)
                                pstrComment[j] = (byte)(byteData[nPos++]);
                            m_strMotionFile_Comment = System.Text.Encoding.Default.GetString(pstrComment);
                            pstrComment = null;
                            #endregion Comment Data

                            #region Caption
                            int nLineNum = 0;
                            string strLineComment;
                            byte[] byLine = new byte[46];
                            for (j = 0; j < nCnt_LineComment; j++)
                            {
                                nLineNum = (short)(byteData[nPos] + byteData[nPos + 1] * 256); nPos += 2;
                                for (int k = 0; k < 46; k++)
                                    byLine[k] = (byte)(byteData[nPos++]);
                                strLineComment = System.Text.Encoding.Default.GetString(byLine);
                                strLineComment = strLineComment.Trim((char)0);
                                m_CGridMotionEditor.SetCaption(nLineNum, strLineComment);
                            }
                            byLine = null;
                            #endregion Caption

                            // 'T' 'E'
                            strData_FE += (char)(byteData[nPos++]);
                            strData_FE += (char)(byteData[nPos++]);

                            //                     if (bMessage == true)
                            //                     {
                            //                         if (strData_ME != "ME") OjwMessage("Motion Table Error\r\n");
                            //                         else OjwMessage("Table Loaded");
                            //                         if (strData_FE != "TE") OjwMessage("File Error\r\n");
                            //                         else OjwMessage("Table Loaded");
                            //                     }

                            pbyteMotorIndex = null;
                            pbyteMirrorIndex = null;

                            bFileOpened = true;
                            #endregion FileOpen V1.0
                        }
                        ////////////////////////////////////////////////////////////////////////////

                        CheckFlag(0);

                        //if (bFile == true)
                        //{
                        //    fs.Close();
                        //    f = null;
                        //}
                        this.Cursor = System.Windows.Forms.Cursors.Default;

                        if (bFileOpened == true) return true;
                        return false;
                    }
                    catch
                    {
                        this.Cursor = System.Windows.Forms.Cursors.Default;
                        //if (bFile == true)
                        //{
                        //    fs.Close();
                        //    f = null;
                        //}
                        return false;
                    }
                }
#endif
                //BinaryFileSave
#if true
                private bool m_bAutoSaved = false;
                private bool m_bModify = false;
                
                private void Modify(bool bModify)
                {
                    //if ((bModify == true) && (m_bModify != bModify)) OjwTimer.TimerSet(TID_FILEBACKUP);
                    m_bModify = bModify;
                    //lbModify.ForeColor = (bModify == true) ? Color.Red : Color.Green;
                    //lbModify.Text = (bModify == true) ? "수정중..." : "완료";
                }
            
                // 디버깅 플레이 할때 사용하기 위한 변수
                private int m_nFirstStreamNum = 0;
                private int m_nLastStreamNum = 0;

                //bool[] m_abEnc; // 엔코더 타입인지 아닌지...

                private string[] m_strCalcTime = new string[10000];
                private long[] m_lCalcTime = new long[10000];
                private long Grid_CalcTimer(int nLine) //
                {
                    if ((nLine < 0) || (m_CGridMotionEditor.GetHandle().RowCount <= nLine)) return 0;

                    int i = nLine - 1;

                    bool bNull = false;
                    if (nLine <= 0) bNull = true;
                    
                    if (bNull == false)
                    {
                        // 시간값 계산
                        // En
                        short sData = (short)Ojw.CConvert.BoolToInt(m_CGridMotionEditor.GetEnable(i)); // En
                        //                short sData0 = Convert.ToInt16(rowData[i]["Data0"]);
                        long nSpeed = 0;
                        long nDelay = 0;
                        long nTimer = 0;
                        if (sData != 0) // En 이 되어있다면
                        {
                            // Speed
                            nSpeed = (long)GridMotionEditor_GetTime(i);
                            // Delay
                            nDelay = (long)GridMotionEditor_GetDelay(i);
                            //nTimer += nSpeed * 10 + nDelay * 10;
                            nTimer += nSpeed + nDelay;
                        }
                        m_lCalcTime[nLine] = m_lCalcTime[i] + nTimer;
                        int nMs = (int)(m_lCalcTime[nLine] % 1000);
                        int nAllSec = (int)(m_lCalcTime[nLine] / 1000);
                        int nS = nAllSec % 60;
                        int nM = (nAllSec / 60) % 60;
                        int nH = (nAllSec / 60) / 60;
                        // Hour
                        string strTmp = Ojw.CConvert.IntToStr(nH);
                        if (strTmp.Length < 2) strTmp = "0" + strTmp;
                        m_strCalcTime[nLine] = strTmp + ":";
                        // Minute
                        strTmp = Ojw.CConvert.IntToStr(nM);
                        if (strTmp.Length < 2) strTmp = "0" + strTmp;
                        m_strCalcTime[nLine] = m_strCalcTime[nLine] + strTmp + ":";
                        // Second
                        strTmp = Ojw.CConvert.IntToStr(nS);
                        if (strTmp.Length < 2) strTmp = "0" + strTmp;
                        m_strCalcTime[nLine] = m_strCalcTime[nLine] + strTmp + ".";
                        // 1 Milli-Second
                        strTmp = Ojw.CConvert.IntToStr(nMs);
                        if (strTmp.Length < 2) strTmp = "0" + strTmp;
                        m_strCalcTime[nLine] = m_strCalcTime[nLine] + strTmp;
                    }
                    else
                    {
                        m_strCalcTime[nLine] = "00:00:00.00";
                        m_lCalcTime[nLine] = 0;
                    }
                    return m_lCalcTime[nLine];
                }
                private void Grid_CalcTimer() { for (int i = 0; i < m_CGridMotionEditor.GetHandle().RowCount; i++) Grid_CalcTimer(i); } /// 시간값 계산
                private const int _V_10 = 0;
                private const int _V_11 = 1;
                private const int _V_12 = 2;
                private bool m_bMessageBoxShow = true;
                public bool BinaryFileSave(bool bSaveAngle, int nFileVersion, String strFileName, bool bCompact, bool bMessageBoxShow)
                {
                    bool bMsg = m_bMessageBoxShow;
                    m_bMessageBoxShow = bMessageBoxShow;
                    bool bRet = BinaryFileSave(bSaveAngle, nFileVersion, strFileName, bCompact);
                    m_bMessageBoxShow = bMsg;
                    return bRet;
                }
                public bool RmtFileSave(string strFileName)//, bool bCompact)
                {
                    bool bRet = false;
                    if (strFileName == "")
                    {
                        Ojw.CMessage.Write_Error("File Saving Error - Null FileName");
                        MessageBox.Show("File Saving Error - Null FileName");
                        return false;
                    }
                    DataGridView dgAngle = m_CGridMotionEditor.GetHandle();
                    // 일단 먼저 선택된 프레임을 
                    int i, j;
                    int nCntLine = dgAngle.SelectedRows.Count;
                    int[] anFrameNum;
                    // Enable 되어 있는 프레임 전체 실행           
                    anFrameNum = new int[dgAngle.RowCount];
                    m_nFirstStreamNum = -1;
                    nCntLine = 0;
                    int nFrameNum = 0;
                    //if (bCompact == true)
                    //{
                        for (i = 0; i < dgAngle.RowCount; i++)
                        {
                            if (m_CGridMotionEditor.GetEnable(i) == true) // 가장 마지막까지 살아있는 Enable Frame 의 번호를 기록한다.
                            {
                                anFrameNum[nFrameNum++] = i;
                                nCntLine++;// = i + 1;
                            }
                        }
                    //}
                    //else
                    //{
                    //    for (i = 0; i < dgAngle.RowCount; i++)
                    //    {
                    //        anFrameNum[nFrameNum++] = i;
                    //        nCntLine++;
                    //    }
                    //}
                    // 정렬
                    Array.Resize<int>(ref anFrameNum, nCntLine);
                    Array.Sort<int>(anFrameNum);
                    m_nFirstStreamNum = anFrameNum[0];// nMin;
                    m_nLastStreamNum = anFrameNum[nCntLine - 1];//nMax;

                    //if (bCompact == false) { nCntLine = dgAngle.RowCount; m_nLastStreamNum = dgAngle.RowCount - 1; }

                    #region 라인 주석(캡션)의 줄 수(2)
                    //// Line Comment ////// 라인 주석의 줄 수
                    //int nCnt_LineComment = 0;
                    //for (nFrameNum = 0; nFrameNum < nCntLine; nFrameNum++)
                    //{
                    //    i = anFrameNum[nFrameNum];
                    //    if (m_CGridMotionEditor.GetEnable(i) == true)
                    //    {
                    //        String strLineComment = m_CGridMotionEditor.GetCaption(i);
                    //        if (strLineComment.Trim() != "") // 주석
                    //            nCnt_LineComment++;
                    //    }
                    //}
                    #endregion 라인 주석(캡션)의 줄 수(2)

                    string strErrMsg = String.Empty;
                    try
                    {
                        #region Rmt File
                        FileInfo f = new FileInfo(strFileName);
                        FileStream fs = f.Create();//OpenWrite();//Create();//f.OpenWrite();

                        try
                        {
                            // 스트림 버퍼를 비운다.
                            fs.Flush();
                            byte[] byteBuffer = Ojw.CConvert.StrToBytes("file type = motion\r\n");
                            fs.Write(byteBuffer, 0, byteBuffer.Length);
                            byteBuffer = Ojw.CConvert.StrToBytes("servo type = herkulex\r\n");
                            fs.Write(byteBuffer, 0, byteBuffer.Length);

                            byteBuffer = Ojw.CConvert.StrToBytes(String.Format("total motors = {0}\r\n", m_CHeader.nMotorCnt));
                            fs.Write(byteBuffer, 0, byteBuffer.Length);

                            
                            byteBuffer = Ojw.CConvert.StrToBytes(String.Format("parameter1 = {0}\r\n", 0)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                            byteBuffer = Ojw.CConvert.StrToBytes(String.Format("parameter2 = {0}\r\n", 0)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                            byteBuffer = Ojw.CConvert.StrToBytes(String.Format("parameter3 = {0}\r\n", 0)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                            byteBuffer = Ojw.CConvert.StrToBytes(String.Format("parameter4 = {0}\r\n", 0)); fs.Write(byteBuffer, 0, byteBuffer.Length);

                            string strData = "motor list =";
                            for (i = 0; i < m_CHeader.nMotorCnt; i++) strData += String.Format("\t{0}{1}", m_CHeader.pSMotorInfo[i].nMotorID, ((i < m_CHeader.nMotorCnt - 1) ? "," : "\r\n"));
                            byteBuffer = Ojw.CConvert.StrToBytes(strData); fs.Write(byteBuffer, 0, byteBuffer.Length);

                            strData = "location x =";
                            int nItemPos = 0; // 일단은 0 으로... 
                            for (i = 0; i < m_CHeader.nMotorCnt; i++) strData += String.Format("\t{0}{1}", nItemPos, ((i < m_CHeader.nMotorCnt - 1) ? "," : "\r\n"));
                            byteBuffer = Ojw.CConvert.StrToBytes(strData); fs.Write(byteBuffer, 0, byteBuffer.Length);

                            strData = "location y =";
                            nItemPos = 0; // 일단은 0 으로... 
                            for (i = 0; i < m_CHeader.nMotorCnt; i++) strData += String.Format("\t{0}{1}", nItemPos, ((i < m_CHeader.nMotorCnt - 1) ? "," : "\r\n"));
                            byteBuffer = Ojw.CConvert.StrToBytes(strData); fs.Write(byteBuffer, 0, byteBuffer.Length);

                            byteBuffer = Ojw.CConvert.StrToBytes("start\r\n"); fs.Write(byteBuffer, 0, byteBuffer.Length);
                            byteBuffer = Ojw.CConvert.StrToBytes("motion begin\r\n"); fs.Write(byteBuffer, 0, byteBuffer.Length);

                            strData = "name = test\r\n";
                            byteBuffer = Ojw.CConvert.StrToBytes(strData); fs.Write(byteBuffer, 0, byteBuffer.Length);

                            int nLine = 0;

                            strData = String.Format("count =\t{0}\r\n", nCntLine);
                            byteBuffer = Ojw.CConvert.StrToBytes(strData); fs.Write(byteBuffer, 0, byteBuffer.Length);
                            for (nFrameNum = 0; nFrameNum < nCntLine; nFrameNum++)
                            {
                                i = anFrameNum[nFrameNum];
                                if (m_CGridMotionEditor.GetEnable(i) == true)
                                {

                                    strData = String.Format("step =");

                                    strData += String.Format("\t{0},", m_CGridMotionEditor.GetTime(i));
                                    strData += String.Format("\t{0},", m_CGridMotionEditor.GetTime(i) + m_CGridMotionEditor.GetDelay(i));
                                    
                                    for (int nID = 0; nID < m_CHeader.nMotorCnt; nID++) 
                                    {
                                        int nData = m_CMotor.CalcAngle2Evd(i, (float)m_CGridMotionEditor.GetData(i, nID));
                                        strData += String.Format("\t{0},", nData);
                                    }

                                    strData += String.Format("\t({0})\r\n", m_CGridMotionEditor.GetCaption(i));
                                    byteBuffer = Ojw.CConvert.StrToBytes(strData); fs.Write(byteBuffer, 0, byteBuffer.Length);
                                }
                            }


                            
                            // 프레임 실행시간 저장(4)
                            long lTime = Grid_CalcTimer(m_nLastStreamNum);
                            byteBuffer = Ojw.CConvert.StrToBytes(String.Format("time =\t{0}\r\n", lTime)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                            byteBuffer = Ojw.CConvert.StrToBytes("motion end\r\n"); fs.Write(byteBuffer, 0, byteBuffer.Length);



                            fs.Close();
                            f = null;
                            if (m_bAutoSaved == false) Modify(false);

                            bRet = true;
                        }
                        catch
                        {
                            //Message("파일 저장 에러");
                            fs.Close();
                            f = null;

                            bRet = false;
                        }
                        #endregion Rmt File
                    }
                    catch (Exception ex)
                    {
                        bRet = false;
                        strErrMsg = ex.ToString();
                        CMessage.Write_Error(strErrMsg);
                    }

                    m_strMotionFile_FileAndTitle = "[RMT]" + strFileName;

                    if (bRet == true)
                    {
                        Ojw.CMessage.Write(String.Format("FileSaved: {0}", m_strMotionFile_FileAndTitle));
                        if (m_bMessageBoxShow == true) MessageBox.Show(String.Format("FileSaved: {0}", m_strMotionFile_FileAndTitle));
                    }
                    else
                    {
                        Ojw.CMessage.Write_Error(String.Format("We can't Save file: {0}", m_strMotionFile_FileAndTitle));
                        if (m_bMessageBoxShow == true) MessageBox.Show(String.Format("[Error] We can't Save file: {0}", m_strMotionFile_FileAndTitle), strErrMsg);
                    }
                    return bRet;
                }
                public bool ArduinoFileSave(string strFileName)//, bool bCompact)
                {
                    bool bRet = false;
                    if (strFileName == "")
                    {
                        Ojw.CMessage.Write_Error("File Saving Error - Null FileName");
                        MessageBox.Show("File Saving Error - Null FileName");
                        return false;
                    }
                    DataGridView dgAngle = m_CGridMotionEditor.GetHandle();
                    // 일단 먼저 선택된 프레임을 
                    int i, j;
                    int nCntLine = dgAngle.SelectedRows.Count;
                    int[] anFrameNum;
                    // Enable 되어 있는 프레임 전체 실행           
                    anFrameNum = new int[dgAngle.RowCount];
                    m_nFirstStreamNum = -1;
                    nCntLine = 0;
                    int nFrameNum = 0;
                    //if (bCompact == true)
                    //{
                    for (i = 0; i < dgAngle.RowCount; i++)
                    {
                        if (m_CGridMotionEditor.GetEnable(i) == true) // 가장 마지막까지 살아있는 Enable Frame 의 번호를 기록한다.
                        {
                            anFrameNum[nFrameNum++] = i;
                            nCntLine++;// = i + 1;
                        }
                    }
                    //}
                    //else
                    //{
                    //    for (i = 0; i < dgAngle.RowCount; i++)
                    //    {
                    //        anFrameNum[nFrameNum++] = i;
                    //        nCntLine++;
                    //    }
                    //}
                    // 정렬
                    Array.Resize<int>(ref anFrameNum, nCntLine);
                    Array.Sort<int>(anFrameNum);
                    m_nFirstStreamNum = anFrameNum[0];// nMin;
                    m_nLastStreamNum = anFrameNum[nCntLine - 1];//nMax;

                    //if (bCompact == false) { nCntLine = dgAngle.RowCount; m_nLastStreamNum = dgAngle.RowCount - 1; }

                    #region 라인 주석(캡션)의 줄 수(2)
                    //// Line Comment ////// 라인 주석의 줄 수
                    //int nCnt_LineComment = 0;
                    //for (nFrameNum = 0; nFrameNum < nCntLine; nFrameNum++)
                    //{
                    //    i = anFrameNum[nFrameNum];
                    //    if (m_CGridMotionEditor.GetEnable(i) == true)
                    //    {
                    //        String strLineComment = m_CGridMotionEditor.GetCaption(i);
                    //        if (strLineComment.Trim() != "") // 주석
                    //            nCnt_LineComment++;
                    //    }
                    //}
                    #endregion 라인 주석(캡션)의 줄 수(2)

                    string strErrMsg = String.Empty;
                    try
                    {
                        #region Rmt File
                        FileInfo f = new FileInfo(strFileName);
                        FileStream fs = f.Create();//OpenWrite();//Create();//f.OpenWrite();

                        try
                        {
                            // 스트림 버퍼를 비운다.
                            fs.Flush();                            
                            
                            byte[] byteBuffer;

                            byteBuffer = Ojw.CConvert.StrToBytes("#ifndef MOTOR_INFO\r\n#define MOTOR_INFO\r\n");
                            fs.Write(byteBuffer, 0, byteBuffer.Length);

                            byteBuffer = Ojw.CConvert.StrToBytes("// OpenJigWare_Arduino\r\n");
                            fs.Write(byteBuffer, 0, byteBuffer.Length);
                            byteBuffer = Ojw.CConvert.StrToBytes("// 1.0\r\n");
                            fs.Write(byteBuffer, 0, byteBuffer.Length);

                            byteBuffer = Ojw.CConvert.StrToBytes("// total motors\r\n");
                            fs.Write(byteBuffer, 0, byteBuffer.Length);
                            int nCnt_Motors = 0;
                            List<int> lstIDs = new List<int>();
                            lstIDs.Clear();
                            for (int nIndex = 0; nIndex < m_CHeader.nMotorCnt; nIndex++)
                            {
                                if (m_CHeader.pSMotorInfo[nIndex].nMotor_Enable >= 0)
                                {
                                    lstIDs.Add(m_CHeader.pSMotorInfo[nIndex].nMotorID);
                                    nCnt_Motors++;
                                }
                            }

                            byteBuffer = Ojw.CConvert.StrToBytes(String.Format("int32_t nCnt_Motors = {0}\r\n", nCnt_Motors));
                            fs.Write(byteBuffer, 0, byteBuffer.Length);

                            byteBuffer = Ojw.CConvert.StrToBytes("// motor ID\r\n");
                            fs.Write(byteBuffer, 0, byteBuffer.Length);
                            byteBuffer = Ojw.CConvert.StrToBytes(String.Format("int m_anMotorIDs[{0}] = ", nCnt_Motors));
                            fs.Write(byteBuffer, 0, byteBuffer.Length);
                            byteBuffer = Ojw.CConvert.StrToBytes("{ ");
                            fs.Write(byteBuffer, 0, byteBuffer.Length);

                            for (int nIndex = 0; nIndex < m_CHeader.nMotorCnt; nIndex++)
                            {
                                if (nIndex < (nCnt_Motors - 1))
                                    byteBuffer = Ojw.CConvert.StrToBytes(String.Format(" {0},", lstIDs[nIndex]));
                                else
                                    byteBuffer = Ojw.CConvert.StrToBytes(String.Format(" {0}", lstIDs[nIndex]));
                                fs.Write(byteBuffer, 0, byteBuffer.Length);
                            }
                            byteBuffer = Ojw.CConvert.StrToBytes(" };\r\n");
                            fs.Write(byteBuffer, 0, byteBuffer.Length);

                            byteBuffer = Ojw.CConvert.StrToBytes(String.Format("// Frames(Lines:{0}, Cols:{1})\r\n", nCntLine, nCnt_Motors));
                            fs.Write(byteBuffer, 0, byteBuffer.Length);

                            byteBuffer = Ojw.CConvert.StrToBytes(String.Format("int m_anFrames[{0}] = ", nCntLine * nCnt_Motors));
                            fs.Write(byteBuffer, 0, byteBuffer.Length);
                            byteBuffer = Ojw.CConvert.StrToBytes("{\r\n");
                            fs.Write(byteBuffer, 0, byteBuffer.Length);
                            int nLine = 0;
                            for (nFrameNum = 0; nFrameNum < nCntLine; nFrameNum++)
                            {
                                i = anFrameNum[nFrameNum];
                                int nSpeedValue = m_CGridMotionEditor.GetTime(i);
                                int nDelayValue = m_CGridMotionEditor.GetTime(i) + m_CGridMotionEditor.GetDelay(i);

                                //byteBuffer = Ojw.CConvert.StrToBytes("\t{ ");
                                byteBuffer = Ojw.CConvert.StrToBytes("\t");
                                fs.Write(byteBuffer, 0, byteBuffer.Length);

                                for (int nID = 0; nID < nCnt_Motors; nID++)
                                {
                                    m_CRobotis.SetParam_Dir(nID, m_CHeader.pSMotorInfo[nID].nMotorDir);
                                    //int nRpm = m_CMotor.CalcAngle2Evd(nID, (float)m_CGridMotionEditor.GetData(i, nID));
                                    int nEvd = m_CMotor.CalcAngle2Evd(nID, (float)m_CGridMotionEditor.GetData(i, nID));//(int)(float)m_CGridMotionEditor.GetData(i, nID);
                                    //float fRpm = (float)Math.Abs(m_CRobotis.CalcTime2Rpm(m_CGridMotionEditor.Get(nLine, nID) - m_CRobotis.CalcEvd2Angle(nID, m_CRobotis.m_SMotion_Pos.anMot[nID]), (float)nSpeedValue));
                                    //float fVal = (float)Math.Round((float)m_CGridMotionEditor.Get(nLine, nID));


                                    //Ojw.CMessage.Write("Rpm = {0}, aMot[{1}]:{2}, Curr:{3}", fRpm, nAxis, CalcEvd2Angle(nAxis, m_SMotion_Pos.anMot[nAxis]), OjwGrid.Get(nLine, nAxis));

                                    // save previous motion
                                    //if ((nDelayValue < 0) && (nSpeedValue > 0))
                                    //{
                                    //    // -Delay 의 % 를 감안해서 빼 줌
                                    //    m_CRobotis.m_SMotion_Pos.anMot[nID] = m_CRobotis.Get(nID) - (int)Math.Round((m_CRobotis.Get(nID) - m_CRobotis.m_SMotion_Pos.anMot[nID]) * ((float)nDelayValue / (float)nSpeedValue));
                                    //}
                                    //else
                                    //    m_CRobotis.m_SMotion_Pos.anMot[nID] = m_CRobotis.Get(nID);
                                    //////////////////////////////////////////////////////////////////////                                       
                                    
                                    if (nID < (nCnt_Motors - 1))
                                        byteBuffer = Ojw.CConvert.StrToBytes(String.Format(" {0},", nEvd));
                                    //else
                                    //    byteBuffer = Ojw.CConvert.StrToBytes(String.Format(" {0}", nEvd));
                                    fs.Write(byteBuffer, 0, byteBuffer.Length);
                                }
                                
                                byteBuffer = Ojw.CConvert.StrToBytes(String.Format("{0}, {1}", nSpeedValue, nDelayValue));
                                fs.Write(byteBuffer, 0, byteBuffer.Length);

                                //byteBuffer = Ojw.CConvert.StrToBytes(" }\r\n");
                                //fs.Write(byteBuffer, 0, byteBuffer.Length);
                                if (i < (nCntLine - 1))
                                {
                                    byteBuffer = Ojw.CConvert.StrToBytes(",\r\n");
                                    fs.Write(byteBuffer, 0, byteBuffer.Length);
                                }
                            }

                            byteBuffer = Ojw.CConvert.StrToBytes("\t};\r\n");
                            fs.Write(byteBuffer, 0, byteBuffer.Length);



                            byteBuffer = Ojw.CConvert.StrToBytes("#endif\r\n");
                            fs.Write(byteBuffer, 0, byteBuffer.Length);

                            // 프레임 실행시간 저장(4)
                            //long lTime = Grid_CalcTimer(m_nLastStreamNum);
                            //byteBuffer = Ojw.CConvert.StrToBytes(String.Format("time =\t{0}\r\n", lTime)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                            //byteBuffer = Ojw.CConvert.StrToBytes("motion end\r\n"); fs.Write(byteBuffer, 0, byteBuffer.Length);



                            fs.Close();
                            f = null;
                            if (m_bAutoSaved == false) Modify(false);

                            bRet = true;
                        }
                        catch
                        {
                            //Message("파일 저장 에러");
                            fs.Close();
                            f = null;

                            bRet = false;
                        }
                        #endregion Rmt File
                    }
                    catch (Exception ex)
                    {
                        bRet = false;
                        strErrMsg = ex.ToString();
                        CMessage.Write_Error(strErrMsg);
                    }
                
                    if (bRet == true)
                    {
                        Ojw.CMessage.Write(String.Format("FileSaved: {0}", m_strMotionFile_FileAndTitle));
                        if (m_bMessageBoxShow == true) MessageBox.Show(String.Format("FileSaved: {0}", m_strMotionFile_FileAndTitle));
                    }
                    else
                    {
                        Ojw.CMessage.Write_Error(String.Format("We can't Save file: {0}", m_strMotionFile_FileAndTitle));
                        if (m_bMessageBoxShow == true) MessageBox.Show(String.Format("[Error] We can't Save file: {0}", m_strMotionFile_FileAndTitle), strErrMsg);
                    }
                    return bRet;
                }
                //public bool BinaryFileSave(int nFileVersion, String strFileName, bool bCompact)
                //{
                //    return BinaryFileSave(false, nFileVersion, strFileName, bCompact);
                //}
                public bool BinaryFileSave(bool bSaveAngle, int nFileVersion, String strFileName, bool bCompact)
                {
                    bool bRet = false;
                    if (strFileName == "")
                    {
                        Ojw.CMessage.Write_Error("File Saving Error - Null FileName");
                        MessageBox.Show("File Saving Error - Null FileName");
                        return false;
                    }
                    DataGridView dgAngle = m_CGridMotionEditor.GetHandle();
                    // 일단 먼저 선택된 프레임을 
                    int i, j;
                    int nCntLine = dgAngle.SelectedRows.Count;
                    int[] anFrameNum;// = new int [nCntLine];
                    // Enable 되어 있는 프레임 전체 실행           
                    anFrameNum = new int[dgAngle.RowCount];
                    m_nFirstStreamNum = -1;
                    nCntLine = 0;
                    int nFrameNum = 0;
                    if (bCompact == true)
                    {
                        for (i = 0; i < dgAngle.RowCount; i++)
                        {
                            if (m_CGridMotionEditor.GetEnable(i) == true) // 가장 마지막까지 살아있는 Enable Frame 의 번호를 기록한다.
                            {
                                anFrameNum[nFrameNum++] = i;
                                nCntLine++;// = i + 1;
                            }
                        }
                    }
                    else
                    {
                        for (i = 0; i < dgAngle.RowCount; i++)
                        {
                            anFrameNum[nFrameNum++] = i;
                            nCntLine++;
                        }
                    }
                    // 정렬
                    Array.Resize<int>(ref anFrameNum, nCntLine);
                    Array.Sort<int>(anFrameNum);
                    m_nFirstStreamNum = anFrameNum[0];// nMin;
                    m_nLastStreamNum = anFrameNum[nCntLine - 1];//nMax;
                    
                    if (bCompact == false) { nCntLine = dgAngle.RowCount; m_nLastStreamNum = dgAngle.RowCount - 1; }

                    #region 라인 주석(캡션)의 줄 수(2)
                    //// Line Comment ////// 라인 주석의 줄 수
                    int nCnt_LineComment = 0;
                    for (nFrameNum = 0; nFrameNum < nCntLine; nFrameNum++)
                    {
                        i = anFrameNum[nFrameNum];
                        if (m_CGridMotionEditor.GetEnable(i) == true)
                        {
                            String strLineComment = m_CGridMotionEditor.GetCaption(i);
                            if (strLineComment.Trim() != "") // 주석
                                nCnt_LineComment++;
                        }
                    }
                    #endregion 라인 주석(캡션)의 줄 수(2)

                    string strErrMsg = String.Empty;
                    try
                    {
                        if (nFileVersion == _V_10)//#if false // ojw5014_v11           
                        {
                            #region V1.0
                            String _STR_EXT = "DMT";
                            String _STR_VER = "1.0";

                            FileInfo f = new FileInfo(strFileName);
                            FileStream fs = f.Create();//OpenWrite();//Create();//f.OpenWrite();

                            try
                            {
                                // 스트림 버퍼를 비운다.
                                fs.Flush();

                                #region 식별코드 부여(6)
                                fs.WriteByte((byte)(char.ToUpper(_STR_EXT[0])));
                                fs.WriteByte((byte)(char.ToUpper(_STR_EXT[1])));
                                fs.WriteByte((byte)(char.ToUpper(_STR_EXT[2])));
                                fs.WriteByte((byte)(char.ToUpper(_STR_VER[0])));
                                fs.WriteByte((byte)(char.ToUpper(_STR_VER[1])));
                                fs.WriteByte((byte)(char.ToUpper(_STR_VER[2])));
                                #endregion 식별코드 부여(6)

                                #region Title - 21 Char
                                // Name
                                byte[] byteName = Encoding.Default.GetBytes(m_strMotionFile_TableName);// Encoding.ASCII.GetBytes(txtTableName.Text);
                                for (i = 0; i < 20; i++)
                                {
                                    if (i < byteName.Length) fs.WriteByte(byteName[i]);
                                    else fs.WriteByte(0);
                                }
                                // 널 종료문자 추가
                                fs.WriteByte(0);
                                #endregion Title - 21 Char

                                #region 시작자세(1)
                                // 시작자세
                                int nStartPosition = (int)(m_nMotionFile_StartPosition);
                                //m_nMotionFile_StartPosition = (((cmbStartPosition.Items.Count > nStartPosition) && (nStartPosition > 0)) ? nStartPosition : 0);
                                fs.WriteByte((byte)(m_nMotionFile_StartPosition & 0xff));
                                #endregion 시작자세(1)

                                short sData;
                                // 프레임 수(모션)
                                string strLineComment;
                                int nLastFrameNum = 0;

                                #region 모션의 프레임 수(2)
                                nLastFrameNum = nCntLine;
                                byte[] byteData = BitConverter.GetBytes((short)nCntLine);
                                fs.Write(byteData, 0, 2);
                                byteData = null;
                                #endregion 모션의 프레임 수(2)

                                // 문자열 수(Comment)
                                #region Comment 글자 수(2)
                                byte[] byteComment = Encoding.Default.GetBytes(m_strMotionFile_Comment);
                                sData = (short)(byteComment.Length);

                                // 널 종료문자 개수 포함
                                if (sData > 0) sData++;
                                byteData = BitConverter.GetBytes(sData);
                                fs.Write(byteData, 0, 2);
                                byteData = null;
                                #endregion Comment 글자 수(2)

                                #region 라인 주석(캡션)의 줄 수(2)
                                //// Line Comment ////// 라인 주석의 줄 수
                                byteData = BitConverter.GetBytes((short)nCnt_LineComment);
                                fs.Write(byteData, 0, 2);
                                byteData = null;
                                #endregion 라인 주석(캡션)의 줄 수(2)

                                #region 프레임 실행시간 저장(4)
                                long lTime = Grid_CalcTimer(m_nLastStreamNum);// / 10;
                                byteData = BitConverter.GetBytes((Int32)lTime);
                                fs.Write(byteData, 0, 4);
                                byteData = null;
                                #endregion 프레임 실행시간 저장(4)
                                //////////////////////
                                #region 로봇 모델 번호(타입) 저장(2)
                            
                                byteData = BitConverter.GetBytes((Int16)m_CHeader.nModelNum);
                                fs.Write(byteData, 0, 2);
                                byteData = null;
                                #endregion 로봇 모델 번호(타입) 저장(2)
                                #region 모터의 총 갯수 저장(1)
                                fs.WriteByte((byte)(m_CHeader.nMotorCnt & 0xff));
                                #endregion 모터의 총 갯수 저장(1)

                                #region 실 프레임 저장
                                // Motion
                                float fValue;
                                bool bEn, bCaption;
                                for (nFrameNum = 0; nFrameNum < nCntLine; nFrameNum++)
                                {
                                    i = anFrameNum[nFrameNum];
                                    //////////////////////////////////
                                    bEn = m_CGridMotionEditor.GetEnable(i);
                                    strLineComment = m_CGridMotionEditor.GetCaption(i);
                                    bCaption = (strLineComment.Trim() == "") ? false : true;
                                    if (
                                        (bCompact == true) &&   // 압축
                                        (bEn == false) //&& // Enable 이 Set 상태가 아니고
                                        //(bCaption == false) // 주석이 없다면
                                    ) continue;

                                    //if ((bCompact == true) && ((bEn == false) && (bCaption == false))) continue;

                                    // En
                                    byte byteEn = 0;
                                    if (bEn == true) byteEn |= 0x01;
                                    if (bCaption == true) byteEn |= 0x02;
                                    fs.WriteByte(byteEn);

                                    // Motor
                                    for (j = 0; j < m_CHeader.nMotorCnt; j++)
                                    {
                                        fValue = GridMotionEditor_GetMotor(i, j);
                                        if (bSaveAngle)
                                        {
                                            fValue *= ((m_CHeader.pSMotorInfo[j].nMotorDir == 0) ? 1.0f : -1.0f);
                                            fValue *= 100; // 2 바이트 연산이라 float 을 표현하기는 어려우니 100 채배를 한 각도값을 사용
                                            sData = (short)Math.Round(fValue);
                                        }
                                        else
                                        {
                                            sData = (short)CalcAngle2Evd(j, fValue);//(short)(CalcAngle2Evd(j, fValue) & 0x0fff);// (short)(((Grid_GetFlag_En(i, j) == true) ? CalcAngle2Evd(j, fValue) : 0x07ff) & 0x0fff);
                                        }
                                        sData |= (short)(((Grid_GetFlag_Led(i, j) & 0x07) << 12) & 0xf000);
                                        sData |= (short)((Grid_GetFlag_Type(i, j) == true) ? 0x8000 : 0x0000);
                                        //sData |= (short)((Grid_GetFlag_En(i, j) == false) ? 0x8000 : 0x0000);
                                        //sData |= 0x0400; // 속도모드인때 정(0-0x0000), 역(1-0x0400)
                                        //sData |= LED;  // 00 - 0ff, 0x0800 - Red(01), 0x1000 - Blue(10), 0x1800 - Green(11)
                                        //sData |= 제어타입 // 0 - 위치, 0x2000 - 속도
                                        //sData |= 0x4000; //Enable // 개별 Enable (0 - Disable, 0x4000 - Enable)

                                        byteData = BitConverter.GetBytes((Int16)sData);
                                        fs.Write(byteData, 0, 2);
                                        byteData = null;
                                    }

                                    #region Speed(2), Delay(2), Group(1), Command(1), Data0(2), Data1(2)
                                    #region Speed(2)
                                    // Speed
                                    sData = (short)GridMotionEditor_GetTime(i);
                                    byteData = BitConverter.GetBytes(sData);
                                    fs.Write(byteData, 0, 2);
                                    byteData = null;
                                    #endregion Speed(2)

                                    #region Delay(2)
                                    // Delay
                                    sData = (short)GridMotionEditor_GetDelay(i);
                                    byteData = BitConverter.GetBytes(sData);
                                    fs.Write(byteData, 0, 2);
                                    byteData = null;
                                    #endregion Delay(2)

                                    #region Group(1)
                                    // Group
                                    fs.WriteByte((byte)(GridMotionEditor_GetGroup(i) & 0xff));
                                    #endregion Group(1)

                                    #region Command(1)
                                    // Command
                                    fs.WriteByte((byte)(GridMotionEditor_GetCommand(i) & 0xff));
                                    #endregion Command(1)

                                    #region Data0(2)
                                    // Data0
                                    sData = (short)(((short)GridMotionEditor_GetData0(i) & 0x3ff) | (((short)GridMotionEditor_GetExtBuzz(i) & 0x3f) << 10));
                                    byteData = BitConverter.GetBytes(sData);
                                    fs.Write(byteData, 0, 2);
                                    byteData = null;
                                    #endregion Data0(2)

                                    #region Data1(2)
                                    // Data1
                                    //sData = (short)m_CGridMotionEditor.GetData1(i);
                                    sData = (short)(((short)GridMotionEditor_GetData1(i) & 0x3ff) | (((short)GridMotionEditor_GetExtLed(i) & 0x3f) << 10));
                                    byteData = BitConverter.GetBytes(sData);
                                    fs.Write(byteData, 0, 2);
                                    byteData = null;
                                    #endregion Data1(2)
                                    #endregion Speed(2), Delay(2), Group(1), Command(1), Data0(2), Data1(2)
                                    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                    #region 추가한 Frame 위치 및 자세
                                    fValue = 0;//GetFrame_X(i);
                                    byteData = BitConverter.GetBytes(fValue);
                                    fs.Write(byteData, 0, 4);
                                    byteData = null;

                                    fValue = 0;//GetFrame_Y(i);
                                    byteData = BitConverter.GetBytes(fValue);
                                    fs.Write(byteData, 0, 4);
                                    byteData = null;

                                    fValue = 0;//GetFrame_Z(i);
                                    byteData = BitConverter.GetBytes(fValue);
                                    fs.Write(byteData, 0, 4);
                                    byteData = null;


                                    fValue = 0;//GetFrame_Pan(i);
                                    byteData = BitConverter.GetBytes(fValue);
                                    fs.Write(byteData, 0, 4);
                                    byteData = null;

                                    fValue = 0;//GetFrame_Tilt(i);
                                    byteData = BitConverter.GetBytes(fValue);
                                    fs.Write(byteData, 0, 4);
                                    byteData = null;

                                    fValue = 0;// GetFrame_Swing(i);
                                    byteData = BitConverter.GetBytes(fValue);
                                    fs.Write(byteData, 0, 4);
                                    byteData = null;
                                    #endregion 추가한 Frame 위치 및 자세
                                }
                                #endregion

                                fs.WriteByte((byte)('M'));
                                fs.WriteByte((byte)('E'));

                                #region Comment
                                // Comment
                                for (int k = 0; k < byteComment.Length; k++) fs.WriteByte(byteComment[k]);
                                // 널 종료문자
                                if (byteComment.Length > 0) fs.WriteByte(0);
                                #endregion

                                #region Caption 저장
                                // Caption Size
                                int nSize_Caption = 46;
                                // Caption
                                for (nFrameNum = 0; nFrameNum < nCntLine; nFrameNum++)
                                {
                                    i = anFrameNum[nFrameNum];
                                    ////////////////////////////////////////////
                                    strLineComment = m_CGridMotionEditor.GetCaption(i);
                                    strLineComment = strLineComment.Trim();
                                    if (strLineComment != "") // 주석
                                    {
                                        byteData = BitConverter.GetBytes((short)i);
                                        fs.Write(byteData, 0, 2);
                                        byteData = null;

                                        byteData = Encoding.Default.GetBytes(strLineComment);
                                        if (byteData.Length > nSize_Caption)
                                        {
                                            for (int k = 0; k < nSize_Caption; k++) fs.WriteByte((byte)byteData[k]);
                                        }
                                        else
                                        {
                                            for (int k = 0; k < byteData.Length; k++) fs.WriteByte((byte)byteData[k]);
                                            for (int k = byteData.Length; k < nSize_Caption; k++) fs.WriteByte((byte)0);
                                        }
                                    }
                                }
                                #endregion


                                fs.WriteByte((byte)('F'));
                                fs.WriteByte((byte)('E'));

                                fs.Close();
                                f = null;
                                if (m_bAutoSaved == false) Modify(false);

                                byteName = null;
                                byteComment = null;

                                bRet = true;
                            }
                            catch
                            {
                                //Message("파일 저장 에러");
                                fs.Close();
                                f = null;

                                bRet = false;
                            }
                            #endregion V1.0
                        }
                        else if (nFileVersion == _V_11) //#else
                        {
                            #region V1.1
                            String _STR_EXT = "DMT";
                            String _STR_VER = "1.1";
                            //bool bOpen = false;
                        
                            FileInfo f = new FileInfo(strFileName);
                            FileStream fs = f.Create();//OpenWrite();//Create();//f.OpenWrite();

                            try
                            {
                                // 스트림 버퍼를 비운다.
                                fs.Flush();

                                                            #region 식별코드 부여(6)
                            fs.WriteByte((byte)(char.ToUpper(_STR_EXT[0])));
                            fs.WriteByte((byte)(char.ToUpper(_STR_EXT[1])));
                            fs.WriteByte((byte)(char.ToUpper(_STR_EXT[2])));
                            fs.WriteByte((byte)(char.ToUpper(_STR_VER[0])));
                            fs.WriteByte((byte)(char.ToUpper(_STR_VER[1])));
                            fs.WriteByte((byte)(char.ToUpper(_STR_VER[2])));
                            #endregion 식별코드 부여(6)

                                                                        #region Title - 21 Char
                            // Name
                            byte[] byteName = Encoding.Default.GetBytes(m_strMotionFile_TableName);// Encoding.ASCII.GetBytes(txtTableName.Text);
                            for (i = 0; i < 20; i++)
                            {
                                if (i < byteName.Length) fs.WriteByte(byteName[i]);
                                else fs.WriteByte(0);
                            }
                            // 널 종료문자 추가
                            fs.WriteByte(0);
                            #endregion Title - 21 Char

                                                    #region 시작자세(1)
                            // 시작자세
                            int nStartPosition = (int)(m_nMotionFile_StartPosition);
                            //m_nMotionFile_StartPosition = (((cmbStartPosition.Items.Count > nStartPosition) && (nStartPosition > 0)) ? nStartPosition : 0);
                            fs.WriteByte((byte)(m_nMotionFile_StartPosition & 0xff));
                            #endregion 시작자세(1)

                                short sData;
                                // 프레임 수(모션)
                                string strLineComment;

                                                #region 모션의 프레임 수(2)
                            byte[] byteData = BitConverter.GetBytes((short)nCntLine);
                            fs.Write(byteData, 0, 2);
                            byteData = null;
                            #endregion 모션의 프레임 수(2)

                                // 문자열 수(Comment)
                                                                #region Comment 글자 수(2)
                            byte[] byteComment = Encoding.Default.GetBytes(m_strMotionFile_Comment);
                            sData = (short)(byteComment.Length);

                            // 널 종료문자 개수 포함
                            if (sData > 0) sData++;
                            byteData = BitConverter.GetBytes(sData);
                            fs.Write(byteData, 0, 2);
                            byteData = null;
                            #endregion Comment 글자 수(2)

                                                    #region 라인 주석(캡션)의 줄 수(2)
                            //// Line Comment ////// 라인 주석의 줄 수
                            byteData = BitConverter.GetBytes((short)nCnt_LineComment);
                            fs.Write(byteData, 0, 2);
                            byteData = null;
                            #endregion 라인 주석(캡션)의 줄 수(2)

                                                    #region 프레임 실행시간 저장(4)
                            long lTime = Grid_CalcTimer(m_nLastStreamNum);// / 10;
                            byteData = BitConverter.GetBytes((Int32)lTime);
                            fs.Write(byteData, 0, 4);
                            byteData = null;
                            #endregion 프레임 실행시간 저장(4)
                                //////////////////////
                                                #region 로봇 모델 번호(타입) 저장(2)
                            byteData = BitConverter.GetBytes((Int16)m_CHeader.nModelNum);
                            fs.Write(byteData, 0, 2);
                            byteData = null;
                            #endregion 로봇 모델 번호(타입) 저장(2)
                                        #region 모터의 총 갯수 저장(1)
                            fs.WriteByte((byte)(m_CHeader.nMotorCnt & 0xff));
                            #endregion 모터의 총 갯수 저장(1)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        #region 실 프레임 저장
                            // Motion
                            float fValue;
                            bool bEn, bCaption;
                            for (nFrameNum = 0; nFrameNum < nCntLine; nFrameNum++)
                            {
                                i = anFrameNum[nFrameNum];
                                //////////////////////////////////
                                bEn = m_CGridMotionEditor.GetEnable(i);
                                strLineComment = m_CGridMotionEditor.GetCaption(i);
                                bCaption = (strLineComment.Trim() == "") ? false : true;
                                if (
                                    (bCompact == true) &&   // 압축
                                    (bEn == false) && // Enable 이 Set 상태가 아니고
                                    (bCaption == false) // 주석이 없다면
                                ) continue;

                                //if ((bCompact == true) && ((bEn == false) && (bCaption == false))) continue;

                                // En
                                byte byteEn = 0;
                                if (bEn == true) byteEn |= 0x01;
                                if (bCaption == true) byteEn |= 0x02;
                                fs.WriteByte(byteEn);
                                int nData;
                                // Motor
                                for (j = 0; j < m_CHeader.nMotorCnt; j++)
                                {
                                    fValue = GridMotionEditor_GetMotor(i, j);
                                    int nValue = CalcAngle2Evd(j, fValue);
                                    int nMinus = 0;
                                    if (nValue <= 0)
                                    {
                                        nMinus = 0x4000; // 부호비트
                                        nValue *= -1;
                                    }
                                    //if (fValue <= 0) nData = 0x4000; 
                                    nData = (int)(nValue & 0x3fff); // ojw5014_genie Data
                                    nData |= nMinus; // ojw5014_genie // 부호비트

                                    //nData |= (int)((m_abEnc[j] == true) ? 0x8000 : 0x0000); // ojw5014_genie 엔코더타입
                                    nData |= (int)(((j >= 6) && (j <= 8)) ? 0x8000 : 0x0000); // ojw5014_genie 엔코더타입
                                    nData |= (int)((Grid_GetFlag_Type(i, j) == true) ? 0x20000 : 0x0000); // 제어타입 // 0 - 위치, 0x20000 - 속도

                                    nData |= (int)((Grid_GetFlag_Led(i, j) & 0x07) << 18);
                                    //nData |= (int)((Grid_GetFlag_Type(i, j) == true) ? 0x8000 : 0x0000);
                                    nData |= (int)((Grid_GetFlag_En(i, j) == false) ? 0x200000 : 0x00000);

                                    // Save
                                    fs.WriteByte((byte)((nData) & 0xff));
                                    fs.WriteByte((byte)((nData >> 8) & 0xff));
                                    fs.WriteByte((byte)((nData >> 16) & 0xff));
                                }

                                #region Speed(2), Delay(2), Group(1), Command(1), Data0(2), Data1(2)
                                #region Speed(2)
                                // Speed
                                sData = (short)GridMotionEditor_GetTime(i);
                                byteData = BitConverter.GetBytes(sData);
                                fs.Write(byteData, 0, 2);
                                byteData = null;
                                #endregion Speed(2)

                                #region Delay(2)
                                // Delay
                                sData = (short)GridMotionEditor_GetDelay(i);
                                byteData = BitConverter.GetBytes(sData);
                                fs.Write(byteData, 0, 2);
                                byteData = null;
                                #endregion Delay(2)

                                #region Group(1)
                                // Group
                                fs.WriteByte((byte)(m_CGridMotionEditor.GetGroup(i) & 0xff));
                                #endregion Group(1)

                                #region Command(1)
                                // Command
                                fs.WriteByte((byte)((byte)(m_CGridMotionEditor.GetCommand(i)) & 0xff));
                                #endregion Command(1)

                                #region Data0(2)
                                // Data0
                                sData = (short)m_CGridMotionEditor.GetData0(i);
                                byteData = BitConverter.GetBytes(sData);
                                fs.Write(byteData, 0, 2);
                                byteData = null;
                                #endregion Data0(2)

                                #region Data1(2)
                                // Data1
                                sData = (short)m_CGridMotionEditor.GetData1(i);
                                byteData = BitConverter.GetBytes(sData);
                                fs.Write(byteData, 0, 2);
                                byteData = null;
                                #endregion Data1(2)
                                #endregion Speed(2), Delay(2), Group(1), Command(1), Data0(2), Data1(2)
                                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                #region 추가한 Frame 위치 및 자세
                                fValue = (float)GetFrame_X(i);
                                byteData = BitConverter.GetBytes(fValue);
                                fs.Write(byteData, 0, 4);
                                byteData = null;

                                fValue = (float)GetFrame_Y(i);
                                byteData = BitConverter.GetBytes(fValue);
                                fs.Write(byteData, 0, 4);
                                byteData = null;

                                fValue = (float)GetFrame_Z(i);
                                byteData = BitConverter.GetBytes(fValue);
                                fs.Write(byteData, 0, 4);
                                byteData = null;


                                fValue = (float)GetFrame_Pan(i);
                                byteData = BitConverter.GetBytes(fValue);
                                fs.Write(byteData, 0, 4);
                                byteData = null;

                                fValue = (float)GetFrame_Tilt(i);
                                byteData = BitConverter.GetBytes(fValue);
                                fs.Write(byteData, 0, 4);
                                byteData = null;

                                fValue = (float)GetFrame_Swing(i);
                                byteData = BitConverter.GetBytes(fValue);
                                fs.Write(byteData, 0, 4);
                                byteData = null;
                                #endregion 추가한 Frame 위치 및 자세
                            }
                            #endregion

                                fs.WriteByte((byte)('M'));
                                fs.WriteByte((byte)('E'));

                                                    #region Comment
                            // Comment
                            for (int k = 0; k < byteComment.Length; k++) fs.WriteByte(byteComment[k]);
                            // 널 종료문자
                            if (byteComment.Length > 0) fs.WriteByte(0);
                            #endregion

                                                                                                                                            #region Caption 저장
                            // Caption Size
                            int nSize_Caption = 46;
                            // Caption
                            for (nFrameNum = 0; nFrameNum < nCntLine; nFrameNum++)
                            {
                                i = anFrameNum[nFrameNum];
                                //////////////////////////////////
                                strLineComment = m_CGridMotionEditor.GetCaption(i);
                                strLineComment = strLineComment.Trim();
                                if (strLineComment != "") // 주석
                                {
                                    byteData = BitConverter.GetBytes((short)i);
                                    fs.Write(byteData, 0, 2);
                                    byteData = null;

                                    byteData = Encoding.Default.GetBytes(strLineComment);
                                    if (byteData.Length > nSize_Caption)
                                    {
                                        for (int k = 0; k < nSize_Caption; k++) fs.WriteByte((byte)byteData[k]);
                                    }
                                    else
                                    {
                                        for (int k = 0; k < byteData.Length; k++) fs.WriteByte((byte)byteData[k]);
                                        for (int k = byteData.Length; k < nSize_Caption; k++) fs.WriteByte((byte)0);
                                    }
                                }
                            }
                            #endregion


                                fs.WriteByte((byte)('F'));
                                fs.WriteByte((byte)('E'));

                                fs.Close();
                                f = null;
                                if (m_bAutoSaved == false) Modify(false);

                                byteName = null;
                                byteComment = null;

                                bRet = true;
                            }
                            catch
                            {
                                fs.Close();
                                f = null;

                                bRet = false;
                            }
                            #endregion V1.1
                        }//#endif
                        else if (nFileVersion == _V_12)
                        {
                            #region V1.2
                            String _STR_EXT = "DMT";
                            String _STR_VER = "1.2";
                            //bool bOpen = false;
                        
                            FileInfo f = new FileInfo(strFileName);
                            FileStream fs = f.Create();//OpenWrite();//Create();//f.OpenWrite();

                            try
                            {
                                // 스트림 버퍼를 비운다.
                                fs.Flush();

                                                            #region 식별코드 부여(6)
                            fs.WriteByte((byte)(char.ToUpper(_STR_EXT[0])));
                            fs.WriteByte((byte)(char.ToUpper(_STR_EXT[1])));
                            fs.WriteByte((byte)(char.ToUpper(_STR_EXT[2])));
                            fs.WriteByte((byte)(char.ToUpper(_STR_VER[0])));
                            fs.WriteByte((byte)(char.ToUpper(_STR_VER[1])));
                            fs.WriteByte((byte)(char.ToUpper(_STR_VER[2])));
                            #endregion 식별코드 부여(6)

                                                                        #region Title - 21 Char
                            // Name
                            byte[] byteName = Encoding.Default.GetBytes(m_strMotionFile_TableName);// Encoding.ASCII.GetBytes(txtTableName.Text);
                            for (i = 0; i < 20; i++)
                            {
                                if (i < byteName.Length) fs.WriteByte(byteName[i]);
                                else fs.WriteByte(0);
                            }
                            // 널 종료문자 추가
                            fs.WriteByte(0);
                            #endregion Title - 21 Char

                                                    #region 시작자세(1)
                            // 시작자세
                            int nStartPosition = (int)(m_nMotionFile_StartPosition);
                            //m_nMotionFile_StartPosition = (((cmbStartPosition.Items.Count > nStartPosition) && (nStartPosition > 0)) ? nStartPosition : 0);
                            fs.WriteByte((byte)(m_nMotionFile_StartPosition & 0xff));
                            #endregion 시작자세(1)

                                short sData;
                                // 프레임 수(모션)
                                string strLineComment;

                                                #region 모션의 프레임 수(2) - 모션의 프레임만 체크, 캡션은 따로 체크한다.
                            byte[] byteData = BitConverter.GetBytes((short)nCntLine);
                            fs.Write(byteData, 0, 2);
                            byteData = null;
                            #endregion 모션의 프레임 수(2) - 모션의 프레임만 체크, 캡션은 따로 체크한다.

                                // 문자열 수(Comment)
                                                                #region Comment 글자 수(2)
                            byte[] byteComment = Encoding.Default.GetBytes(m_strMotionFile_Comment);
                            sData = (short)(byteComment.Length);

                            // 널 종료문자 개수 포함
                            if (sData > 0) sData++;
                            byteData = BitConverter.GetBytes(sData);
                            fs.Write(byteData, 0, 2);
                            byteData = null;
                            #endregion Comment 글자 수(2)

                                #region 라인 주석(캡션)의 줄 수(2) - 여기서 연산해야할 최대 프레임 수를 계산한다.
                                //// Line Comment ////// 라인 주석의 줄 수
                                nCnt_LineComment = 0;

                                for (nFrameNum = 0; nFrameNum < nCntLine; nFrameNum++)
                                {
                                    i = anFrameNum[nFrameNum];
                                    //////////////////////////////////
    #if false
                                    strLineComment = m_CGridMotionEditor.GetCaption(i);
                        if (strLineComment.Trim() != "") // 주석
                            nCnt_LineComment++;
    #else

                                    strLineComment = m_CGridMotionEditor.GetCaption(i);
                                    if (strLineComment.Trim() != "") // 주석
                                    {
                                        nCnt_LineComment++;
                                        //nFrameSize++;
                                    }
                                    //else
                                    //{
                                    //    sData = (short)Ojw.CConvert.BoolToInt(m_CGridMotionEditor.GetEnable(i)); // En
                                    //    if (sData != 0) nFrameSize++; // En
                                    //}
    #endif

                                }
                                byteData = BitConverter.GetBytes((short)nCnt_LineComment);
                                fs.Write(byteData, 0, 2);
                                byteData = null;
                                #endregion 라인 주석(캡션)의 줄 수(2) - 여기서 연산해야할 최대 프레임 수를 계산한다.

                                                    #region 프레임 실행시간 저장(4)
                            long lTime = Grid_CalcTimer(m_nLastStreamNum);// / 10;
                            byteData = BitConverter.GetBytes((Int32)lTime);
                            fs.Write(byteData, 0, 4);
                            byteData = null;
                            #endregion 프레임 실행시간 저장(4)
                                //////////////////////
                                                #region 로봇 모델 번호(타입) 저장(2)
                            byteData = BitConverter.GetBytes((Int16)m_CHeader.nModelNum);
                            fs.Write(byteData, 0, 2);
                            byteData = null;
                            #endregion 로봇 모델 번호(타입) 저장(2)
                                        #region 모터의 총 갯수 저장(1)
                            fs.WriteByte((byte)(m_CHeader.nMotorCnt & 0xff));
                            #endregion 모터의 총 갯수 저장(1)

                                                    #region 모터의 ID 저장(1)
                            for (i = 0; i < m_CHeader.nMotorCnt; i++)
                            {
                                fs.WriteByte((byte)(m_CHeader.pSMotorInfo[i].nMotorID & 0xff));
                            }
                            #endregion 모터의 ID 저장(1)

                                                    #region 모터의 Mirror ID 저장(1)
                            for (i = 0; i < m_CHeader.nMotorCnt; i++)
                            {
                                fs.WriteByte((byte)(m_CHeader.pSMotorInfo[i].nAxis_Mirror & 0xff));
                            }
                            #endregion 모터의 Mirror ID 저장(1)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #region 실 프레임 저장
                            // Motion
                            float fValue;
                            bool bEn, bCaption;
                            for (nFrameNum = 0; nFrameNum < nCntLine; nFrameNum++)
                            {
                                i = anFrameNum[nFrameNum];
                                //////////////////////////////////
                                bEn = m_CGridMotionEditor.GetEnable(i);
                                strLineComment = m_CGridMotionEditor.GetCaption(i);
                                bCaption = (strLineComment.Trim() == "") ? false : true;
                                if (
                                    (bCompact == true) &&   // 압축
                                    (bEn == false) && // Enable 이 Set 상태가 아니고
                                    (bCaption == false) // 주석이 없다면
                                ) continue;

                                if ((bCompact == true) && ((bEn == false) && (bCaption == false))) continue;

                                // En
                                byte byteEn = 0;
                                if (bEn == true) byteEn |= 0x01;
                                if (bCaption == true) byteEn |= 0x02;
                                fs.WriteByte(byteEn);

                                // Motor - 3 bytes
                                int nData;
                                for (j = 0; j < m_CHeader.nMotorCnt; j++)
                                {
                                    fValue = GridMotionEditor_GetMotor(i, j);
                                    // 속도모드인지를 먼저 체크 - 속도모드시 환산을 하지 않는다.
                                    bool bSpeed = Grid_GetFlag_Type(i, j); // true -> Speed, false -> Position
                                    int nMinus = 0;
                                    if ((bSpeed == true) && (fValue < 0))
                                    {
                                        nMinus = 0x4000; // 부호비트
                                        fValue *= -1.0f;
                                    }

                                    // 속도모드일땐 그냥 값을 적용하고, 위치모드일땐 각도 환산하도록 한다.
                                    nData = (int)(((bSpeed == false) ? CalcAngle2Evd(j, fValue) : ((int)Math.Round(fValue))) & 0x3fff);

                                    nData |= nMinus; // 부호비트
                                    nData |= (int)(((m_CHeader.pSMotorInfo[j].nMotorControlType >= 2) && (m_CHeader.pSMotorInfo[j].nMotorControlType <= 3)) ? 0x8000 : 0); // 엔코더 타입 정의

                                    //nData |= (int)((bStop == true) ? 0x10000 : 0); // 정지비트(1 인경우 정지(최상위 우선제어)
                                    nData |= (int)((bSpeed == true) ? 0x20000 : 0); // 위치제어(0), 속도제어(1)

                                    nData |= (int)(((Grid_GetFlag_Led(i, j) & 0x07) << 18) & 0x1C0000); // LED

                                    nData |= (int)((Grid_GetFlag_En(i, j) == false) ? 0x200000 : 0);

                                    //sData |= 0x0400; // 속도모드인때 정(0-0x0000), 역(1-0x0400)
                                    //sData |= LED;  // 00 - 0ff, 0x0800 - Red(01), 0x1000 - Blue(10), 0x1800 - Green(11)
                                    //sData |= 제어타입 // 0 - 위치, 0x2000 - 속도
                                    //sData |= 0x4000; //Enable // 개별 Enable (0 - Disable, 0x4000 - Enable)

                                    // Save
                                    fs.WriteByte((byte)((nData) & 0xff));
                                    fs.WriteByte((byte)((nData >> 8) & 0xff));
                                    fs.WriteByte((byte)((nData >> 16) & 0xff));
                                }

                                #region Speed(2), Delay(2), Group(1), Command(1), Data0(2), Data1(2), Data2(2), ExtBuzz(1), ExtLed(1)
                                #region Speed(2)
                                // Speed
                                sData = (short)GridMotionEditor_GetTime(i);
                                byteData = BitConverter.GetBytes(sData);
                                fs.Write(byteData, 0, 2);
                                byteData = null;
                                #endregion Speed(2)

                                #region Delay(2)
                                // Delay
                                sData = (short)GridMotionEditor_GetDelay(i);
                                byteData = BitConverter.GetBytes(sData);
                                fs.Write(byteData, 0, 2);
                                byteData = null;
                                #endregion Delay(2)

                                #region Group(1)
                                // Group
                                fs.WriteByte((byte)(m_CGridMotionEditor.GetGroup(i) & 0xff));
                                #endregion Group(1)

                                #region Command(1)
                                // Command
                                fs.WriteByte((byte)(GridMotionEditor_GetCommand(i) & 0xff));
                                #endregion Command(1)

                                #region Data0(2)
                                // Data0
                                sData = (short)GridMotionEditor_GetData0(i);
                                byteData = BitConverter.GetBytes(sData);
                                fs.Write(byteData, 0, 2);
                                byteData = null;
                                #endregion Data0(2)

                                #region Data1(2)
                                // Data1
                                sData = (short)GridMotionEditor_GetData1(i);
                                byteData = BitConverter.GetBytes(sData);
                                fs.Write(byteData, 0, 2);
                                byteData = null;
                                #endregion Data1(2)

                                #region Data2(2)
                                // Data2
                                sData = (short)GridMotionEditor_GetData2(i);
                                byteData = BitConverter.GetBytes(sData);
                                fs.Write(byteData, 0, 2);
                                byteData = null;
                                #endregion Data2(2)

                                #region ExtBuzz(1)
                                // Buzz
                                fs.WriteByte((byte)(GridMotionEditor_GetExtBuzz(i) & 0xff));
                                #endregion ExtBuzz(1)

                                #region ExtLed(1)
                                // Led
                                fs.WriteByte((byte)(GridMotionEditor_GetExtLed(i) & 0xff));
                                #endregion ExtLed(1)

                                #endregion Speed(2), Delay(2), Group(1), Command(1), Data0(2), Data1(2), Data2(2), ExtBuzz(1), ExtLed(1)
                                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                #region 추가한 Frame 위치 및 자세
                                fValue = (float)GetFrame_X(i);
                                byteData = BitConverter.GetBytes(fValue);
                                fs.Write(byteData, 0, 4);
                                byteData = null;

                                fValue = (float)GetFrame_Y(i);
                                byteData = BitConverter.GetBytes(fValue);
                                fs.Write(byteData, 0, 4);
                                byteData = null;

                                fValue = (float)GetFrame_Z(i);
                                byteData = BitConverter.GetBytes(fValue);
                                fs.Write(byteData, 0, 4);
                                byteData = null;


                                fValue = (float)GetFrame_Pan(i);
                                byteData = BitConverter.GetBytes(fValue);
                                fs.Write(byteData, 0, 4);
                                byteData = null;

                                fValue = (float)GetFrame_Tilt(i);
                                byteData = BitConverter.GetBytes(fValue);
                                fs.Write(byteData, 0, 4);
                                byteData = null;

                                fValue = (float)GetFrame_Swing(i);
                                byteData = BitConverter.GetBytes(fValue);
                                fs.Write(byteData, 0, 4);
                                byteData = null;
                                #endregion 추가한 Frame 위치 및 자세
                            }
                            #endregion

                                fs.WriteByte((byte)('M'));
                                fs.WriteByte((byte)('E'));

                                                    #region Comment
                            // Comment
                            for (int k = 0; k < byteComment.Length; k++) fs.WriteByte(byteComment[k]);
                            // 널 종료문자
                            if (byteComment.Length > 0) fs.WriteByte(0);
                            #endregion

                                                                                                                                            #region Caption 저장
                            // Caption Size
                            int nSize_Caption = 46;
                            // Caption
                            for (nFrameNum = 0; nFrameNum < nCntLine; nFrameNum++)
                            {
                                i = anFrameNum[nFrameNum];
                                //////////////////////////////////
                                strLineComment = m_CGridMotionEditor.GetCaption(i);
                                strLineComment = strLineComment.Trim();
                                if (strLineComment != "") // 주석
                                {
                                    byteData = BitConverter.GetBytes((short)i);
                                    fs.Write(byteData, 0, 2);
                                    byteData = null;

                                    byteData = Encoding.Default.GetBytes(strLineComment);
                                    if (byteData.Length > nSize_Caption)
                                    {
                                        for (int k = 0; k < nSize_Caption; k++) fs.WriteByte((byte)byteData[k]);
                                    }
                                    else
                                    {
                                        for (int k = 0; k < byteData.Length; k++) fs.WriteByte((byte)byteData[k]);
                                        for (int k = byteData.Length; k < nSize_Caption; k++) fs.WriteByte((byte)0);
                                    }
                                }
                            }
                            #endregion


                                fs.WriteByte((byte)('F'));
                                fs.WriteByte((byte)('E'));

                                fs.Close();
                                f = null;
                                if (m_bAutoSaved == false) Modify(false);

                                byteName = null;
                                byteComment = null;

                                bRet = true;
                            }
                            catch
                            {
                                //Message("파일 저장 에러");
                                fs.Close();
                                f = null;

                                bRet = false;
                            }
                            #endregion V1.2
                        }
                    }
                    catch (Exception ex)
                    {
                        bRet = false;
                        strErrMsg = ex.ToString();
                        CMessage.Write_Error(strErrMsg);
                    }

                    String strTmp = Ojw.CConvert.IntToStr(nFileVersion);// "V" + Ojw.CConvert.FloatToStr((float)nFileVersion / 10.0f);
                    //lbTitle.Text = m_strTitle + "[DMT1." + strTmp + "]" + strFileName;
                    m_strMotionFile_FileAndTitle = "[DMT1." + strTmp + "]" + strFileName;

                    if (bRet == true)
                    {
                        Ojw.CMessage.Write(String.Format("FileSaved: {0}", m_strMotionFile_FileAndTitle));
                        if (m_bMessageBoxShow == true) MessageBox.Show(String.Format("FileSaved: {0}", m_strMotionFile_FileAndTitle));
                    }
                    else
                    {
                        Ojw.CMessage.Write_Error(String.Format("We can't Save file: {0}", m_strMotionFile_FileAndTitle));
                        if (m_bMessageBoxShow == true) MessageBox.Show(String.Format("[Error] We can't Save file: {0}", m_strMotionFile_FileAndTitle), strErrMsg);
                    }
                    return bRet;
                }
#endif
                #endregion MotionFile
                private void m_ctxmenuMouse_ItemClicked(object sender, ToolStripItemClickedEventArgs e)
                {
                    //if (e.ClickedItem != m_ctxmenuMouse.Items[_MENU_FILE])
                    //    MessageBox.Show(e.ClickedItem.Text);        
#if false
                    if (e.ClickedItem == m_ctxmenuMouse.Items[_MENU_FILE])//"File")
                    {
                        m_nMenu = _MENU_FILE;
                    }
                    else if (e.ClickedItem == m_ctxmenuMouse.Items[_MENU_ITEM])
                    {
                        m_nMenu = _MENU_ITEM;
                    }
                    else m_nMenu = -1;
#endif
                }
                //private void m_ctxmenuMouse_Opened(object sender, EventArgs e)
                //{
                //    MessageBox.Show("Opened");

                //}
                //private void m_ctxmenuMouse_MouseMove(object sender, MouseEventArgs e)
                //{
                //    MessageBox.Show(e.ToString());
                //}

                
                public string m_strDesignerFilePath = String.Empty;
                public void FileImport()
                {
#if true
                    if (MessageBox.Show("Do you want me to copy all 3d-files for you?", "Files Copy(Import)", MessageBoxButtons.OKCancel) == System.Windows.Forms.DialogResult.OK)
                    {

                        OpenFileDialog dlg = new OpenFileDialog();
                        dlg.Multiselect = true;
                        if (dlg.ShowDialog() != DialogResult.OK) return;

                        //Ojw.CFile.FileCopy(String.Format("{0}{1}", Application.StartupPath, GetAseFile_Path()), dlg.FileNames);   
#if true
                        List<string> lstFiles = new List<string>();
                        lstFiles.Clear();

                        Ojw.C3d.COjwDesignerHeader CHeader = new COjwDesignerHeader();
                        int nMotorCount;
                        string strError;
                        string strPath = CFile.GetPath(dlg.FileName);
                        for (int i = 0; i < dlg.FileNames.Length; i++)
                        {
                            FileOpen_Without_Event(dlg.FileNames[i], out CHeader);
                            COjwDispAll CDispAll = new COjwDispAll();
                            int[] anMotorIDs;
                            CompileDesign(CHeader.strDrawModel, out CDispAll, out nMotorCount, out anMotorIDs, out strError);
                            //COjwDisp[] pCDisp;
                            string[] pstrLines = CHeader.strDrawModel.Split('\n');
                            COjwDisp CDisp = new COjwDisp();
                            string strItem;
                            for (int j = 0; j < CDispAll.GetCount(); j++)
                            {
                                strItem = Ojw.CConvert.RemoveChar(CDispAll.GetData(j).strDispObject, '!');
                                strItem = Ojw.CConvert.RemoveChar(strItem, '?');
                                if (strItem.IndexOf('#') < 0)
                                {
                                    strItem += ((strItem.IndexOf('.') < 0) ? ".ase" : "");
                                    if (lstFiles.Contains(strItem) == false)
                                    {
                                        lstFiles.Add(strItem);
                                    }
                                }
                            }
                            


                            
                            //int nMotorCount;
                            //string strError;
                            //CompileDesign(CHeader.strDrawModel, out nMotorCount, out strError);
                            //MessageBox.Show("Models[" + dlg.FileNames[i] + "] -> " + GetNoLoadedModelingFile());
                        }

                        string strTest = String.Empty;
                        string strTest_Fail = String.Empty;
                        if (lstFiles.Count > 0)
                        {
                            List<string> lstFind = new List<string>();
                            lstFind.Clear();
                            List<string> lstFind_Not = new List<string>();
                            lstFind_Not.Clear();

                            lstFind.AddRange(dlg.FileNames);
                            for (int i = 0; i < lstFiles.Count; i++)
                            {
                                string strFind = CFile.FindFile(strPath, lstFiles[i]);
                                if (strFind != null)
                                {
                                    lstFind.Add(strFind);
                                    strTest += strFind + "\r\\n";
                                }
                                else
                                {
                                    lstFind_Not.Add(lstFiles[i]);
                                    strTest_Fail += lstFiles[i] + "\r\n";
                                }
                            }
                            if (lstFind_Not.Count > 0)
                            {
                                strTest += "\r\n===============\r\n[fail]\r\n" + strTest_Fail;
                            }
                            //MessageBox.Show(strTest);

                            Ojw.CFile.FileCopy(String.Format("{0}{1}", Application.StartupPath, GetAseFile_Path()), lstFind.ToArray());
                        }

                        //else MessageBox.Show("No Files...");
#endif
                    }
#else
                    if (MessageBox.Show("Do you want me to Import all 3d-files(STL & Ojw) from Source?", "Files Copy(Import)", MessageBoxButtons.OKCancel) == System.Windows.Forms.DialogResult.OK)
                    {
                        OpenFileDialog dlg = new OpenFileDialog();
                        dlg.Multiselect = true;
                        if (dlg.ShowDialog() != DialogResult.OK) return;
                        
                        Ojw.C3d.COjwDesignerHeader CHeader = new COjwDesignerHeader();
                        for (int i = 0; i < dlg.FileNames.Length; i++)
                        {
                            if (FileOpen(dlg.FileNames[i], out CHeader) == true)
                            {
                                //CHeader.
                            }
                        }


                    }
                    if (FileOpen() == true)
                    {
                        string[] pstrList = GetNoLoadedModelingFile().Split(',');
                        string strTmp = Ojw.CConvert.ChangeString(GetNoLoadedModelingFile(), ",", "\r\n");
                        //MessageBox.Show(strTmp
                        ////if (GetModelingFiles_Count() > 0)
                        ////{
                        //    if (MessageBox.Show("Do you want me to Import all 3d-files(STL & Ojw) from Source?", "Files Copy(Import)", MessageBoxButtons.OKCancel) == System.Windows.Forms.DialogResult.OK)
                        //    {
                        //        string strPath = Application.StartupPath;
                        //        DirectoryInfo dirInfo = new DirectoryInfo(strPath);
                        //        List<string> lststrMissing = new List<string>();
                        //        lststrMissing.Clear();
                        //        if (dirInfo.Exists == true)
                        //        {
                        //            List<String> lstFiles = new List<string>();
                        //            lstFiles.Clear();
                        //            lstFiles.AddRange(GetModelingFiles());
                        //            lstFiles.Add(GetFileName());

                        //            string[] pstrMissing = Ojw.CFile.FileCopy(String.Format("{0}", Application.StartupPath), dirInfo.FullName, GetModelingFiles().ToArray());
                        //            if (pstrMissing.Length > 0)
                        //            {
                        //                string strError = String.Empty;
                        //                foreach (string strItem in pstrMissing) strError += strItem + ", ";
                        //                Ojw.CMessage.Write_Error("File Import Error => {0}", strError);
                        //            }
                        //            else Ojw.CMessage.Write("Done : (File Import)");
                        //        }        
                        //    }
                        ////}
                    }
#endif
                }
                public void FileExport()//FileExtract()
                {
                    if (FileOpen() == true)
                    {
                        if (GetModelingFiles_Count() > 0)
                        {
                            if (MessageBox.Show("Do you want me to copy all 3d-files for you?", "Files Copy(Export)", MessageBoxButtons.OKCancel) == System.Windows.Forms.DialogResult.OK)
                            {
                                FolderBrowserDialog dlg = new FolderBrowserDialog();
                                //dlg.SelectedPath = 

                                if (dlg.ShowDialog() != DialogResult.OK) return;

                                string strPath = dlg.SelectedPath;
                                DirectoryInfo dirInfo = new DirectoryInfo(strPath);
                                List<string> lststrMissing = new List<string>();
                                lststrMissing.Clear();
                                if (dirInfo.Exists == true)
                                {
                                    string[] pstrMissing = Ojw.CFile.FileCopy(String.Format("{0}{1}", Application.StartupPath, GetAseFile_Path()), dirInfo.FullName, GetModelingFiles().ToArray());
                                    if (pstrMissing.Length > 0)
                                    {
                                        string strError = String.Empty;
                                        foreach (string strItem in pstrMissing) strError += strItem + ", ";
                                        Ojw.CMessage.Write_Error("FileCopy Error => {0}", strError);
                                    }
                                    else Ojw.CMessage.Write("Done : (File Copy)");
                                    //foreach (string strItem in m_C3d.GetModelingFiles())
                                    //{
                                    //    string strFile = String.Format("{0}\\{1}{2}", m_C3d.GetAseFile_Path(), strItem, (strItem.IndexOf('.') < 0) ? ".ase" : "");
                                    //    //Ojw.CMessage.Write2("{0}\r\n", strItem);

                                    //}
                                }
                            }
                        }
                    }
                }
                private void m_ctxmenuMouse_DropDownItemClicked(object sender, ToolStripItemClickedEventArgs e)
                {
                    //MessageBox.Show("[Sub]" + e.ClickedItem.Text);
                    //if (m_nMenu >= 0)
                    {
                        m_ctxmenuMouse.Close();
                        
                        //if (e.ClickedItem.Text == "Open")
                        if (e.ClickedItem == (m_ctxmenuMouse.Items[_MENU_FILE] as ToolStripMenuItem).DropDownItems[_MENU_SUB_OPEN])
                        {
                            #region File Open
                            FileOpen();
                            #endregion File Open
                        }
                        else if (e.ClickedItem == (m_ctxmenuMouse.Items[_MENU_FILE] as ToolStripMenuItem).DropDownItems[_MENU_SUB_SAVE])
                        {
                            #region File Save
                            SaveFileDialog saveDlg = new SaveFileDialog();
                            saveDlg.FileName = "*." + _STR_EXT;
                            saveDlg.Filter = "Design file(*." + _STR_EXT + ")|*." + _STR_EXT;

                            saveDlg.DefaultExt = _STR_EXT;
                            if (saveDlg.ShowDialog() == DialogResult.OK)
                            {
                                String fileName = saveDlg.FileName;
                                if (fileName != null)
                                {
                                    if (fileName.Length > 0)
                                    {
                                        //m_strWorkDirectory = Directory.GetCurrentDirectory();
                                        //txtFileName.Text = fileName;

                                        FileSave(fileName, m_CHeader);
                                        Ojw.CMessage.Write(fileName + "(" + m_CHeader.strVersion + ") file saved");
                                    }
                                }
                            }
                            #endregion File Save
                        }
                        else if (e.ClickedItem == (m_ctxmenuMouse.Items[_MENU_FILE] as ToolStripMenuItem).DropDownItems[_MENU_SUB_CLOSE])
                        {
                            FileClose();
                        }
                        else if (e.ClickedItem == (m_ctxmenuMouse.Items[_MENU_FILE] as ToolStripMenuItem).DropDownItems[_MENU_SUB_EXPORT])
                        {
                            #region File Extract
                            FileExport();
                            #endregion File Extract
                        }
                        else if (e.ClickedItem == (m_ctxmenuMouse.Items[_MENU_FILE] as ToolStripMenuItem).DropDownItems[_MENU_SUB_IMPORT])
                        {
                            #region File Import
                            FileImport();
                            #endregion File Import
                        }
                        else if (e.ClickedItem == (m_ctxmenuMouse.Items[_MENU_FILE] as ToolStripMenuItem).DropDownItems[_MENU_SUB_MAKE_JSON])
                        {
                            string str = "noname.json";
                            if (Ojw.CInputBox.Show("Json Export", "File Name(*.json) 을 정해 주세요", ref str) == System.Windows.Forms.DialogResult.OK)
                            {
                                Json_Export(str);
                            }
                        }
                        else if (e.ClickedItem == (m_ctxmenuMouse.Items[_MENU_ITEM] as ToolStripMenuItem).DropDownItems[_MENU_SUB_ITEM_ADD])
                        {
                            AddVirtualClassToReal();
                        }
                    }
                }
                //private TextBox m_txtDraw = null;
                private RichTextBox m_rtxtDraw = null;

                public void SetDrawText_ForDisplay(RichTextBox rtxtDraw)
                {
                    rtxtDraw.Multiline = true;
                    rtxtDraw.WordWrap = false;

                    m_rtxtDraw.TextChanged -= new System.EventHandler(m_rtxtDraw_TextChanged);
                    m_rtxtDraw.KeyDown -= new KeyEventHandler(m_rtxtDraw_KeyDown);
                    m_rtxtDraw.MouseDown -= new MouseEventHandler(m_rtxtDraw_MouseDown);

                    m_rtxtDraw = rtxtDraw;

                    m_rtxtDraw.TextChanged += new System.EventHandler(m_rtxtDraw_TextChanged);
                    m_rtxtDraw.KeyDown += new KeyEventHandler(m_rtxtDraw_KeyDown);
                    m_rtxtDraw.MouseDown += new MouseEventHandler(m_rtxtDraw_MouseDown);
                }
                //public void SetDrawText_ForDisplay(TextBox txtDraw)
                //{
                //    txtDraw.Multiline = true;
                //    txtDraw.WordWrap = false;

                //    m_txtDraw.TextChanged -= new System.EventHandler(m_txtDraw_TextChanged);
                //    m_txtDraw.KeyDown -= new KeyEventHandler(m_txtDraw_KeyDown);
                //    m_txtDraw.MouseDown -= new MouseEventHandler(m_txtDraw_MouseDown);

                //    m_txtDraw = txtDraw;
                    
                //    m_txtDraw.TextChanged += new System.EventHandler(m_txtDraw_TextChanged);
                //    m_txtDraw.KeyDown += new KeyEventHandler(m_txtDraw_KeyDown);
                //    m_txtDraw.MouseDown += new MouseEventHandler(m_txtDraw_MouseDown);

                //}//m_txtDraw.TextChanged += new System.EventHandler(m_txtDraw_TextChanged); }
                //private void m_txtDraw_TextChanged(object sender, EventArgs e)
                //{
                //    //if (m_bEditing == false)
                //    {
                //        //GridToStringList();
                //        SetHeader_strDrawModel(m_txtDraw.Text);
                //        CompileDesign();
                //        StringListToGrid(); // for Gridview only
                //    }
                //}
                private void m_rtxtDraw_TextChanged(object sender, EventArgs e)
                {
                    //if (m_bEditing == false)
                    {
                        //GridToStringList();
                        SetHeader_strDrawModel(m_rtxtDraw.Text);
                        if (m_bFileOpening == false) CompileDesign();
                        StringListToGrid(); // for Gridview only
                    }
                }
                //public void SetDrawGrid_ForDisplay(DataGridView dgDraw) //{ //m_txtDraw = txtDraw; }
                //{
                //    //m_CGridMotionEditor = dgDraw;

                //}
                //private bool IsDrawText() 
                //{
                //    bool bRet = false;
                //    try
                //    {
                //        //bRet = ((m_txtDraw == null) ? false : true);
                //        if (m_txtDraw != null)
                //        {
                //            if (m_txtDraw.IsHandleCreated == true) 
                //                bRet = true;
                //        }
                //    }
                //    catch //(Exception e)
                //    {
                //        //Ojw.CMessage.Write_Error(e.ToString());
                //    }
                //    return bRet;
                //}
                private bool IsDrawRText()
                {
                    bool bRet = false;
                    try
                    {
                        //bRet = ((m_rtxtDraw == null) ? false : true);
                        if (m_rtxtDraw != null)
                        {
                            if (m_rtxtDraw.IsHandleCreated == true)
                                bRet = true;
                        }
                    }
                    catch //(Exception e)
                    {
                        //Ojw.CMessage.Write_Error(e.ToString());
                    }
                    return bRet;
                }

                private void PopupMenu()
                {
#if true
                    m_ctxmenuMouse = new System.Windows.Forms.ContextMenuStrip();
                    m_ctxmenuMouse.Items.Clear();
                    m_ctxmenuMouse.Items.Add("File");
                    (m_ctxmenuMouse.Items[_MENU_FILE] as ToolStripMenuItem).DropDownItems.Add("Open");
                    (m_ctxmenuMouse.Items[_MENU_FILE] as ToolStripMenuItem).DropDownItems.Add("Save");
                    (m_ctxmenuMouse.Items[_MENU_FILE] as ToolStripMenuItem).DropDownItems.Add("Close");
                    (m_ctxmenuMouse.Items[_MENU_FILE] as ToolStripMenuItem).DropDownItems.Add("-");
                    (m_ctxmenuMouse.Items[_MENU_FILE] as ToolStripMenuItem).DropDownItems.Add("Export(3D Model에 포함된 stl file들을 지정한 위치로 복사)");
                    (m_ctxmenuMouse.Items[_MENU_FILE] as ToolStripMenuItem).DropDownItems.Add("Import(3D Model에 필요한 stl file들을 지정한 폴더에서 골라 가져옴)");
                    (m_ctxmenuMouse.Items[_MENU_FILE] as ToolStripMenuItem).DropDownItems.Add("-");
                    (m_ctxmenuMouse.Items[_MENU_FILE] as ToolStripMenuItem).DropDownItems.Add("Make Json 3D Model File");
                    (m_ctxmenuMouse.Items[_MENU_FILE] as ToolStripMenuItem).DropDownItemClicked += new ToolStripItemClickedEventHandler(m_ctxmenuMouse_DropDownItemClicked);
                    m_ctxmenuMouse.Items.Add("Item");
                    (m_ctxmenuMouse.Items[_MENU_ITEM] as ToolStripMenuItem).DropDownItems.Add("Add");
                    (m_ctxmenuMouse.Items[_MENU_ITEM] as ToolStripMenuItem).DropDownItemClicked += new ToolStripItemClickedEventHandler(m_ctxmenuMouse_DropDownItemClicked);
#else
                    m_ctxmenuMouse.Items.Add("Test0");
                    m_ctxmenuMouse.Items.Add("Test1");
                    m_ctxmenuMouse.Items.Add("Test2");
                    m_ctxmenuMouse.Items.Add("Test3");
                    m_ctxmenuMouse.Items.Add("Test4");
                    m_ctxmenuMouse.Items.Add("Test5");
                    m_ctxmenuMouse.Items.Add("Test6");
                    (m_ctxmenuMouse.Items[1] as ToolStripMenuItem).DropDownItems.Add("SubTest0");
                    (m_ctxmenuMouse.Items[1] as ToolStripMenuItem).DropDownItems.Add("SubTest1");
                    (m_ctxmenuMouse.Items[1] as ToolStripMenuItem).DropDownItemClicked += new ToolStripItemClickedEventHandler(m_ctxmenuMouse_DropDownItemClicked);
#endif
                    //m_ctxmenuMouse.Items[1].Click += new EventHandler(m_ctxmenuMouse);

                    m_ctxmenuMouse.Show(Cursor.Position.X, Cursor.Position.Y);
                }
#if false
                public void OjwKeyDown(KeyEventArgs e)
                {
                    int nKey = e.KeyValue;

                    //if (e.Control == true) m_bKey_Ctrl = true; else m_bKey_Ctrl = false;
                    //if (e.Alt == true) m_bKey_Alt = true; else m_bKey_Alt = false;
                    //if (e.Shift == true) m_bKey_Shift = true; else m_bKey_Shift = false;

                    switch (e.KeyCode)
                    {
                        #region Keys.Up
                        case Keys.Up:
                            {
                                if (e.Control)
                                {
                                }
                                else
                                {
                                    int nDir = 1;
                                    m_afLookat_Dir[nDir] += 0.1f;
                                    if (m_afLookat_Dir[nDir] > 1.0f) m_afLookat_Dir[nDir] = 1.0f;
                                }
                            }
                            break;
                        #endregion Keys.Up
                        #region Keys.Down
                        case Keys.Down:
                            {
                                if (e.Control)
                                {
                                }
                                else
                                {
                                    int nDir = 1;
                                    m_afLookat_Dir[nDir] -= 0.1f;
                                    if (m_afLookat_Dir[nDir] <= 0.0f) m_afLookat_Dir[nDir] = 0.0f;
                                }
                            }
                            break;
                        #endregion Keys.Down
                            
                        #region Keys.Left
                        case Keys.Left:
                            {
                                if (e.Control)
                                {
                                }
                                else
                                {
                                    int nDir = 0;
                                    m_afLookat_Dir[nDir] += 0.1f;
                                    if (m_afLookat_Dir[nDir] > 1.0f) m_afLookat_Dir[nDir] = 1.0f;
                                }
                            }
                            break;
                        #endregion Keys.Left
                        #region Keys.Right
                        case Keys.Right:
                            {
                                if (e.Control)
                                {
                                }
                                else
                                {
                                    int nDir = 0;
                                    m_afLookat_Dir[nDir] -= 0.1f;
                                    if (m_afLookat_Dir[nDir] <= 0.0f) m_afLookat_Dir[nDir] = 0.0f;
                                }
                            }
                            break;
                        #endregion Keys.Right
                        #region Keys.Escape - ESC : 긴급정지
                        //case Keys.Escape:
                        //    {
                        //        Stop();
                        //        //Cmd_Stop(m_nCurrentRobot);
                        //    }
                        //    break;
                        #endregion Keys.Escape - ESC : 긴급정지
                        #region Keys.Delete: - 삭제하기
                        case Keys.Delete:
                            {
                                if (e.Control)
                                {
                                }
                                else
                                {
                                }
                            }
                            break;
                        #endregion Keys.Delete: - 삭제하기
                    }
#if false
                    float fDelta2 = 0.1f;// 1.0f;
                    //m_fMouse_W_Left -= (float)((e.Delta > 0) ? -fDelta2 : fDelta2);
                    m_fMouse_W_Left = (float)((e.Delta > 0) ? -fDelta2 : fDelta2);

                    //if (m_fMouse_W_Left < 0) m_fMouse_W_Left = 0.0f;

                    double dPos_X = 0;// (e.X - m_nMouse_X_Left);
                    double dPos_Y = 0;// (m_nMouse_Y_Left - e.Y);
                    double dPos_Z = (double)m_fMouse_W_Left;// (m_fMouse_W_Left - e.Y);
                    float fAngle_X, fAngle_Y, fAngle_Z;
                    GetAngle_Display(out fAngle_Y, out fAngle_X, out fAngle_Z);
                    //GetAngle_(out m_afLookat[0], out m_afLookat[1], out m_afLookat[2]);

                    CMath.CalcRot(0, 0, (double)(-fAngle_Z), ref dPos_X, ref dPos_Y, ref dPos_Z);
                    CMath.CalcRot(0, (double)(-fAngle_Y), 0, ref dPos_X, ref dPos_Y, ref dPos_Z);
                    CMath.CalcRot((double)(-fAngle_X), 0, 0, ref dPos_X, ref dPos_Y, ref dPos_Z);

                    //if (
                    //((m_afLookat[0] + dPos_X) > 0) &&
                    //((m_afLookat[1] + dPos_Y) > 0) &&
                    //((m_afLookat[2] + dPos_Z) > 0)
                    //)
                    {
                        m_afLookat[0] += (float)dPos_X;
                        m_afLookat[1] += (float)dPos_Y;
                        m_afLookat[2] += (float)dPos_Z;
                    }
                    //    int nMotCnt = m_CHeader.nMotorCnt;
                    //for (int i = 0; i < nMotCnt; i++)
                    //{
                    //    SetData(i, (float)CKinematics.CInverse.GetValue_Motor(i));
                    //}
                    //Glu.gluLookAt(m_afLookat[0], m_afLookat[1], m_afLookat[2], 0, 0, 0, 0, 1, 0);
                    //Glu.
#endif
                }
                public void OjwKeyUp(KeyEventArgs e)
                {
                }
#endif
                
                public void OjwMouseUp(MouseEventArgs e)
                {
                    m_nSeq_MouseUp++;

                    //OjwDraw();
                    //m_nMouse_X_Left = e.X;
                    //m_nMouse_Y_Left = e.Y; 
                    //m_nMouse_X_Right = e.X;
                    //m_nMouse_Y_Right = e.Y;


                    //m_bPickMouseClick = true;
                    //m_bPickMouseClick_Reserve = true;
                    //SetPickCheck_OneShot(e.X, e.Y);

#if true
                    if (m_bMouseClick == true)
                    {
                        if (e.Button == MouseButtons.Right)
                        {
                            //m_fLeg0 = m_fMouseMove - e.X;
                            if (m_bShowPopup == true)
                            {
                                // m_nMenuStatus == 0 => Dragging...
                                //if ((GetMouseMode() == 0) && (m_nMenuStatus != 0))
                                if (m_nMenuStatus != 0)
                                    PopupMenu();                                
                            }
                        }
                        
                        //// 마우스 제어시에 그리드를 생성한 경우 그리드에 값이 갱신되도록 ...                        
                        if (m_CGridMotionEditor != null)
                        {
                            if (m_CGridMotionEditor.m_nGridMode == 1)
                            {
                                if (m_CHeader != null)
                                {
#if true
                                    for (int i = 0; i < m_CHeader.nMotorCnt; i++)
                                    {
                                        int nID = m_CHeader.anMotorIDs[i];
                                        float fValue = GetData(nID);
                                        int nIndex = m_lstIDs_Motion.FindIndex(x => x == nID);
                                        if (nID < 0) continue;
                                        if ((m_CHeader.pSMotorInfo[nID].nMotor_Enable < 0) || (m_CHeader.pSMotorInfo[nID].nMotor_Enable > 1))
                                            continue;
                                        try
                                        {
                                            GridMotionEditor_SetMotor(GridMotionEditor_GetCurrentLine(), nIndex, fValue);
                                            //SetData(nID, GridMotionEditor_GetMotor(GridMotionEditor_GetCurrentLine(), nID));
                                            //SetData(nID, GridMotionEditor_GetMotor(GridMotionEditor_GetCurrentLine(), nID));
                                        }
                                        catch
                                        {
                                            fValue = GetData(nID);
                                            SetData(nID, fValue);
                                        }
                                    }
#else
                                    for (int i = 0; i < m_CHeader.nMotorCnt; i++)
                                    {
                                        //GridMotionEditor_SetMotor(GridMotionEditor_GetCurrentLine(), i, GetData(i));
                                        int nID = m_CHeader.anMotorIDs[i];
                                        if (nID < 0) continue;
                                        if ((m_CHeader.pSMotorInfo[nID].nMotor_Enable < 0) || (m_CHeader.pSMotorInfo[nID].nMotor_Enable > 1))
                                            continue;
                                        try
                                        {
                                            GridMotionEditor_SetMotor(GridMotionEditor_GetCurrentLine(), nID, GetData(nID));
                                            //SetData(nID, GridMotionEditor_GetMotor(GridMotionEditor_GetCurrentLine(), nID));
                                            //SetData(nID, GridMotionEditor_GetMotor(GridMotionEditor_GetCurrentLine(), nID));
                                        }
#if false
                                        int nID = m_CHeader.anMotorIDs[i];
                                        if (nID < 0) continue;
                                        if ((m_CHeader.pSMotorInfo[nID].nMotor_Enable < 0) || (m_CHeader.pSMotorInfo[nID].nMotor_Enable > 1))
                                            continue;
                                        try
                                        {
                                            SetData(nID, GridMotionEditor_GetMotor(GridMotionEditor_GetCurrentLine(), nID));
                                            //SetData(nID, GridMotionEditor_GetMotor(GridMotionEditor_GetCurrentLine(), nID));
                                        }
#endif
                                        catch
                                        {
                                            float fValue = GetData(nID);
                                            SetData(nID, fValue);
                                        }
                                    }
#endif
                                }
                            }
                            else if (m_bGridInit == true)
                            {
                                if (m_CHeader != null)
                                {
                                    for (int i = 0; i < m_CHeader.nMotorCnt; i++)
                                    {
                                        int nID = i;
                                        if (m_CHeader.anMotorIDs != null)
                                            nID = m_CHeader.anMotorIDs[i];
                                        GridMotionEditor_SetMotor(GridMotionEditor_GetCurrentLine(), nID, GetData(nID));
                                    }
                                }
                            }
                        }
                        //Ojw.CMessage.Write("MouseUp");
                    }
#endif
                    m_bMouseClick = false;
                }

                //private string m_strTitle = "";
                //private int m_nModelNum = -1;
                //private string m_strModelName = "";
                private int m_nMouseControlMode = 1;// 0;
                public void SetMouseMode_Move() { SetMouseMode(0); }
                public void SetMouseMode_Control() { SetMouseMode(1); }
                public void SetMouseMode_Ext() { SetMouseMode(2); }
                public void SetMouseMode(int nControl) { m_nMouseControlMode = nControl; }
                public int GetMouseMode() { return m_nMouseControlMode; }
                private bool m_bFreeze_X = false;
                private bool m_bFreeze_Y = false;
                private bool m_bFreeze_Z = false;
                public void SetFreeze_X(bool bFreeze) { m_bFreeze_X = bFreeze; }
                public void SetFreeze_Y(bool bFreeze) { m_bFreeze_Y = bFreeze; }
                public void SetFreeze_Z(bool bFreeze) { m_bFreeze_Z = bFreeze; }
                public bool GetFreeze_X() { return m_bFreeze_X; }
                public bool GetFreeze_Y() { return m_bFreeze_Y; }
                public bool GetFreeze_Z() { return m_bFreeze_Z; }
                private bool m_bFreeze_Pan = false;
                private bool m_bFreeze_Tilt = false;
                private bool m_bFreeze_Swing = false;
                public void SetFreeze_Pan(bool bFreeze) { m_bFreeze_Pan = bFreeze; }
                public void SetFreeze_Tilt(bool bFreeze) { m_bFreeze_Tilt = bFreeze; }
                public void SetFreeze_Swing(bool bFreeze) { m_bFreeze_Swing = bFreeze; }
                public bool GetFreeze_Pan() { return m_bFreeze_Pan; }
                public bool GetFreeze_Tilt() { return m_bFreeze_Tilt; }
                public bool GetFreeze_Swing() { return m_bFreeze_Swing; }
                public void OjwMouseMove(object sender, MouseEventArgs e) { OjwMouseMove(e); }
                public int m_nMenuStatus = 0;
                public bool m_bShowPopup = true;//false;
                public void ShowPopup(bool bEn) { m_bShowPopup = bEn; }
                public void OjwMouseMove(MouseEventArgs e)
                {
                    if (m_bMouseClick == true)
                    {
                        if (e.Button == MouseButtons.Left)
                        {
                            //m_fLeg0 = m_fMouseMove - e.X;
                            if (GetMouseMode() == 0)
                            {
                                #region View Change
#if false // 화면 이동(View Change)을 직관적으로 변경 with Mouse
                                m_fX -= (m_nMouse_X_Left - e.X);
                                m_fY += (m_nMouse_Y_Left - e.Y);
#else
                                double dPos_X = (e.X - m_nMouse_X_Left);
                                double dPos_Y = (m_nMouse_Y_Left - e.Y);
                                double dPos_Z = 0;
                                
                                float fAngle_X, fAngle_Y, fAngle_Z;
                                GetAngle_Display(out fAngle_Y, out fAngle_X, out fAngle_Z);
                                CMath.CalcRot(0, 0, (double)(-fAngle_Z), ref dPos_X, ref dPos_Y, ref dPos_Z);
                                CMath.CalcRot(0, (double)(-fAngle_Y), 0, ref dPos_X, ref dPos_Y, ref dPos_Z);
                                CMath.CalcRot((double)(-fAngle_X), 0, 0, ref dPos_X, ref dPos_Y, ref dPos_Z);

                                m_fX += (GetFreeze_X() == true) ? 0.0f : (float)dPos_X;
                                m_fY += (GetFreeze_Y() == true) ? 0.0f : (float)dPos_Y;
                                m_fZ += (GetFreeze_Z() == true) ? 0.0f : (float)dPos_Z;
#endif                               
                                #endregion View Change
                            }
                            else if (GetMouseMode() == 1)
                            {
                                int nInverseNum = m_nSelected_InverseKinematicsNumber;// m_nStatus_InverseKinematicsNumber;
                                #region Motor Control
                                if (nInverseNum == 255)
                                {
                                    SetData(m_anSelectedGroup[1], GetData(m_anSelectedGroup[1]) + e.X - m_nMouse_X_Left);
                                }
                                #endregion Motor Control
                                #region Kinematics Control
                                else
                                {
                                    //float fR_T = GetMot(8) - GetMot(7);// -GetMot(9);
                                    //float fR_S = GetMot(6) - GetMot(10);
                                    //float fL_T = GetMot(13) - GetMot(12);// -GetMot(14);
                                    //float fL_S = GetMot(11) - GetMot(15);
                                    double dPos_X = (e.X - m_nMouse_X_Left);
                                    double dPos_Y = (m_nMouse_Y_Left - e.Y);
                                    double dPos_Z = 0;
                                    float fAngle_X, fAngle_Y, fAngle_Z;
                                    GetAngle_Display(out fAngle_Y, out fAngle_X, out fAngle_Z);
                                    CMath.CalcRot(0, 0, (double)(-fAngle_Z), ref dPos_X, ref dPos_Y, ref dPos_Z);
                                    CMath.CalcRot(0, (double)(-fAngle_Y), 0, ref dPos_X, ref dPos_Y, ref dPos_Z);
                                    CMath.CalcRot((double)(-fAngle_X), 0, 0, ref dPos_X, ref dPos_Y, ref dPos_Z);
                                    //m_COjwCsgl.Rotation(m_fDisp_Tilt, m_fDisp_Pan, m_fDisp_Swing, ref fPos_X, ref fPos_Y, ref fPos_Z);

                                    // 2D -> 3D rotation : rotate (e.X - m_nX) 
                                    // Pan - Rotation(Y)
                                    // Tilt - Rotation(X)
                                    // Swing - Rotation(Z)
                                    #region Kor
                                    // 2차원을 3차원으로 회전 : (e.X - m_nX) 를 회전
                                    // Pan - Y축 회전
                                    // Tilt - X축 회전
                                    // Swing - Z축 회전
                                    #endregion Kor
#if true
                                    m_dPos_X += (GetFreeze_X() == true) ? 0.0f : dPos_X;
                                    m_dPos_Y += (GetFreeze_Y() == true) ? 0.0f : dPos_Y;
                                    m_dPos_Z += (GetFreeze_Z() == true) ? 0.0f : dPos_Z;
#else
                                    m_dPos_X += dPos_X;
                                    m_dPos_Y += dPos_Y;
                                    m_dPos_Z += dPos_Z;
#endif
                                    int nMotCnt = m_CHeader.pSOjwCode[nInverseNum].nMotor_Max;
                                    if (nMotCnt > 0)
                                    {
                                        CKinematics.CInverse.SetValue_ClearAll(ref m_CHeader.pSOjwCode[nInverseNum]);
                                        CKinematics.CInverse.SetValue_X(m_dPos_X);
                                        CKinematics.CInverse.SetValue_Y(m_dPos_Y);
                                        CKinematics.CInverse.SetValue_Z(m_dPos_Z);

                                        double[] adMot = new double[m_afMot.Length];
                                        //Buffer.BlockCopy(GetData(), 0, adMot, 0, adMot.Length);
                                        for (int i = 0; i < m_afMot.Length; i++) adMot[i] = (double)m_afMot[i];
                                        CKinematics.CInverse.SetValue_Motor(adMot);
                                        adMot = null;

                                        CKinematics.CInverse.CalcCode(ref m_CHeader.pSOjwCode[nInverseNum]);
                                        //OjwMessage(CKinematics.CInverse.GetValue_V(0).ToString() + ", " + CKinematics.CInverse.GetValue_V(1).ToString() + ", " + CKinematics.CInverse.GetValue_V(2).ToString());


                                        for (int i = 0; i < nMotCnt; i++)
                                        {
                                            int nMotNum = m_CHeader.pSOjwCode[nInverseNum].pnMotor_Number[i];
                                            SetData(nMotNum, (float)CKinematics.CInverse.GetValue_Motor(nMotNum));
                                        }
                                    }
                                    else
                                    {
                                        //CalcInv(nInverseNum, GetHeader_pDhParamAll()[nInverseNum].GetMotors(), (float)m_dPos_X, (float)m_dPos_Y, (float)m_dPos_Z, 10, 0.1f);
                                        CalcInv(nInverseNum, (float)m_dPos_X, (float)m_dPos_Y, (float)m_dPos_Z, 10, 0.1f);
                                    }
                                    /////////////////
                                }
                                #endregion Kinematics Control
                            }
                            else if (GetMouseMode() == 2) // 2
                            {
                                #region Robot Control(Rotation)
                                m_fPan_Robot -= (m_nMouse_X_Left - e.X);
                                m_fTilt_Robot += (m_nMouse_Y_Left - e.Y);
                                #endregion Robot Control(Rotation)
                            }
                            else if (GetMouseMode() == 3) // 3
                            {
                                #region Robot Control(Translation)
                                m_fX_Robot -= (m_nMouse_X_Left - e.X);
                                m_fY_Robot += (m_nMouse_Y_Left - e.Y);
                                #endregion Robot Control(Translation)
                            }
                            else if ((GetMouseMode() >= 4) && (GetMouseMode() <= 6))
                            {
                                #region Offset Translation X ~ Z
                                SVector3D_t SVec = Prop_Get_Offset_Trans();
                                float fValue = (e.Button == MouseButtons.Right) ? 0.1f : 1.0f;
                                //if (e.Delta < 0) fValue = -fValue;
                                //Prop_Set_Offset_Trans(m_C3d_Designer.Prop_Get_Width_Or_Radius() + fValue);
                                //m_C3d_Designer.Prop_Update_VirtualObject();
                                
                                double dPos_X = (e.X - m_nMouse_X_Left);
                                double dPos_Y = (m_nMouse_Y_Left - e.Y);
                                double dPos_Z = 0;
                                float fAngle_X, fAngle_Y, fAngle_Z;
                                GetAngle_Display(out fAngle_Y, out fAngle_X, out fAngle_Z);
                                CMath.CalcRot(0, 0, (double)(-fAngle_Z), ref dPos_X, ref dPos_Y, ref dPos_Z);
                                CMath.CalcRot(0, (double)(-fAngle_Y), 0, ref dPos_X, ref dPos_Y, ref dPos_Z);
                                CMath.CalcRot((double)(-fAngle_X), 0, 0, ref dPos_X, ref dPos_Y, ref dPos_Z);
                                //m_COjwCsgl.Rotation(m_fDisp_Tilt, m_fDisp_Pan, m_fDisp_Swing, ref fPos_X, ref fPos_Y, ref fPos_Z);

                                // 2D -> 3D rotation : rotate (e.X - m_nX) 
                                // Pan - Rotation(Y)
                                // Tilt - Rotation(X)
                                // Swing - Rotation(Z)
                                #region Kor
                                // 2차원을 3차원으로 회전 : (e.X - m_nX) 를 회전
                                // Pan - Y축 회전
                                // Tilt - X축 회전
                                // Swing - Z축 회전
                                #endregion Kor

                                //m_dPos_X += (GetFreeze_X() == true) ? 0.0f : dPos_X;
                                //m_dPos_Y += (GetFreeze_Y() == true) ? 0.0f : dPos_Y;
                                //m_dPos_Z += (GetFreeze_Z() == true) ? 0.0f : dPos_Z;
                                int nDir = GetMouseMode() - 4;
                                SVec.x += (nDir == 0) ? (float)dPos_X : 0.0f;
                                SVec.y += (nDir == 1) ? (float)dPos_Y : 0.0f;
                                SVec.z += (nDir == 2) ? (float)dPos_Z : 0.0f;


                                Prop_Set_Offset_Trans(SVec);
                                Prop_Update_VirtualObject();



                                //Prop_Set_Offset_Trans(SVec);
                                //Prop_Update_VirtualObject();
                                //OjwVirtualDisp.SOffset_Trans = SVec;
                                //m_CPropAll.SOffset_Trans = SVec;//SOffset_Trans(SVec);
                                #endregion Offset Translation X ~ Z
                                OjwDraw();
                            }
                            else if ((GetMouseMode() >= 7) && (GetMouseMode() <= 9))
                            {
                                #region Offset Rotation X ~ Z
                                SAngle3D_t SAngle = Prop_Get_Offset_Rot();
                                //SVector3D_t SVec = Prop_Get_Offset_Trans();
                                float fValue = (e.Button == MouseButtons.Right) ? 0.1f : 1.0f;

                                double dPos_X = (e.X - m_nMouse_X_Left);
                                double dPos_Y = (m_nMouse_Y_Left - e.Y);
                                double dPos_Z = 0;
                                float fAngle_X, fAngle_Y, fAngle_Z;
                                GetAngle_Display(out fAngle_Y, out fAngle_X, out fAngle_Z);
                                CMath.CalcRot(0, 0, (double)(-fAngle_Z), ref dPos_X, ref dPos_Y, ref dPos_Z);
                                CMath.CalcRot(0, (double)(-fAngle_Y), 0, ref dPos_X, ref dPos_Y, ref dPos_Z);
                                CMath.CalcRot((double)(-fAngle_X), 0, 0, ref dPos_X, ref dPos_Y, ref dPos_Z);
                                // 2D -> 3D rotation : rotate (e.X - m_nX) 
                                // Pan - Rotation(Y)
                                // Tilt - Rotation(X)
                                // Swing - Rotation(Z)
                                #region Kor
                                // 2차원을 3차원으로 회전 : (e.X - m_nX) 를 회전
                                // Pan - Y축 회전
                                // Tilt - X축 회전
                                // Swing - Z축 회전
                                #endregion Kor

                                int nDir = GetMouseMode() - 7;
                                SAngle.tilt += (nDir == 0) ? (float)dPos_X : 0.0f;
                                SAngle.pan += (nDir == 1) ? (float)dPos_Y : 0.0f;
                                SAngle.swing += (nDir == 2) ? (float)dPos_Z : 0.0f;

                                Prop_Set_Offset_Rot(SAngle);
                                Prop_Update_VirtualObject();

                                #endregion Offset Rotation X ~ Z
                                OjwDraw();
                            }
                            else if ((GetMouseMode() >= 10) && (GetMouseMode() <= 12))
                            {
                                #region Offset Translation X ~ Z
                                SVector3D_t SVec = Prop_Get_Trans_1();
                                float fValue = (e.Button == MouseButtons.Right) ? 0.1f : 1.0f;
                                //if (e.Delta < 0) fValue = -fValue;
                                //Prop_Set_Offset_Trans(m_C3d_Designer.Prop_Get_Width_Or_Radius() + fValue);
                                //m_C3d_Designer.Prop_Update_VirtualObject();

                                double dPos_X = (e.X - m_nMouse_X_Left);
                                double dPos_Y = (m_nMouse_Y_Left - e.Y);
                                double dPos_Z = 0;
                                float fAngle_X, fAngle_Y, fAngle_Z;
                                GetAngle_Display(out fAngle_Y, out fAngle_X, out fAngle_Z);
                                CMath.CalcRot(0, 0, (double)(-fAngle_Z), ref dPos_X, ref dPos_Y, ref dPos_Z);
                                CMath.CalcRot(0, (double)(-fAngle_Y), 0, ref dPos_X, ref dPos_Y, ref dPos_Z);
                                CMath.CalcRot((double)(-fAngle_X), 0, 0, ref dPos_X, ref dPos_Y, ref dPos_Z);
                                //m_COjwCsgl.Rotation(m_fDisp_Tilt, m_fDisp_Pan, m_fDisp_Swing, ref fPos_X, ref fPos_Y, ref fPos_Z);

                                // 2D -> 3D rotation : rotate (e.X - m_nX) 
                                // Pan - Rotation(Y)
                                // Tilt - Rotation(X)
                                // Swing - Rotation(Z)
                                #region Kor
                                // 2차원을 3차원으로 회전 : (e.X - m_nX) 를 회전
                                // Pan - Y축 회전
                                // Tilt - X축 회전
                                // Swing - Z축 회전
                                #endregion Kor

                                //m_dPos_X += (GetFreeze_X() == true) ? 0.0f : dPos_X;
                                //m_dPos_Y += (GetFreeze_Y() == true) ? 0.0f : dPos_Y;
                                //m_dPos_Z += (GetFreeze_Z() == true) ? 0.0f : dPos_Z;
                                int nDir = GetMouseMode() - 10;
                                SVec.x += (nDir == 0) ? (float)dPos_X : 0.0f;
                                SVec.y += (nDir == 1) ? (float)dPos_Y : 0.0f;
                                SVec.z += (nDir == 2) ? (float)dPos_Z : 0.0f;
                                
                                Prop_Set_Trans_1(SVec);
                                Prop_Update_VirtualObject();

                                //Prop_Set_Offset_Trans(SVec);
                                //Prop_Update_VirtualObject();
                                //OjwVirtualDisp.SOffset_Trans = SVec;
                                //m_CPropAll.SOffset_Trans = SVec;//SOffset_Trans(SVec);
                                #endregion Offset Translation X ~ Z
                                OjwDraw();
                            }
                            else if ((GetMouseMode() >= 13) && (GetMouseMode() <= 15))
                            {
                                #region Rotation X ~ Z
                                SAngle3D_t SAngle = Prop_Get_Rot_1();
                                //SVector3D_t SVec = Prop_Get_Offset_Trans();
                                float fValue = (e.Button == MouseButtons.Right) ? 0.1f : 1.0f;

                                double dPos_X = (e.X - m_nMouse_X_Left);
                                double dPos_Y = (m_nMouse_Y_Left - e.Y);
                                double dPos_Z = 0;
                                float fAngle_X, fAngle_Y, fAngle_Z;
                                GetAngle_Display(out fAngle_Y, out fAngle_X, out fAngle_Z);
                                CMath.CalcRot(0, 0, (double)(-fAngle_Z), ref dPos_X, ref dPos_Y, ref dPos_Z);
                                CMath.CalcRot(0, (double)(-fAngle_Y), 0, ref dPos_X, ref dPos_Y, ref dPos_Z);
                                CMath.CalcRot((double)(-fAngle_X), 0, 0, ref dPos_X, ref dPos_Y, ref dPos_Z);
                                // 2D -> 3D rotation : rotate (e.X - m_nX) 
                                // Pan - Rotation(Y)
                                // Tilt - Rotation(X)
                                // Swing - Rotation(Z)
                                #region Kor
                                // 2차원을 3차원으로 회전 : (e.X - m_nX) 를 회전
                                // Pan - Y축 회전
                                // Tilt - X축 회전
                                // Swing - Z축 회전
                                #endregion Kor

                                int nDir = GetMouseMode() - 13;
                                SAngle.tilt += (nDir == 0) ? (float)dPos_X : 0.0f;
                                SAngle.pan += (nDir == 1) ? (float)dPos_Y : 0.0f;
                                SAngle.swing += (nDir == 2) ? (float)dPos_Z : 0.0f;

                                Prop_Set_Rot_1(SAngle);
                                Prop_Update_VirtualObject();

                                #endregion Rotation X ~ Z
                                OjwDraw();
                            }

                            //// 마우스 제어시에 그리드를 생성한 경우 그리드에 값이 갱신되도록 ...
#if true
                            if (m_CGridMotionEditor != null)
                            {
                                if (m_CGridMotionEditor.m_nGridMode == 1)
                                {
                                    if (m_CHeader != null)
                                    {
#if false
                                        for (int i = 0; i < m_CHeader.nMotorCnt; i++)
                                        {
                                            //GridMotionEditor_SetMotor(GridMotionEditor_GetCurrentLine(), i, GetData(i));

                                            int nID = m_CHeader.anMotorIDs[i];
                                            if (nID < 0) continue;
                                            if ((m_CHeader.pSMotorInfo[nID].nMotor_Enable < 0) || (m_CHeader.pSMotorInfo[nID].nMotor_Enable > 1))
                                                continue;
                                            try
                                            {
                                                GridMotionEditor_SetMotor(GridMotionEditor_GetCurrentLine(), nID, GetData(nID));
                                                //SetData(nID, GridMotionEditor_GetMotor(GridMotionEditor_GetCurrentLine(), nID));
                                                //SetData(nID, GridMotionEditor_GetMotor(GridMotionEditor_GetCurrentLine(), nID));
                                            }
                                            catch
                                            {
                                                float fValue = GetData(nID);
                                                SetData(nID, fValue);
                                            }
                                        }
#else
                                        for (int i = 0; i < m_CHeader.nMotorCnt; i++)
                                        {
                                            int nID = m_CHeader.anMotorIDs[i];
                                            float fValue = GetData(nID);
                                            int nIndex = m_lstIDs_Motion.FindIndex(x => x == nID);
                                            if (nID < 0) continue;
                                            if ((m_CHeader.pSMotorInfo[nID].nMotor_Enable < 0) || (m_CHeader.pSMotorInfo[nID].nMotor_Enable > 1))
                                                continue;
                                            try
                                            {
                                                GridMotionEditor_SetMotor(GridMotionEditor_GetCurrentLine(), nIndex, fValue);
                                                //SetData(nID, GridMotionEditor_GetMotor(GridMotionEditor_GetCurrentLine(), nID));
                                                //SetData(nID, GridMotionEditor_GetMotor(GridMotionEditor_GetCurrentLine(), nID));
                                            }
                                            catch
                                            {
                                                fValue = GetData(nID);
                                                SetData(nID, fValue);
                                            }
                                        }
#endif
                                    }
                                }
                                else if (m_bGridInit == true)
                                {
                                    if (m_CHeader != null)
                                    {
                                        for (int i = 0; i < m_CHeader.nMotorCnt; i++)
                                        {
                                            int nID = i;
                                            if (m_CHeader.anMotorIDs != null)
                                                nID = m_CHeader.anMotorIDs[i];
                                            GridMotionEditor_SetMotor(GridMotionEditor_GetCurrentLine(), nID, GetData(nID));
                                        }
                                    }
                                }
                            }
#else
                            if (m_bGridInit == true)
                            {
                                for (int i = 0; i < m_CHeader.nMotorCnt; i++)
                                {
                                    GridMotionEditor_SetMotor(GridMotionEditor_GetCurrentLine(), i, GetData(i));
                                }
                            }
                            if (m_CGridMotionEditor != null)
                            {
                                if (m_CGridMotionEditor.m_nGridMode == 1)
                                {
                                    if (m_CHeader != null)
                                    {
                                        for (int i = 0; i < m_CHeader.nMotorCnt; i++)
                                        {
                                            //GridMotionEditor_SetMotor(GridMotionEditor_GetCurrentLine(), i, GetData(i));

                                            int nID = m_CHeader.anMotorIDs[i];
                                            if (nID < 0) continue;
                                            if ((m_CHeader.pSMotorInfo[nID].nMotor_Enable < 0) || (m_CHeader.pSMotorInfo[nID].nMotor_Enable > 1))
                                                continue;
                                            try
                                            {
                                                SetData(nID, GridMotionEditor_GetMotor(GridMotionEditor_GetCurrentLine(), nID));
                                            }
                                            catch
                                            {
                                                float fValue = GetData(nID);
                                                SetData(nID, fValue);
                                            }
                                        }
                                    }
                                }
                            }
#endif
                            m_nMouse_X_Left = e.X;
                            m_nMouse_Y_Left = e.Y;                            
                        }
                        else if (e.Button == MouseButtons.Right)
                        {
                            if (GetFreeze_Pan() != true) m_fPan -= (m_nMouse_X_Right - e.X);
                            if (GetFreeze_Tilt() != true) m_fTilt -= (m_nMouse_Y_Right - e.Y);
                            if ((GetFreeze_Pan() == true) && (GetFreeze_Tilt() == true) && (GetFreeze_Swing() == false))
                            {
                                m_fSwing -= (m_nMouse_X_Right - e.X);
                            }
                            if (m_fTilt < 0) m_fTilt += 360;
                            if (m_fPan < 0) m_fPan += 360;
                            if (m_fTilt >= 360) m_fTilt -= 360;
                            if (m_fPan >= 360) m_fPan -= 360;
                            if (GetMouseMode() == 0)
                            {
                                //if ((m_nMouse_X_Right == e.X) && (m_nMouse_Y_Right == e.Y)) m_nMenuStatus = 1;
                                //else m_nMenuStatus = 0;
                                if ((m_nMouse_X_Right != e.X) || (m_nMouse_Y_Right != e.Y)) m_nMenuStatus = 0;
                            }
                            else
                            {
                                m_nMenuStatus = 0;
                            }
                            m_nMouse_X_Right = e.X;
                            m_nMouse_Y_Right = e.Y;
                        }
                        else
                        {
                        }
                        //OjwDraw();
                    }
                }
#if false
                public void OjwMouseMove2(MouseEventArgs e, bool bMoveZ, bool bMoveSwing)
                {
                    if (m_bMouseClick == true)
                    {
                        if (e.Button == MouseButtons.Left)
                        {
                            //m_fLeg0 = m_fMouseMove - e.X;
                            if (bMoveZ == true) m_fZ -= (m_nMouse_X_Left - e.X);
                            else m_fX -= (m_nMouse_X_Left - e.X);
                            m_fY += (m_nMouse_Y_Left - e.Y);
                            m_nMouse_X_Left = e.X;
                            m_nMouse_Y_Left = e.Y;
                        }
                        else //if (m_abMouseClick == true)
                        {
                            if (bMoveSwing == true) m_fSwing -= (m_nMouse_X_Right - e.X);
                            else m_fPan -= (m_nMouse_X_Right - e.X);
                            m_fTilt -= (m_nMouse_Y_Right - e.Y);
                            if (m_fTilt < 0) m_fTilt += 360;
                            if (m_fPan < 0) m_fPan += 360;
                            if (m_fSwing < 0) m_fSwing += 360;
                            if (m_fTilt >= 360) m_fTilt -= 360;
                            if (m_fPan >= 360) m_fPan -= 360;
                            if (m_fSwing >= 360) m_fSwing -= 360;
                            m_nMouse_X_Right = e.X;
                            m_nMouse_Y_Right = e.Y;
                        }
                    }
                }
#endif
                public void OjwMouseDoubleClick(object sender, MouseEventArgs e) { OjwMouseDoubleClick(e); }
                public void OjwMouseDoubleClick(MouseEventArgs e)
                {
                    if (e.Button == MouseButtons.Left)
                    {
                        //SetScale()
                    }
                }

                //public float[] m_afLookat = new float[3] { -20.0f, -20.0f, _RATIO / 4.0f };//{0.0f, 0.0f, _RATIO / 2};//0.0f};
                public float[] m_afLookat = new float[3] { 10.0f, 10.0f, -_RATIO / 64.0f };//{0.0f, 0.0f, _RATIO / 2};//0.0f};
                public float[] m_afLookat_Dir = new float[3] { 0.0f, 1.0f, 0.0f };
                public void OjwMouseWheel(object sender, MouseEventArgs e) { OjwMouseWheel(false, e); }
                public void OjwMouseWheel(bool bSmallValue, MouseEventArgs e)
                {
                    if (m_bMouseClick == true)
                    {
                        // so if a key is depressed to move a little bit.
                        // Kor: Shift Key 가 눌렸다면 작게(1) 움직이도록...
                        float fDelta = ((bSmallValue == true) ? 0.005f : 0.01f); 
                        float fData = (e.Delta > 0) ? -fDelta : fDelta;

                        if (m_bMouseLeftClick == false)
                        {
                            if ((m_fScale + fData) > 0) m_fScale += fData;
                            if (GetMouseMode() == 0) m_nMenuStatus = 0;
                        }
                        else
                        {
                            float fMul = 1000.0f;
                            if (GetMouseMode() == 0) m_fZ += fData * fMul;
                            else if (GetMouseMode() == 2) // 2
                            {
                                #region Robot Control(Rotation)
                                m_fSwing_Robot += fData * fMul;
                                #endregion Robot Control(Rotation)
                            }
                            else if (GetMouseMode() == 3) // 3
                            {
                                #region Robot Control(Translation)
                                m_fZ_Robot += fData * fMul;
                                #endregion Robot Control(Translation)
                            }
                            else if (GetMouseMode() == 4)
                            {







                                //float fDelta2 = 0.1f;// 1.0f;
                                ////m_fMouse_W_Left -= (float)((e.Delta > 0) ? -fDelta2 : fDelta2);
                                //m_fMouse_W_Left = (float)((e.Delta > 0) ? -fDelta2 : fDelta2);

                                ////if (m_fMouse_W_Left < 0) m_fMouse_W_Left = 0.0f;

                                //double dPos_X = 0;// (e.X - m_nMouse_X_Left);
                                //double dPos_Y = 0;// (m_nMouse_Y_Left - e.Y);
                                //double dPos_Z = (double)m_fMouse_W_Left;// (m_fMouse_W_Left - e.Y);
                                //float fAngle_X, fAngle_Y, fAngle_Z;
                                //GetAngle_Display(out fAngle_Y, out fAngle_X, out fAngle_Z);
                                ////GetAngle_(out m_afLookat[0], out m_afLookat[1], out m_afLookat[2]);
                                
                                //CMath.CalcRot(0, 0, (double)(-fAngle_Z), ref dPos_X, ref dPos_Y, ref dPos_Z);
                                //CMath.CalcRot(0, (double)(-fAngle_Y), 0, ref dPos_X, ref dPos_Y, ref dPos_Z);
                                //CMath.CalcRot((double)(-fAngle_X), 0, 0, ref dPos_X, ref dPos_Y, ref dPos_Z);

                                ////if (
                                //    //((m_afLookat[0] + dPos_X) > 0) &&
                                //    //((m_afLookat[1] + dPos_Y) > 0) &&
                                //    //((m_afLookat[2] + dPos_Z) > 0)
                                //    //)
                                //{
                                //    m_afLookat[0] += (float)dPos_X;
                                //    m_afLookat[1] += (float)dPos_Y;
                                //    m_afLookat[2] += (float)dPos_Z;
                                //}
                                ////    int nMotCnt = m_CHeader.nMotorCnt;
                                ////for (int i = 0; i < nMotCnt; i++)
                                ////{
                                ////    SetData(i, (float)CKinematics.CInverse.GetValue_Motor(i));
                                ////}
                                ////Glu.gluLookAt(m_afLookat[0], m_afLookat[1], m_afLookat[2], 0, 0, 0, 0, 1, 0);
                                ////Glu.











                            }
                        }
                        //OjwDraw();
                    }
                }
                #endregion Mouse Control
                ///////////////////////

                //// CSGL - 2 ////
                /// Default Constructor
                /// 

                #region There are basic functions for initialization.(Kor: OpenGL 을 처음 실행시 초기화 하는 함수등 OpenGL 기본적 구현 함수)

                // contructor, destructor
                #region Initialize
                private bool m_bClassEnd = false;
                private bool m_bMouseEventEnable = false;
                private bool m_bKeyboardEventEnable = false;
                //protected override void OnNotifyMessage(Message m)
                //{
                //    // 0x14 = WM_ERASEBKGND
                //    if (m.Msg != 0x14)
                //        base.OnNotifyMessage(m);
                //}
                public C3d()//CCsgl()
                    : base()
                {
                    this.InitializeContexts();
                    //for (int i = 0; i < m_astrMot.Length; i++) m_astrMot[i] = "t" + i;

                    m_lstMotorsEn.Clear(); // 여기에 만들어진 모터의 수량 및 인덱스를 넣는다.
#if false
                    string [] pstrFiles = new string[5] {
                        "freeglut", 
                        "tao.freeglut", 
                        "tao.ode", 
                        "tao.opengl", 
                        "tao.platform.windows"
                    };
                    
                    foreach (string strFile in pstrFiles)
                    {
                        //if (Ojw.CFile.IsFile(string.Format(Application.StartupPath + "\\" + strFile + ".dll")) == false)
                        {
#if true
                            // 이분 꼼수 방법(스스로 꼼수라 칭함) 참조 - 이 방법이 제일 마음에 든다. 로그인 해서 감사인사 하고 싶어도... 해당 계정이 휴면 계정이라서인지 티스토리에서 비 로그인시 댓글 허용이 안된다... ㅠ.ㅠ                            
                            // http://imjuni.tistory.com/437
                            FileStream fs = new FileStream(strFile + ".dll", FileMode.Create);
                            fs.Write(OpenJigWare.Properties.Resources.freeglut, 0, OpenJigWare.Properties.Resources.freeglut.Length);
                            fs.Close();
#else

                            FileStream fs = new FileStream(strFile + ".dll", FileMode.Create);
                            UnmanagedMemoryStream umsFile = OpenJigWare.Properties.Resources.ResourceManager.GetStream(strFile + ".dll");
                            byte [] pbyStream = new byte[umsFile.Length];
                            umsFile.Read(pbyStream, 0, (int)umsFile.Length);
                            fs.Write(pbyStream, 0, (int)umsFile.Length);
                            fs.Close();
                            //System.Reflection.Assembly asm = System.Reflection.Assembly.GetExecutingAssembly();
                            
                            //   using (Stream strmFile = asm.GetManifestResourceStream(strFile))
                            //{ if (strmFile != null)
                            //    {
                            //        byte[] pbyStream = new byte[strmFile.Length];
                            //        //strmFile.Read(pbyStream, 0, pbyStream.Length);
                            //        FileStream fs = new FileStream(strFile + ".dll", FileMode.Create);
                            //        fs.Write(OpenJigWare.Properties.Resources.freeglut, 0, OpenJigWare.Properties.Resources.freeglut.Length);
                            //        fs.Close();
                            //    }
                            //}
#endif
                        }
                    }
#else
                    // 이분 꼼수 방법(스스로 꼼수라 칭함) 참조 - 이 방법이 제일 마음에 든다. 로그인 해서 감사인사 하고 싶어도... 해당 계정이 휴면 계정이라서인지 티스토리에서 비 로그인시 댓글 허용이 안된다... ㅠ.ㅠ                            
                    // http://imjuni.tistory.com/437
                    FileStream fs = new FileStream("freeglut.dll", FileMode.Create);
                    fs.Write(OpenJigWare.Properties.Resources.freeglut, 0, OpenJigWare.Properties.Resources.freeglut.Length);
                    fs.Close();

                    //fs = new FileStream("Tao.FreeGlut.dll", FileMode.Create);
                    //fs.Write(OpenJigWare.Properties.Resources.Tao_FreeGlut, 0, OpenJigWare.Properties.Resources.Tao_FreeGlut.Length);
                    //fs.Close();

                    //fs = new FileStream("Tao.Ode.dll", FileMode.Create);
                    //fs.Write(OpenJigWare.Properties.Resources.Tao_Ode, 0, OpenJigWare.Properties.Resources.Tao_Ode.Length);
                    //fs.Close();

                    //fs = new FileStream("Tao.OpenGl.dll", FileMode.Create);
                    //fs.Write(OpenJigWare.Properties.Resources.Tao_OpenGl, 0, OpenJigWare.Properties.Resources.Tao_OpenGl.Length);
                    //fs.Close();

                    //fs = new FileStream("Tao.Platform.Windows.dll", FileMode.Create);
                    //fs.Write(OpenJigWare.Properties.Resources.Tao_Platform_Windows, 0, OpenJigWare.Properties.Resources.Tao_Platform_Windows.Length);
                    //fs.Close();

                    //LoadDll("Tao.FreeGlut.dll");
                    //LoadDll("Tao.Ode.dll");
                    //LoadDll("Tao.OpenGl.dll");
                    //LoadDll("Tao.Platform.Windows.dll");
#endif


                    // 변수 초기화
                    for (int i = 0; i < _SIZE_MAX_MOT; i++)
                    {
                        m_pSRot[i] = new SAngle3D_t();
                        //m_pSTmrTrack[i] = new CTimer();
                    }

                    // 디자인 파일 오픈 경로 설정
                    m_strDesignerFilePath = Application.StartupPath + "\\";

                    for (int i = 0; i < 3; i++) m_fColor[i] = 1.0f;
                    InitGLContext();
                    //m_txtDraw = new TextBox();
                    //m_txtDraw.CreateControl();
                    //m_txtDraw.TextChanged += new System.EventHandler(m_txtDraw_TextChanged);
                    //m_txtDraw.KeyDown += new KeyEventHandler(m_txtDraw_KeyDown);
                    //m_txtDraw.MouseDown += new MouseEventHandler(m_txtDraw_MouseDown);
                    
                    m_rtxtDraw = new RichTextBox();
                    m_rtxtDraw.CreateControl();
                    m_rtxtDraw.TextChanged += new System.EventHandler(m_rtxtDraw_TextChanged);
                    m_rtxtDraw.KeyDown += new KeyEventHandler(m_rtxtDraw_KeyDown);
                    m_rtxtDraw.MouseDown += new MouseEventHandler(m_rtxtDraw_MouseDown);

                    m_lstDraw.Clear();

                    //this.SetStyle(ControlStyles.OptimizedDoubleBuffer, true);
                    //this.SetStyle(ControlStyles.EnableNotifyMessage, true);
                    //this.SetStyle(ControlStyles.AllPaintingInWmPaint, true);
                    //this.SetStyle(ControlStyles.UserPaint, true);

                    //this.MouseDown += (MouseEventHandler)OjwMouseDown;
                    //this.MouseMove += (MouseEventHandler)OjwMouseMove;
                    //this.MouseUp += (MouseEventHandler)OjwMouseUp;
                    //this.MouseWheel += (MouseEventHandler)OjwMouseWheel;
                    //m_bMouseEventEnable = true;
                    SetMouseEventEnable(true);
                    //SetKeyboardEventEnable(true);

                    //m_CTId_Pan.Set();
                    //m_CTId_Tilt.Set();
                    //m_CTId_Swing.Set();
                    InitVirtualClass();

                    SelectObject_Clear();

                    //m_pnKinematics.Size = new Size(900, 778);
                    //m_pnKinematics.Location = new Point(6, 9);
                    InitTools_Kinematics(m_pnKinematics); // 다른 것도 필요하다면 하는게 좋지만 이게 Combobox 들 초기화 때문에 하는게 좋다. OJW5014_20150922

                    m_ctxmenuMouse.ItemClicked += new ToolStripItemClickedEventHandler(m_ctxmenuMouse_ItemClicked);
                    //m_ctxmenuMouse.Layout   +=new LayoutEventHandler(m_ctxmenuMouse_Layout);  // += new EventHandler(m_ctxmenuMouse_Opened);
                    //m_ctxmenuMouse.MouseMove +=new MouseEventHandler(m_ctxmenuMouse_MouseMove);
                    //m_ctxmenuMouse.Opened += new EventHandler(m_ctxmenuMouse_Opened); //new System.ComponentModel.EventHandlerList(m_ctxmenuMouse_Opened);
                    Event_ItemAdd.UserEvent += new EventHandler(ItemAdded);//+= new (ItemAdded);
                    
                    Event_FileOpen.UserEvent += new EventHandler(FileRestore);

                    Event_Compile.UserEvent += new EventHandler(Compiled);
                }
                
                //void m_txtDraw_MouseDown(object sender, MouseEventArgs e)
                //{
                //    //throw new NotImplementedException();
                //    try
                //    {
                //        // http://blog.naver.com/PostView.nhn?blogId=gurae83&logNo=20155939347 => 참고
                //        int nLine = m_txtDraw.GetLineFromCharIndex(m_txtDraw.GetFirstCharIndexOfCurrentLine());

                //        SelectLine(nLine);
                //    }
                //    catch
                //    {
                //    }
                //}
                void m_rtxtDraw_MouseDown(object sender, MouseEventArgs e)
                {
                    //throw new NotImplementedException();
                    try
                    {
                        // http://blog.naver.com/PostView.nhn?blogId=gurae83&logNo=20155939347 => 참고
                        int nLine = m_rtxtDraw.GetLineFromCharIndex(m_rtxtDraw.GetFirstCharIndexOfCurrentLine());

                        SelectLine(nLine);
                    }
                    catch
                    {
                    }
                }

                //private void m_txtDraw_KeyDown(object sender, KeyEventArgs e)
                //{
                //    //throw new NotImplementedException();
                //    try
                //    {
                //        int nLine = m_txtDraw.GetLineFromCharIndex(m_txtDraw.GetFirstCharIndexOfCurrentLine());
                //        if (e.KeyValue == 38) // Up
                //        {
                //            nLine--;
                //            if (nLine < 0) nLine = 0;
                //        }
                //        else if (e.KeyValue == 40) // Down
                //        {
                //            nLine++;
                //            if (nLine >= m_txtDraw.Lines.Length)
                //            {
                //                nLine = m_txtDraw.Lines.Length - 1;
                //            }
                //        }
                //        SelectLine(nLine);
                //    }
                //    catch
                //    {
                //    }
                //}
                private void m_rtxtDraw_KeyDown(object sender, KeyEventArgs e)
                {
                    //throw new NotImplementedException();
                    try
                    {
                        int nLine = m_rtxtDraw.GetLineFromCharIndex(m_rtxtDraw.GetFirstCharIndexOfCurrentLine());
                        if (e.KeyValue == 38) // Up
                        {
                            nLine--;
                            if (nLine < 0) nLine = 0;
                        }
                        else if (e.KeyValue == 40) // Down
                        {
                            nLine++;
                            if (nLine >= m_rtxtDraw.Lines.Length)
                            {
                                nLine = m_rtxtDraw.Lines.Length - 1;
                            }
                        }
                        SelectLine(nLine);
                    }
                    catch
                    {
                    }
                }
                public void SelectLine(int nLine)
                {
                    try
                    {
                        //if ((treeInfo.Nodes[0].IsExpanded == false) || (treeInfo.Nodes[0].Nodes[nLine].IsExpanded == false))
                        //    treeInfo.Nodes[0].Collapse();
                        //if (treeInfo.Nodes[0].IsExpanded == false)
                        //    treeInfo.Nodes[0].Expand();
                        //if (treeInfo.Nodes[0].Nodes[nLine].IsExpanded == false)
                        //    treeInfo.Nodes[0].Nodes[nLine].Expand();
                        //treeInfo.SelectedNode = treeInfo.Nodes[0].Nodes[nLine]; // 선택 효과
                        SelectObject_Clear();
                        SelectObject_Add(nLine);
                    }
                    catch
                    {
                    }
                }
                public void AddMouseEvent(MouseEventHandler FDown, MouseEventHandler FMove, MouseEventHandler FUp, MouseEventHandler FWheel)
                {
                    this.MouseDown += (MouseEventHandler)FDown;
                    this.MouseMove += (MouseEventHandler)FMove;
                    this.MouseUp += (MouseEventHandler)FUp;
                    this.MouseWheel += (MouseEventHandler)FWheel;
                }
                public void AddMouseEvent_Down(MouseEventHandler FFunc) { this.MouseDown += (MouseEventHandler)FFunc; }
                public void AddMouseEvent_Move(MouseEventHandler FFunc) { this.MouseMove += (MouseEventHandler)FFunc; }
                public void AddMouseEvent_Up(MouseEventHandler FFunc) { this.MouseUp += (MouseEventHandler)FFunc; }
                public void AddMouseEvent_Wheel(MouseEventHandler FFunc) { this.MouseWheel += (MouseEventHandler)FFunc; }

                public void RemoveMouseEvent(MouseEventHandler FDown, MouseEventHandler FMove, MouseEventHandler FUp, MouseEventHandler FWheel)
                {
                    this.MouseDown -= (MouseEventHandler)FDown;
                    this.MouseMove -= (MouseEventHandler)FMove;
                    this.MouseUp -= (MouseEventHandler)FUp;
                    this.MouseWheel -= (MouseEventHandler)FWheel;
                }
                public void RemoveMouseEvent_Down(MouseEventHandler FFunc) { this.MouseDown -= (MouseEventHandler)FFunc; }
                public void RemoveMouseEvent_Move(MouseEventHandler FFunc) { this.MouseMove -= (MouseEventHandler)FFunc; }
                public void RemoveMouseEvent_Up(MouseEventHandler FFunc) { this.MouseUp -= (MouseEventHandler)FFunc; }
                public void RemoveMouseEvent_Wheel(MouseEventHandler FFunc) { this.MouseWheel -= (MouseEventHandler)FFunc; }

                public C3d GetHandle() { return this; }
                private bool m_bMousePickEnable = true; // 기본적으로 마우스가 클릭하면 클릭부분이 나타나도록 되어 있다.
                public void SetMousePickEnable(bool bDisplayOn)
                {
                    m_bMousePickEnable = bDisplayOn;
                }
                public void SetMouseEventEnable(bool bEn)
                {
                    if (bEn != m_bMouseEventEnable)
                    {
                        m_bMouseEventEnable = bEn;
                        if (bEn == true)
                        {
                            this.MouseDown += (MouseEventHandler)OjwMouseDown;
                            this.MouseMove += (MouseEventHandler)OjwMouseMove;
                            this.MouseUp += (MouseEventHandler)OjwMouseUp;
                            this.MouseWheel += (MouseEventHandler)OjwMouseWheel;
                        }
                        else
                        {
                            this.MouseDown -= (MouseEventHandler)OjwMouseDown;
                            this.MouseMove -= (MouseEventHandler)OjwMouseMove;
                            this.MouseUp -= (MouseEventHandler)OjwMouseUp;
                            this.MouseWheel -= (MouseEventHandler)OjwMouseWheel;
                        }
                    }
                }
                
                //public void SetKeyboardEventEnable(bool bEn)
                //{
                //    if (bEn != m_bKeyboardEventEnable)
                //    {
                //        m_bKeyboardEventEnable = bEn;
                //        if (bEn == true)
                //        {
                            
                //            //this.KeyPress +=new KeyPressEventHandler(C3d_KeyPress);
                //            //this.KeyDown += (KeyEventHandler)OjwKeyDown;
                //            this.KeyDown += new KeyEventHandler(OjwKeyDown);
                //            this.KeyUp += (KeyEventHandler)OjwKeyUp;
                //        }
                //        else
                //        {
                //            this.KeyDown -= (KeyEventHandler)OjwKeyDown;
                //            this.KeyUp -= (KeyEventHandler)OjwKeyUp;
                //        }
                //    }
                //}
                
                ~C3d()//CCsgl()
                {
                    //model.Destroy();
                    if (m_bClassEnd == true) m_bClassEnd = true;
                    if (m_CPropAll_Selected != null) { m_CPropAll_Selected.Destroy(); m_CProperty_Selected = null; }
                    if (m_CProperty_Selected != null) { m_CProperty_Selected.Destroy(); m_CProperty_Selected = null; }
                    if (m_CPropAll != null) m_CPropAll = null;
                    if (m_CProperty != null) { m_CProperty.Destroy(); m_CProperty = null; }
                }
#if _SET_DEFAULT_PERSPECTIVE
                private int m_nPerspectiveMode = 1;
#else
                private int m_nPerspectiveMode = 0;
#endif
                public void SetPerspectiveMode(bool bOn) { m_nPerspectiveMode = ((bOn  == true) ? 1 : 0); } // 보이는 뷰를 원근 뷰로 전환
                public bool IsPerspectiveMode() { return ((m_nPerspectiveMode == 1) ? true : false); }
                public void InitGLContext()
                {                    
#if _GL_FLAT
                    Gl.glShadeModel(Gl.GL_FLAT);							    // Enable Flat Shading
#else
                    Gl.glShadeModel(Gl.GL_SMOOTH);							    // Enable Smooth Shading                    
#endif
                    //glShadeModel(GL_FLAT);							        // Enable Smooth Shading
                    //if (m_bIgnore == false)
                        Gl.glClearColor(0.0f, 0.0f, 0.0f, 1.0f);				    // Black Background
                    //Gl.glClearColor(0.0f, 0.0f, 0.0f, 0.5f);				    // Black Background

                    //if (m_bIgnore == false) 
                        Gl.glClearDepth(1.0f);									    // Depth Buffer Setup
                    if (IsPerspectiveMode() == false)
                    {
                        //Gl.glEnable(Gl.GL_DEPTH_TEST);							    // Enables Depth Testing
                        //Gl.glDepthFunc(Gl.GL_LEQUAL);								// The Type Of Depth Testing To Do
                    }
                    else
                    {
                        //Gl.glEnable(Gl.GL_DEPTH_TEST);
                        //Gl.glDepthFunc(Gl.GL_LEQUAL);								// The Type Of Depth Testing To Do
                    }
                    Gl.glHint(Gl.GL_PERSPECTIVE_CORRECTION_HINT, Gl.GL_NICEST);	// Really Nice Perspective Calculations

                    // Texture
                    Gl.glEnable(Gl.GL_TEXTURE_2D);									// Enable Texture Mapping
                }
                #endregion Initialize

                //public void Init(PictureBox picMain)
                //{
                //    this.Parent = picMain;
                //    this.Dock = DockStyle.Fill;
                //    picMain.Controls.Add(this);
                //    this.InitializeContexts();
                //    //m_szDisplaySize = picMain.Size;
                //    //SizeChange(m_szDisplaySize);
                //    SizeChange(this.Size);
                //}

                //http://blog.danggun.net/2147 출처
                //private bool LoadDll(string sFileName)
                //{
                //    //Dll이 있는지 여부
                //    if (false == File.Exists(sFileName))
                //    {	//없으면 에러
                //        return false;
                //    }

                //    //Dll 로드
                //    Assembly asm = Assembly.LoadFrom(sFileName);

                //    //로드가 되었나?
                //    if (asm == null)
                //    {
                //        return false;
                //    }

                //    //로드가되었으면 
                //    //Dll에 소속된 구성요소 리스트를 받아온다.
                //    Type[] types = asm.GetExportedTypes();

                //    //types[]의 내용으로 원하는 네임스페이스나 클래스를 찾을수 있다.
                //    //이 예제에서는 네임스페이스와 클래스가 한개뿐이기 때문에 그냥 0번 오브젝트를 사용한다.
                //    //m_Type = Activator.CreateInstance(types[0]);
                //    Activator.CreateInstance(types[0]);

                //    //Dll로드가 정상적으로 끝났다.
                //    return true;
                //}



                private Form m_frm3D;
                void m_frm3D_FormClosing(object sender, FormClosingEventArgs e)
                {
                    //throw new NotImplementedException();
                }
                void tmr_Tick(object sender, EventArgs e)
                {
                    //throw new NotImplementedException();
                    OjwDraw();
                }
                public void Init()
                {                    
                    Init(800, 600);
                }
                public void Init(int nWidth, int nHeight)
                {
                    m_frm3D = new Form();
                    //m_frm3D.Left = 0;
                    //m_frm3D.Top = 0;
                    m_frm3D.Width = 600;
                    m_frm3D.Height = 600;
                    m_frm3D.FormClosing += new FormClosingEventHandler(m_frm3D_FormClosing);
                    
                    m_frm3D.Show();
                    System.Windows.Forms.Timer tmr = new System.Windows.Forms.Timer();
                    tmr.Interval = 100;
                    tmr.Enabled = true;
                    tmr.Tick += new EventHandler(tmr_Tick);
                    //m_


#if true
                    this.Left = m_frm3D.Left + m_frm3D.Width;
                    this.Top = m_frm3D.Top;// + m_frm3D.Height;
                    //Ojw.CMessage.Init(txtMessage);
                    //MakeBox(pnMotors, 256);

                    Init(m_frm3D);//pnDisp);
                    //CreateProb_VirtualObject(pnProp);
                    //CreateProp_Selected(pnProp_Selected, null);

                    SetAseFile_Path("ase");

                    // 기준축 보이기
                    SetStandardAxis(true);
                    // 빛 사용
                    Enable_Light(true);

                    // 클릭한 부분 색 / 투명도 지정
                    ////m_C3d.SetAlpha_Display_Enalbe(true);
                    SetPick_ColorMode(true);
                    SetPick_ColorValue(Color.Green); // 클릭된 부분을 녹색으로 설정
                    SetPick_AlphaMode(true); // 투명 모드 활성화
                    SetPick_AlphaValue(0.5f); // 클릭된 부분을 반투명으로 한다.
                    
                    SetVirtualClass_Enable(true);

                    #region PropertyGrid

                    ////m_C3d.InitTools_Motor(pnMotors);
                    //SetTextboxes_ForAngle(m_atxtAngle);
#if false
            m_C3d.InitTools_Kinematics(m_pnKinematics);
            //m_C3d.InitTools_Background(pnBackground);
            // 
            m_C3d.Prop_Set_Main_ShowStandardAxis(true);
            m_C3d.Prop_Set_Main_ShowVirtualAxis(true);
            m_C3d.Prop_Update_VirtualObject();

#endif
                    #endregion PropertyGrid
#endif
                }
                            
                private Control m_ctrlMain = new Control();
                public void Init(Control ctrlMain)
                {                    
                    m_ctrlMain = ctrlMain;
                    this.Parent = ctrlMain;
                    this.Dock = DockStyle.Fill;
                    ctrlMain.Controls.Add(this);
                    //this.InitializeContexts();
                    //m_szDisplaySize = ctrlMain.Size;
                    //SizeChange(m_szDisplaySize);
                    SizeChange(this.Size);

                    for (int i = 0; i < _CNT_TRACK_BALL; i++) m_aSTrack[i] = new STrackD_t();                                   
                }
                public void DInit()
                {
                    if (m_CProperty != null) m_CProperty.Destroy();
                    if (m_CProperty_Selected != null) m_CProperty_Selected.Destroy();
                    m_CProperty = null;
                    m_CProperty_Selected = null;
                    //this.Dispose();
                    try { ((IDisposable)this).Dispose(); }
                    catch { }
                    GC.SuppressFinalize(this);
                }

                #region LoadTextures()
                /// <summary>
                /// Loads and creates the texture.
                /// </summary>
                /// 

                private const int _CNT_TEXTURE = 10;
                private uint[] m_puiTexture = new uint[_CNT_TEXTURE];
                public bool LoadTextures(params String[] strFileNames)
                {
                    bool bRet = true;
                    // The Files To Load
                    //string[] filename = {@"..\..\data\NeHeLesson17\Font.bmp", @"..\..\data\NeHeLesson17\Bumps.bmp"};
                    Bitmap bitmap = null;														// The Bitmap Image For Our Texture
                    Rectangle rectangle;														// The Rectangle For Locking The Bitmap In Memory
                    BitmapData bitmapData = null;												// The Bitmap's Pixel Data

                    int nCnt = strFileNames.Length;
                    m_puiTexture = new uint[nCnt];
                    
                    //Gl.glPushMatrix();
                    
                    
                    
                    //int uiType = Gl.GL_POLYGON;

                    //Gl.glBegin(uiType);
                    //Gl.glEnable(Gl.GL_BLEND); 
                    //Gl.glEnable(Gl.GL_LIGHTING);     //조명 활성화
                    //Gl.glEnable(Gl.GL_LIGHT0);
                    //Gl.glBlendFunc(Gl.GL_SRC_ALPHA, Gl.GL_ONE_MINUS_SRC_ALPHA);

                    


                    // Load The Bitmaps
                    try
                    {
                        Gl.glGenTextures(nCnt, m_puiTexture);									// Create 2 Textures

                        for (int i = 0; i < nCnt; i++)
                        {
                            try
                            {
                                bitmap = new Bitmap(strFileNames[i]);								// Load The File As A Bitmap
                                bitmap.RotateFlip(RotateFlipType.RotateNoneFlipY);					// Flip The Bitmap Along The Y-Axis
                                rectangle = new Rectangle(0, 0, bitmap.Width, bitmap.Height);		// Select The Whole Bitmap

                                // Get The Pixel Data From The Locked Bitmap
                                bitmapData = bitmap.LockBits(rectangle, ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format24bppRgb);

                                // Create Linear Filtered Texture
                                Gl.glBindTexture(Gl.GL_TEXTURE_2D, m_puiTexture[i]);
                                Gl.glTexParameteri(Gl.GL_TEXTURE_2D, Gl.GL_TEXTURE_MIN_FILTER, Gl.GL_LINEAR);
                                Gl.glTexParameteri(Gl.GL_TEXTURE_2D, Gl.GL_TEXTURE_MAG_FILTER, Gl.GL_LINEAR);
                                //Gl.glTexImage2D(Gl.GL_TEXTURE_2D, 0, (int)Gl.GL_RGB8, bitmap.Width, bitmap.Height, 0, Gl.GL_BGR_EXT, Gl.GL_UNSIGNED_BYTE, bitmap.GetH);
                                Gl.glTexImage2D(Gl.GL_TEXTURE_2D, 0, (int)Gl.GL_RGB8, bitmap.Width, bitmap.Height, 0, Gl.GL_BGR_EXT, Gl.GL_UNSIGNED_BYTE, bitmapData.Scan0);

                                bitmap.UnlockBits(bitmapData);										// Unlock The Pixel Data From Memory
                                bitmap.Dispose();													// Clean Up The Bitmap
                                bitmapData = null;
                                bitmap = null;
                            }
                            catch
                            {
                                if (bitmap != null)
                                {
                                    if (bitmapData != null) bitmap.UnlockBits(bitmapData);										// Unlock The Pixel Data From Memory
                                    bitmap.Dispose();													// Clean Up The Bitmap													// Clean Up The Bitmap
                                    bitmapData = null;
                                    bitmap = null;
                                }
                            }
                        }
                    }
                    catch// (Exception e)
                    {
                        bRet = false;
                        // Handle Any Exceptions While Loading Textures, Exit App
                        // 				string errorMsg = "An Error Occurred While Loading Texture:\n\t" + strFileNames + "\n" + "\n\nStack Trace:\n\t" + e.StackTrace + "\n";
                        // 				MessageBox.Show(errorMsg, "Error", MessageBoxButtons.OK, MessageBoxIcon.Stop);
                        // 				App.Terminate();
                    }
                    finally
                    {
                        if (bitmap != null)
                        {
                            if (bitmapData != null) bitmap.UnlockBits(bitmapData);										// Unlock The Pixel Data From Memory
                            bitmap.Dispose();													// Clean Up The Bitmap
                        }
                    }

                    
                    ////
                    //Gl.glEnable(Gl.GL_TEXTURE_2D);
                    //Gl.glEnd();
                    //SetLight();
                    //Gl.glPopMatrix()

                    return bRet;
                }
                #endregion LoadTextures()

                // The top function is first called to the drawing.(Kor: 그리기를 하기위해 맨 처음 호출하는 함수)
                #region glDraw_Ready
                public void GetPickMousePoint(out int nX, out int nY)
                {
                    nX = m_nMouse_X_Left;
                    nY = m_nMouse_Y_Left;
                }

                public void glFlush() { Gl.glFlush(); }
                //private bool m_bIgnore = false;
                //public void IgnoreClear(bool bIgnore) { m_bIgnore = bIgnore; }
                public void glDraw_Ready()
                {
                    m_nTrackBall = 0;

                    //SwapBuffers();
                    //Glut.glutInit();
                    //m_szDisplaySize = this.Size;
                    //SizeChange(m_szDisplaySize);
                    SizeChange(this.Size);

                    if (m_bPickMouseClick_Reserve == true)
                    {
                        m_bPickMouseClick = true;
                        m_bPickMouseClick_Reserve = false;

                        /////////////////////////////////////////////////////////
                        // 픽킹이 선택된 순간 m_nSelectMotor 는 비활성
                        //bool bSelectObject_DrawClass = SelectObject_Check(m_nDrawClass_Pos);
                        if (m_bSyncSelectedMotor == true) m_nSelectedMotor = -1;
                    }

                    if (m_bPickMouseClick == true)
                    {            
                        //Refresh();
                        Picking_Ready(m_nMouse_X_Left, m_nMouse_Y_Left);
                    }
                    else
                    {
                        //Refresh();
                        // Switch to normal rendering mode(Kor: 보통의 렌더링 모드로 전환)
                        //GL.glMatrixMode(GL.GL_MODELVIEW);

                        SetLight(); // 이거 없애면 큰일난다. -_-;;;

                        //if (m_bIgnore == false) 
                            Gl.glClear(Gl.GL_COLOR_BUFFER_BIT | Gl.GL_DEPTH_BUFFER_BIT);
                        m_fColor_Back[0] = ((float)(m_BackColor.R) / 255.0f);  // R
                        m_fColor_Back[1] = ((float)(m_BackColor.G) / 255.0f);  // G
                        m_fColor_Back[2] = ((float)(m_BackColor.B) / 255.0f);  // B
                        
                        //if (m_bIgnore == false) 
                            Gl.glClearColor(m_fColor_Back[0], m_fColor_Back[1], m_fColor_Back[2], 1.0f);
                        
                        //Gl.glLoadIdentity();
                    }
                }
                #endregion glDraw_Ready()
                #region Grid For Draw
                private List<String> m_lstDraw = new List<string>();
                private bool m_bEditing = false;
                private void StringListToGrid()
                {
#if _IS_VAR_GRIDDRAW
                    if (m_bGridDraw == true)
                    {
                        int nRow = m_CGridMotionEditor.m_nCurrntCell;
                        int nCol = m_CGridMotionEditor.m_nCurrntColumn;

                        m_bEditing = true;
                        //String strData = CConvert.RemoveChar(CConvert.RemoveChar(m_CHeader.strDrawModel.Trim(), '['), ']');
                        m_lstDraw.Clear();
                        m_CGridMotionEditor.Delete();
                        //int i = 0;
#if true
                        foreach (String strItem in m_rtxtDraw.Lines)
                        {
                            m_lstDraw.Add(strItem);
                            int nIndex = strItem.IndexOf("//");
                            int nLength = m_CGridMotionEditor.GetLineCount();
                            if (nIndex < 0)
                            {
                                m_CGridMotionEditor.Insert(nLength, 1);
                                //m_CGridMotionEditor.SetData(nLength, 0, "//");
                                //m_lstDraw.Add("//");
                            }
                            else
                            {
                                m_CGridMotionEditor.Insert(nLength, 1);
                                m_CGridMotionEditor.SetData(nLength, 0, strItem.Substring(nIndex + 2));
                            }
                            //if (nLength - 1 == m_nSelectedItem)
                            //    m_CGridMotionEditor.SetCaption(nLength, Prop_Get_PickGroup_Comment_Selected());
                        }
#else
                        foreach (String strItem in m_txtDraw.Lines)
                        {
                            m_lstDraw.Add(strItem);
                            int nIndex = strItem.IndexOf("//");
                            int nLength = m_CGridMotionEditor.GetLineCount();
                            if (nIndex < 0)
                            {
                                m_CGridMotionEditor.Insert(nLength, 1);
                                //m_CGridMotionEditor.SetData(nLength, 0, "//");
                                //m_lstDraw.Add("//");
                            }
                            else
                            {
                                m_CGridMotionEditor.Insert(nLength, 1);
                                m_CGridMotionEditor.SetData(nLength, 0, strItem.Substring(nIndex + 2));
                            }
                            //if (nLength - 1 == m_nSelectedItem)
                            //    m_CGridMotionEditor.SetCaption(nLength, Prop_Get_PickGroup_Comment_Selected());
                        }
#endif
                        if (m_bItemAdded == true)
                            if (m_CGridMotionEditor.GetHandle().Rows.Count > m_nSelectedItem) m_CGridMotionEditor.GetHandle().CurrentCell = m_CGridMotionEditor.GetHandle().Rows[m_nSelectedItem].Cells[1];
                        for (int i = 0; i < OjwDispAll.GetCount(); i++)
                        {
                            if (OjwDispAll.GetData(i) != null)
                            {
                                string strData = OjwDispAll.GetData(i).GetData_DispObject();
                                bool bData = false;
                                //if (OjwDispAll.GetData(i).GetData_DispObject() != "#-1")
                                if (strData.Length > 1)
                                {
                                    if (strData[0] == '#')
                                    {
                                        if (CConvert.IsDigit(strData.Substring(1)) == true)
                                        {
                                            if (CConvert.StrToInt(strData.Substring(1)) >= 0)
                                            {
                                                bData = true;
                                            }
                                        }
                                    }
                                }
                                m_CGridMotionEditor.SetEnable(i, bData);
                                //if (bData == true)
                                //    m_CGridMotionEditor.SetEnable(i, true);
                                //else m_CGridMotionEditor.SetEnable(i, false);
                            }
                            else m_CGridMotionEditor.SetEnable(i, false);

                            if (m_bItemAdded == false)
                            {
                                //m_CGridMotionEditor.ChangePos(m_CGridMotionEditor.GetHandle(), nRow, nCol);
                                if ((nRow >= 0) && (nCol >= 0))
                                    m_CGridMotionEditor.GetHandle().CurrentCell = m_CGridMotionEditor.GetHandle().Rows[nRow].Cells[nCol];
                            }
                        }

                        // Reset
                        //m_CGridMotionEditor.m_bGridAdded = false;

                        //m_CGridMotionEditor.SetChangeCurrentLine
                        m_bEditing = false;
                    }
#endif
                }
                private void GridToStringList()
                {
                    //m_txtDraw.Text = String.Empty;
                    //foreach (String strItem in m_lstDraw)
                    //{
                    //    m_txtDraw.Text += strItem + "\r\n";
                    //}
                    /////////////
                    m_rtxtDraw.Text = String.Empty;
                    foreach (String strItem in m_lstDraw)
                    {
                        m_rtxtDraw.Text += strItem + "\r\n";
                    }
                }

                //private CGridView m_CGridMotionEditor = new CGridView();
                //private bool m_bGridDraw = false;
                //public void GridDraw_Init(DataGridView dgDraw, int nWidth)
                //{
                //    int nLines = 0;
                //    //m_lstDraw.Clear();
                //    m_CGridMotionEditor.Create(dgDraw, nLines, new SGridTable_t("Caption", 250, 0, 0, Color.LightGray, ""));
                //    //m_CGridMotionEditor.Create(dgDraw, nLines, 
                //    //    new SGridTable_t("Group", 30, 0, 0, Color.LightGray, ""),
                //    //    new SGridTable_t("Motor(-1:None)", 30, 0, 0, Color.LightGray, ""),
                //    //    new SGridTable_t("", 30, 0, 0, Color.LightGray, ""),
                //    //    );

                //    //m_CGridMotionEditor.GetHandle().Columns[0].Visible = false; // Enable Column 숨김

                //    m_CGridMotionEditor.GetHandle().CellEnter += new System.Windows.Forms.DataGridViewCellEventHandler(GridDraw_Event_CellEnter);
                //    m_CGridMotionEditor.GetHandle().MouseDoubleClick += new System.Windows.Forms.MouseEventHandler(GridDraw_MouseDoubleClick);
                //    //m_CGridMotionEditor.Ignore_CellEnter(true);

                //    m_CGridMotionEditor.dgAngle_Block_GridChange(m_rtxtDraw, true); // Insert, Delete 블럭.

                //    m_CGridMotionEditor.GetHandle().RowsAdded += new DataGridViewRowsAddedEventHandler(GridDraw_Event_RowsAdded);
                //    m_CGridMotionEditor.GetHandle().RowsRemoved += new DataGridViewRowsRemovedEventHandler(GridDraw_Event_RowsRemoved);
                //    m_CGridMotionEditor.GetHandle().CellValueChanged += new DataGridViewCellEventHandler(GridDraw_CellValueChanged);


                //    m_bGridDraw = true;
                //}
                #endregion Grid For Draw

                //#region Add / Sub Grid Event
                //public void Add_CellMouseDoubleClick(DataGridViewCellMouseEventHandler FFunc) { m_CGridMotionEditor.Add_CellMouseDoubleClick((DataGridViewCellMouseEventHandler)FFunc); }
                //public void Sub_CellMouseDoubleClick(DataGridViewCellMouseEventHandler FFunc) { m_CGridMotionEditor.Sub_CellMouseDoubleClick((DataGridViewCellMouseEventHandler)FFunc); }
                //#endregion Add / Sub Grid Event

                #region Grid For Motion
                public CGridView m_CGridMotionEditor = null;//new CGridView();
                private bool m_bGridInit = false;
                public bool IsGridInit() { return m_bGridInit; }
                public int GetWidth_GridItem() { return m_nWidth_GridItem; }
                private DataGridView m_dgAngle = new DataGridView();
                private void GridMotionEditor_Init(int nWidth, int nLines)
                {
                    GridMotionEditor_Init(nWidth, nLines, true);
                }
                private void GridMotionEditor_Init(int nWidth, int nLines, bool bEventSet)
                {
                    if (m_bGridInit == true) GridMotionEditor_Init(m_dgAngle, nWidth, nLines, bEventSet);
                    //else CMessage.Write_Error("Grid Init Error");
                }

                private int m_nWidth_GridItem = 0;
                private Button[,] m_pbtnLed;
                private Button[] m_pbtnType;
                private Button[] m_pbtnEnable;
                public int[,] m_pnFlag;
                private struct SFlag_t
                {
                    List<int> nLed;
                }
                private int[,] m_pnFlag_Copy;
                Panel m_pnButton = new Panel();
                public void GridMotionEditor_Init_Panel(Panel pnButton)
                {
                    m_pnButton = pnButton;
                }
                private bool m_bGridEvent = false;
                public void GridMotionEditor_Init(DataGridView dgAngle, int nWidth, int nLines)
                {
                    GridMotionEditor_Init(dgAngle, nWidth, nLines, true);
                }
                public void GridMotionEditor_Init(DataGridView dgAngle, int nWidth, int nLines, bool bEventSet)
                {
                    int nWidth_Interval = 11;
                    //m_CGridMotionEditor.GetHandle().Dispose();
                    //m_CGridMotionEditor.GetHandle().Controls.Clear();
                    //m_CGridMotionEditor = new CGridView();
                    m_dgAngle = dgAngle;
                    // 모터의 갯수
                    int nCnt = m_CHeader.nMotorCnt;
                    // GridView
                    //int nWidth = 65;
                    //int nLines = 0;
                    SGridTable_t[] aSTable = new SGridTable_t[nCnt + 2];// + 12];// Speed, Delay   // Speed, Delay, Time //2]; // Speed, Delay
                    Color[] acColor = new Color[] { Color.Orange, Color.Green, Color.Yellow, Color.Cyan, Color.GreenYellow, Color.DarkOrange };

                    /////////////////////////////////////
                    //m_abEnc = new bool[nLines + 1]; // 가변으로 잡으면 속도가 영향을 받으니 메모리 전체적으로 잡아버리자.
                    m_pnFlag = new int[nLines + 1, nCnt];// + 12]; // En, Speed, Delay, Cmd, ...
                    m_pnFlag.Initialize();
                    m_pnFlag_Copy = new int[m_pnFlag.GetLength(0), m_pnFlag.GetLength(1)];// + 12];//nCnt];
                    for (int i = 0; i < m_pnFlag_Copy.GetLength(0); i++)
                    {
                        for (int j = 0; j < m_pnFlag_Copy.GetLength(1); j++)
                        {
                            m_pnFlag_Copy[i, j] = -1;
                        }
                    }
                    /////////////////////////////////////

                    if (m_pbtnEnable != null)
                    {
                        for (int i = 0; i < m_pbtnEnable.Length; i++)
                        {

                            for (int j = 0; j < 3; j++)
                            {
                                m_pbtnLed[j, i].Dispose();
                                m_pbtnLed[j, i] = null;
                            }
                            m_pbtnEnable[i].Dispose();
                            m_pbtnEnable[i] = null;
                            m_pbtnType[i].Dispose();
                            m_pbtnType[i] = null;
                        }
                    }

                    int nWidth_Offset = 0;
                    m_pbtnEnable = new Button[nCnt];
                    m_pbtnType = new Button[nCnt];
                    int nLedCnt = 3;
                    m_pbtnLed = new Button[nLedCnt, nCnt];

                    int nTop = 55;// dgAngle.Top;
                    for (int i = 0; i < nCnt; i++)
                    {
                        int nMotWidth = nWidth;
                        int nMotHeight = 18;
                        int nHeightOffset = -1;

                        // Enable
                        m_pbtnEnable[i] = new Button();
                        m_pbtnEnable[i].Top = nTop - 52;
                        m_pbtnEnable[i].Left = dgAngle.Left + (dgAngle.RowHeadersWidth + nWidth_Offset) + nWidth_Interval;
                        m_pbtnEnable[i].Width = nMotWidth / 5 * 2;
                        m_pbtnEnable[i].Height = (nMotHeight + nHeightOffset) * 3 / 2;
                        m_pbtnEnable[i].Name = "btnServe_En" + Ojw.CConvert.IntToStr(i);
                        m_pbtnEnable[i].Text = "E";
                        m_pbtnEnable[i].Click += new System.EventHandler(btnServe_En_Click);
                        m_pnButton.Controls.Add(m_pbtnEnable[i]);
                        // Type
                        m_pbtnType[i] = new Button();
                        m_pbtnType[i].Top = nTop - 52 + m_pbtnEnable[i].Height;
                        m_pbtnType[i].Left = dgAngle.Left + (dgAngle.RowHeadersWidth + nWidth_Offset) + nWidth_Interval;
                        m_pbtnType[i].Width = nMotWidth / 5 * 2;
                        m_pbtnType[i].Height = (nMotHeight + nHeightOffset) * 3 / 2;
                        m_pbtnType[i].Name = "btnServe_Type" + Ojw.CConvert.IntToStr(i);
                        m_pbtnType[i].Text = "T";
                        m_pbtnType[i].Click += new System.EventHandler(btnServe_Type_Click);
                        m_pnButton.Controls.Add(m_pbtnType[i]);
                        // Led
                        String[] pstrText = new String[3] { "R", "B", "G" };
                        for (int j = 0; j < nLedCnt; j++)
                        {
                            m_pbtnLed[j, i] = new Button();
                            m_pbtnLed[j, i].Top = m_pbtnEnable[i].Top + ((nMotHeight + ((j != 0) ? nHeightOffset : 0)) * j);
                            m_pbtnLed[j, i].Left = m_pbtnEnable[i].Left + nMotWidth / 5 * 2;
                            m_pbtnLed[j, i].Width = nMotWidth / 5 * 3;
                            m_pbtnLed[j, i].Height = nMotHeight;
                            m_pbtnLed[j, i].Name = "btnServe_Led" + Ojw.CConvert.IntToStr(i) + "_" + Ojw.CConvert.IntToStr(j);
                            m_pbtnLed[j, i].Text = pstrText[j];
                            m_pbtnLed[j, i].Click += new System.EventHandler(btnServe_Led_Click);
                            m_pnButton.Controls.Add(m_pbtnLed[j, i]);
                        }
                        
                        Color cColor = acColor[m_CHeader.pSMotorInfo[i].nGroupNumber % acColor.Length];
                        string strName = CConvert.RemoveChar(m_CHeader.pSMotorInfo[i].strNickName, '\0');
                        strName = (strName.Length > 0) ? strName : "Motor" + CConvert.IntToStr(i);
                        aSTable[i] = new SGridTable_t(strName, nWidth, m_CHeader.pSMotorInfo[i].nGroupNumber, m_CHeader.pSMotorInfo[i].nAxis_Mirror, cColor, m_CHeader.pSMotorInfo[i].fInitAngle, m_CHeader.pSMotorInfo[i].fInitAngle2);

                        nWidth_Interval += nWidth + nWidth_Offset;
                    }
                    // Time
                    aSTable[nCnt] = new SGridTable_t("Speed", nWidth, 0, -1, Color.OrangeRed, 1000, 1000);
                    // Delay
                    aSTable[nCnt + 1] = new SGridTable_t("Delay", nWidth, 0, -1, Color.Olive, 0, 0);
                    //// Time
                    //aSTable[nCnt + 2] = new SGridTable_t("Time", nWidth, 0, -1, Color.LightBlue, 0);

#if false
                    int nDefaultWidth = 10;
                    int nPos = 2;
                    // 3 - Group
                    aSTable[nCnt + nPos++] = new SGridTable_t("Grp", nDefaultWidth, 0, -1, Color.Gray, 0);
                    // 4 - Command
                    aSTable[nCnt + nPos++] = new SGridTable_t("Cmd", nDefaultWidth, 0, -1, Color.Gray, 0);

                    for (int i = 0; i < 6; i++)
                    {
                        // 5 ~ 10 - Data0 ~ Data5
                        aSTable[nCnt + nPos++] = new SGridTable_t(String.Format("D{0}", i), nDefaultWidth, 0, -1, Color.Gray, 0);
                    }

                    // 11 - Buzz
                    aSTable[nCnt + nPos++] = new SGridTable_t("Bzz", nDefaultWidth, 0, -1, Color.Gray, 0);

                    // 12 - Emoticon
                    aSTable[nCnt + nPos++] = new SGridTable_t("Emt", nDefaultWidth, 0, -1, Color.Gray, 0);
                    
#endif
                    m_CGridMotionEditor = new CGridView();
                    m_CGridMotionEditor.Create(dgAngle, nLines, bEventSet, aSTable);

                    //int nLine;
                    //int nMotPos;
                    for (int i = 0; i < dgAngle.RowCount; i++)
                    {
                        for (int j = 0; j < m_CHeader.nMotorCnt; j++)
                        {
                            //nMotPos = j + 1;

                            m_pnFlag[i, j] = (int)(
                                0x10 | // Enable
                                ((m_CHeader.pSMotorInfo[j].nMotorControlType != 0) ? 0x08 : 0x00) // 위치제어가 아니라면 //0x08 //| // MotorType
                                //0x07 // Led
                                );
                        }
                    }


#if false
                    m_CGridMotionEditor.Events_Remove_KeyDown();
                    m_CGridMotionEditor.Events_Remove_KeyUp();
                    //m_CGridMotionEditor.Events_Remove_CellEnter();
                    //m_CGridMotionEditor.Events_Remove_MouseDoubleClick();
                    
                    //m_CGridMotionEditor.Events_Remove_MouseDown();
                    //m_CGridMotionEditor.Events_Remove_MouseMove();
                    //m_CGridMotionEditor.Events_Remove_MouseUp();
                    if (m_bGridInit == true)
                    {
                        m_CGridMotionEditor.GetHandle().CellEnter -= new System.Windows.Forms.DataGridViewCellEventHandler(GridMotionEditor_Event_CellEnter);
                        m_CGridMotionEditor.GetHandle().MouseDoubleClick -= new System.Windows.Forms.MouseEventHandler(GridMotionEditor_MouseDoubleClick);

                        m_CGridMotionEditor.GetHandle().KeyDown -= new System.Windows.Forms.KeyEventHandler(GridMotionEditor_Event_KeyDown);
                        m_CGridMotionEditor.GetHandle().KeyUp -= new System.Windows.Forms.KeyEventHandler(GridMotionEditor_Event_KeyUp);

                        m_CGridMotionEditor.GetHandle().MouseDown -= new System.Windows.Forms.MouseEventHandler(GridMotionEditor_MouseDown);
                        m_CGridMotionEditor.GetHandle().MouseUp -= new System.Windows.Forms.MouseEventHandler(GridMotionEditor_MouseUp);
                        m_CGridMotionEditor.GetHandle().MouseMove -= new System.Windows.Forms.MouseEventHandler(GridMotionEditor_MouseMove);

                        m_CGridMotionEditor.GetHandle().Scroll -= new ScrollEventHandler(GridMotionEditor_Scroll);
                    }
                    m_CGridMotionEditor.GetHandle().CellEnter += new System.Windows.Forms.DataGridViewCellEventHandler(GridMotionEditor_Event_CellEnter);
                    m_CGridMotionEditor.GetHandle().MouseDoubleClick += new System.Windows.Forms.MouseEventHandler(GridMotionEditor_MouseDoubleClick);

                    m_CGridMotionEditor.GetHandle().KeyDown += new System.Windows.Forms.KeyEventHandler(GridMotionEditor_Event_KeyDown);
                    m_CGridMotionEditor.GetHandle().KeyUp += new System.Windows.Forms.KeyEventHandler(GridMotionEditor_Event_KeyUp);

                    m_CGridMotionEditor.GetHandle().MouseDown += new System.Windows.Forms.MouseEventHandler(GridMotionEditor_MouseDown);
                    m_CGridMotionEditor.GetHandle().MouseUp += new System.Windows.Forms.MouseEventHandler(GridMotionEditor_MouseUp);
                    m_CGridMotionEditor.GetHandle().MouseMove += new System.Windows.Forms.MouseEventHandler(GridMotionEditor_MouseMove);

                    //m_CGridMotionEditor.Ignore_CellEnter(true); // 속도 버벅거림을 없애기 위해 모션 수행시만 이게 들어간다.

                    m_CGridMotionEditor.GetHandle().Scroll += new ScrollEventHandler(GridMotionEditor_Scroll);
#else
                    if (bEventSet == true)
                    {
                        if (m_bGridInit == false)
                        {
                            m_CGridMotionEditor.Events_Remove_KeyDown();
                            m_CGridMotionEditor.Events_Remove_KeyUp();
                            //m_CGridMotionEditor.Events_Remove_CellEnter();
                            //m_CGridMotionEditor.Events_Remove_MouseDoubleClick();

                            //m_CGridMotionEditor.Events_Remove_MouseDown();
                            //m_CGridMotionEditor.Events_Remove_MouseMove();
                            //m_CGridMotionEditor.Events_Remove_MouseUp();

                            m_CGridMotionEditor.GetHandle().CellEnter += new System.Windows.Forms.DataGridViewCellEventHandler(GridMotionEditor_Event_CellEnter);
                            m_CGridMotionEditor.GetHandle().MouseDoubleClick += new System.Windows.Forms.MouseEventHandler(GridMotionEditor_MouseDoubleClick);

                            m_CGridMotionEditor.GetHandle().KeyDown += new System.Windows.Forms.KeyEventHandler(GridMotionEditor_Event_KeyDown);
                            m_CGridMotionEditor.GetHandle().KeyUp += new System.Windows.Forms.KeyEventHandler(GridMotionEditor_Event_KeyUp);

                            m_CGridMotionEditor.GetHandle().MouseDown += new System.Windows.Forms.MouseEventHandler(GridMotionEditor_MouseDown);
                            m_CGridMotionEditor.GetHandle().MouseUp += new System.Windows.Forms.MouseEventHandler(GridMotionEditor_MouseUp);
                            m_CGridMotionEditor.GetHandle().MouseMove += new System.Windows.Forms.MouseEventHandler(GridMotionEditor_MouseMove);

                            //m_CGridMotionEditor.Ignore_CellEnter(true); // 속도 버벅거림을 없애기 위해 모션 수행시만 이게 들어간다.

                            m_CGridMotionEditor.GetHandle().Scroll += new ScrollEventHandler(GridMotionEditor_Scroll);
                        }
                    }
#endif
                    m_nWidth_GridItem = nWidth;

                    CheckFlag(0);

#if false // For Test
                    MessageBox.Show(String.Format("{0}", m_CGridMotionEditor.GetOffset_Rot_Swing(0)));
#endif

                    m_CGridMotionEditor.SetHeader(this);

                    m_bGridInit = true;
                }

                #region KeyDown & KeyUp
                private void GridMotionEditor_Event_KeyDown(object sender, KeyEventArgs e)
                {
                    OjwGrid_KeyDown(m_CGridMotionEditor.GetHandle(), e);
                }
                private void GridMotionEditor_Event_KeyUp(object sender, KeyEventArgs e)
                {
                    OjwGrid_KeyUp(m_CGridMotionEditor.GetHandle(), e);
                }
                private int m_nKey = 0;  // Keyboard Event variable
                private bool m_bKey_Ctrl = false;
                private bool m_bKey_Alt = false;
                private bool m_bKey_Shift = false;
                private int m_nFirstPos_Min_X = 9999999;
                private int m_nFirstPos_Min_Line = 9999999;
                public void Flag_Insert(int nInsertCnt) { Flag_Insert(m_CGridMotionEditor.m_nCurrntCell, nInsertCnt); }
                public void Flag_Insert(int nIndex, int nInsertCnt)
                {
                    if (nInsertCnt <= 0) return;
                    if (nIndex < 0) nIndex = 0;

                    int[,] pnFlag = (int[,])m_pnFlag.Clone();
                    for (int i = 0; i < m_pnFlag.GetLength(0) - nInsertCnt; i++)
                    {
                        if (i > nIndex)
                        {
                            if (i < nIndex + nInsertCnt)
                            {
                                for (int j = 0; j < GetHeader_nMotorCnt(); j++)
                                {
                                    m_pnFlag[i, j] = 0x10;
                                }
                            }
                            else
                            {
                                for (int j = 0; j < GetHeader_nMotorCnt(); j++)
                                {
                                    m_pnFlag[i + nInsertCnt, j] = pnFlag[i, j];
                                }
                            }
                        }
                    }
                }
                private void Flag_Add(int nInsertCnt) { Flag_Add(m_CGridMotionEditor.m_nCurrntCell, nInsertCnt); }
                public void Flag_Add(int nIndex, int nInsertCnt)
                {
                    if (nInsertCnt <= 0) return;
                    if (nIndex < 0) nIndex = 0;

                    int[,] pnFlag = (int[,])m_pnFlag.Clone();
                    for (int i = 0; i < m_pnFlag.GetLength(0) - nInsertCnt; i++)
                    {
                        if (i >= nIndex)
                        {
                            if (i < nIndex + nInsertCnt)
                            {
                                for (int j = 0; j < GetHeader_nMotorCnt(); j++)
                                {
                                    m_pnFlag[i, j] = 0x10;
                                }
                            }
                            else
                            {
                                for (int j = 0; j < GetHeader_nMotorCnt(); j++)
                                {
                                    m_pnFlag[i + nInsertCnt, j] = pnFlag[i, j];
                                }
                            }
                        }
                    }
                }
                public void Flag_Delete() { Flag_Delete(0, 999); }
                private void Flag_Delete(int nIndex, int nDeleteCnt)
                {
                    if (nDeleteCnt <= 0) return;
                    if (nIndex < 0) nIndex = 0;

                    int[,] pnFlag = (int[,])m_pnFlag.Clone();
                    for (int i = 0; i < m_pnFlag.GetLength(0); i++)
                    {
                        if (i >= nIndex)
                        {
                            if ((i + nDeleteCnt) >= m_pnFlag.GetLength(0) - 1)
                            {
                                for (int j = 0; j < GetHeader_nMotorCnt(); j++)
                                {
                                    m_pnFlag[i, j] = 0x10;
                                }
                            }
                            else
                            {
                                for (int j = 0; j < GetHeader_nMotorCnt(); j++)
                                {
                                    m_pnFlag[i, j] = pnFlag[i + nDeleteCnt, j];
                                }
                            }
                        }
                    }
                }
#if false
            public void Insert(int nInsertCnt) { Insert(m_nCurrntCell, nInsertCnt); }
            public void Insert(int nIndex, int nInsertCnt)
            {
                int nErrorNum = 0;
                try
                {
                    if (nIndex < 0) nIndex = 0;
                    
                    int nFirst = nIndex;
                    dgAngle.Rows.Insert(nIndex, nInsertCnt);
                    //m_lstLineInfo.Insert(nIndex, new SGridLineInfo_t(false, 0, "", 0, 0, 0, 0, 0, 0));
                    for (int i = nFirst; i < nFirst + nInsertCnt; i++) Clear(i);
#if !_TEST
                    SetColorGrid(nIndex, nInsertCnt); 
#endif
                }
                catch (System.Exception e)
                {
                    Ojw.CMessage.Write_Error("[" + Ojw.CConvert.IntToStr(nErrorNum) + "]" + e.ToString());
                }
            }
            public void Add(int nInsertCnt) { Add(((dgAngle.RowCount == 0) ? 0 : dgAngle.RowCount - 1), nInsertCnt); }
            public void Add(int nIndex, int nInsertCnt)
            {
                if (nIndex < 0) nIndex = 0;

                if (dgAngle.RowCount > 0) nIndex++;
                else nIndex = 0;

                if (nIndex < dgAngle.RowCount - 1)
                {
                    Insert(nIndex, nInsertCnt);
                    ChangePos(dgAngle, nIndex, dgAngle.CurrentCell.ColumnIndex);
                    return;
                }
                int nFirst = nIndex;

                dgAngle.Rows.Add(nInsertCnt);
                ////////////////
                for (int i = nFirst; i < nFirst + nInsertCnt; i++) Clear(i);
                ChangePos(dgAngle, nIndex, dgAngle.CurrentCell.ColumnIndex);
#if !_TEST
                SetColorGrid(nIndex, nInsertCnt); 
#endif
                ////////////////
            }
#endif
                private int m_nTorq = 0;
                private int m_nKeyCommand = 0;
                public void KeyCommand_Clear() { m_nKeyCommand = 0; }
                public int KeyCommand_Get() { int nKey = m_nKeyCommand; m_nKeyCommand = 0; return nKey; }
                private void OjwGrid_KeyDown(DataGridView dgGrid, KeyEventArgs e)
                {
                    m_nKey = e.KeyValue;
                    
                    m_nKeyCommand = e.KeyValue; // KeyCommand

                    if (e.Control == true) m_bKey_Ctrl = true; else m_bKey_Ctrl = false;
                    if (e.Alt == true) m_bKey_Alt = true; else m_bKey_Alt = false;
                    if (e.Shift == true) m_bKey_Shift = true; else m_bKey_Shift = false;

                    switch (e.KeyCode)
                    {
                        #region Keys.Insert - 삽입
                        case Keys.Insert:
                            {
                                if (dgGrid.Focused == true)
                                {
                                    string strValue = "1";
                                    if (e.Control)
                                    {
                                        if (Ojw.CInputBox.Show("Insert", "뒤로 추가할 테이블의 수를 지정하시오", ref strValue) == DialogResult.OK)
                                        {
                                            int nInsertCnt = Ojw.CConvert.StrToInt(strValue);
                                            int nFirst = m_CGridMotionEditor.m_nCurrntCell;
                                            
                                            // 먼저 빼고
                                            m_CGridMotionEditor.Delete(m_CGridMotionEditor.GetHandle().RowCount - nInsertCnt - 1, nInsertCnt);

                                            Flag_Add(m_CGridMotionEditor.m_nCurrntCell, nInsertCnt);
                                            m_CGridMotionEditor.Add(m_CGridMotionEditor.m_nCurrntCell, nInsertCnt);

                                            for (int i = m_CGridMotionEditor.m_nCurrntCell; i < m_CGridMotionEditor.m_nCurrntCell + nInsertCnt; i++)
                                            {
                                                for (int j = 0; j < m_CHeader.nMotorCnt; j++)
                                                {
                                                    m_pnFlag[i, j] = (int)(
                                                        0x10 | // Enable
                                                        ((m_CHeader.pSMotorInfo[j].nMotorControlType != 0) ? 0x08 : 0x00)// 위치제어가 아니라면 //0x08 //| // MotorType
                                                        //0x07 // Led
                                                        );
                                                }
                                            }

                                            CheckFlag(m_CGridMotionEditor.m_nCurrntCell);
                                            // 색칠하기...
                                            GridMotionEditor_SetColorGrid(0, dgGrid.RowCount);
                                        }
                                    }
                                    else
                                    {
                                        if (Ojw.CInputBox.Show("Insert", "삽입할 테이블의 수를 지정하시오", ref strValue) == DialogResult.OK)
                                        {
                                            //m_bKeyInsert = true;
                                            int nInsertCnt = Ojw.CConvert.StrToInt(strValue);
                                            int nFirst = m_CGridMotionEditor.m_nCurrntCell;

                                            // 먼저 빼고
                                            m_CGridMotionEditor.Delete(m_CGridMotionEditor.GetHandle().RowCount - nInsertCnt - 1, nInsertCnt);

                                            Flag_Insert(m_CGridMotionEditor.m_nCurrntCell, nInsertCnt);
                                            m_CGridMotionEditor.Insert(m_CGridMotionEditor.m_nCurrntCell, nInsertCnt);
                                            //Grid_Insert(nFirst, nInsertCnt);
                                            //m_bKeyInsert = false;

                                            for (int i = m_CGridMotionEditor.m_nCurrntCell; i < m_CGridMotionEditor.m_nCurrntCell + nInsertCnt; i++)
                                            {
                                                for (int j = 0; j < m_CHeader.nMotorCnt; j++)
                                                {
                                                    m_pnFlag[i, j] = (int)(
                                                        0x10 | // Enable
                                                        ((m_CHeader.pSMotorInfo[j].nMotorControlType != 0) ? 0x08 : 0x00)// 위치제어가 아니라면 //0x08 //| // MotorType
                                                        //0x07 // Led
                                                        );
                                                }
                                            }
                                            CheckFlag(m_CGridMotionEditor.m_nCurrntCell);
                                            // 색칠하기...
                                            GridMotionEditor_SetColorGrid(0, dgGrid.RowCount);
                                        }
                                    }
                                    //Grid_DisplayLine(m_nCurrntCell);
                                }
                            }
                            break;
                        #endregion Keys.Insert - 삽입
                        #region Keys.Escape - ESC : 긴급정지
                        case Keys.Escape:
                            {
                                //m_CMotor.Stop();
                                //Cmd_Stop(m_nCurrentRobot);
                            }
                            break;
                        #endregion Keys.Escape - ESC : 긴급정지
                        #region Keys.F4 - 초기자세
                        //case Keys.F4:
                        //    {
                        //        frmMain.Cmd_InitPos(m_nCurrentRobot, frmMain._INITPOS_DEFAULT, 2000);
                        //        //DefaultPosition(1);
                        //    }
                        //    break;
                        #endregion Keys.F4 - 초기자세
                        #region Keys.F5 - 모션
                        //case Keys.F5:
                        //    {
                        //        if (m_bStart == false)
                        //            StartMotion();
                        //    }
                        //    break;
                        #endregion Keys.F5 - 모션
                        #region Keys.F - 주석 검색하기
                        case Keys.F:
                            {
                                String strFind = "";
                                if (Ojw.CInputBox.Show("검색", "검색할 주석의 키워드를 입력하시오", ref strFind) == DialogResult.OK)
                                {
                                    int nLine = m_CGridMotionEditor.GetHandle().CurrentCell.RowIndex;
                                    int nPos = 0;
                                    string strValue = "";
                                    bool bFind = false;
                                    for (int i = nLine; i < m_CGridMotionEditor.GetHandle().RowCount; i++)
                                    {
                                        strValue = m_CGridMotionEditor.GetCaption(i);

                                        // 원하는 문자열이 없다면 -1을 리턴
                                        if (strValue.IndexOf(strFind) >= 0)
                                        {
                                            nPos = i;
                                            bFind = true;
                                            break;
                                        }
                                    }
                                    if (bFind == true)
                                    {
                                        m_CGridMotionEditor.GetHandle()[0, nPos].Selected = true;
                                        m_CGridMotionEditor.ChangePos(m_CGridMotionEditor.GetHandle(), nPos, 0);
                                    }
                                    else
                                    {
                                        MessageBox.Show("결과 없음.");
                                    }
                                }
                            }
                            break;
                        #endregion Keys.F - 주석 검색하기
                        #region Keys.F1 - 위치값 가져오기
                        case Keys.F1:
                            {
                                if (dgGrid.Focused == true)
                                {
                                    bool bOk = false;
                                    //if (m_CMotor2.IsOpen_Socket() == true)
                                    //{
                                    //    for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) m_CMotor2.Read_Motor_Push(nAxis);
                                    //    m_CMotor2.Wait_Delay(1000);
                                    //    bOk = true;
                                    //}
                                    if (m_CMotor2.IsOpen_Socket() == true)
                                    {
                                        m_CMotor.SetSocket(m_CMotor2.m_CSocket);
                                    }
                                    int _ADDRESS_TORQUE_CONTROL = 52;
                                    for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++)
                                    {
                                        if (m_bDynamixel == true)
                                        {
#if !_MONSTER_LIB
                                            m_CRobotis.SetParam_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);
                                            GridMotionEditor_SetMotor(m_CGridMotionEditor.m_nCurrntCell, nAxis, m_CRobotis.Get_Pos_Angle(nAxis));
#else
                                            m_CMonster.SetParam_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);
                                            GridMotionEditor_SetMotor(m_CGridMotionEditor.m_nCurrntCell, nAxis, m_CMonster.Read_Pos(nAxis));
#endif
                                        }
                                        else
                                        {
                                            //if (m_abEnc[nAxis] == true)//((nAxis >= 6) && (nAxis <= 8)) // ojw5014_genie
                                            //{
                                            //    //Grid_SetMot(m_nCurrntCell, nAxis, 0);  -> Don't care 가 더 낳다.
                                            //}
                                            //else
                                            //{
                                            //bool bOk;
                                            //if (m_CMotor2.IsOpen_Socket() == true)
                                            //{
                                            //    GridMotionEditor_SetMotor(m_CGridMotionEditor.m_nCurrntCell, nAxis, m_CMotor2.Get_Pos_Angle(nAxis));
                                            //}
                                            //else
                                            {
                                                m_CMotor.ReadMot(nAxis, _ADDRESS_TORQUE_CONTROL, 8);
                                                bOk = m_CMotor.WaitReceive(nAxis, 40);
                                                if (bOk == false)
                                                {
                                                    //bPass = false;
                                                }
                                                else
                                                {
                                                    GridMotionEditor_SetMotor(m_CGridMotionEditor.m_nCurrntCell, nAxis, m_CMotor.GetPos_Angle(nAxis));
                                                }
                                            }
                                            //}
                                        }
                                    }
                                    if (m_CMotor2.IsOpen_Socket() == true)
                                    {
                                        m_CMotor.SetSocket(null);
                                    }
                                    //Grid_DisplayLine(m_nCurrntCell);
                                }
                            }
                            break;
                        #endregion Keys.F1 - 위치값 가져오기
                        #region Keys.F2 - (해당 모터 Servo(1,3,5 등 홀수회) / Driver(2,4,6 등 짝수회) Off
                        case Keys.F2:
                            {
                                //int nLine = m_CGridMotionEditor.OjwGrid_GetCurrentLine();
                                //int nCol = m_CGridMotionEditor.OjwGrid_GetCurrentColumn();
                                int nLine = m_CGridMotionEditor.OjwGrid_GetCurrentLine();
                                //if (dgGrid[0, nLine].Selected == true)
                                //{

                                //}
                                for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++)
                                {
                                    if (dgGrid[nAxis + 1, nLine].Selected == true)
                                    {
                                        m_CMotor.DrvSrv(nAxis, false, false);
                                    }
                                }
                            }
                            break;
                        #endregion Keys.F2 - (해당 모터 Servo(1,3,5 등 홀수회) / Driver(2,4,6 등 짝수회) Off
                        #region Keys.F3 - 해당 모터 Servo/Driver On
                        case Keys.F3:
                            {
                                int nLine = m_CGridMotionEditor.OjwGrid_GetCurrentLine();
                                //if (dgGrid[0, nLine].Selected == true)
                                //{

                                //}
                                for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++)
                                {
                                    if (dgGrid[nAxis + 1, nLine].Selected == true)
                                    {
                                        m_CMotor.DrvSrv(nAxis, true, true);
                                    }
                                }
                            }
                            break;
                        #endregion Keys.F3 - 해당 모터 Servo/Driver On
                        #region Keys.Delete: - 삭제하기
                        case Keys.Delete:
                            {
                                if (dgGrid.Focused == true)
                                {
                                    if (e.Control)
                                    {
                                        int nLine = m_CGridMotionEditor.OjwGrid_GetCurrentLine();
                                        int nCol = m_CGridMotionEditor.OjwGrid_GetCurrentColumn();
                                        Flag_Delete(nLine, 1);
                                        m_CGridMotionEditor.Delete(nLine, 1);

                                        // 뺀만큼 더해준다.
                                        m_CGridMotionEditor.Add(m_CGridMotionEditor.GetHandle().RowCount - 1, 1);
                                        for (int j = 0; j < m_CHeader.nMotorCnt; j++)
                                        {
                                            m_pnFlag[m_CGridMotionEditor.GetHandle().RowCount - 1, j] = (int)(
                                                        0x10 | // Enable
                                                        ((m_CHeader.pSMotorInfo[j].nMotorControlType != 0) ? 0x08 : 0x00)// 위치제어가 아니라면 //0x08 //| // MotorType
                                                //0x07 // Led
                                                        );
                                            CheckFlag(nLine);
                                        }
                                        //m_CGridMotionEditor.GetHandle().GetCellDisplayRectangle(
                                        m_CGridMotionEditor.ChangePos(m_CGridMotionEditor.GetHandle(), nLine, 1);//nCol); // OJW5014_20161031
                                    }
                                    else
                                    {
                                        int nPos_Start_X = 0, nPos_Start_Y = 0;
                                        int nPos_End_X = 0, nPos_End_Y = 0;
                                        int nX_Limit = dgGrid.RowCount;
                                        int nY_Limit = dgGrid.ColumnCount;
                                        // 첫 위치 찾아내기
                                        int k = 0;
                                        bool bStart = false;
                                        
                                        bool bLed = false; // For Led Copy
                                        bool bChoose = false;

                                        for (int j = 0; j < nY_Limit; j++)
                                        {
                                            bStart = false;
                                            for (int i = 0; i < nX_Limit; i++)
                                            {
                                                if (dgGrid[j, i].Selected == true)
                                                {
                                                    // Start
                                                    if (i == 0)
                                                    {
                                                        bStart = true;
                                                    }
                                                    else if (dgGrid[j, i - 1].Selected == false)
                                                    {
                                                        bStart = true;
                                                    }
                                                    else bStart = false;

                                                    if (bStart == true)
                                                    {
                                                        nPos_Start_X = i; nPos_Start_Y = j;

                                                        for (k = i; k < nX_Limit; k++)
                                                        {
                                                            if (k >= (nX_Limit - 1))
                                                            {
                                                                nPos_End_X = k; nPos_End_Y = j; // j는 항상 같게...
                                                            }
                                                            else
                                                            {
                                                                if (dgGrid[j, k + 1].Selected == false)
                                                                {
                                                                    nPos_End_X = k; nPos_End_Y = j; // j는 항상 같게...

                                                                    break;
                                                                }
                                                            }
                                                        }

                                                        for (k = nPos_Start_X; k <= nPos_End_X; k++)
                                                        {
                                                            dgGrid[j, k].Selected = true;
                                                            if (j == dgGrid.ColumnCount - 1) dgGrid[j, k].Value = ""; // Caption
                                                            //else if (j == 0) {} // Index
                                                            else
                                                            {
                                                                dgGrid[j, k].Value = 0;
                                                                //if ((j > 0) && (j <= m_pCHeader[m_nCurrentRobot].nMotorCnt))
                                                                //{
                                                                // Led만 클리어 한다.
                                                                //Grid_SetFlag_Led(k, j, 0);
                                                                //    m_pnFlag[k, j - 1] = (int)(m_pnFlag[k, j - 1] & 0x18);// | (int)(nLed & 0x07));
                                                                //}

                                                                int nLine = k;
                                                                int nMotNum = (j - 1);
                                                                if ((nMotNum >= 0) && (nMotNum < GetHeader_nMotorCnt()))
                                                                {
                                                                    if (bLed == false)
                                                                    {
                                                                        if ((m_pnFlag[nLine, nMotNum] & 0X07) != 0)
                                                                        {
                                                                            if (bChoose == false)
                                                                            {
                                                                                bChoose = true;
                                                                                DialogResult dlgRet = MessageBox.Show("Do you want to remove this with some LED Values?", "Copy", MessageBoxButtons.OKCancel, MessageBoxIcon.Warning);
                                                                                if (dlgRet == DialogResult.OK) bLed = true;
                                                                            }
                                                                        }
                                                                    }

                                                                    #region Led
                                                                    if (bLed == true)
                                                                    {

                                                                        m_pnFlag[nLine, nMotNum] = (
                                                                            (m_pnFlag[nLine, nMotNum] & 0X18) | // Enable, SpeedType
                                                                            0x00 // LED 정보만 클리어
                                                                            );
#if _ENABLE_LED_FONT_COLOR
                                                                        m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.ForeColor = Color.Black;
#endif

                                                                    }
                                                                    #endregion Led
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    //Grid_DisplayLine(m_nCurrntCell);
                                    //CheckFlag(m_nCurrntCell);
                                    CheckFlag(m_CGridMotionEditor.m_nCurrntCell);
                                    // 색칠하기...
                                    GridMotionEditor_SetColorGrid(0, dgGrid.RowCount);
                                }
                            }
                            break;
                        #endregion Keys.Delete: - 삭제하기
                        #region Keys.V - 붙여넣기
                        case Keys.V:
                            {
                                if (dgGrid.Focused == true)
                                {
                                    try
                                    {
                                        //int nCntPos = 0;

                                        int nPos_X = 0, nPos_Y = 0;
                                        bool bPass = false;
                                        int nX_Limit = dgGrid.RowCount;
                                        int nY_Limit = dgGrid.ColumnCount;

                                        #region 첫 위치 찾아내기
                                        for (int i = 0; i < nX_Limit; i++)
                                        {
                                            for (int j = 0; j < nY_Limit; j++)
                                            {
                                                if ((dgGrid[j, i].Selected == true) && (bPass == false))
                                                {
                                                    nPos_X = i; nPos_Y = j;
                                                    //Message(CConvert.IntToStr(nPos_X) + ", " + CConvert.IntToStr(nPos_Y));
                                                    bPass = true;
                                                    break;
                                                }
                                            }
                                            if (bPass == true) break;
                                        }
                                        #endregion

                                        // 복사된 행의 열을 구하기 위하여 클립보드 사용.
                                        IDataObject iData = Clipboard.GetDataObject();
                                        string strClp = (string)iData.GetData(DataFormats.Text);

                                        if (strClp == null) break;

                                        string strClip = "";

                                        #region Tab, \r\n 의 개수를 셈
                                        int nCnt = 0;
                                        int nT_Cnt = 0;
                                        int nLine_Cnt = 0;
                                        string strDisp = "";
                                        for (int i = 0; i < strClp.Length; i++)
                                        {
                                            if (strClp[i] == '\t') nT_Cnt++;
                                            else if (strClp[i] == '\n') nLine_Cnt++;
                                            if (strClp[i] != '\r')
                                            {
                                                if ((i == strClp.Length - 1) && (strClp[i] < 0x20)) break;
                                                if ((strClp[i] >= 0x20) && (strClp[i] != '\t') && (strClp[i] != '\n'))
                                                {
                                                    nCnt++;
                                                    strDisp += strClp[i];
                                                }
                                                strClip += strClp[i];
                                            }
                                        }
                                        #endregion

                                        int nW = 0, nH = 0;
                                        int nAll = 0;
                                        if (strClip.Length > 0)
                                        {
                                            // strClip -> 이 데이타가 진짜
                                            //nW = 1; 
                                            nH = 1;
                                            nAll = 1;
                                            for (int i = 0; i < strClip.Length; i++)
                                            {
                                                // 가로열, 세로열 카운트
                                                if (strClip[i] == '\n') nH++;
                                                if ((strClip[i] == '\n') || (strClip[i] == '\t')) nAll++;
                                            }
                                            nW = (int)Math.Round((float)nAll / (float)nH, 0);
                                            //Message("nW = " + CConvert.IntToStr(nW) + ", nH = " + CConvert.IntToStr(nH));

                                            bool bW = false, bH = false;
                                            if (nW >= nY_Limit) bW = true;
                                            if (nH >= nX_Limit) bH = true;

                                            String[,] pstrValue = new string[nW, nH];
                                            bool[,] pbValid = new bool[nW, nH];
                                            int nX = 0, nY = 0;
                                            for (int i = 0; i < nW; i++) // 초기화
                                                for (int j = 0; j < nH; j++)
                                                {
                                                    pstrValue[i, j] = "";
                                                    pbValid[i, j] = false;
                                                }

                                            for (int i = 0; i < strClip.Length; i++)
                                            {
                                                if (strClip[i] == '\n') { nY++; nX = 0; }
                                                else if (strClip[i] == '\t') nX++;
                                                else
                                                {
                                                    pbValid[nX, nY] = true;
                                                    pstrValue[nX, nY] += strClip[i];
                                                }
                                            }

                                            if (e.Shift)
                                                m_CGridMotionEditor.Insert(m_CGridMotionEditor.m_nCurrntCell, nH);
                                            //Grid_Insert(nPos_X, nH);
                                            else
                                            {
                                                // 모자란 라인 채우기
                                                if (nH > dgGrid.RowCount)
                                                {
                                                    m_CGridMotionEditor.Insert(m_CGridMotionEditor.m_nCurrntCell, nH - dgGrid.RowCount);
                                                }
                                            }

                                            #region 실 데이타 저장
                                            ////// 실 데이타 저장 ///////
                                            // Display
                                            int nOffset_i = 0, nOffset_j = 0;
                                            if (bW == true) nOffset_i++;
                                            if (bH == true) nOffset_j++;
                                            string strTmp;
                                            
                                            bool bLed = false; // For Led Copy
                                            bool bChoose = false;

                                            for (int j = 0; j < nH - nOffset_j; j++)
                                                for (int i = 0; i < nW - nOffset_i; i++)
                                                {
                                                    strTmp = pstrValue[i + nOffset_i, j + nOffset_j];
                                                    if (((nPos_X + j) < dgGrid.RowCount) && ((nPos_Y + i) < nY_Limit))
                                                    {
                                                        if ((pbValid[i + nOffset_i, j + nOffset_j] == true))
                                                        {
                                                            //dgGrid[nPos_Y + i, nPos_X + j].Style.BackColor = Color.Blue;
                                                            // Data
                                                            dgGrid[nPos_Y + i, nPos_X + j].Value = strTmp;
                                                            dgGrid[nPos_Y + i, nPos_X + j].Selected = true;                                                                                                                                                    
#if _COPY_FLAG // 'V'

                                                            int nPosLine = nPos_X + j - (nPos_X - m_nFirstPos_Min_Line);// nPos_X + j + m_nFirstPos_Min_Line;
                                                            int nPosMotor = nPos_Y + i - (nPos_Y - m_nFirstPos_Min_X) - 1;//nPos_Y + i + m_nFirstPos_Min_X;
                                                            if (
                                                                (nPosLine < dgGrid.RowCount) &&
                                                                (nPosLine >= 0) &&
                                                                (nPosMotor < GetHeader_nMotorCnt()) &&
                                                                (nPosMotor >= 0)
                                                            )
                                                            {
                                                                if (((m_pnFlag_Copy[nPosLine, nPosMotor] & 0x07) != 0) && (m_pnFlag_Copy[nPosLine, nPosMotor] != -1))
                                                                {
                                                                    if (bLed == false)
                                                                    {
                                                                        if (bChoose == false)
                                                                        {
                                                                            bChoose = true;
                                                                            DialogResult dlgRet = MessageBox.Show("Do you want to copy this with some LED Values?", "Copy", MessageBoxButtons.OKCancel, MessageBoxIcon.Warning);
                                                                            if (dlgRet == DialogResult.OK) bLed = true;
                                                                        }
                                                                    }

                                                                    if (bLed == true)
                                                                    {
                                                                        int nLine = nPos_X + j;
                                                                        int nMotNum = nPos_Y + (i - 1);

                                                                        m_pnFlag[nLine, nMotNum] = (
                                                                            (m_pnFlag[nLine, nMotNum] & 0X18) | // Enable, SpeedType
                                                                            (m_pnFlag_Copy[nPosLine, nPosMotor] & 0x07) // LED 정보만 // (int)((m_pnFlag_Copy[nPosLine, nPosMotor] & 0x18) | (int)(m_pnFlag_Copy[nPosLine, nPosMotor] & 0x07));
                                                                            );
                                                                        m_pnFlag_Copy[nPosLine, nPosMotor] = -1; // 복사를 완료했으니 클리어       
                                                                                                                   
#if _ENABLE_LED_FONT_COLOR
                                                                        Color cColor = Color.FromArgb(
                                                                            (((m_pnFlag[nLine, nMotNum] & 0x01) != 0) ? 255 : 0), // R
                                                                            (((m_pnFlag[nLine, nMotNum] & 0x04) != 0) ? 255 : 0), // G
                                                                            (((m_pnFlag[nLine, nMotNum] & 0x02) != 0) ? 255 : 0) // B
                                                                        );
                                                                        //System.Drawing.Font("굴림", 9F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(129)));

#if _ENABLE_LED_FONT_BOLD
                                                                        if (cColor != Color.FromArgb(0, 0, 0))//Color.Black)
                                                                        {
                                                                            Font fnt = this.Font;//m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font;
                                                                            m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(m_CGridMotionEditor.GetHandle().Font, FontStyle.Bold);
                                                                            //m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(fnt.Name, fnt.Size, System.Drawing.FontStyle.Bold, fnt.Unit, fnt.GdiCharSet);
                                                                        }
                                                                        else// if (m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font.Bold == true)
                                                                        {
                                                                            Font fnt = this.Font;//m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font;
                                                                            m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(m_CGridMotionEditor.GetHandle().Font, FontStyle.Regular);
                                                                            //m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(fnt.Name, fnt.Size, System.Drawing.FontStyle.Regular, fnt.Unit, fnt.GdiCharSet);
                                                                        }
#endif
                                                                        m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.ForeColor = (((m_pnFlag[nLine, nMotNum] & 0x02) != 0) ? Color.Gray : cColor);
#endif





                                                                    }
                                                                }
                                                            }
#endif
                                                            //                                             if (dgGrid == dgAngle)
                                                            //                                             {
                                                            //                                                 // Forward
                                                            //                                                 int nGroup = CheckKinematicsMotor_ByIndex(nPos_X + j);
                                                            //                                                 if (nGroup >= 0)
                                                            //                                                 {
                                                            //                                                     Grid_ForwardKinematics_Separation(nPos_Y + i, nGroup);
                                                            //                                                 }
                                                            //                                             }
                                                            //                                             else// dataGrid_XY2Angle(k);
                                                            //                                             {
                                                            //                                                 int nGroup = j / 3;
                                                            //                                                 Grid_InverseKinematics_Separation(nPos_Y + i, nGroup);
                                                            //                                             }
                                                        }
                                                    }
                                                }
                                            //                                 for (int j = 0; j < nH - nOffset_j; j++)
                                            //                                 {
                                            //                                     if (dgGrid == dataGrid_Angle) dataGrid_Angle2XY(nPos_X + j);
                                            //                                     else dataGrid_XY2Angle(nPos_X + j);
                                            //                                 }
                                            #endregion



                                        }
                                        m_nFirstPos_Min_X = 9999999;
                                        m_nFirstPos_Min_Line = 9999999;
                                        //Grid_DisplayLine(m_nCurrntCell);

                                        CheckFlag(m_CGridMotionEditor.m_nCurrntCell);
                                        // 색칠하기...
                                        GridMotionEditor_SetColorGrid(0, dgGrid.RowCount);
                                    }
                                    catch (Exception e2)
                                    {
                                        MessageBox.Show(e2.ToString());
                                    }
                                }
                            }
                            break;
                        #endregion Keys.V - 붙여넣기

                        #region Keys.B - 수식 붙여넣기
                        case Keys.B:
                            {
                                if (dgGrid.Focused == true)
                                {
                                    try
                                    {
                                        int nPos_X = 0, nPos_Y = 0;
                                        bool bPass = false;
                                        int nX_Limit = dgGrid.RowCount;
                                        int nY_Limit = dgGrid.ColumnCount;

                                        #region 첫 위치 찾아내기
                                        for (int i = 0; i < nX_Limit; i++)
                                        {
                                            for (int j = 0; j < nY_Limit; j++)
                                            {
                                                if ((dgGrid[j, i].Selected == true) && (bPass == false))
                                                {
                                                    nPos_X = i; nPos_Y = j;
                                                    bPass = true;
                                                    break;
                                                }
                                            }
                                            if (bPass == true) break;
                                        }
                                        #endregion

                                        // 복사된 행의 열을 구하기 위하여 클립보드 사용.
                                        IDataObject iData = Clipboard.GetDataObject();
                                        //string strClp = (string)iData.GetData(DataFormats.Text);
                                        string strClp = Ojw.CConvert.RemoveChar((string)iData.GetData(DataFormats.Text), '"');

                                        if (strClp == null) break;

                                        string strClip = "";

                                        #region Tab, \r\n 의 개수를 셈
                                        int nCnt = 0;
                                        int nT_Cnt = 0;
                                        int nLine_Cnt = 0;
                                        string strDisp = "";
                                        for (int i = 0; i < strClp.Length; i++)
                                        {
                                            //if (strClp[i] == '"')
                                            //    continue;
                                            if (strClp[i] == '\t') nT_Cnt++;
                                            else if (strClp[i] == '\n') nLine_Cnt++;
                                            if (strClp[i] != '\r')
                                            {
                                                if ((i == strClp.Length - 1) && (strClp[i] < 0x20)) break;
                                                if ((strClp[i] >= 0x20) && (strClp[i] != '\t') && (strClp[i] != '\n'))
                                                {
                                                    nCnt++;
                                                    strDisp += strClp[i];
                                                }
                                                strClip += strClp[i];
                                            }
                                        }
                                        #endregion

                                        int nW = 0, nH = 0;
                                        int nAll = 0;
                                        if (strClip.Length > 0)
                                        {
                                            // strClip -> 이 데이타가 진짜
                                            //nW = 1; 
                                            nH = 1;
                                            nAll = 1;
                                            for (int i = 0; i < strClip.Length; i++)
                                            {
                                                // 가로열, 세로열 카운트
                                                if (strClip[i] == '\n') nH++;
                                                if ((strClip[i] == '\n') || (strClip[i] == '\t')) nAll++;
                                            }
                                            nW = (int)Math.Round((float)nAll / (float)nH, 0);
                                            //Message("nW = " + CConvert.IntToStr(nW) + ", nH = " + CConvert.IntToStr(nH));

                                            bool bW = false, bH = false;
                                            if (nW >= nY_Limit) bW = true;
                                            if (nH >= nX_Limit) bH = true;

                                            String[,] pstrValue = new string[nW, nH];
                                            bool[,] pbValid = new bool[nW, nH];
                                            int nX = 0, nY = 0;
                                            for (int i = 0; i < nW; i++) // 초기화
                                                for (int j = 0; j < nH; j++)
                                                {
                                                    pstrValue[i, j] = "";
                                                    pbValid[i, j] = false;
                                                }

                                            for (int i = 0; i < strClip.Length; i++)
                                            {
                                                if (strClip[i] == '\n') { nY++; nX = 0; }
                                                else if (strClip[i] == '\t') nX++;
                                                else
                                                {
                                                    pbValid[nX, nY] = true;
                                                    pstrValue[nX, nY] += strClip[i];
                                                }
                                            }

                                            if (e.Shift)
                                                m_CGridMotionEditor.Insert(m_CGridMotionEditor.m_nCurrntCell, nH);
                                            //Grid_Insert(nPos_X, nH);
                                            else
                                            {
                                                // 모자란 라인 채우기
                                                if (nH > dgGrid.RowCount)
                                                {
                                                    m_CGridMotionEditor.Insert(m_CGridMotionEditor.m_nCurrntCell, nH - dgGrid.RowCount);
                                                }
                                            }

                                            #region 실 데이타 저장
                                            ////// 실 데이타 저장 ///////
                                            // Display
                                            int nOffset_i = 0, nOffset_j = 0;
                                            //if (bW == true) nOffset_i++; // 이 형식에서는 해당 안됨
                                            if (bH == true) nOffset_j++;
                                            string strTmp;

                                            //bool bLed = false; // For Led Copy
                                            //bool bChoose = false;

                                            int nNum = 0;
                                            int nLine = 0;
                                            //float fX = 0.0f, fY = 0.0f, fZ = 0.0f;
                                            float[] afX = new float[256];
                                            float[] afY = new float[256];
                                            float[] afZ = new float[256];
                                            Array.Clear(afX, 0, afX.Length);
                                            Array.Clear(afY, 0, afY.Length);
                                            Array.Clear(afZ, 0, afZ.Length);

                                            for (int j = 0; j < nH - nOffset_j; j++)
                                            {
                                                // 2차 라인부터는 상대값이 적용되지 않게 한다.
                                                Array.Clear(afX, 0, afX.Length);
                                                Array.Clear(afY, 0, afY.Length);
                                                Array.Clear(afZ, 0, afZ.Length);

                                                strTmp = "";
                                                // Line : nPos_X + j
                                                nLine = nPos_X + j;// j + nOffset_j;
                                                //GridMotionEditor_Clear(nLine);
                                                int nCommand = 0;
                                                // Enable
                                                //dgGrid[0, j + nOffset_j].Value = Ojw.CConvert.StrToInt(pstrValue[nOffset_i, j + nOffset_j]);
                                                bool bInc = false;
                                                for (int i = 0; i < nW - nOffset_i; i++)
                                                {
                                                    //nLine = j + nOffset_j;
                                                    strTmp = pstrValue[i + nOffset_i, j + nOffset_j].ToLower();
                                                    if (nCommand == 0)
                                                    {
                                                        if (strTmp.Length > 1)
                                                        {
                                                            if (strTmp[0] == 't')
                                                            {
                                                                nCommand = 1; // Motor
                                                                //nNum = m_CRobotis.GetParam_Axis_From_RealID(Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1)));
                                                                nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));
                                                                //m_CRobotis.GetParam_RealID(nNum);
                                                                continue;
                                                            }
                                                            else if (strTmp[0] == 'n') // Function
                                                            {
                                                                bInc = false;
                                                                nCommand = 2;
                                                                nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));
                                                                continue;
                                                            }
                                                            else if (strTmp[0] == 'i') // Function(incremental)
                                                            {
                                                                bInc = true;
                                                                nCommand = 2;
                                                                nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));

                                                                #region Read Forward
                                                                // 결과가 나오기 보다는 결과를 메모리에 올리기만 한다.
                                                                float[] afMot = new float[m_CHeader.nMotorCnt];
                                                                for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) { afMot[nAxis] = GridMotionEditor_GetMotor(nLine, nAxis); }
                                                                Ojw.CKinematics.CForward.CalcKinematics(m_CHeader.pDhParamAll[nNum], afMot, out afX[nNum], out afY[nNum], out afZ[nNum]);
                                                                #endregion Read Forward

                                                                continue;
                                                            }
                                                            else if (strTmp[0] == 'p') // plus
                                                            {
                                                                nCommand = 8; // Motor
                                                                //nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));
                                                                //nNum = m_CRobotis.GetParam_Axis_From_RealID(Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1)));
                                                                nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));
                                                                continue;
                                                            }
                                                            else if (strTmp[0] == 'c') // copy
                                                            {
                                                                nCommand = 9; // Motor
                                                                //nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));
                                                                //nNum = m_CRobotis.GetParam_Axis_From_RealID(Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1)));
                                                                nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));
                                                                continue;
                                                            }
                                                            else if (strTmp[0] == 'm') // multi
                                                            {
                                                                nCommand = 10; // Motor
                                                                //nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));
                                                                //nNum = m_CRobotis.GetParam_Axis_From_RealID(Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1)));
                                                                nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));
                                                                continue;
                                                            }
                                                            //else if (strTmp[0] == 'x') // mirror
                                                            //{
                                                            //    nCommand = 13; // mirror
                                                            //    //if (Ojw.CConvert.IsDigit(strTmp.Substring(1, strTmp.Length - 1)) == false)
                                                            //    if (strTmp == "xa") nNum = -1;
                                                            //    else if (Ojw.CConvert.IsDigit(strTmp.Substring(1, strTmp.Length - 1)) == true)
                                                            //    {
                                                            //        nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));
                                                            //    }
                                                            //    continue;
                                                            //}
                                                            else if (strTmp[0] == 'r') // refresh
                                                            {
                                                                nCommand = 0; // refresh
                                                                nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));
                                                                
                                                                // 결과가 나오기 보다는 결과를 메모리에 올리기만 한다.
                                                                float [] afMot = new float[m_CHeader.nMotorCnt];
                                                                for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) { afMot[nAxis] = GridMotionEditor_GetMotor(nLine, nAxis); }

                                                                Ojw.CKinematics.CForward.CalcKinematics(m_CHeader.pDhParamAll[nNum], afMot, out afX[nNum], out afY[nNum], out afZ[nNum]);
                                                                continue;
                                                            }
                                                            else if (strTmp[0] == 'f') // Function 000 ~ 
                                                            {
                                                                nCommand = 1000; // Motor
                                                                nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));
                                                                continue;
                                                            }
                                                            // @Command,operand0,operand1,operand2,...
                                                            else if (strTmp[0] == '@')
                                                            {                                                                
                                                                string[] pstrFunctions = strTmp.ToUpper().Split(',');
                                                                if (pstrFunctions.Length > 0)
                                                                {
                                                                    int nIndex = 0;
                                                                    //switch (pstrFunctions[0])
                                                                    switch (pstrFunctions[nIndex++])
                                                                    {
#if false
                                                                        case "@SET_ABS":
                                                                            {
                                                                                if (pstrFunctions.Length >= 4)
                                                                                {
                                                                                    int nIndex = 0;
                                                                                    int nFunction = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                                    float fX = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    float fY = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    float fZ = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);

                                                                                    afX[nFunction] = fX;
                                                                                    afY[nFunction] = fY;
                                                                                    afZ[nFunction] = fZ;
                                                                                    Ojw.CGridView.Grid_Xyz2Angle(this, nLine, nFunction, afX[nFunction], afY[nFunction], afZ[nFunction]);
                                                                                }
                                                                            }
                                                                            break;
                                                                        case "@SET_ABS2":
                                                                            {
                                                                                if (pstrFunctions.Length >= 4)
                                                                                {
                                                                                    int nIndex = 0;
                                                                                    int nFunction = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                                    float fX = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    float fY = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    float fZ = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);

                                                                                    #region Read Forward
                                                                                    // 결과가 나오기 보다는 결과를 메모리에 올리기만 한다.
                                                                                    float[] afMot = new float[m_CHeader.nMotorCnt];
                                                                                    Array.Clear(afMot, 0, afMot.Length);
                                                                                    Ojw.CKinematics.CForward.CalcKinematics(m_CHeader.pDhParamAll[nFunction], afMot, out afX[nFunction], out afY[nFunction], out afZ[nFunction]);
                                                                                    #endregion Read Forward

                                                                                    afX[nFunction] = afX[nFunction] + fX;
                                                                                    afY[nFunction] = afY[nFunction] + fY;
                                                                                    afZ[nFunction] = afZ[nFunction] + fZ;
                                                                                    Ojw.CGridView.Grid_Xyz2Angle(this, nLine, nFunction, afX[nFunction], afY[nFunction], afZ[nFunction]);
                                                                                }
                                                                            }
                                                                            break;
                                                                        case "@SET_INC":
                                                                            {
                                                                                if (pstrFunctions.Length >= 4)
                                                                                {
                                                                                    int nIndex = 0;
                                                                                    int nFunction = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                                    float fX = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    float fY = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    float fZ = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);

                                                                                    #region Read Forward
                                                                                    // 결과가 나오기 보다는 결과를 메모리에 올리기만 한다.
                                                                                    float[] afMot = new float[m_CHeader.nMotorCnt];
                                                                                    for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) { afMot[nAxis] = GridMotionEditor_GetMotor(nLine, nAxis); }
                                                                                    Ojw.CKinematics.CForward.CalcKinematics(m_CHeader.pDhParamAll[nFunction], afMot, out afX[nFunction], out afY[nFunction], out afZ[nFunction]);
                                                                                    #endregion Read Forward

                                                                                    afX[nFunction] += fX;
                                                                                    afY[nFunction] += fY;
                                                                                    afZ[nFunction] += fZ;
                                                                                    Ojw.CGridView.Grid_Xyz2Angle(this, nLine, nFunction, afX[nFunction], afY[nFunction], afZ[nFunction]);
                                                                                }
                                                                            }
                                                                            break;
                                                                        // @SET_INC2,[x],[y],[z],[Rot_X],[Rot_Y],[Rot_Z] 
                                                                        case "@SET_INC2":
                                                                            {
                                                                                if (pstrFunctions.Length >= 4)
                                                                                {
                                                                                    int nIndex = 0;
                                                                                    int nFunction = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                                    float fX = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    float fY = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    float fZ = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    float fRot_X = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    float fRot_Y = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    float fRot_Z = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);

                                                                                    Ojw.CMath.Rotation(fRot_X, fRot_Y, fRot_Z, ref fX, ref fY, ref fZ);

                                                                                    #region Read Forward
                                                                                    // 결과가 나오기 보다는 결과를 메모리에 올리기만 한다.
                                                                                    float[] afMot = new float[m_CHeader.nMotorCnt];
                                                                                    for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) { afMot[nAxis] = GridMotionEditor_GetMotor(nLine, nAxis); }
                                                                                    Ojw.CKinematics.CForward.CalcKinematics(m_CHeader.pDhParamAll[nFunction], afMot, out afX[nFunction], out afY[nFunction], out afZ[nFunction]);
                                                                                    #endregion Read Forward

                                                                                    afX[nFunction] += fX;
                                                                                    afY[nFunction] += fY;
                                                                                    afZ[nFunction] += fZ;
                                                                                    Ojw.CGridView.Grid_Xyz2Angle(this, nLine, nFunction, afX[nFunction], afY[nFunction], afZ[nFunction]);
                                                                                }
                                                                            }
                                                                            break;
                                                                        // 원통좌표계
                                                                        // http://blog.naver.com/PostView.nhn?blogId=mindo1103&logNo=90155554939&redirect=Dlog&widgetTypeCall=true
                                                                        // x = rcosΘ
                                                                        // y = rsinΘ
                                                                        // z = z
                                                                        // r^2 = (x^2 + y^2)
                                                                        // tanΘ = y / z
                                                                        // z = z
                                                                        case "@SET_INC3":
                                                                            {
                                                                                if (pstrFunctions.Length >= 4)
                                                                                {
                                                                                    int nIndex = 0;
                                                                                    int nFunction = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                                    float fR = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    float fTheta = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    float fZ = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    
                                                                                    #region Read Forward
                                                                                    // 결과가 나오기 보다는 결과를 메모리에 올리기만 한다.
                                                                                    float[] afMot = new float[m_CHeader.nMotorCnt];
                                                                                    for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) { afMot[nAxis] = GridMotionEditor_GetMotor(nLine, nAxis); }
                                                                                    Ojw.CKinematics.CForward.CalcKinematics(m_CHeader.pDhParamAll[nFunction], afMot, out afX[nFunction], out afY[nFunction], out afZ[nFunction]);
                                                                                    #endregion Read Forward

                                                                                    afX[nFunction] += (float)(fR * Ojw.CMath.Cos(fTheta));
                                                                                    afY[nFunction] += (float)(fR * Ojw.CMath.Sin(fTheta));
                                                                                    afZ[nFunction] += fZ;
                                                                                    Ojw.CGridView.Grid_Xyz2Angle(this, nLine, nFunction, afX[nFunction], afY[nFunction], afZ[nFunction]);
                                                                                }
                                                                            }
                                                                            break;
#else
                                                                        case "@HELP":
                                                                            {
                                                                                //strRet = FCommand_Help();
                                                                            }
                                                                            break;
                                                                        case "@SET_ABS":
                                                                            {
                                                                                if (pstrFunctions.Length >= 4)
                                                                                {
                                                                                    int nFunction = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                                    float fX = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    float fY = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    float fZ = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);

                                                                                    afX[nFunction] = fX;
                                                                                    afY[nFunction] = fY;
                                                                                    afZ[nFunction] = fZ;
                                                                                    Ojw.CGridView.Grid_Xyz2Angle(this, nLine, nFunction, afX[nFunction], afY[nFunction], afZ[nFunction]);
                                                                                }
                                                                            }
                                                                            break;
                                                                        case "@SET_ABS2":
                                                                            {
                                                                                if (pstrFunctions.Length >= 4)
                                                                                {
                                                                                    int nFunction = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                                    float fX = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    float fY = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    float fZ = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);

                                                                                    #region Read Forward
                                                                                    // 결과가 나오기 보다는 결과를 메모리에 올리기만 한다.
                                                                                    float[] afMot = new float[m_CHeader.nMotorCnt];
                                                                                    Array.Clear(afMot, 0, afMot.Length);
                                                                                    Ojw.CKinematics.CForward.CalcKinematics(m_CHeader.pDhParamAll[nFunction], afMot, out afX[nFunction], out afY[nFunction], out afZ[nFunction]);
                                                                                    #endregion Read Forward

                                                                                    afX[nFunction] = afX[nFunction] + fX;
                                                                                    afY[nFunction] = afY[nFunction] + fY;
                                                                                    afZ[nFunction] = afZ[nFunction] + fZ;
                                                                                    Ojw.CGridView.Grid_Xyz2Angle(this, nLine, nFunction, afX[nFunction], afY[nFunction], afZ[nFunction]);
                                                                                }
                                                                            }
                                                                            break;
                                                                        case "@SET_INC":
                                                                            {
                                                                                if (pstrFunctions.Length >= 4)
                                                                                {
                                                                                    int nFunction = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                                    float fX = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    float fY = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    float fZ = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);

                                                                                    #region Read Forward
                                                                                    // 결과가 나오기 보다는 결과를 메모리에 올리기만 한다.
                                                                                    float[] afMot = new float[m_CHeader.nMotorCnt];
                                                                                    for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) { afMot[nAxis] = GridMotionEditor_GetMotor(nLine, nAxis); }
                                                                                    Ojw.CKinematics.CForward.CalcKinematics(m_CHeader.pDhParamAll[nFunction], afMot, out afX[nFunction], out afY[nFunction], out afZ[nFunction]);
                                                                                    #endregion Read Forward

                                                                                    afX[nFunction] += fX;
                                                                                    afY[nFunction] += fY;
                                                                                    afZ[nFunction] += fZ;
                                                                                    Ojw.CGridView.Grid_Xyz2Angle(this, nLine, nFunction, afX[nFunction], afY[nFunction], afZ[nFunction]);
                                                                                }
                                                                            }
                                                                            break;
                                                                        // @SET_INC1,[Num][x_y_z_0_1_2],[길이],[Rot_X_Y_Z_0_1_2],[각도]
                                                                        case "@SET_INC1":
                                                                            {
                                                                                if (pstrFunctions.Length >= 6)
                                                                                {
                                                                                    int nFunction = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                                    String strXyz = pstrFunctions[nIndex++];
                                                                                    float fXyz = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    String strRot = pstrFunctions[nIndex++];
                                                                                    float fRot = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);

                                                                                    if (strXyz.Length != 1) continue;// return null;
                                                                                    if (strRot.Length != 1) continue;//return null;

                                                                                    float[] afRot = new float[3];
                                                                                    float[] afXyz = new float[3];
                                                                                    Array.Clear(afRot, 0, afRot.Length);
                                                                                    Array.Clear(afXyz, 0, afXyz.Length);

                                                                                    int nXyz = (int)((strXyz[0] >= 'X') ? strXyz[0] - 'X' : Ojw.CConvert.StrToInt(strXyz));
                                                                                    int nRot = (int)((strRot[0] >= 'X') ? strRot[0] - 'X' : Ojw.CConvert.StrToInt(strRot));
                                                                                    if ((nXyz < 0) || (nXyz > 2) || (nRot < 0) || (nRot > 2)) continue;//return null;
                                                                                    afXyz[nXyz] = fXyz;
                                                                                    afRot[nRot] = fRot;

                                                                                    Ojw.CMath.Rotation(afRot[0], afRot[1], afRot[2], ref afXyz[0], ref afXyz[1], ref afXyz[2]);

                                                                                    #region Read Forward
                                                                                    // 결과가 나오기 보다는 결과를 메모리에 올리기만 한다.
                                                                                    float[] afMot = new float[m_CHeader.nMotorCnt];
                                                                                    for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) { afMot[nAxis] = GridMotionEditor_GetMotor(nLine, nAxis); }
                                                                                    Ojw.CKinematics.CForward.CalcKinematics(m_CHeader.pDhParamAll[nFunction], afMot, out afX[nFunction], out afY[nFunction], out afZ[nFunction]);
                                                                                    #endregion Read Forward

                                                                                    afX[nFunction] += afXyz[0];
                                                                                    afY[nFunction] += afXyz[1];
                                                                                    afZ[nFunction] += afXyz[2];
                                                                                    Ojw.CGridView.Grid_Xyz2Angle(this, nLine, nFunction, afX[nFunction], afY[nFunction], afZ[nFunction]);
                                                                                }
                                                                            }
                                                                            break;
                                                                        // @SET_INC2,[Num][x],[y],[z],[Rot_X],[Rot_Y],[Rot_Z] 
                                                                        case "@SET_INC2":
                                                                            {
                                                                                if (pstrFunctions.Length >= 8)
                                                                                {
                                                                                    int nFunction = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                                    float fX = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    float fY = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    float fZ = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    float fRot_X = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    float fRot_Y = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    float fRot_Z = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);

                                                                                    Ojw.CMath.Rotation(fRot_X, fRot_Y, fRot_Z, ref fX, ref fY, ref fZ);

                                                                                    #region Read Forward
                                                                                    // 결과가 나오기 보다는 결과를 메모리에 올리기만 한다.
                                                                                    float[] afMot = new float[m_CHeader.nMotorCnt];
                                                                                    for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) { afMot[nAxis] = GridMotionEditor_GetMotor(nLine, nAxis); }
                                                                                    Ojw.CKinematics.CForward.CalcKinematics(m_CHeader.pDhParamAll[nFunction], afMot, out afX[nFunction], out afY[nFunction], out afZ[nFunction]);
                                                                                    #endregion Read Forward

                                                                                    afX[nFunction] += fX;
                                                                                    afY[nFunction] += fY;
                                                                                    afZ[nFunction] += fZ;
                                                                                    Ojw.CGridView.Grid_Xyz2Angle(this, nLine, nFunction, afX[nFunction], afY[nFunction], afZ[nFunction]);
                                                                                }
                                                                            }
                                                                            break;
                                                                        // 원통좌표계
                                                                        // http://blog.naver.com/PostView.nhn?blogId=mindo1103&logNo=90155554939&redirect=Dlog&widgetTypeCall=true
                                                                        // x = rcosΘ
                                                                        // y = rsinΘ
                                                                        // z = z
                                                                        // r^2 = (x^2 + y^2)
                                                                        // tanΘ = y / z
                                                                        // z = z
                                                                        case "@SET_INC3":
                                                                            {
                                                                                if (pstrFunctions.Length >= 4)
                                                                                {
                                                                                    int nFunction = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                                    float fR = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    float fTheta = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                    float fZ = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);

                                                                                    #region Read Forward
                                                                                    // 결과가 나오기 보다는 결과를 메모리에 올리기만 한다.
                                                                                    float[] afMot = new float[m_CHeader.nMotorCnt];
                                                                                    for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) { afMot[nAxis] = GridMotionEditor_GetMotor(nLine, nAxis); }
                                                                                    Ojw.CKinematics.CForward.CalcKinematics(m_CHeader.pDhParamAll[nFunction], afMot, out afX[nFunction], out afY[nFunction], out afZ[nFunction]);
                                                                                    #endregion Read Forward

                                                                                    afX[nFunction] += (float)(fR * Ojw.CMath.Cos(fTheta));
                                                                                    afY[nFunction] += (float)(fR * Ojw.CMath.Sin(fTheta));
                                                                                    afZ[nFunction] += fZ;
                                                                                    Ojw.CGridView.Grid_Xyz2Angle(this, nLine, nFunction, afX[nFunction], afY[nFunction], afZ[nFunction]);
                                                                                }
                                                                            }
                                                                            break;
                                                                        case "@INIT":// Init
                                                                            {
                                                                                int nTmp = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                                if (nTmp < 0) m_CGridMotionEditor.Clear();
                                                                                else m_CGridMotionEditor.Clear(nLine);
                                                                            }
                                                                            break;
                                                                        case "@SET":// Set Motor
                                                                            {
                                                                                //int nAxis = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                                //int nAxis = m_CRobotis.GetParam_Axis_From_RealID(Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]));
                                                                                int nAxis = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);// Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));
                                                                                float fValue = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                GridMotionEditor_SetMotor(nLine, nAxis, fValue);
                                                                            }
                                                                            break;
                                                                        case "@SET_PLUS":// Set Motor
                                                                            {
                                                                                //int nAxis = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                                int nAxis = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);// m_CRobotis.GetParam_Axis_From_RealID(Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]));
                                                                                float fValue = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                GridMotionEditor_SetMotor(nLine, nAxis, GridMotionEditor_GetMotor(nLine, nAxis) + fValue);
                                                                            }
                                                                            break;
                                                                        case "@Clear":// Clear Motor
                                                                            {
                                                                                int nTmp = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                                for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) GridMotionEditor_SetMotor(nLine, nAxis, 0.0f);
                                                                            }
                                                                            break;
                                                                        case "@ENTER": // Moving Next Line
                                                                            {
                                                                                int nValue = 1;
                                                                                if (pstrFunctions.Length > 1)
                                                                                {
                                                                                    nValue = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                                }
                                                                                int nCurrLine = m_CGridMotionEditor.OjwGrid_GetCurrentLine();
                                                                                int nCurrCol = m_CGridMotionEditor.OjwGrid_GetCurrentColumn();
                                                                                m_CGridMotionEditor.ChangePos_Command(m_CGridMotionEditor.GetHandle(), nCurrLine + nValue, nCurrCol);//.SetChangeCurrentLine(nCurrLine + nValue);
                                                                            }
                                                                            break;
                                                                        case "@SPACE": // Moving Next Column
                                                                            {
                                                                                int nValue = 1;
                                                                                if (pstrFunctions.Length > 1)
                                                                                {
                                                                                    nValue = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                                }
                                                                                int nCurrLine = m_CGridMotionEditor.OjwGrid_GetCurrentLine();
                                                                                int nCurrCol = m_CGridMotionEditor.OjwGrid_GetCurrentColumn();
                                                                                //m_CGridMotionEditor.SetChangeCurrentCol(nCurrLine + nValue);
                                                                                m_CGridMotionEditor.ChangePos_Command(m_CGridMotionEditor.GetHandle(), nCurrLine, nCurrCol + nValue);//.SetChangeCurrentLine(nCurrLine + nValue);
                                                                            }
                                                                            break;
                                                                        case "@SET_COMMAND":
                                                                            {
                                                                                int nTmp = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                                m_CGridMotionEditor.SetCommand(nLine, nTmp);
                                                                            }
                                                                            break;
                                                                        case "@SET_DATA0":
                                                                            {
                                                                                int nTmp = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                                m_CGridMotionEditor.SetData0(nLine, nTmp);
                                                                            }
                                                                            break;
                                                                        case "@SET_DATA1":
                                                                            {
                                                                                int nTmp = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                                m_CGridMotionEditor.SetData1(nLine, nTmp);
                                                                            }
                                                                            break;
                                                                        case "@SET_DATA2":
                                                                            {
                                                                                int nTmp = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                                m_CGridMotionEditor.SetData2(nLine, nTmp);
                                                                            }
                                                                            break;
                                                                        case "@SET_DATA3":
                                                                            {
                                                                                int nTmp = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                                m_CGridMotionEditor.SetData3(nLine, nTmp);
                                                                            }
                                                                            break;
                                                                        case "@SET_DATA4":
                                                                            {
                                                                                int nTmp = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                                m_CGridMotionEditor.SetData4(nLine, nTmp);
                                                                            }
                                                                            break;
                                                                        case "@SET_DATA5":
                                                                            {
                                                                                int nTmp = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                                m_CGridMotionEditor.SetData5(nLine, nTmp);
                                                                            }
                                                                            break;
                                                                        case "@SET_ENABLE":
                                                                            {
                                                                                GridMotionEditor_SetEnable(nLine, Ojw.CConvert.StrToBool(pstrFunctions[nIndex++]));
                                                                            }
                                                                            break;
                                                                        case "@ROT":
                                                                        case "@ROTATE":
                                                                        case "@ROTATION":
                                                                            {
                                                                                float fX = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                float fY = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                float fZ = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                SetAngle_Display(fY, fX, fZ);
                                                                            }
                                                                            break;
                                                                        case "@TRANS":
                                                                        case "@TRANSLATE":
                                                                        case "@TRANSLATION":
                                                                            {
                                                                                float fX = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                float fY = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                float fZ = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                SetPos_Display(fY, fX, fZ);
                                                                            }
                                                                            break;
                                                                        case "@SCALE":
                                                                            {
                                                                                float fValue = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                SetScale(fValue);
                                                                            }
                                                                            break;
                                                                        case "@SET_GROUP": // Group
                                                                            {
                                                                                GridMotionEditor_SetGroup(nLine, Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]));
                                                                            }
                                                                            break;
                                                                        case "@SET_CAPTION": // Caption
                                                                            {
                                                                                m_CGridMotionEditor.SetCaption(nLine, pstrFunctions[nIndex++]);
                                                                            }
                                                                            break;
                                                                        case "@SET_SPEED":
                                                                            {
                                                                                m_CGridMotionEditor.SetTime(nLine, Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]));
                                                                            }
                                                                            break;
                                                                        case "@SET_DELAY":
                                                                            {
                                                                                m_CGridMotionEditor.SetDelay(nLine, Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]));
                                                                            }
                                                                            break;
                                                                        case "@COPY":
                                                                            {
                                                                                //int nID1 = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                                //int nID2 = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                                int nID1 = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);// m_CRobotis.GetParam_Axis_From_RealID(Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]));
                                                                                int nID2 = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);//m_CRobotis.GetParam_Axis_From_RealID(Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]));
                                                                                int nDir = ((strTmp.IndexOf('-') >= 0) ? -1 : 1);
                                                                                if (nDir < 0) nID2 = -nID2;
                                                                                GridMotionEditor_SetMotor(nLine, nNum, GridMotionEditor_GetMotor(nLine, nID2) * nDir);
                                                                            }
                                                                            break;
                                                                        case "@SET_MULTI":
                                                                            {
                                                                                //int nAxis = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                                int nAxis = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);//m_CRobotis.GetParam_Axis_From_RealID(Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]));
                                                                                float fValue = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                                                GridMotionEditor_SetMotor(nLine, nAxis, GridMotionEditor_GetMotor(nLine, nAxis) * fValue);
                                                                            }
                                                                            break;
                                                                        case "@READ":
                                                                            {
                                                                                if (pstrFunctions.Length > 1)
                                                                                {
                                                                                    int nFunction = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);

                                                                                    // 결과가 나오기 보다는 결과를 메모리에 올리기만 한다.
                                                                                    float[] afMot = new float[m_CHeader.nMotorCnt];
                                                                                    for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) { afMot[nAxis] = GridMotionEditor_GetMotor(nLine, nAxis); }

                                                                                    Ojw.CKinematics.CForward.CalcKinematics(m_CHeader.pDhParamAll[nFunction], afMot, out afX[nFunction], out afY[nFunction], out afZ[nFunction]);
                                                                                    //Ojw.CMessage.Write2("Position : {0}, {1}, {2}", afX[nFunction], afY[nFunction], afZ[nFunction]);
                                                                                    //strRet = String.Format("Position[{0}] : {1}, {2}, {3}", GetHeader_pstrGroupName()[nFunction], afX[nFunction], afY[nFunction], afZ[nFunction]);
                                                                                }
                                                                            }
                                                                            break;
                                                                        case "@SET_LINE": // Group
                                                                            {
                                                                                nLine = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                                            }
                                                                            break;
#endif
                                                                    }
                                                                }
                                                                nCommand = 0;
                                                                //return; // 이 명령어 이후는 굳이 실행할 필요 없다.
                                                            }
                                                        }
                                                        else if (strTmp.Length == 1)
                                                        {
                                                            if (strTmp == "e") // Enable
                                                            {
                                                                nCommand = 5;
                                                                continue;
                                                            }
                                                            else if (strTmp == "s") // Speed
                                                            {
                                                                nCommand = 6;
                                                                continue;
                                                            }
                                                            else if (strTmp == "d") // Delay
                                                            {
                                                                nCommand = 7;
                                                                continue;
                                                            }
                                                            else if (strTmp == "g") // group
                                                            {
                                                                nCommand = 11;
                                                                continue;
                                                            }
                                                            else if (strTmp == "w") // write
                                                            {
                                                                nCommand = 12;

                                                                //SetRobot_Rot(30, 10, 20);
                                                                continue;
                                                            }
                                                            else if (strTmp == "x") // mirror
                                                            {
                                                                nCommand = 13;
                                                                continue;
                                                            }
                                                        }
                                                    }
                                                    //else if (strTmp.Le
                                                    ///////////////////
                                                    // Value
                                                    if (nCommand != 0)
                                                    {
                                                        if (nCommand == 1)
                                                        {
                                                            GridMotionEditor_SetMotor(nLine, nNum, Ojw.CConvert.StrToFloat(strTmp));
                                                            //dgGrid[nNum, nLine].Value = Ojw.CConvert.StrToFloat(strTmp);
                                                            nCommand = 0;
                                                        }
                                                        #region Function - Absolute / Incremental
                                                        else if (nCommand == 2)
                                                        {
                                                            if (bInc == true)
                                                                afX[nNum] += Ojw.CConvert.StrToFloat(strTmp);
                                                            else
                                                                afX[nNum] = Ojw.CConvert.StrToFloat(strTmp);
                                                            nCommand++;
                                                        }
                                                        else if (nCommand == 3)
                                                        {
                                                            if (bInc == true)
                                                                afY[nNum] += Ojw.CConvert.StrToFloat(strTmp);
                                                            else
                                                                afY[nNum] = Ojw.CConvert.StrToFloat(strTmp);
                                                            nCommand++;
                                                        }
                                                        else if (nCommand == 4)
                                                        {
                                                            if (bInc == true)
                                                                afZ[nNum] += Ojw.CConvert.StrToFloat(strTmp);
                                                            else
                                                                afZ[nNum] = Ojw.CConvert.StrToFloat(strTmp);
                                                            Ojw.CGridView.Grid_Xyz2Angle(this, nLine, nNum, afX[nNum], afY[nNum], afZ[nNum]);
                                                            nCommand = 0;
                                                        }
                                                        #endregion
                                                        else if (nCommand == 5) // Enable
                                                        {
                                                            GridMotionEditor_SetEnable(nLine, Ojw.CConvert.StrToBool(strTmp));
                                                            nCommand = 0;
                                                        }
                                                        else if (nCommand == 6) // Speed
                                                        {
                                                            GridMotionEditor_SetTime(nLine, Ojw.CConvert.StrToInt(strTmp));
                                                            nCommand = 0;
                                                        }
                                                        else if (nCommand == 7) // Delay
                                                        {
                                                            GridMotionEditor_SetDelay(nLine, Ojw.CConvert.StrToInt(strTmp));
                                                            nCommand = 0;
                                                        }
                                                        else if (nCommand == 8) // plus
                                                        {
                                                            GridMotionEditor_SetMotor(nLine, nNum, GridMotionEditor_GetMotor(nLine, nNum) + Ojw.CConvert.StrToFloat(strTmp));
                                                            //dgGrid[nNum, nLine].Value = Ojw.CConvert.StrToFloat(strTmp);
                                                            nCommand = 0;
                                                        }
                                                        else if (nCommand == 9) // copy
                                                        {
                                                            int nID2 = Ojw.CConvert.StrToInt(strTmp);
                                                            int nDir = ((strTmp.IndexOf('-') >= 0) ? -1 : 1);
                                                            //if (nID2 < 0)
                                                            //{
                                                            //    nDir = -1;
                                                            //    nID2 = -nID2;
                                                            //}
                                                            if (nDir < 0)
                                                            {
                                                                nID2 = -nID2;
                                                            }
                                                            GridMotionEditor_SetMotor(nLine, nNum, GridMotionEditor_GetMotor(nLine, nID2) * nDir);
                                                            //dgGrid[nNum, nLine].Value = Ojw.CConvert.StrToFloat(strTmp);
                                                            nCommand = 0;
                                                        }
                                                        else if (nCommand == 10) // multi
                                                        {
                                                            GridMotionEditor_SetMotor(nLine, nNum, GridMotionEditor_GetMotor(nLine, nNum) * Ojw.CConvert.StrToFloat(strTmp));
                                                            //dgGrid[nNum, nLine].Value = Ojw.CConvert.StrToFloat(strTmp);
                                                            nCommand = 0;
                                                        }
                                                        else if (nCommand == 11) // Group
                                                        {
                                                            GridMotionEditor_SetGroup(nLine, Ojw.CConvert.StrToInt(strTmp));
                                                            nCommand = 0;
                                                        }
                                                        else if (nCommand == 12) // Caption
                                                        {
                                                            m_CGridMotionEditor.SetCaption(nLine, strTmp);
                                                            // 색칠하기...
                                                            //GridMotionEditor_SetColorGrid(nLine, 2);
                                                            //GridMotionEditor_
                                                            nCommand = 0;
                                                        }
                                                        else if (nCommand == 13) // Mirror
                                                        {                                           
                                                            if (Ojw.CConvert.IsDigit(strTmp) == true)
                                                            {
                                                                int nMotorID = Ojw.CConvert.StrToInt(strTmp);
                                                                if (nMotorID < 0)
                                                                {
                                                                    // Mirror All(이중 복사 방지)
                                                                    bool [] abSet = new bool[m_CHeader.nMotorCnt];
                                                                    for (int nMotor = 0; nMotor < m_CHeader.nMotorCnt; nMotor++)
                                                                    {
                                                                        int nMirror = m_CHeader.pSMotorInfo[nMotor].nAxis_Mirror;
                                                                        if (abSet[nMotor] == true) continue;
                                                                        abSet[nMotor] = true;
                                                                        if (nMirror >= 0)
                                                                        {
                                                                            if (abSet[nMirror] == true) continue;
                                                                            abSet[nMirror] = true;
                                                                        }

                                                                        if (nMirror == -2)
                                                                        {
                                                                            GridMotionEditor_SetMotor(nLine, nMotor, -GridMotionEditor_GetMotor(nLine, nMotor));
                                                                        }
                                                                        else if ((nMirror >= 0) && (nMirror < m_CHeader.nMotorCnt))
                                                                        {
                                                                            float fTmp = GridMotionEditor_GetMotor(nLine, nMotor);
                                                                            GridMotionEditor_SetMotor(nLine, nMotor, GridMotionEditor_GetMotor(nLine, nMirror));
                                                                            GridMotionEditor_SetMotor(nLine, nMirror, fTmp);
                                                                        }
                                                                    }
                                                                }
                                                                else
                                                                {
                                                                    int nMotor = nMotorID;
                                                                    int nMirror = m_CHeader.pSMotorInfo[nMotor].nAxis_Mirror;
                                                                    if (nMirror == -2)
                                                                    {
                                                                        GridMotionEditor_SetMotor(nLine, nMotor, -GridMotionEditor_GetMotor(nLine, nMotor));
                                                                    }
                                                                    else if ((nMirror >= 0) && (nMirror < m_CHeader.nMotorCnt))
                                                                    {
                                                                        float fTmp = GridMotionEditor_GetMotor(nLine, nMotor);
                                                                        GridMotionEditor_SetMotor(nLine, nMotor, GridMotionEditor_GetMotor(nLine, nMirror));
                                                                        GridMotionEditor_SetMotor(nLine, nMirror, fTmp);
                                                                    }
                                                                }
                                                            }
                                                            nCommand = 0;
                                                        }
                                                        else if (nCommand >= 1000)
                                                        {
                                                            if (nNum == 0) // Function 000 ~ Clear
                                                            {
                                                                int nTmp = Ojw.CConvert.StrToInt(strTmp);
                                                                if (nTmp < 0) m_CGridMotionEditor.Clear();
                                                                else m_CGridMotionEditor.Clear(nLine);
                                                                //m_CGridMotionEditor.SetData1(nLine, 1);
                                                                //m_CGridMotionEditor.SetData2(nLine, 1);
                                                            }
                                                            else if (nNum == 1) // Function 001 ~ Clear Motor
                                                            {
                                                                float fValue = Ojw.CConvert.StrToFloat(strTmp);
                                                                for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) GridMotionEditor_SetMotor(nLine, nAxis, fValue);
                                                            }
                                                            else if (nNum == 2) // Function 002 ~ Moving Next Line
                                                            {
                                                                int nValue = Ojw.CConvert.StrToInt(strTmp);
                                                                int nCurrLine = m_CGridMotionEditor.OjwGrid_GetCurrentLine();
                                                                m_CGridMotionEditor.SetChangeCurrentLine(nCurrLine + nValue);
                                                            }
                                                            else if (nNum == 3) // Function 003 ~ Moving Next Column
                                                            {
                                                                int nValue = Ojw.CConvert.StrToInt(strTmp);
                                                                int nCurrLine = m_CGridMotionEditor.OjwGrid_GetCurrentColumn();
                                                                m_CGridMotionEditor.SetChangeCurrentCol(nCurrLine + nValue);
                                                            }
                                                            else if (nNum == 99)
                                                            {
                                                                int nTmp = Ojw.CConvert.StrToInt(strTmp);
                                                                m_CGridMotionEditor.SetCommand(nLine, nTmp);
                                                            }
                                                            else if (nNum == 100)
                                                            {
                                                                int nTmp = Ojw.CConvert.StrToInt(strTmp);
                                                                m_CGridMotionEditor.SetData0(nLine, nTmp);
                                                            }
                                                            else if (nNum == 101)
                                                            {
                                                                int nTmp = Ojw.CConvert.StrToInt(strTmp);
                                                                m_CGridMotionEditor.SetData1(nLine, nTmp);
                                                            }
                                                            else if (nNum == 102)
                                                            {
                                                                int nTmp = Ojw.CConvert.StrToInt(strTmp);
                                                                m_CGridMotionEditor.SetData2(nLine, nTmp);
                                                            }
                                                            else if (nNum == 103)
                                                            {
                                                                int nTmp = Ojw.CConvert.StrToInt(strTmp);
                                                                m_CGridMotionEditor.SetData3(nLine, nTmp);
                                                            }
                                                            else if (nNum == 104)
                                                            {
                                                                int nTmp = Ojw.CConvert.StrToInt(strTmp);
                                                                m_CGridMotionEditor.SetData4(nLine, nTmp);
                                                            }
                                                            else if (nNum == 105)
                                                            {
                                                                int nTmp = Ojw.CConvert.StrToInt(strTmp);
                                                                m_CGridMotionEditor.SetData5(nLine, nTmp);
                                                            }
                                                            nCommand = 0;
                                                        }
                                                    }
                                                    //strTmp += pstrValue[i + nOffset_i, j + nOffset_j] + "[]";
                                                }
                                                //MessageBox.Show(strTmp);
                                            }
#if false
                                            for (int j = 0; j < nH - nOffset_j; j++)
                                                for (int i = 0; i < nW - nOffset_i; i++)
                                                {
                                                    strTmp = pstrValue[i + nOffset_i, j + nOffset_j];
                                                    if (((nPos_X + j) < dgGrid.RowCount) && ((nPos_Y + i) < nY_Limit))
                                                    {
                                                        if ((pbValid[i + nOffset_i, j + nOffset_j] == true))
                                                        {
                                                            //dgGrid[nPos_Y + i, nPos_X + j].Style.BackColor = Color.Blue;
                                                            // Data
                                                            dgGrid[nPos_Y + i, nPos_X + j].Value = strTmp;
                                                            dgGrid[nPos_Y + i, nPos_X + j].Selected = true;
#if _COPY_FLAG // 'V'

                                                            int nPosLine = nPos_X + j - (nPos_X - m_nFirstPos_Min_Line);// nPos_X + j + m_nFirstPos_Min_Line;
                                                            int nPosMotor = nPos_Y + i - (nPos_Y - m_nFirstPos_Min_X) - 1;//nPos_Y + i + m_nFirstPos_Min_X;
                                                            if (
                                                                (nPosLine < dgGrid.RowCount) &&
                                                                (nPosLine >= 0) &&
                                                                (nPosMotor < GetHeader_nMotorCnt()) &&
                                                                (nPosMotor >= 0)
                                                            )
                                                            {
                                                                if (((m_pnFlag_Copy[nPosLine, nPosMotor] & 0x07) != 0) && (m_pnFlag_Copy[nPosLine, nPosMotor] != -1))
                                                                {
                                                                    if (bLed == false)
                                                                    {
                                                                        if (bChoose == false)
                                                                        {
                                                                            bChoose = true;
                                                                            DialogResult dlgRet = MessageBox.Show("Do you want to copy this with some LED Values?", "Copy", MessageBoxButtons.OKCancel, MessageBoxIcon.Warning);
                                                                            if (dlgRet == DialogResult.OK) bLed = true;
                                                                        }
                                                                    }

                                                                    if (bLed == true)
                                                                    {
                                                                        int nLine = nPos_X + j;
                                                                        int nMotNum = nPos_Y + (i - 1);

                                                                        m_pnFlag[nLine, nMotNum] = (
                                                                            (m_pnFlag[nLine, nMotNum] & 0X18) | // Enable, SpeedType
                                                                            (m_pnFlag_Copy[nPosLine, nPosMotor] & 0x07) // LED 정보만 // (int)((m_pnFlag_Copy[nPosLine, nPosMotor] & 0x18) | (int)(m_pnFlag_Copy[nPosLine, nPosMotor] & 0x07));
                                                                            );
                                                                        m_pnFlag_Copy[nPosLine, nPosMotor] = -1; // 복사를 완료했으니 클리어       

#if _ENABLE_LED_FONT_COLOR
                                                                        Color cColor = Color.FromArgb(
                                                                            (((m_pnFlag[nLine, nMotNum] & 0x01) != 0) ? 255 : 0), // R
                                                                            (((m_pnFlag[nLine, nMotNum] & 0x04) != 0) ? 255 : 0), // G
                                                                            (((m_pnFlag[nLine, nMotNum] & 0x02) != 0) ? 255 : 0) // B
                                                                        );
                                                                        //System.Drawing.Font("굴림", 9F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(129)));

#if _ENABLE_LED_FONT_BOLD
                                                                        if (cColor != Color.FromArgb(0, 0, 0))//Color.Black)
                                                                        {
                                                                            Font fnt = this.Font;//m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font;
                                                                            m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(m_CGridMotionEditor.GetHandle().Font, FontStyle.Bold);
                                                                            //m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(fnt.Name, fnt.Size, System.Drawing.FontStyle.Bold, fnt.Unit, fnt.GdiCharSet);
                                                                        }
                                                                        else// if (m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font.Bold == true)
                                                                        {
                                                                            Font fnt = this.Font;//m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font;
                                                                            m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(m_CGridMotionEditor.GetHandle().Font, FontStyle.Regular);
                                                                            //m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(fnt.Name, fnt.Size, System.Drawing.FontStyle.Regular, fnt.Unit, fnt.GdiCharSet);
                                                                        }
#endif
                                                                        m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.ForeColor = (((m_pnFlag[nLine, nMotNum] & 0x02) != 0) ? Color.Gray : cColor);
#endif





                                                                    }
                                                                }
                                                            }
#endif
                                                            //                                             if (dgGrid == dgAngle)
                                                            //                                             {
                                                            //                                                 // Forward
                                                            //                                                 int nGroup = CheckKinematicsMotor_ByIndex(nPos_X + j);
                                                            //                                                 if (nGroup >= 0)
                                                            //                                                 {
                                                            //                                                     Grid_ForwardKinematics_Separation(nPos_Y + i, nGroup);
                                                            //                                                 }
                                                            //                                             }
                                                            //                                             else// dataGrid_XY2Angle(k);
                                                            //                                             {
                                                            //                                                 int nGroup = j / 3;
                                                            //                                                 Grid_InverseKinematics_Separation(nPos_Y + i, nGroup);
                                                            //                                             }
                                                        }
                                                    }
                                                }
#endif
                                            //                                 for (int j = 0; j < nH - nOffset_j; j++)
                                            //                                 {
                                            //                                     if (dgGrid == dataGrid_Angle) dataGrid_Angle2XY(nPos_X + j);
                                            //                                     else dataGrid_XY2Angle(nPos_X + j);
                                            //                                 }
                                            #endregion



                                        }
                                        m_nFirstPos_Min_X = 9999999;
                                        m_nFirstPos_Min_Line = 9999999;
                                        //Grid_DisplayLine(m_nCurrntCell);

                                        CheckFlag(m_CGridMotionEditor.m_nCurrntCell);
                                        // 색칠하기...
                                        GridMotionEditor_SetColorGrid(0, dgGrid.RowCount);
                                    }
                                    catch (Exception e2)
                                    {
                                        MessageBox.Show(e2.ToString());
                                    }
                                }
                            }
                            break;
                        #endregion Keys.B - 수식 붙여넣기

                        #region Keys.E - 클립보드 Evd 전환
                        case Keys.E:
                            {
                                if (dgGrid.Focused == true)
                                {
                                    try
                                    {
                                        int nLine = dgGrid.RowCount;
                                        int nColumn = dgGrid.ColumnCount;
                                        // 첫 위치 찾아내기

                                        int nMin_Line = 9999999;
                                        int nMin_Column = nMin_Line;
                                        for (int j = 0; j < nColumn; j++)
                                        {                                            
                                            for (int i = 0; i < nLine; i++)
                                            {
                                                if (dgGrid[j, i].Selected == true)
                                                {
                                                    if (nMin_Line > i) nMin_Line = i;
                                                    if (nMin_Column > j) nMin_Column = j;
                                                }
                                            }
                                        }
                                        //MessageBox.Show(String.Format("Line {0}, Column {1}", nMin_Line, nMin_Column));

                                        string strClip = (string)Clipboard.GetDataObject().GetData(typeof(string));
                                        //MessageBox.Show(strClip);
                                        string strData = String.Empty;
                                        string [] pstrClipLine = Ojw.CConvert.RemoveChar(strClip, '\r').Split('\n');
                                        nLine = nMin_Line;
                                        nColumn = nMin_Column;
                                        int nLineAdd = 0;
                                        int nColumnAdd = 0;
                                        foreach (string strLine in pstrClipLine)
                                        {
                                            nColumnAdd = 0;
                                            string [] pstrItems = strLine.Split('\t');
                                            foreach (string strItem in pstrItems)
                                            {
                                                if (strItem.Length > 0)
                                                {
                                                    // Data
                                                    int nAxis = nColumn + nColumnAdd - 1;
                                                    if ((nAxis >= 0) && (nAxis < m_CHeader.nMotorCnt))
                                                    {
                                                        if (m_bDynamixel == false)
                                                            strData += String.Format("{0}\t", m_CMotor.CalcAngle2Evd(nAxis, Ojw.CConvert.StrToFloat(strItem)));
                                                        else
                                                        {
#if !_MONSTER_LIB
                                                            strData += String.Format("{0}\t", m_CRobotis.CalcAngle2Evd(nAxis, Ojw.CConvert.StrToFloat(strItem)));
#else
                                                            strData += String.Format("{0}\t", m_CMonster.CalcAngle2Evd(nAxis, Ojw.CConvert.StrToFloat(strItem)));
#endif
                                                        }
                                                    }
                                                    else strData += strItem + "\t";
                                                }
                                                else
                                                {
                                                    strData += strItem + "\t";
                                                }
                                                nColumnAdd++;
                                            }
                                            strData += "\r\n";
                                            nLineAdd++;
                                        }
                                        Clipboard.SetText(strData);
                                    }
                                    catch (Exception e2)
                                    {
                                        MessageBox.Show(e2.ToString());
                                    }
                                }
                            }
                            break;
                        #endregion Keys.E - 클립보드 Evd 전환
                        #region Keys.R - 클립보드 R+호환 프레임 전환
                        case Keys.R:
                            {
                                if (dgGrid.Focused == true)
                                {
                                    #region Shift
                                    if (e.Shift) // 클립보드의 내용을 R+Motion -> OpenJigWare 로 변환
                                    {                        
#if true

                                            //// 복사된 행의 열을 구하기 위하여 클립보드 사용.
                                        //IDataObject iData = Clipboard.GetDataObject();
                                        //string strClp = (string)iData.GetData(DataFormats.Text);

                                        //// 데이터 변형
                                        //int nOffsetIndex = strClp.IndexOf("pose=");
                                        //if (nOffsetIndex >= 0)
                                        //{
                                        //    string strTmp = String.Empty;

                                        //    int nTime = 0;
                                        //    string[] pstrLines = strClp.Split(' ');
                                        //    foreach (string strItem in pstrLines)
                                        //    {
                                        //        if (strItem.IndexOf("Keyframes") >= 0) continue;
                                        //        else if (strItem.IndexOf("Motion2+Step") >= 0) continue;
                                        //        else if (strItem.IndexOf("frame") >= 0)
                                        //        {
                                        //            nTime = Ojw.CConvert.StrToInt(strItem.Substring(7, strItem.Length - 7 - 1));
                                        //            GridMotionEditor_SetTime(nLine + nLineAdd) / 7.8125f);
                                        //            continue;
                                        //        }
                                        //        else if (strItem.IndexOf("/>") >= 0)
                                        //        {
                                        //            continue;
                                        //        }
                                        //        else if (strItem.IndexOf('\"') >= 0)
                                        //        {
                                        //            strTmp += strItem.Remove(strItem.IndexOf('\"')) + "\t";
                                        //        }
                                        //    }
                                        //    //strClp = strClp.Substring(nOffsetIndex + 6);
                                        //    //strClp = strClp.Substring(0, strClp.IndexOf('\"'));
                                        //}
                                        ///////////////////////////////////////////////////////////////
                                        try
                                        {
                                            int nLine = dgGrid.RowCount;
                                            int nLineAdd = 0;
                                            int nColumn = dgGrid.ColumnCount;
                                            // 첫 위치 찾아내기

                                            int nMin_Line = 9999999;
                                            int nMin_Column = 2;//nMin_Line; // -> MinColumn 을 그냥 첫 위치로 잡는다.
                                            for (int j = 0; j < nColumn; j++)
                                            {
                                                for (int i = 0; i < nLine; i++)
                                                {
                                                    if (dgGrid[j, i].Selected == true)
                                                    {
                                                        if (nMin_Line > i) nMin_Line = i;
                                                        //if (nMin_Column > j) nMin_Column = j;
                                                    }
                                                }
                                            }
                                            //MessageBox.Show(String.Format("Line {0}, Column {1}", nMin_Line, nMin_Column));

                                            string strClips = (string)Clipboard.GetDataObject().GetData(typeof(string));
                                            string[] pstrClips = strClips.Split('\n');
                                            int nOffsetIndex = strClips.IndexOf("Keyframes");
                                            nLineAdd = 0;
                                            nLine = nMin_Line;
                                            int nIncrease = 1;
                                            if (nOffsetIndex >= 0)
                                            {
                                                int nFrame = -1;
                                                List<String> lstClips = new List<string>();
                                                List<int> lstTime = new List<int>();
                                                lstClips.Clear();
                                                lstTime.Clear();
                                                foreach (string strClipData in pstrClips)
                                                {
                                                    if (strClipData.IndexOf("Motion2+Step") >= 0)
                                                    {
                                                        lstClips.Add(strClipData);


                                                        string strClip = strClipData;
                                                        nOffsetIndex = strClip.IndexOf("frame=");
                                                        strClip = strClip.Substring(nOffsetIndex + 7);
                                                        int nTmp = strClip.IndexOf('\"');
                                                        nFrame = Ojw.CConvert.StrToInt(strClip.Substring(0, nTmp));
                                                        lstTime.Add(nFrame);
                                                    }
                                                }
                                                if (lstClips.Count > 1)
                                                {
                                                    //if (lstClips[lstClips.Count - 1]
                                                    //string strClip = lstClips[0];
                                                    //nOffsetIndex = strClip.IndexOf("frame=");
                                                    //strClip = strClip.Substring(nOffsetIndex + 7);
                                                    //int nTmp = strClip.IndexOf('\"');
                                                    //int nFrame0 = Ojw.CConvert.StrToInt(strClip.Substring(0, nTmp));

                                                    //strClip = lstClips[lstClips.Count - 1];
                                                    //nOffsetIndex = strClip.IndexOf("frame="); 
                                                    //strClip = strClip.Substring(nOffsetIndex + 7);
                                                    //nTmp = strClip.IndexOf('\"');
                                                    //int nFrame1 = Ojw.CConvert.StrToInt(strClip.Substring(0, nTmp));
                                                    if (lstTime[0] > lstTime[lstTime.Count - 1])
                                                    {
                                                        nIncrease = -1;
                                                        nLineAdd = lstClips.Count - 1;
                                                        lstTime.Reverse();
                                                    }
                                                }

                                                foreach (string strClipData in pstrClips)
                                                {
                                                    if (strClipData.IndexOf("Motion2+Step") < 0) continue;
                                                    string strClip = strClipData;
                                                    //if (strLine.Length < 3) continue
                                                    string strData = String.Empty;
                                                    nOffsetIndex = strClip.IndexOf("frame=");
                                                    if (nOffsetIndex >= 0)
                                                    {
                                                        //strClip = strClip.Substring(nOffsetIndex + 7);
                                                        //int nTmp = strClip.IndexOf('\"');
                                                        //nFrame = Ojw.CConvert.StrToInt(strClip.Substring(0, nTmp));
                                                        //strClip = strClip.Substring(nTmp);
                                                        nFrame = lstTime[nLineAdd];
                                                        if (nLineAdd > 0)
                                                        {
                                                            nFrame -= lstTime[nLineAdd - 1];
                                                        }
                                                        GridMotionEditor_SetTime(nLine + nLineAdd, (int)Math.Round(nFrame * 7.8125f));
                                                    }
                                                    //// 데이터 변형
                                                    nOffsetIndex = strClip.IndexOf("pose=");
                                                    if (nOffsetIndex >= 0)
                                                    {
                                                        GridMotionEditor_SetEnable(nLine + nLineAdd, true);

                                                        strClip = strClip.Substring(nOffsetIndex + 6);
                                                        strClip = strClip.Substring(0, strClip.IndexOf('\"'));

                                                        //string strTmp = String.Empty;

                                                        ////int nTime = 0;
                                                        //string[] pstrLines = strClip.Split(' ');
                                                        //foreach (string strItem in pstrLines)
                                                        //{
                                                        //    if (strItem.IndexOf('\"') >= 0)
                                                        //    {
                                                        //        strTmp += strItem.Remove(strItem.IndexOf('\"')) + "\t";
                                                        //    }
                                                        //}
                                                        //strClp = strClp.Substring(nOffsetIndex + 6);
                                                        //strClp = strClp.Substring(0, strClp.IndexOf('\"'));



                                                        //MessageBox.Show(strClip);
                                                        //string[] pstrClipLine = Ojw.CConvert.RemoveString(Ojw.CConvert.RemoveChar(strClip, '\r'), "\n\n").Split('\n');
                                                        

                                                        int nColumnPos = (nMin_Column - 1); // Enable 위치를 뺀다.
                                                        // nColumnPos = nMin_Column;
                                                        
                                                        int nColumnAdd = 0;
                                                        //foreach (string strLine in pstrClipLine)
                                                        //{
                                                            nColumnAdd = 0;
                                                            strData += Ojw.CConvert.ChangeChar(strClip, ' ', '\t');
                                                            string[] pstrItems = strClip.Split(' ');
                                                            foreach (string strItem in pstrItems)
                                                            {
                                                                //if (nColumnPos + nColumnAdd >= m_CHeader.nMotorCnt) continue; // 마지막은 Time Cell 위치
                                                                //if (m_CHeader.pSMotorInfo[nColumnPos + nColumnAdd]
                                                                //if (nColumnPos + nColumnAdd == 0) continue; // 이건 나중 헤더의 Enable 을 넣어 처리하도록 한다.
                                                                //if (nColumnPos + nColumnAdd < 0) continue; // 외적인것 삭제
                                                                GridMotionEditor_SetMotor(nLine + nLineAdd, nColumnPos + nColumnAdd, Ojw.CConvert.StrToFloat(strItem) * ((m_CHeader.pSMotorInfo[nColumnPos + nColumnAdd].nMotorDir) > 0 ? -1 : 1) * ((m_CHeader.pSMotorInfo[nColumnPos + nColumnAdd].fRobotisConvertingVar) == 0 ? 1 : m_CHeader.pSMotorInfo[nColumnPos + nColumnAdd].fRobotisConvertingVar));
                                                                //    if (strItem.Length > 0)
                                                                //    {
                                                                //        // Data
                                                                //        int nAxis = nColumn + nColumnAdd - 1;
                                                                //        if ((nAxis >= 0) && (nAxis < m_CHeader.nMotorCnt))
                                                                //        {
                                                                //            strData += String.Format("{0}\t", m_CMotor.CalcAngle2Evd(nAxis, Ojw.CConvert.StrToFloat(strItem)));
                                                                //        }
                                                                //        else strData += strItem + "\t";
                                                                //    }
                                                                //    else
                                                                //    {
                                                                //        strData += strItem + "\t";
                                                                //    }

                                                                //    nColumnAdd++;

                                                                //    //if (strItem.IndexOf("Keyframes") >= 0) continue;
                                                                //    //else if (strItem.IndexOf("Motion2+Step") >= 0) continue;
                                                                //    //else if (strItem.IndexOf("frame") >= 0)
                                                                //    //{
                                                                //    //    int nTime = Ojw.CConvert.StrToInt(strItem.Substring(7, strItem.Length - 7 - 1));
                                                                //    //    GridMotionEditor_SetTime(nLine + nLineAdd - 1, (int)Math.Round(nTime * 7.8125f));
                                                                //    //    continue;
                                                                //    //}
                                                                //    //else if (strItem.IndexOf("/>") >= 0)
                                                                //    //{
                                                                //    //    continue;
                                                                //    //}
                                                                //    //else if (strItem.IndexOf('\"') >= 0)
                                                                //    //{
                                                                //    strData += strItem.Remove(strItem.IndexOf('\"')) + "\t";
                                                                //    //}
                                                                nColumnAdd++;
                                                            }
                                                            //strData += "\r\n";
                                                            //nLineAdd++;
                                                        //}
                                                        //Clipboard.SetText(strData);
                                                    }
                                                    ///////////////////////////////////////////////////////////////
                                                    //nLineAdd++;
                                                    nLineAdd += nIncrease;
                                                }
                                            }
                                            else
                                            {
                                                // 조인트일때도 찾자.
                                                nOffsetIndex = strClips.IndexOf("Joints");
                                                if (nOffsetIndex >= 0)
                                                {
                                                    strClips = Ojw.CConvert.ChangeString(strClips.Substring(nOffsetIndex = strClips.IndexOf("\n") + 1), "\n\n", ";");
                                                    string[] pstrLines = strClips.Split(';');
                                                    foreach (string strLine in pstrLines)
                                                    {
                                                        int nAxis = -1;
                                                        if (strLine.IndexOf("System.Int32(@)") >= 0)
                                                        {
                                                            int nTmp0 = strLine.IndexOf(")") + 1;
                                                            nAxis = Ojw.CConvert.StrToInt(strLine.Substring(nTmp0));
                                                        }
                                                        else if ((nAxis >= 0) && (strLine.IndexOf("System.Single(@)") >= 0))
                                                        {
                                                            int nTmp0 = strLine.IndexOf(")") + 1;
                                                            GridMotionEditor_SetMotor(nLine + nLineAdd, nAxis, Ojw.CConvert.StrToFloat(strLine.Substring(nTmp0)) * ((m_CHeader.pSMotorInfo[nAxis].nMotorDir) > 0 ? -1 : 1) * ((m_CHeader.pSMotorInfo[nAxis].fRobotisConvertingVar) == 0 ? 1 : m_CHeader.pSMotorInfo[nAxis].fRobotisConvertingVar));
                                                        }
                                                    }
                                                }
                                            }                                            
                                        }
                                        catch (Exception e2)
                                        {
                                            MessageBox.Show(e2.ToString());
                                        }
#endif
                                    }
                                    #endregion Shift
                                    else // 클립보드 변형하기 // 클립보드의 내용을 OpenJigWare -> R+Motion 으로 변환
                                    {
#if true
                                        try
                                        {
                                            m_nFirstPos_Min_X = 9999999;
                                            m_nFirstPos_Min_Line = 9999999;

                                            int nPos_Start_X = 0, nPos_Start_Y = 0;
                                            int nPos_End_X = 0, nPos_End_Y = 0;
                                            int nX_Limit = dgGrid.RowCount;
                                            int nY_Limit = dgGrid.ColumnCount;
                                            // 첫 위치 찾아내기
                                            int k = 0;
                                            string strData = "Keyframes\n";// String.Empty;
                                            string strData_Joint = "Joints\n";
                                            bool bStart = false;
                                            int nTimer = 0;
                                            int nFrame = 0;
                                            int nLineAdd = 0;
                                            for (int nLine = 0; nLine < nX_Limit; nLine++)
                                            {
                                                bStart = false;
                                                for (int nCol = 0; nCol < nY_Limit; nCol++)
                                                {
                                                    if (dgGrid[nCol, nLine].Selected == true) 
                                                    {
                                                        if (GridMotionEditor_GetEnable(nLine) == true)
                                                        {
                                                            bStart = true;
                                                        }
                                                        break;
                                                    }
                                                }
                                                if (bStart == false) continue;
                                                
                                                strData_Joint = "Joints\n";
#if true
                                                nFrame += (int)Math.Round((float)GridMotionEditor_GetTime(nLine) / 7.8125f); // R+Motion 에서는 딜레이를 감안하지 않도록 한다.
                                                //strData += String.Format("Motion2+Step(@)<step frame=\"{0}\" pose=\"", nFrame);
                                                strData += String.Format("Motion2+Step|<step frame=\"{0}\" pose=\"", nFrame);
#else
                                                int nTmp_nFrame = (int)(GridMotionEditor_GetTime(nLine) / 7.8125f);//_TIME_TO_FRAME_VALUE);
                                                nTimer = (int)(nTmp_nFrame * 7.8125f);//_TIME_TO_FRAME_VALUE);
                                                nFrame += (int)(nTimer / 7.8125f);//_TIME_TO_FRAME_VALUE);                                                
                                                //strData += String.Format("Motion2+Step(@)<step frame=\"{0}\" pose=\"", nFrame);
                                                strData += String.Format("Motion2+Step|<step frame=\"{0}\" pose=\"", nFrame);
#endif

                                                for (int i = 0; i < m_CHeader.nMotorCnt; i++)
                                                {
                                                    int nAxis = i;
                                                    if (m_CHeader.pSMotorInfo[i].nMotorEnable_For_RPTask == -1) continue; // Enable 이 죽어 있다면 패스
                                                    if (i == 0) continue; // 0번 모터는 사용 안하는 경향이 있어 일단 패스. 나중에는 헤더에서 패스된걸 찾도록 한다.
                                                    float fData = GridMotionEditor_GetMotor(nLine, nAxis) * ((m_CHeader.pSMotorInfo[nAxis].nMotorDir == 0) ? 1 : -1) * ((m_CHeader.pSMotorInfo[nAxis].fRobotisConvertingVar == 0) ? 1 : m_CHeader.pSMotorInfo[nAxis].fRobotisConvertingVar);
                                                    strData += String.Format("{0} ", fData);

                                                    strData_Joint += String.Format("System.Int32(@){0}\nSystem.Single(@){1}\nSystem.String(@)?\nSystem.String(@)?\n\n", m_CHeader.pSMotorInfo[i].nMotorID, fData);
                                                    
                                                }
                                                int nSpare = strData.LastIndexOf(' ');
                                                if (nSpare == strData.Length - 1) strData = strData.Remove(nSpare);
                                                //strData += "\r\n";
                                                strData += "\" />\n\n";

                                                //////////////////////////////////////////////////////////////////////////////////////////

                                                nLineAdd++;  
                                            }
                                            //if (nLineAdd == 1) Clipboard.SetText(strData_Joint); // 이거 그냥 안쓰는게 더 편한듯...
                                            //else 
                                                Clipboard.SetText(strData);
                                            //Grid_DisplayLine(m_nCurrntCell);
                                        }
                                        catch (Exception e2)
                                        {
                                            MessageBox.Show(e2.ToString());
                                        }
#else
                                        try
                                        {
                                            int nLine = dgGrid.RowCount;
                                            int nColumn = dgGrid.ColumnCount;
                                            // 첫 위치 찾아내기

                                            int nMin_Line = 9999999;
                                            int nMin_Column = nMin_Line;
                                            for (int j = 0; j < nColumn; j++)
                                            {
                                                for (int i = 0; i < nLine; i++)
                                                {
                                                    if (dgGrid[j, i].Selected == true)
                                                    {
                                                        if (nMin_Line > i) nMin_Line = i;
                                                        if (nMin_Column > j) nMin_Column = j;
                                                    }
                                                }
                                            }
                                            //MessageBox.Show(String.Format("Line {0}, Column {1}", nMin_Line, nMin_Column));

                                            string strClip = (string)Clipboard.GetDataObject().GetData(typeof(string));
                                            //MessageBox.Show(strClip);
                                            string strData = "Keyframes\n";// String.Empty;
                                            string strData_Joint = "Joints\n";
                                            string[] pstrClipLine = Ojw.CConvert.RemoveChar(strClip, '\r').Split('\n');
                                            nLine = nMin_Line;
                                            nColumn = nMin_Column;
                                            int nLineAdd = 0;
                                            int nColumnAdd = 0;
                                            int nTimer = 0;
                                            foreach (string strLine in pstrClipLine)
                                            {

                                                if (GridMotionEditor_GetEnable(nLine + nLineAdd) == false)
                                                {
                                                    nLineAdd++;
                                                    // Enable == 1 인 프레임만 넣는다.
                                                    continue;
                                                }

                                                strData_Joint = "Joints\n"; //String.Empty; // 이건 그냥 지워둔다.

                                                nTimer += (int)Math.Round((float)GridMotionEditor_GetTime(nLine + nLineAdd) / 7.8125f); // R+Motion 에서는 딜레이를 감안하지 않도록 한다.
                                                strData += String.Format("Motion2+Step(@)<step frame=\"{0}\" pose=\"", nTimer);
                                                nColumnAdd = 0;
                                                string[] pstrItems = strLine.Split('\t');
                                                foreach (string strItem in pstrItems)
                                                {
                                                    if (strItem.Length > 0)
                                                    {
                                                        // Data
                                                        int nAxis = nColumn + nColumnAdd - 1;
                                                        if (nAxis == 0)
                                                        {
                                                            //nPassMotor++;
                                                            nColumnAdd++;
                                                            continue; // 0번 모터는 사용 안하는 경향이 있어 패스 (나중에는 고치도록 한다. 일단은 쉽게)
                                                        }
                                                        if ((nAxis >= 0) && (nAxis < m_CHeader.nMotorCnt))
                                                        {
                                                            float fData = GridMotionEditor_GetMotor(nLine + nLineAdd, nAxis) * ((m_CHeader.pSMotorInfo[nAxis].nMotorDir == 0) ? 1 : -1) * ((m_CHeader.pSMotorInfo[nAxis].fRobotisConvertingVar == 0) ? 1 : m_CHeader.pSMotorInfo[nAxis].fRobotisConvertingVar);
                                                            strData += String.Format("{0} ", fData);

                                                            strData_Joint += String.Format("System.Int32(@){0}\nSystem.Single(@){1}\nSystem.String(@)?\nSystem.String(@)?\n\n", nAxis, fData);
                                                            //if (nColumnAdd < pstrItems.Length - 1)
                                                            //{
                                                            //    strData += " ";
                                                            //}
                                                            //else strData += " ";
                                                        }
                                                        //else strData += strItem + " ";
                                                    }
                                                    else
                                                    {
                                                        if (strItem.Length > 0) strData += strItem + " ";
                                                    }
                                                    nColumnAdd++;
                                                }
                                                int nSpare = strData.LastIndexOf(' ');
                                                if (nSpare == strData.Length - 1) strData = strData.Remove(nSpare);
                                                //strData += "\r\n";
                                                strData += "\" />\n\n";
                                                nLineAdd++;
                                            }
                                            if (nLineAdd == 1)  Clipboard.SetText(strData_Joint);
                                            else                Clipboard.SetText(strData);
                                        }
                                        catch (Exception e2)
                                        {
                                            MessageBox.Show(e2.ToString());
                                        }
#endif
                                    }
                                }
                            }
                            break;
                        #endregion Keys.R - 클립보드 R+호환 프레임 전환
                        #region Keys.C - 복사하기
                        case Keys.C:
                            {
                                if (dgGrid.Focused == true)
                                {
                                    try
                                    {
                                        //bool bLed = true;
                                        //DialogResult dlgRet = MessageBox.Show("Do you want to copy this with some LED Values?", "Copy", MessageBoxButtons.OKCancel, MessageBoxIcon.Warning);
                                        //if (dlgRet != DialogResult.OK)
                                        //{
                                        //    bLed = false;
                                        //}

                                        m_nFirstPos_Min_X = 9999999;
                                        m_nFirstPos_Min_Line = 9999999;

                                        int nPos_Start_X = 0, nPos_Start_Y = 0;
                                        int nPos_End_X = 0, nPos_End_Y = 0;
                                        int nX_Limit = dgGrid.RowCount;
                                        int nY_Limit = dgGrid.ColumnCount;
                                        // 첫 위치 찾아내기
                                        int k = 0;
                                        bool bStart = false;
                                        for (int j = 0; j < nY_Limit; j++)
                                        {
                                            bStart = false;
                                            for (int i = 0; i < nX_Limit; i++)
                                            {
                                                if (dgGrid[j, i].Selected == true)
                                                {
                                                    // Start
                                                    if (i == 0)
                                                    {
                                                        bStart = true;
                                                    }
                                                    else if (dgGrid[j, i - 1].Selected == false)
                                                    {
                                                        bStart = true;
                                                    }
                                                    else bStart = false;

                                                    if (bStart == true)
                                                    {
                                                        nPos_Start_X = i; nPos_Start_Y = j;

                                                        for (k = i; k < nX_Limit; k++)
                                                        {
                                                            if (k >= (nX_Limit - 1))
                                                            {
                                                                nPos_End_X = k; nPos_End_Y = j; // j는 항상 같게...
                                                            }
                                                            else
                                                            {
                                                                if (dgGrid[j, k + 1].Selected == false)
                                                                {
                                                                    nPos_End_X = k; nPos_End_Y = j; // j는 항상 같게...

                                                                    break;
                                                                }
                                                            }
                                                        }

                                                        // 위치와 값을 알고나서...
                                                        //nValue_Start = Convert.ToInt16(rowData[nPos_Start_X][pstrData[nPos_Start_Y]]);
                                                        //nValue_End = Convert.ToInt16(rowData[nPos_End_X][pstrData[nPos_End_Y]]);
                                                        //int nLen = nPos_End_X - nPos_Start_X;

                                                        // 여기서 계산
                                                        //int nValue = CConvert.StrToInt(txtChangeValue.Text);

                                                        //bool bFirst = true;
                                                        for (k = nPos_Start_X; k <= nPos_End_X; k++)
                                                        {
                                                            //dgGrid[j, k].Style.BackColor = Color.Blue;
                                                            dgGrid[j, k].Selected = true;
                                                            if (j == dgGrid.ColumnCount - 1) dgGrid[j, k].Value = ""; // Caption
                                                            //else if (j == 0) {} // Index
                                                            else
                                                            {

#if _COPY_FLAG // 'C'
                                                                int nPosLine = k;
                                                                int nPosMotor = j - 1;
                                                                if ((nPosMotor >= 0) && (nPosMotor < GetHeader_nMotorCnt()))
                                                                {
                                                                    m_pnFlag_Copy[nPosLine, nPosMotor] = (int)m_pnFlag[nPosLine, nPosMotor];// (int)((m_pnFlag[nPosLine, nPosMotor] & 0x18) | (int)(m_pnFlag[nPosLine, nPosMotor] & 0x07));
                                                                    m_nFirstPos_Min_Line = (m_nFirstPos_Min_Line > nPosLine) ? nPosLine : m_nFirstPos_Min_Line;
                                                                    m_nFirstPos_Min_X = (m_nFirstPos_Min_X > j) ? j : m_nFirstPos_Min_X; // 위치의 가로열 몇번째인지...
                                                                }
#if false
                                                            if ((j >= 0) && (j <= m_pCHeader[m_nCurrentRobot].nMotorCnt))
                                                            {
                                                                int m = j;
                                                                if ((m >= 1) && (m <= m_pCHeader[m_nCurrentRobot].nMotorCnt))
                                                                {
                                                                    // Led만 복사 한다.
                                                                    //Grid_SetFlag_Led(k, j, 0); 
                                                                    m_pnFlag_Copy[k, m - 1] = (int)((m_pnFlag[k, m - 1] & 0x18) | (int)(m_pnFlag[k, m - 1] & 0x07));

                                                                    m_nFirstPos_Min_Line = (m_nFirstPos_Min_Line > k) ? k : m_nFirstPos_Min_Line;
                                                                    m_nFirstPos_Min_X = (m_nFirstPos_Min_X > (m - 1)) ? (m - 1) : m_nFirstPos_Min_X;

                                                                    //m_pnFlag_Copy_Pos[k, m - 1, 0] = k;
                                                                    //m_pnFlag_Copy_Pos[k, m - 1, 1] = m - 1;
                                                                    //if (bFirst == true)
                                                                    //{
                                                                        m_pnFlag_Offset_Num_Line[nCntPos] = k;
                                                                        m_pnFlag_Offset_Num_Motor[nCntPos] = m - 1;
                                                                        nCntPos++;
                                                                        //bFirst = false;
                                                                    //}
                                                                }
                                                            }
#endif
#endif
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        //Grid_DisplayLine(m_nCurrntCell);
                                    }
                                    catch (Exception e2)
                                    {
                                        MessageBox.Show(e2.ToString());
                                    }
                                }
                            }
                            break;
                        #endregion Keys.C - 복사하기
                    }
                }
                
                public string FCommand(string strCommand)
                {
                    //m_CGridMotionEditor.GetHandle().CurrentCell = m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[1];
                    //int nX = dgAngle.CurrentCell.ColumnIndex;
                    int nLine = m_dgAngle.CurrentCell.RowIndex;
                    string strRet = FCommand(nLine, strCommand);



                    // 속도 느려질 수도...
                    float[] afMot = new float[256];
                    for (int i = 0; i < GetHeader_nMotorCnt(); i++) SetData(i, m_CGridMotionEditor.Get(nLine, i));//afMot[0] = m_C3d.m_CGridMotionEditor.Get(//GridMotionEditor_GetMotor(nLine);
                    //OjwDraw();

                    return strRet;
                }
                public string FCommand(int nLine, string strCommand)
                {
                    strCommand = Ojw.CConvert.ChangeChar(strCommand, '\t', ' ');
                    string strRet = String.Empty;
                    string strTmp;
                    int nNum = 0;
                    //int nLine = 0;
                    //float fX = 0.0f, fY = 0.0f, fZ = 0.0f;
                    float[] afX = new float[256];
                    float[] afY = new float[256];
                    float[] afZ = new float[256];
                    Array.Clear(afX, 0, afX.Length);
                    Array.Clear(afY, 0, afY.Length);
                    Array.Clear(afZ, 0, afZ.Length);

                    if (strCommand.Length < 1) return null;
                    string strCommand2 = String.Empty;
                    strCommand2 += strCommand[0];
                    for (int k = 1; k < strCommand.Length; k++)
                    {
                        if ((strCommand[k - 1] == ' ') && (strCommand[k] == ' '))
                        {
                        }
                        else
                            strCommand2 += strCommand[k];
                    }
                    string[] pstrValue = Ojw.CConvert.ChangeString(strCommand2, "  ", " ").Split(' ');

                    //for (int j = 0; j < 1; j++)//nH - nOffset_j; j++)
                    {
                        // 2차 라인부터는 상대값이 적용되지 않게 한다.
                        Array.Clear(afX, 0, afX.Length);
                        Array.Clear(afY, 0, afY.Length);
                        Array.Clear(afZ, 0, afZ.Length);

                        strTmp = "";
                        // Line : nPos_X + j
                        //nLine = //nPos_X + j;// j + nOffset_j;
                        //GridMotionEditor_Clear(nLine);
                        int nCommand = 0;
                        // Enable
                        //dgGrid[0, j + nOffset_j].Value = Ojw.CConvert.StrToInt(pstrValue[nOffset_i, j + nOffset_j]);
                        bool bInc = false;
                        for (int i = 0; i < pstrValue.Length; i++)//nW - nOffset_i; i++)
                        {
                            //nLine = j + nOffset_j;
                            strTmp = pstrValue[i].ToLower();//pstrValue[i + nOffset_i, j + nOffset_j].ToLower();
                            if (nCommand == 0)
                            {
                                if (strTmp.Length > 1)
                                {
                                    if (strTmp[0] == 't')
                                    {
                                        nCommand = 1; // Motor
                                        //nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));
                                        nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));// m_CRobotis.GetParam_Axis_From_RealID(Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1)));
                                        continue;
                                    }
                                    else if (strTmp[0] == 'n') // Function
                                    {
                                        bInc = false;
                                        nCommand = 2;
                                        nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));
                                        continue;
                                    }
                                    else if (strTmp[0] == 'i') // Function(incremental)
                                    {
                                        bInc = true;
                                        nCommand = 2;
                                        nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));

                                        #region Read Forward
                                        // 결과가 나오기 보다는 결과를 메모리에 올리기만 한다.
                                        float[] afMot = new float[m_CHeader.nMotorCnt];
                                        for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) { afMot[nAxis] = GridMotionEditor_GetMotor(nLine, nAxis); }
                                        Ojw.CKinematics.CForward.CalcKinematics(m_CHeader.pDhParamAll[nNum], afMot, out afX[nNum], out afY[nNum], out afZ[nNum]);
                                        #endregion Read Forward

                                        continue;
                                    }
                                    else if (strTmp[0] == 'p') // plus
                                    {
                                        nCommand = 8; // Motor
                                        //nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));
                                        nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));// m_CRobotis.GetParam_Axis_From_RealID(Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1)));
                                        continue;
                                    }
                                    else if (strTmp[0] == 'c') // copy
                                    {
                                        nCommand = 9; // Motor
                                        //nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));
                                        nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));// m_CRobotis.GetParam_Axis_From_RealID(Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1)));
                                        continue;
                                    }
                                    else if (strTmp[0] == 'm') // multi
                                    {
                                        nCommand = 10; // Motor
                                        //nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));
                                        nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));// m_CRobotis.GetParam_Axis_From_RealID(Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1)));
                                        continue;
                                    }
                                    //else if (strTmp[0] == 'u') // set user data
                                    //{
                                    //    nCommand = 14;
                                    //    nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));
                                    //    continue;
                                    //}
                                    else if (strTmp[0] == 'r') // refresh
                                    {
                                        nCommand = 0; // refresh
                                        nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));

                                        // 결과가 나오기 보다는 결과를 메모리에 올리기만 한다.
                                        float[] afMot = new float[m_CHeader.nMotorCnt];
                                        for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) { afMot[nAxis] = GridMotionEditor_GetMotor(nLine, nAxis); }

                                        Ojw.CKinematics.CForward.CalcKinematics(m_CHeader.pDhParamAll[nNum], afMot, out afX[nNum], out afY[nNum], out afZ[nNum]);
                                        strRet = String.Format("Position[{0}] : {1}, {2}, {3}", GetHeader_pstrGroupName()[nNum], afX[nNum], afY[nNum], afZ[nNum]);
                                        continue;
                                    }
                                    else if (strTmp[0] == 'f') // Function 000 ~ 
                                    {
                                        nCommand = 1000; // Motor
                                        nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));
                                        continue;
                                    }
#if true

                                    // @Command,operand0,operand1,operand2,...
                                    else if (strTmp[0] == '?')
                                    {

                                    }
                                    else if (strTmp[0] == '@')
                                    {
                                        nCommand = 0;
                                        string[] pstrFunctions = strTmp.ToUpper().Split(',');
                                        if (pstrFunctions.Length > 0)
                                        {
                                            int nIndex = 0;
                                            switch (pstrFunctions[nIndex++])
                                            {
                                                case "@HELP":
                                                    {
                                                        strRet = FCommand_Help();
                                                    }
                                                    break;
                                                case "@SET_ABS":
                                                    {
                                                        if (pstrFunctions.Length >= 4)
                                                        {
                                                            int nFunction = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                            float fX = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                            float fY = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                            float fZ = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);

                                                            afX[nFunction] = fX;
                                                            afY[nFunction] = fY;
                                                            afZ[nFunction] = fZ;
                                                            Ojw.CGridView.Grid_Xyz2Angle(this, nLine, nFunction, afX[nFunction], afY[nFunction], afZ[nFunction]);
                                                        }
                                                    }
                                                    break;
                                                case "@SET_ABS2":
                                                    {
                                                        if (pstrFunctions.Length >= 4)
                                                        {
                                                            int nFunction = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                            float fX = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                            float fY = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                            float fZ = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);

                                                            #region Read Forward
                                                            // 결과가 나오기 보다는 결과를 메모리에 올리기만 한다.
                                                            float[] afMot = new float[m_CHeader.nMotorCnt];
                                                            Array.Clear(afMot, 0, afMot.Length);
                                                            Ojw.CKinematics.CForward.CalcKinematics(m_CHeader.pDhParamAll[nFunction], afMot, out afX[nFunction], out afY[nFunction], out afZ[nFunction]);
                                                            #endregion Read Forward

                                                            afX[nFunction] = afX[nFunction] + fX;
                                                            afY[nFunction] = afY[nFunction] + fY;
                                                            afZ[nFunction] = afZ[nFunction] + fZ;
                                                            Ojw.CGridView.Grid_Xyz2Angle(this, nLine, nFunction, afX[nFunction], afY[nFunction], afZ[nFunction]);
                                                        }
                                                    }
                                                    break;
                                                case "@SET_INC":
                                                    {
                                                        if (pstrFunctions.Length >= 4)
                                                        {
                                                            int nFunction = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                            float fX = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                            float fY = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                            float fZ = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);

                                                            #region Read Forward
                                                            // 결과가 나오기 보다는 결과를 메모리에 올리기만 한다.
                                                            float[] afMot = new float[m_CHeader.nMotorCnt];
                                                            for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) { afMot[nAxis] = GridMotionEditor_GetMotor(nLine, nAxis); }
                                                            Ojw.CKinematics.CForward.CalcKinematics(m_CHeader.pDhParamAll[nFunction], afMot, out afX[nFunction], out afY[nFunction], out afZ[nFunction]);
                                                            #endregion Read Forward

                                                            afX[nFunction] += fX;
                                                            afY[nFunction] += fY;
                                                            afZ[nFunction] += fZ;
                                                            Ojw.CGridView.Grid_Xyz2Angle(this, nLine, nFunction, afX[nFunction], afY[nFunction], afZ[nFunction]);
                                                        }
                                                    }
                                                    break;
                                                // @SET_INC1,[Num][x_y_z_0_1_2],[길이],[Rot_X_Y_Z_0_1_2],[각도]
                                                case "@SET_INC1":
                                                    {
                                                        if (pstrFunctions.Length >= 6)
                                                        {
                                                            int nFunction = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                            String strXyz = pstrFunctions[nIndex++];
                                                            float fXyz = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                            String strRot = pstrFunctions[nIndex++];
                                                            float fRot = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);

                                                            if (strXyz.Length != 1) return null;
                                                            if (strRot.Length != 1) return null;

                                                            float[] afRot = new float[3];
                                                            float[] afXyz = new float[3];
                                                            Array.Clear(afRot, 0, afRot.Length);
                                                            Array.Clear(afXyz, 0, afXyz.Length);

                                                            int nXyz = (int)((strXyz[0] >= 'X') ? strXyz[0] - 'X' : Ojw.CConvert.StrToInt(strXyz));
                                                            int nRot = (int)((strRot[0] >= 'X') ? strRot[0] - 'X' : Ojw.CConvert.StrToInt(strRot));
                                                            if ((nXyz < 0) || (nXyz > 2) || (nRot < 0) || (nRot > 2)) return null;
                                                            afXyz[nXyz] = fXyz;
                                                            afRot[nRot] = fRot;

                                                            Ojw.CMath.Rotation(afRot[0], afRot[1], afRot[2], ref afXyz[0], ref afXyz[1], ref afXyz[2]);

                                                            #region Read Forward
                                                            // 결과가 나오기 보다는 결과를 메모리에 올리기만 한다.
                                                            float[] afMot = new float[m_CHeader.nMotorCnt];
                                                            for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) { afMot[nAxis] = GridMotionEditor_GetMotor(nLine, nAxis); }
                                                            Ojw.CKinematics.CForward.CalcKinematics(m_CHeader.pDhParamAll[nFunction], afMot, out afX[nFunction], out afY[nFunction], out afZ[nFunction]);
                                                            #endregion Read Forward

                                                            afX[nFunction] += afXyz[0];
                                                            afY[nFunction] += afXyz[1];
                                                            afZ[nFunction] += afXyz[2];
                                                            Ojw.CGridView.Grid_Xyz2Angle(this, nLine, nFunction, afX[nFunction], afY[nFunction], afZ[nFunction]);
                                                        }
                                                    }
                                                    break;
                                                // @SET_INC2,[Num][x],[y],[z],[Rot_X],[Rot_Y],[Rot_Z] 
                                                case "@SET_INC2":
                                                    {
                                                        if (pstrFunctions.Length >= 8)
                                                        {
                                                            int nFunction = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                            float fX = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                            float fY = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                            float fZ = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                            float fRot_X = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                            float fRot_Y = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                            float fRot_Z = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);

                                                            Ojw.CMath.Rotation(fRot_X, fRot_Y, fRot_Z, ref fX, ref fY, ref fZ);

                                                            #region Read Forward
                                                            // 결과가 나오기 보다는 결과를 메모리에 올리기만 한다.
                                                            float[] afMot = new float[m_CHeader.nMotorCnt];
                                                            for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) { afMot[nAxis] = GridMotionEditor_GetMotor(nLine, nAxis); }
                                                            Ojw.CKinematics.CForward.CalcKinematics(m_CHeader.pDhParamAll[nFunction], afMot, out afX[nFunction], out afY[nFunction], out afZ[nFunction]);
                                                            #endregion Read Forward

                                                            afX[nFunction] += fX;
                                                            afY[nFunction] += fY;
                                                            afZ[nFunction] += fZ;
                                                            Ojw.CGridView.Grid_Xyz2Angle(this, nLine, nFunction, afX[nFunction], afY[nFunction], afZ[nFunction]);
                                                        }
                                                    }
                                                    break;
                                                // 원통좌표계
                                                // http://blog.naver.com/PostView.nhn?blogId=mindo1103&logNo=90155554939&redirect=Dlog&widgetTypeCall=true
                                                // x = rcosΘ
                                                // y = rsinΘ
                                                // z = z
                                                // r^2 = (x^2 + y^2)
                                                // tanΘ = y / z
                                                // z = z
                                                case "@SET_INC3":
                                                    {
                                                        if (pstrFunctions.Length >= 4)
                                                        {
                                                            int nFunction = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                            float fR = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                            float fTheta = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                            float fZ = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);

                                                            #region Read Forward
                                                            // 결과가 나오기 보다는 결과를 메모리에 올리기만 한다.
                                                            float[] afMot = new float[m_CHeader.nMotorCnt];
                                                            for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) { afMot[nAxis] = GridMotionEditor_GetMotor(nLine, nAxis); }
                                                            Ojw.CKinematics.CForward.CalcKinematics(m_CHeader.pDhParamAll[nFunction], afMot, out afX[nFunction], out afY[nFunction], out afZ[nFunction]);
                                                            #endregion Read Forward

                                                            afX[nFunction] += (float)(fR * Ojw.CMath.Cos(fTheta));
                                                            afY[nFunction] += (float)(fR * Ojw.CMath.Sin(fTheta));
                                                            afZ[nFunction] += fZ;
                                                            Ojw.CGridView.Grid_Xyz2Angle(this, nLine, nFunction, afX[nFunction], afY[nFunction], afZ[nFunction]);
                                                        }
                                                    }
                                                    break;
                                                case "@INIT":// Init
                                                    {
                                                        int nTmp = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                        if (nTmp < 0) m_CGridMotionEditor.Clear();
                                                        else m_CGridMotionEditor.Clear(nLine);
                                                    }
                                                    break;
                                                case "@SET":// Set Motor
                                                    {
                                                        //int nAxis = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                        int nAxis = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);// m_CRobotis.GetParam_Axis_From_RealID(Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]));
                                                        float fValue = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                        GridMotionEditor_SetMotor(nLine, nAxis, fValue);
                                                    }
                                                    break;
                                                case "@SET_PLUS":// Set Motor
                                                    {
                                                        //int nAxis = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                        int nAxis = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);//m_CRobotis.GetParam_Axis_From_RealID(Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]));
                                                        float fValue = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                        GridMotionEditor_SetMotor(nLine, nAxis, GridMotionEditor_GetMotor(nLine, nAxis) + fValue);
                                                    }
                                                    break;
                                                case "@Clear":// Clear Motor
                                                    {
                                                        int nTmp = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                        for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) GridMotionEditor_SetMotor(nLine, nAxis, 0.0f);
                                                    }
                                                    break;
                                                case "@ENTER" : // Moving Next Line
                                                    {
                                                        int nValue = 1;
                                                        if (pstrFunctions.Length > 1)
                                                        {
                                                            nValue = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                        }
                                                        int nCurrLine = m_CGridMotionEditor.OjwGrid_GetCurrentLine();
                                                        int nCurrCol = m_CGridMotionEditor.OjwGrid_GetCurrentColumn();
                                                        m_CGridMotionEditor.ChangePos_Command(m_CGridMotionEditor.GetHandle(), nCurrLine + nValue, nCurrCol);//.SetChangeCurrentLine(nCurrLine + nValue);
                                                    }
                                                    break;
                                                case "@SPACE": // Moving Next Column
                                                    {
                                                        int nValue = 1;
                                                        if (pstrFunctions.Length > 1)
                                                        {
                                                            nValue = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                        }
                                                        int nCurrLine = m_CGridMotionEditor.OjwGrid_GetCurrentLine();
                                                        int nCurrCol = m_CGridMotionEditor.OjwGrid_GetCurrentColumn();
                                                        //m_CGridMotionEditor.SetChangeCurrentCol(nCurrLine + nValue);
                                                        m_CGridMotionEditor.ChangePos_Command(m_CGridMotionEditor.GetHandle(), nCurrLine, nCurrCol + nValue);//.SetChangeCurrentLine(nCurrLine + nValue);
                                                    }
                                                    break;
                                                case "@SET_COMMAND":
                                                    {
                                                        int nTmp = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                        m_CGridMotionEditor.SetCommand(nLine, nTmp);
                                                    }
                                                    break;
                                                case "@SET_DATA0":
                                                    {
                                                        int nTmp = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                        m_CGridMotionEditor.SetData0(nLine, nTmp);
                                                    }
                                                    break;
                                                case "@SET_DATA1":
                                                    {
                                                        int nTmp = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                        m_CGridMotionEditor.SetData1(nLine, nTmp);
                                                    }
                                                    break;
                                                case "@SET_DATA2":
                                                    {
                                                        int nTmp = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                        m_CGridMotionEditor.SetData2(nLine, nTmp);
                                                    }
                                                    break;
                                                case "@SET_DATA3":
                                                    {
                                                        int nTmp = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                        m_CGridMotionEditor.SetData3(nLine, nTmp);
                                                    }
                                                    break;
                                                case "@SET_DATA4":
                                                    {
                                                        int nTmp = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                        m_CGridMotionEditor.SetData4(nLine, nTmp);
                                                    }
                                                    break;
                                                case "@SET_DATA5":
                                                    {
                                                        int nTmp = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                        m_CGridMotionEditor.SetData5(nLine, nTmp);
                                                    }
                                                    break;
                                                case "@SET_ENABLE":
                                                    {
                                                        GridMotionEditor_SetEnable(nLine, Ojw.CConvert.StrToBool(pstrFunctions[nIndex++]));                                    
                                                    }
                                                    break;
                                                case "@ROT":
                                                case "@ROTATE":
                                                case "@ROTATION":
                                                    {
                                                        float fX = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                        float fY = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                        float fZ = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                        SetAngle_Display(fY, fX, fZ);
                                                    }
                                                    break;
                                                case "@TRANS":
                                                case "@TRANSLATE":
                                                case "@TRANSLATION":
                                                    {
                                                        float fX = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                        float fY = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                        float fZ = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                        SetPos_Display(fY, fX, fZ);
                                                    }
                                                    break;
                                                case "@SCALE":
                                                    {
                                                        float fValue = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                        SetScale(fValue);
                                                    }
                                                    break;
                                                case "@SET_GROUP": // Group
                                                    {
                                                        GridMotionEditor_SetGroup(nLine, Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]));
                                                    }
                                                    break;
                                                case "@SET_CAPTION": // Caption
                                                    {
                                                        m_CGridMotionEditor.SetCaption(nLine, pstrFunctions[nIndex++]);
                                                    }
                                                    break;
                                                case "@SET_SPEED":
                                                    {
                                                        m_CGridMotionEditor.SetTime(nLine, Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]));
                                                    }
                                                    break;
                                                case "@SET_DELAY":
                                                    {
                                                        m_CGridMotionEditor.SetDelay(nLine, Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]));
                                                    }
                                                    break;
                                                case "@COPY":
                                                    {
                                                        //int nID1 = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                        //int nID2 = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                        int nID1 = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);//m_CRobotis.GetParam_Axis_From_RealID(Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]));
                                                        int nID2 = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);//m_CRobotis.GetParam_Axis_From_RealID(Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]));
                                                        int nDir = ((strTmp.IndexOf('-') >= 0) ? -1 : 1);
                                                        if (nDir < 0) nID2 = -nID2;
                                                        GridMotionEditor_SetMotor(nLine, nNum, GridMotionEditor_GetMotor(nLine, nID2) * nDir);
                                                    }
                                                    break;
                                                case "@SET_MULTI":
                                                    {
                                                        //int nAxis = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                        int nAxis = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);//m_CRobotis.GetParam_Axis_From_RealID(Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]));
                                                        float fValue = Ojw.CConvert.StrToFloat(pstrFunctions[nIndex++]);
                                                        GridMotionEditor_SetMotor(nLine, nAxis, GridMotionEditor_GetMotor(nLine, nAxis) * fValue);
                                                    }
                                                    break;
                                                case "@READ":
                                                    {
                                                        if (pstrFunctions.Length > 1)
                                                        {
                                                            int nFunction = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);

                                                            // 결과가 나오기 보다는 결과를 메모리에 올리기만 한다.
                                                            float[] afMot = new float[m_CHeader.nMotorCnt];
                                                            for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) { afMot[nAxis] = GridMotionEditor_GetMotor(nLine, nAxis); }

                                                            Ojw.CKinematics.CForward.CalcKinematics(m_CHeader.pDhParamAll[nFunction], afMot, out afX[nFunction], out afY[nFunction], out afZ[nFunction]);
                                                            //Ojw.CMessage.Write2("Position : {0}, {1}, {2}", afX[nFunction], afY[nFunction], afZ[nFunction]);
                                                            strRet = String.Format("Position[{0}] : {1}, {2}, {3}", GetHeader_pstrGroupName()[nFunction], afX[nFunction], afY[nFunction], afZ[nFunction]);
                                                        }
                                                    }
                                                    break;
                                                case "@SET_LINE": // Group
                                                    {
                                                        nLine = Ojw.CConvert.StrToInt(pstrFunctions[nIndex++]);
                                                    }
                                                    break;
                                            }
                                        }

                                        nCommand = 0; 
                                        //return strRet; // 이 명령어 이후는 굳이 실행할 필요 없다.
                                    }
#endif
                                }
                                else if (strTmp.Length == 1)
                                {
                                    if (strTmp == "e") // Enable
                                    {
                                        nCommand = 5;
                                        continue;
                                    }
                                    else if (strTmp == "s") // Speed
                                    {
                                        nCommand = 6;
                                        continue;
                                    }
                                    else if (strTmp == "d") // Delay
                                    {
                                        nCommand = 7;
                                        continue;
                                    }
                                    else if (strTmp == "g") // group
                                    {
                                        nCommand = 11;
                                        continue;
                                    }
                                    else if (strTmp == "w") // write
                                    {
                                        nCommand = 12;
                                        //m_CGridMotionEditor.SetCaption(nLine, strTmp);
                                        //SetRobot_Rot(30, 10, 20);
                                        continue;
                                    }
                                    else if (strTmp == "x") // mirror
                                    {
                                        nCommand = 13;
                                        continue;
                                    }
                                }
                            }
                            //else if (strTmp.Le
                            ///////////////////
                            // Value
                            if (nCommand != 0)
                            {
                                if (nCommand == 1)
                                {
                                    GridMotionEditor_SetMotor(nLine, nNum, Ojw.CConvert.StrToFloat(strTmp));
                                    //dgGrid[nNum, nLine].Value = Ojw.CConvert.StrToFloat(strTmp);
                                    nCommand = 0;
                                }
                                #region Function - Absolute / Incremental
                                else if (nCommand == 2)
                                {
                                    if (bInc == true)
                                        afX[nNum] += Ojw.CConvert.StrToFloat(strTmp);
                                    else
                                        afX[nNum] = Ojw.CConvert.StrToFloat(strTmp);
                                    nCommand++;
                                }
                                else if (nCommand == 3)
                                {
                                    if (bInc == true)
                                        afY[nNum] += Ojw.CConvert.StrToFloat(strTmp);
                                    else
                                        afY[nNum] = Ojw.CConvert.StrToFloat(strTmp);
                                    nCommand++;
                                }
                                else if (nCommand == 4)
                                {
                                    if (bInc == true)
                                        afZ[nNum] += Ojw.CConvert.StrToFloat(strTmp);
                                    else
                                        afZ[nNum] = Ojw.CConvert.StrToFloat(strTmp);
                                    Ojw.CGridView.Grid_Xyz2Angle(this, nLine, nNum, afX[nNum], afY[nNum], afZ[nNum]);
                                    nCommand = 0;
                                }
                                #endregion
                                else if (nCommand == 5) // Enable
                                {
                                    GridMotionEditor_SetEnable(nLine, Ojw.CConvert.StrToBool(strTmp));
                                    nCommand = 0;
                                }
                                else if (nCommand == 6) // Speed
                                {
                                    GridMotionEditor_SetTime(nLine, Ojw.CConvert.StrToInt(strTmp));
                                    nCommand = 0;
                                }
                                else if (nCommand == 7) // Delay
                                {
                                    GridMotionEditor_SetDelay(nLine, Ojw.CConvert.StrToInt(strTmp));
                                    nCommand = 0;
                                }
                                else if (nCommand == 8) // plus
                                {
                                    GridMotionEditor_SetMotor(nLine, nNum, GridMotionEditor_GetMotor(nLine, nNum) + Ojw.CConvert.StrToFloat(strTmp));
                                    //dgGrid[nNum, nLine].Value = Ojw.CConvert.StrToFloat(strTmp);
                                    nCommand = 0;
                                }
                                else if (nCommand == 9) // copy
                                {
                                    int nID2 = Ojw.CConvert.StrToInt(strTmp);
                                    int nDir = ((strTmp.IndexOf('-') >= 0) ? -1 : 1);
                                    //if (nID2 < 0)
                                    //{
                                    //    nDir = -1;
                                    //    nID2 = -nID2;
                                    //}
                                    if (nDir < 0)
                                    {
                                        nID2 = -nID2;
                                    }
                                    GridMotionEditor_SetMotor(nLine, nNum, GridMotionEditor_GetMotor(nLine, nID2) * nDir);
                                    //dgGrid[nNum, nLine].Value = Ojw.CConvert.StrToFloat(strTmp);
                                    nCommand = 0;
                                }
                                else if (nCommand == 10) // multi
                                {
                                    GridMotionEditor_SetMotor(nLine, nNum, GridMotionEditor_GetMotor(nLine, nNum) * Ojw.CConvert.StrToFloat(strTmp));
                                    //dgGrid[nNum, nLine].Value = Ojw.CConvert.StrToFloat(strTmp);
                                    nCommand = 0;
                                }
                                else if (nCommand == 11) // Group
                                {
                                    GridMotionEditor_SetGroup(nLine, Ojw.CConvert.StrToInt(strTmp));
                                    GridMotionEditor_SetColorGrid(nLine, 2);
                                    //m_CGridMotionEditor.GetHandle().InvalidateRow(nLine);
                                    nCommand = 0;
                                }
                                else if (nCommand == 12) // Caption
                                {
                                    m_CGridMotionEditor.SetCaption(nLine, strTmp);
                                    //m_CGridMotionEditor.GetHandle().Invalidate();
                                    m_CGridMotionEditor.GetHandle().InvalidateRow(nLine);
                                    // 색칠하기...
                                    //GridMotionEditor_SetColorGrid(nLine, 2);
                                    //GridMotionEditor_
                                    nCommand = 0;
                                }
                                else if (nCommand == 13) // Mirror
                                {
                                    if (Ojw.CConvert.IsDigit(strTmp) == true)
                                    {
                                        int nMotorID = Ojw.CConvert.StrToInt(strTmp);
                                        if (nMotorID < 0)
                                        {
                                            // Mirror All(이중 복사 방지)
                                            bool[] abSet = new bool[m_CHeader.nMotorCnt];
                                            for (int nMotor = 0; nMotor < m_CHeader.nMotorCnt; nMotor++)
                                            {
                                                int nMirror = m_CHeader.pSMotorInfo[nMotor].nAxis_Mirror;
                                                if (abSet[nMotor] == true) continue;
                                                abSet[nMotor] = true;
                                                if (nMirror >= 0)
                                                {
                                                    if (abSet[nMirror] == true) continue;
                                                    abSet[nMirror] = true;
                                                }

                                                if (nMirror == -2)
                                                {
                                                    GridMotionEditor_SetMotor(nLine, nMotor, -GridMotionEditor_GetMotor(nLine, nMotor));
                                                }
                                                else if ((nMirror >= 0) && (nMirror < m_CHeader.nMotorCnt))
                                                {
                                                    float fTmp = GridMotionEditor_GetMotor(nLine, nMotor);
                                                    GridMotionEditor_SetMotor(nLine, nMotor, GridMotionEditor_GetMotor(nLine, nMirror));
                                                    GridMotionEditor_SetMotor(nLine, nMirror, fTmp);
                                                }
                                            }
                                        }
                                        else
                                        {
                                            int nMotor = nMotorID;
                                            int nMirror = m_CHeader.pSMotorInfo[nMotor].nAxis_Mirror;
                                            if (nMirror == -2)
                                            {
                                                GridMotionEditor_SetMotor(nLine, nMotor, -GridMotionEditor_GetMotor(nLine, nMotor));
                                            }
                                            else if ((nMirror >= 0) && (nMirror < m_CHeader.nMotorCnt))
                                            {
                                                float fTmp = GridMotionEditor_GetMotor(nLine, nMotor);
                                                GridMotionEditor_SetMotor(nLine, nMotor, GridMotionEditor_GetMotor(nLine, nMirror));
                                                GridMotionEditor_SetMotor(nLine, nMirror, fTmp);
                                            }
                                        }
                                    }
                                    nCommand = 0;
                                }
                                //else if (nCommand == 14)
                                //{
                                //    string [] pstrDatas = strTmp.Split(';');
                                //    int nPos = 0;
                                //    foreach (string strData in pstrDatas)
                                //    {
                                //        int nData = Ojw.CConvert.StrToInt(strData);
                                //        switch (nPos)
                                //        {
                                //            case 0: GridMotionEditor_SetCommand(nLine, nData); break;
                                //            case 1: GridMotionEditor_SetData0(nLine, nData); break;
                                //            case 2: GridMotionEditor_SetData1(nLine, nData); break;
                                //            case 3: GridMotionEditor_SetData2(nLine, nData); break;
                                //            case 4: GridMotionEditor_SetData3(nLine, nData); break;
                                //            case 5: GridMotionEditor_SetData4(nLine, nData); break;
                                //            case 6: GridMotionEditor_SetData5(nLine, nData); break;
                                //        }
                                //        nPos++;
                                //    }
                                //    nCommand = 0;
                                //}
                                else if (nCommand >= 1000)
                                {
                                    if (nNum == 0) // Function 000 ~ Clear
                                    {
                                        int nTmp = Ojw.CConvert.StrToInt(strTmp);
                                        if (nTmp < 0) m_CGridMotionEditor.Clear();
                                        else m_CGridMotionEditor.Clear(nLine);
                                        //m_CGridMotionEditor.SetData1(nLine, 1);
                                        //m_CGridMotionEditor.SetData2(nLine, 1);
                                    }
                                    else if (nNum == 1) // Function 000 ~ Clear Motor
                                    {
                                        float fValue = Ojw.CConvert.StrToFloat(strTmp);
                                        for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) GridMotionEditor_SetMotor(nLine, nAxis, fValue);
                                    }
                                    else if (nNum == 2) // Function 002 ~ Moving Next Line
                                    {
                                        int nValue = Ojw.CConvert.StrToInt(strTmp);
                                        int nCurrLine = m_CGridMotionEditor.OjwGrid_GetCurrentLine();
                                        int nCurrCol = m_CGridMotionEditor.OjwGrid_GetCurrentColumn();
                                        m_CGridMotionEditor.ChangePos_Command(m_CGridMotionEditor.GetHandle(), nCurrLine + nValue, nCurrCol);//.SetChangeCurrentLine(nCurrLine + nValue);
                                    }
                                    else if (nNum == 3) // Function 003 ~ Moving Next Column
                                    {
                                        int nValue = Ojw.CConvert.StrToInt(strTmp);
                                        int nCurrLine = m_CGridMotionEditor.OjwGrid_GetCurrentLine();
                                        int nCurrCol = m_CGridMotionEditor.OjwGrid_GetCurrentColumn();
                                        //m_CGridMotionEditor.SetChangeCurrentCol(nCurrLine + nValue);
                                        m_CGridMotionEditor.ChangePos_Command(m_CGridMotionEditor.GetHandle(), nCurrLine, nCurrCol + nValue);//.SetChangeCurrentLine(nCurrLine + nValue);
                                    }
                                    else if (nNum == 99)
                                    {
                                        int nTmp = Ojw.CConvert.StrToInt(strTmp);
                                        m_CGridMotionEditor.SetCommand(nLine, nTmp);
                                    }
                                    else if (nNum == 100)
                                    {
                                        int nTmp = Ojw.CConvert.StrToInt(strTmp);
                                        m_CGridMotionEditor.SetData0(nLine, nTmp);
                                    }
                                    else if (nNum == 101)
                                    {
                                        int nTmp = Ojw.CConvert.StrToInt(strTmp);
                                        m_CGridMotionEditor.SetData1(nLine, nTmp);
                                    }
                                    else if (nNum == 102)
                                    {
                                        int nTmp = Ojw.CConvert.StrToInt(strTmp);
                                        m_CGridMotionEditor.SetData2(nLine, nTmp);
                                    }
                                    else if (nNum == 103)
                                    {
                                        int nTmp = Ojw.CConvert.StrToInt(strTmp);
                                        m_CGridMotionEditor.SetData3(nLine, nTmp);
                                    }
                                    else if (nNum == 104)
                                    {
                                        int nTmp = Ojw.CConvert.StrToInt(strTmp);
                                        m_CGridMotionEditor.SetData4(nLine, nTmp);
                                    }
                                    else if (nNum == 105)
                                    {
                                        int nTmp = Ojw.CConvert.StrToInt(strTmp);
                                        m_CGridMotionEditor.SetData5(nLine, nTmp);
                                    }
                                    nCommand = 0;
                                }
                            }
                            //strTmp += pstrValue[i + nOffset_i, j + nOffset_j] + "[]";
                        }
                        //MessageBox.Show(strTmp);
                    }
                    return strRet;
                }
                //    {
                //        if (dgGrid.Focused == true)
                //        {
                //            try
                //            {
                //                int nPos_X = 0, nPos_Y = 0;
                //                bool bPass = false;
                //                int nX_Limit = dgGrid.RowCount;
                //                int nY_Limit = dgGrid.ColumnCount;

                //                #region 첫 위치 찾아내기
                //                for (int i = 0; i < nX_Limit; i++)
                //                {
                //                    for (int j = 0; j < nY_Limit; j++)
                //                    {
                //                        if ((dgGrid[j, i].Selected == true) && (bPass == false))
                //                        {
                //                            nPos_X = i; nPos_Y = j;
                //                            bPass = true;
                //                            break;
                //                        }
                //                    }
                //                    if (bPass == true) break;
                //                }
                //                #endregion

                //                // 복사된 행의 열을 구하기 위하여 클립보드 사용.
                //                IDataObject iData = Clipboard.GetDataObject();
                //                string strClp = (string)iData.GetData(DataFormats.Text);

                //                if (strClp == null) break;

                //                string strClip = "";

                //                #region Tab, \r\n 의 개수를 셈
                //                int nCnt = 0;
                //                int nT_Cnt = 0;
                //                int nLine_Cnt = 0;
                //                string strDisp = "";
                //                for (int i = 0; i < strClp.Length; i++)
                //                {
                //                    if (strClp[i] == '\t') nT_Cnt++;
                //                    else if (strClp[i] == '\n') nLine_Cnt++;
                //                    if (strClp[i] != '\r')
                //                    {
                //                        if ((i == strClp.Length - 1) && (strClp[i] < 0x20)) break;
                //                        if ((strClp[i] >= 0x20) && (strClp[i] != '\t') && (strClp[i] != '\n'))
                //                        {
                //                            nCnt++;
                //                            strDisp += strClp[i];
                //                        }
                //                        strClip += strClp[i];
                //                    }
                //                }
                //                #endregion

                //                int nW = 0, nH = 0;
                //                int nAll = 0;
                //                if (strClip.Length > 0)
                //                {
                //                    // strClip -> 이 데이타가 진짜
                //                    //nW = 1; 
                //                    nH = 1;
                //                    nAll = 1;
                //                    for (int i = 0; i < strClip.Length; i++)
                //                    {
                //                        // 가로열, 세로열 카운트
                //                        if (strClip[i] == '\n') nH++;
                //                        if ((strClip[i] == '\n') || (strClip[i] == '\t')) nAll++;
                //                    }
                //                    nW = (int)Math.Round((float)nAll / (float)nH, 0);
                //                    //Message("nW = " + CConvert.IntToStr(nW) + ", nH = " + CConvert.IntToStr(nH));

                //                    bool bW = false, bH = false;
                //                    if (nW >= nY_Limit) bW = true;
                //                    if (nH >= nX_Limit) bH = true;

                //                    String[,] pstrValue = new string[nW, nH];
                //                    bool[,] pbValid = new bool[nW, nH];
                //                    int nX = 0, nY = 0;
                //                    for (int i = 0; i < nW; i++) // 초기화
                //                        for (int j = 0; j < nH; j++)
                //                        {
                //                            pstrValue[i, j] = "";
                //                            pbValid[i, j] = false;
                //                        }

                //                    for (int i = 0; i < strClip.Length; i++)
                //                    {
                //                        if (strClip[i] == '\n') { nY++; nX = 0; }
                //                        else if (strClip[i] == '\t') nX++;
                //                        else
                //                        {
                //                            pbValid[nX, nY] = true;
                //                            pstrValue[nX, nY] += strClip[i];
                //                        }
                //                    }

                //                    if (e.Shift)
                //                        m_CGridMotionEditor.Insert(m_CGridMotionEditor.m_nCurrntCell, nH);
                //                    //Grid_Insert(nPos_X, nH);
                //                    else
                //                    {
                //                        // 모자란 라인 채우기
                //                        if (nH > dgGrid.RowCount)
                //                        {
                //                            m_CGridMotionEditor.Insert(m_CGridMotionEditor.m_nCurrntCell, nH - dgGrid.RowCount);
                //                        }
                //                    }

                //                    #region 실 데이타 저장
                //                    ////// 실 데이타 저장 ///////
                //                    // Display
                //                    int nOffset_i = 0, nOffset_j = 0;
                //                    //if (bW == true) nOffset_i++; // 이 형식에서는 해당 안됨
                //                    if (bH == true) nOffset_j++;
                //                    string strTmp;

                //                    //bool bLed = false; // For Led Copy
                //                    //bool bChoose = false;

                //                    int nNum = 0;
                //                    int nLine = 0;
                //                    //float fX = 0.0f, fY = 0.0f, fZ = 0.0f;
                //                    float[] afX = new float[256];
                //                    float[] afY = new float[256];
                //                    float[] afZ = new float[256];
                //                    Array.Clear(afX, 0, afX.Length);
                //                    Array.Clear(afY, 0, afY.Length);
                //                    Array.Clear(afZ, 0, afZ.Length);

                //                    for (int j = 0; j < nH - nOffset_j; j++)
                //                    {
                //                        // 2차 라인부터는 상대값이 적용되지 않게 한다.
                //                        Array.Clear(afX, 0, afX.Length);
                //                        Array.Clear(afY, 0, afY.Length);
                //                        Array.Clear(afZ, 0, afZ.Length);

                //                        strTmp = "";
                //                        // Line : nPos_X + j
                //                        nLine = nPos_X + j;// j + nOffset_j;
                //                        //GridMotionEditor_Clear(nLine);
                //                        int nCommand = 0;
                //                        // Enable
                //                        //dgGrid[0, j + nOffset_j].Value = Ojw.CConvert.StrToInt(pstrValue[nOffset_i, j + nOffset_j]);
                //                        bool bInc = false;
                //                        for (int i = 0; i < nW - nOffset_i; i++)
                //                        {
                //                            //nLine = j + nOffset_j;
                //                            strTmp = pstrValue[i + nOffset_i, j + nOffset_j].ToLower();
                //                            if (nCommand == 0)
                //                            {
                //                                if (strTmp.Length > 1)
                //                                {
                //                                    if (strTmp[0] == 't')
                //                                    {
                //                                        nCommand = 1; // Motor
                //                                        nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));
                //                                        continue;
                //                                    }
                //                                    else if (strTmp[0] == 'n') // Function
                //                                    {
                //                                        bInc = false;
                //                                        nCommand = 2;
                //                                        nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));
                //                                        continue;
                //                                    }
                //                                    else if (strTmp[0] == 'i') // Function(incremental)
                //                                    {
                //                                        bInc = true;
                //                                        nCommand = 2;
                //                                        nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));

                //                                        #region Read Forward
                //                                        // 결과가 나오기 보다는 결과를 메모리에 올리기만 한다.
                //                                        float[] afMot = new float[m_CHeader.nMotorCnt];
                //                                        for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) { afMot[nAxis] = GridMotionEditor_GetMotor(nLine, nAxis); }
                //                                        Ojw.CKinematics.CForward.CalcKinematics(m_CHeader.pDhParamAll[nNum], afMot, out afX[nNum], out afY[nNum], out afZ[nNum]);
                //                                        #endregion Read Forward

                //                                        continue;
                //                                    }
                //                                    else if (strTmp[0] == 'p') // plus
                //                                    {
                //                                        nCommand = 8; // Motor
                //                                        nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));
                //                                        continue;
                //                                    }
                //                                    else if (strTmp[0] == 'c') // copy
                //                                    {
                //                                        nCommand = 9; // Motor
                //                                        nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));
                //                                        continue;
                //                                    }
                //                                    else if (strTmp[0] == 'm') // multi
                //                                    {
                //                                        nCommand = 10; // Motor
                //                                        nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));
                //                                        continue;
                //                                    }
                //                                    else if (strTmp[0] == 'r') // refresh
                //                                    {
                //                                        nCommand = 0; // refresh
                //                                        nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));

                //                                        // 결과가 나오기 보다는 결과를 메모리에 올리기만 한다.
                //                                        float[] afMot = new float[m_CHeader.nMotorCnt];
                //                                        for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) { afMot[nAxis] = GridMotionEditor_GetMotor(nLine, nAxis); }

                //                                        Ojw.CKinematics.CForward.CalcKinematics(m_CHeader.pDhParamAll[nNum], afMot, out afX[nNum], out afY[nNum], out afZ[nNum]);
                //                                        continue;
                //                                    }
                //                                    else if (strTmp[0] == 'f') // Function 000 ~ 
                //                                    {
                //                                        nCommand = 1000; // Motor
                //                                        nNum = Ojw.CConvert.StrToInt(strTmp.Substring(1, strTmp.Length - 1));
                //                                        continue;
                //                                    }
                //                                }
                //                                else if (strTmp.Length == 1)
                //                                {
                //                                    if (strTmp == "e") // Enable
                //                                    {
                //                                        nCommand = 5;
                //                                        continue;
                //                                    }
                //                                    else if (strTmp == "s") // Speed
                //                                    {
                //                                        nCommand = 6;
                //                                        continue;
                //                                    }
                //                                    else if (strTmp == "d") // Delay
                //                                    {
                //                                        nCommand = 7;
                //                                        continue;
                //                                    }
                //                                    else if (strTmp == "g") // group
                //                                    {
                //                                        nCommand = 11;
                //                                        continue;
                //                                    }
                //                                    else if (strTmp == "w") // write
                //                                    {
                //                                        nCommand = 12;

                //                                        SetRobot_Rot(30, 10, 20);
                //                                        continue;
                //                                    }
                //                                }
                //                            }
                //                            //else if (strTmp.Le
                //                            ///////////////////
                //                            // Value
                //                            if (nCommand != 0)
                //                            {
                //                                if (nCommand == 1)
                //                                {
                //                                    GridMotionEditor_SetMotor(nLine, nNum, Ojw.CConvert.StrToFloat(strTmp));
                //                                    //dgGrid[nNum, nLine].Value = Ojw.CConvert.StrToFloat(strTmp);
                //                                    nCommand = 0;
                //                                }
                //                                #region Function - Absolute / Incremental
                //                                else if (nCommand == 2)
                //                                {
                //                                    if (bInc == true)
                //                                        afX[nNum] += Ojw.CConvert.StrToFloat(strTmp);
                //                                    else
                //                                        afX[nNum] = Ojw.CConvert.StrToFloat(strTmp);
                //                                    nCommand++;
                //                                }
                //                                else if (nCommand == 3)
                //                                {
                //                                    if (bInc == true)
                //                                        afY[nNum] += Ojw.CConvert.StrToFloat(strTmp);
                //                                    else
                //                                        afY[nNum] = Ojw.CConvert.StrToFloat(strTmp);
                //                                    nCommand++;
                //                                }
                //                                else if (nCommand == 4)
                //                                {
                //                                    if (bInc == true)
                //                                        afZ[nNum] += Ojw.CConvert.StrToFloat(strTmp);
                //                                    else
                //                                        afZ[nNum] = Ojw.CConvert.StrToFloat(strTmp);
                //                                    Ojw.CGridView.Grid_Xyz2Angle(this, nLine, nNum, afX[nNum], afY[nNum], afZ[nNum]);
                //                                    nCommand = 0;
                //                                }
                //                                #endregion
                //                                else if (nCommand == 5) // Enable
                //                                {
                //                                    GridMotionEditor_SetEnable(nLine, Ojw.CConvert.StrToBool(strTmp));
                //                                    nCommand = 0;
                //                                }
                //                                else if (nCommand == 6) // Speed
                //                                {
                //                                    GridMotionEditor_SetTime(nLine, Ojw.CConvert.StrToInt(strTmp));
                //                                    nCommand = 0;
                //                                }
                //                                else if (nCommand == 7) // Delay
                //                                {
                //                                    GridMotionEditor_SetDelay(nLine, Ojw.CConvert.StrToInt(strTmp));
                //                                    nCommand = 0;
                //                                }
                //                                else if (nCommand == 8) // plus
                //                                {
                //                                    GridMotionEditor_SetMotor(nLine, nNum, GridMotionEditor_GetMotor(nLine, nNum) + Ojw.CConvert.StrToFloat(strTmp));
                //                                    //dgGrid[nNum, nLine].Value = Ojw.CConvert.StrToFloat(strTmp);
                //                                    nCommand = 0;
                //                                }
                //                                else if (nCommand == 9) // copy
                //                                {
                //                                    int nID2 = Ojw.CConvert.StrToInt(strTmp);
                //                                    int nDir = ((strTmp.IndexOf('-') >= 0) ? -1 : 1);
                //                                    //if (nID2 < 0)
                //                                    //{
                //                                    //    nDir = -1;
                //                                    //    nID2 = -nID2;
                //                                    //}
                //                                    if (nDir < 0)
                //                                    {
                //                                        nID2 = -nID2;
                //                                    }
                //                                    GridMotionEditor_SetMotor(nLine, nNum, GridMotionEditor_GetMotor(nLine, nID2) * nDir);
                //                                    //dgGrid[nNum, nLine].Value = Ojw.CConvert.StrToFloat(strTmp);
                //                                    nCommand = 0;
                //                                }
                //                                else if (nCommand == 10) // multi
                //                                {
                //                                    GridMotionEditor_SetMotor(nLine, nNum, GridMotionEditor_GetMotor(nLine, nNum) * Ojw.CConvert.StrToFloat(strTmp));
                //                                    //dgGrid[nNum, nLine].Value = Ojw.CConvert.StrToFloat(strTmp);
                //                                    nCommand = 0;
                //                                }
                //                                else if (nCommand == 11) // Group
                //                                {
                //                                    GridMotionEditor_SetGroup(nLine, Ojw.CConvert.StrToInt(strTmp));
                //                                    nCommand = 0;
                //                                }
                //                                else if (nCommand == 12) // Caption
                //                                {
                //                                    m_CGridMotionEditor.SetCaption(nLine, strTmp);
                //                                    // 색칠하기...
                //                                    //GridMotionEditor_SetColorGrid(nLine, 2);
                //                                    //GridMotionEditor_
                //                                    nCommand = 0;
                //                                }
                //                                else if (nCommand >= 1000)
                //                                {
                //                                    if (nNum == 0) // Function 000 ~ 
                //                                    {

                //                                        //m_CGridMotionEditor.SetData1(nLine, 1);
                //                                        //m_CGridMotionEditor.SetData2(nLine, 1);
                //                                    }
                //                                    nCommand = 0;
                //                                }
                //                            }
                //                        }
                //                    }
                //                    #endregion



                //                }
                //                m_nFirstPos_Min_X = 9999999;
                //                m_nFirstPos_Min_Line = 9999999;
                //                //Grid_DisplayLine(m_nCurrntCell);

                //                CheckFlag(m_CGridMotionEditor.m_nCurrntCell);
                //                // 색칠하기...
                //                GridMotionEditor_SetColorGrid(0, dgGrid.RowCount);
                //            }
                //            catch (Exception e2)
                //            {
                //                MessageBox.Show(e2.ToString());
                //            }
                //        }
                //    }
                //}
                private string FCommand_Help()
                {
                    string strMsg = "[(퀵)명령]\r\n" +
                                    "<<Arg0 은 붙어 있는 명령>>\r\n" +
                                    "Cmd    Arg0    Arg1\r\n" +
                                    "W		안녕?   			captiondp \"안녕?\" 이라는 말을 넣는다.\r\n" +
                                    "G		1			Group 1 로 셋팅한다.(0은 해제)		\r\n" +
                                    "S		100			100 ms 에 맞춰 모터를 동작 시킨다.\r\n" +
                                    "D		100			동작 후 100 ms 멈춘다.\r\n" +
                                    "E		1			프레임 Enable(1 - Enable, 0 - Disable)\r\n" +
                                    "R	2				2번 수식의 Forward 를 풀어 메모리에 가지고 있는다.\r\n" +
                                    "N	2	10	20	30		2번 수식 사용 (10, 20, 30) 의 위치로 이동\r\n" +
                                    "I	2	5	0	-7		2번 수식 사용 x 를 마지막 사용한 값에서 5 증가, z 를 마지막 사용한 값에서 7 감소\r\n" +
                                    "T	2	10			2번 모터의 위치값을 10 으로 변경한다.\r\n" +
                                    "P	2	3			2번 모터의 위치값을 현재의 값에 \"3\" 을 더한다.\r\n" +
                                    "M	2	0.5			2번 모터의 위치값에 0.5 를 곱한다.\r\n" +
                                    "C	2	-5			5번 모터의 값을 2번 모터에 붙인다.(-가 붙으면 반대방향으로 붙인다.)\r\n" +
                                    "\r\n" +
                                    "[명령]\r\n" +
                                    "@HELP\r\n" +
                                    "@SET_ABS,[Num],[X],[Y],[Z]\r\n" +
                                    "@SET_ABS2,[Num],[X],[Y],[Z] // 모든 Motors 의 위치가 0 일 경우의 좌표점을 기준점으로 삼는 절대값\r\n" +
                                    "@SET_INC,[Num],[X],[Y],[Z]\r\n" +
                                    "@SET_INC1,[Num][x_y_z_0_1_2],[길이],[Rot_X_Y_Z_0_1_2],[각도]\r\n" +
                                    "@SET_INC2,[Num][x],[y],[z],[Rot_X],[Rot_Y],[Rot_Z] \r\n" +
                                    "@SET_INC3,[Num],[반경(길이)],[각도],[z]   // 원통좌표계\r\n" +
                                    "@INIT,-1  // 전체 초기화\r\n" +
                                    "@INIT,[Line]   // Line 초기화\r\n" +
                                    "@SET,[Axis],[value]   // 모터 값 설정\r\n" +
                                    "@SET_PLUS,[Axis],[Value] // 모터 값 증분\r\n" +
                                    "@CLEAR,[Line] // Line 모터 0 설정\r\n" +
                                    "@ENTER,[{LineCount}]    // [LineCount]삭제가능, LineCount 만큼 밑으로 이동\r\n" +
                                    "@SPACE,[{ColumnCount}]    // [ColumnCount]삭제가능, ColumnCount 만큼 옆으로 이동\r\n" +
                                    "@SET_COMMAND,[Value]\r\n" +
                                    "@SET_DATA0,[Value]\r\n" +
                                    "@SET_DATA1,[Value]\r\n" +
                                    "@SET_DATA2,[Value]\r\n" +
                                    "@SET_DATA3,[Value]\r\n" +
                                    "@SET_DATA4,[Value]\r\n" +
                                    "@SET_DATA5,[Value]\r\n" +
                                    "@SET_ENABLE,[Value]\r\n" +
                                    "@SET_SPEED,[Value]\r\n" +
                                    "@SET_DELAY,[Value]\r\n" +
                                    "@SET_MULTI,[Axis],[Value] // 모터 값 곱\r\n" +
                                    "@READ,[Num]    // 해당 수식의 Forward 값을 읽음\r\n" +
                                    "@COPY,[ORG],[TARGET],[DIR:0] \r\n" +
                                    "@ROT,[X],[Y],[Z]  // Rot, Rotate, Rotation\r\n" +
                                    "@TRANS,[X],[Y],[Z] // Trans, Translate, Translation\r\n" +
                                    "@SCALE,[Value]   // 1.0 기준\r\n";
                    return strMsg;
                }
                private void OjwGrid_KeyUp(object sender, KeyEventArgs e)
                {
                    m_nKey = 0;
                    m_bKey_Ctrl = false;
                    m_bKey_Alt = false;
                    m_bKey_Shift = false;

                    //m_bKeyDown = false;
                }
                #endregion KeyDown & KeyUp

                #region Button
                private void btnServe_En_Click(object sender, EventArgs e)
                {
                    int nSelected = -1;
                    for (int i = 0; i < m_pbtnEnable.Length; i++)
                    {
                        //if (m_pbtnEnable[i].Focused == true)
                        if ((Control)sender == m_pbtnEnable[i])
                        {
                            nSelected = i;
                            break;
                        }
                    }
                    if (nSelected >= 0)
                    {
                        Grid_SetFlag_En(m_CGridMotionEditor.m_nCurrntCell, nSelected, !Grid_GetFlag_En(m_CGridMotionEditor.m_nCurrntCell, nSelected));
                        CheckFlag(m_CGridMotionEditor.m_nCurrntCell, nSelected);
#if _IS_VAR_GRIDDRAW
                        Grid_SetFlag_En(m_nCurrntCell, nSelected, !Grid_GetFlag_En(m_nCurrntCell, nSelected));
                        CheckFlag(m_nCurrntCell, nSelected);
                        //MessageBox.Show(Ojw.CConvert.IntToStr(nSelected) + "(En)번 버튼이 눌렸습니다.");
#endif
                    }
                }
                private void btnServe_Type_Click(object sender, EventArgs e)
                {
                    int nSelected = -1;
                    for (int i = 0; i < m_pbtnType.Length; i++)
                    {
                        if (m_pbtnType[i].Focused == true)
                        {
                            nSelected = i;
                            break;
                        }
                    }
                    if (nSelected >= 0)
                    {
                        Grid_SetFlag_Type(m_CGridMotionEditor.m_nCurrntCell, nSelected, !Grid_GetFlag_Type(m_CGridMotionEditor.m_nCurrntCell, nSelected));
                        CheckFlag(m_CGridMotionEditor.m_nCurrntCell, nSelected);
#if _IS_VAR_GRIDDRAW
                        Grid_SetFlag_Type(m_nCurrntCell, nSelected, !Grid_GetFlag_Type(m_nCurrntCell, nSelected));
                        CheckFlag(m_nCurrntCell, nSelected);
#endif
                    }
                }
                private void btnServe_Led_Click(object sender, EventArgs e)
                {
                    int nSelected = -1;
                    int nSelected_Led = -1;
                    for (int i = 0; i < m_pbtnLed.Length; i++)
                    {
                        for (int j = 0; j < 3; j++)
                        {
                            if (m_pbtnLed[j, i].Focused == true)
                            {
                                nSelected = i;
                                nSelected_Led = j;
                                break;
                            }
                        }
                        if (nSelected >= 0) break;
                    }
                    if (nSelected >= 0)// && (nSelected_Led >= 0))
                    {
                        bool[] abLed = new bool[3];
                        int i = 0;
                        abLed[i++] = Grid_GetFlag_Led_Red(m_CGridMotionEditor.m_nCurrntCell, nSelected);
                        abLed[i++] = Grid_GetFlag_Led_Blue(m_CGridMotionEditor.m_nCurrntCell, nSelected);
                        abLed[i++] = Grid_GetFlag_Led_Green(m_CGridMotionEditor.m_nCurrntCell, nSelected);

                        abLed[nSelected_Led] = !abLed[nSelected_Led];
                        i = 0;
                        Grid_SetFlag_Led_Red(m_CGridMotionEditor.m_nCurrntCell, nSelected, abLed[i++]);
                        Grid_SetFlag_Led_Blue(m_CGridMotionEditor.m_nCurrntCell, nSelected, abLed[i++]);
                        Grid_SetFlag_Led_Green(m_CGridMotionEditor.m_nCurrntCell, nSelected, abLed[i++]);
                        CheckFlag(m_CGridMotionEditor.m_nCurrntCell, nSelected);
                        abLed = null;

                        //                 int nValue = Grid_GetFlag_Led(m_nCurrntCell, nSelected) & 0x07;
                        //                 int nPulse = 0x01 << nSelected_Led;
                        //                 nValue = (nValue & (nPulse ^ 0x07)) | ((nValue & nPulse) ^ nPulse);
                        //                 //int nRed = (nValue & 0x01);
                        //                 Grid_SetFlag_Led(m_nCurrntCell, nSelected, nValue);
                        //                 CheckFlag(m_nCurrntCell, nSelected);
                        //                 //MessageBox.Show(Ojw.CConvert.IntToStr(nSelected) + "(Led)번 버튼이 눌렸습니다.");
#if _IS_VAR_GRIDDRAW
                        bool[] abLed = new bool[3];
                        int i = 0;
                        abLed[i++] = Grid_GetFlag_Led_Red(m_nCurrntCell, nSelected);
                        abLed[i++] = Grid_GetFlag_Led_Blue(m_nCurrntCell, nSelected);
                        abLed[i++] = Grid_GetFlag_Led_Green(m_nCurrntCell, nSelected);

                        abLed[nSelected_Led] = !abLed[nSelected_Led];
                        i = 0;
                        Grid_SetFlag_Led_Red(m_nCurrntCell, nSelected, abLed[i++]);
                        Grid_SetFlag_Led_Blue(m_nCurrntCell, nSelected, abLed[i++]);
                        Grid_SetFlag_Led_Green(m_nCurrntCell, nSelected, abLed[i++]);
                        CheckFlag(m_nCurrntCell, nSelected);
                        abLed = null;

                        //                 int nValue = Grid_GetFlag_Led(m_nCurrntCell, nSelected) & 0x07;
                        //                 int nPulse = 0x01 << nSelected_Led;
                        //                 nValue = (nValue & (nPulse ^ 0x07)) | ((nValue & nPulse) ^ nPulse);
                        //                 //int nRed = (nValue & 0x01);
                        //                 Grid_SetFlag_Led(m_nCurrntCell, nSelected, nValue);
                        //                 CheckFlag(m_nCurrntCell, nSelected);
                        //                 //MessageBox.Show(Ojw.CConvert.IntToStr(nSelected) + "(Led)번 버튼이 눌렸습니다.");
#endif
                    }
                }
                #endregion Button


                private int m_nSelectedItem = 0;
                //public void GridDraw_Event_CellEnter(object sender, DataGridViewCellEventArgs e)
                //{
                //    //if (m_CGridMotionEditor.GetHandle().Focused == true)// || (m_bStart == true))
                //    //{
                //        SelectObject_Clear();
                //        SelectObject_Add(e.RowIndex);
                //        m_nSelectedItem = e.RowIndex;

                //        CheckFlag(e.RowIndex);
                        
                //    //}
                //}
                //public void GridDraw_MouseDoubleClick(object sender, MouseEventArgs e)
                //{
                //    DataGridView dgAngle = m_CGridMotionEditor.GetHandle();
                //    OjwGrid_CellMouseDoubleClick(dgAngle, e);
                //}
                public COjwMotor m_CMotor = new COjwMotor();
                public CHerkulex2 m_CMotor2 = new CHerkulex2();
#if !_MONSTER_LIB                
            public CDynamixel m_CRobotis = new CDynamixel();
#endif
            public CMonster2 m_CMonster = new CMonster2();
                //public void OjwGrid_SetHandle_Herculex(COjwMotor CMotor)
                //{
                //    m_CMotor = CMotor;
                //}
                private void OjwGrid_CellMouseDoubleClick(DataGridView dgData, MouseEventArgs e)
                {
                    DataGridView.HitTestInfo hti = dgData.HitTest(e.X, e.Y);
                    int a = hti.RowIndex;
                    int b = hti.ColumnIndex;
                    if ((b < 0) && (a >= 0) && (a < dgData.RowCount))
                    {
                        //CaptionControl(m_bKey_Ctrl); // 컨트롤 키가 눌리면 삽입, 아니라면 변경
                    }
                    else
                    {
#if true
                        OjwGrid_SetMotion();
#endif
                    }
                }
#if true
                private void OjwGrid_SetMotion()
                {
                    if (m_bDynamixel == true)
                    {
                        if (m_bDynamixel == false)
                        {
                            Ojw.CMessage.Write_Error("Can't find a Serial or Socket Connection");
                            return;
                        }
#if !_MONSTER_LIB
                        m_CRobotis.Reset();
                        m_CRobotis.SetTorque(true);
#else
                        m_CMonster.Reset();
                        //m_CMonster.Delay(100);
                        m_CMonster.SetTorq(true);
#endif
                        //SetFirstMoving(true);
                        SetFirstMoving(false);
                        PlayFrame_Dynamixel(m_CGridMotionEditor.m_nCurrntCell);
                    }
                    else
                    {
                        if ((m_CMotor.IsConnect() == false) && (m_CMotor2.IsOpen_Socket() == false))
                        {
                            Ojw.CMessage.Write_Error("Can't find a Serial or Socket Connection");
                            return;
                        }
                        //int[] pnAddress = frmMain.m_pnZigBeeAddress;
                        //m_CMotor.SetZigBee_Address(pnAddress[m_nCurrentRobot]);
                        m_CMotor.ResetStop();
                        m_CMotor.DrvSrv(true, true);

                        if (m_CMotor2.IsOpen_Socket() == true)
                        {
                            m_CMotor2.Reset();
                            m_CMotor2.SetTorque(true, true);
                        }
                        //if (CheckWifi() == true)
                        //{
                        //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_reset_stop();
                        //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_drvsrv(true, true);
                        //}

                        //frmMain.m_DrBluetooth.drbluetooth_set_id(frmMain.m_pnBluetoothAddress[m_nCurrentRobot]);
                        //frmMain.m_DrBluetooth.drbluetooth_client_request_motion_stop();
                        //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_reset_stop();
                        //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_drvsrv(true, true);

                        //SetAxisParam(m_nCurrentRobot);

                        //int nRow = OjwGrid.m_nCurrntCell;
                        //int nCol = CGrid.m_nCurrntColumn;

                        PlayFrame(m_CGridMotionEditor.m_nCurrntCell);
                    }
                }                            
#if true
                // 
                public void Motion_Stop()
                {
                    m_CMotor.Stop();
                    WaitAction_KillTimer();
                    m_bMotionEnd = true;
                    Ojw.CTimer.Stop();
                }
                public void Motion_Reset()
                {
                    m_CMotor.ResetEms();
                    m_CMotor.ResetStop();
                    //m_CMotor.Reset(); // -> 이건 나중에 디바이스 에러 체크 후 할지 말지 결정하도록 한다.
                }
                public void Motion_End()
                {
                    m_bMotionEnd = true;
                }
                public void Motion_Play(string strFileName, bool b3D_Display)
                {
                    try
                    {
#if !_MONSTER_LIB
                        SMotion_t SMotion = new SMotion_t();
                        if (BinaryFileOpen(strFileName, out SMotion) == true)
                        {
                            if (SMotion.nFrameSize > 0)
                            {
                                m_bStart = true;

                                WaitAction_SetTimer();

                                foreach (SMotionTable_t STable in SMotion.STable)
                                {
                                    if (STable.bEn == true)
                                    {
                                        if (m_CRobotis.IsOpen() == true) PlayFrame_Dynamixel(STable, b3D_Display, 100);
                                        else PlayFrame(STable, b3D_Display);
#if false
                                        int nDelay = STable.nTime + STable.nDelay;
                                        //m_nSimulTime_For_Last = -STable.nDelay;// nSpeedValue - nDelay;
                                        //if (GetSimulation_With_PlayFrame() == true) { SetSimulation_Calc(STable.nTime, 1.0f); }

                                        if (nDelay > 0) WaitAction_ByTimer(nDelay);
                                        //else
                                        //{
                                        //    if (GetSimulation_With_PlayFrame() == true)
                                        //    {
                                        //        for (int i = 0; i < m_CHeader.nMotorCnt; i++)
                                        //            SetData(i, GetSimulation_Value(i));
                                        //        //OjwDraw();
                                        //    }
                                        //}
#endif
                                    }
                                }

                                m_bStart = false;
                                m_bMotionEnd = false;
                            }
                        }
#else
                        m_CMonster.Motion_Play(strFileName);
#endif
                    }
                    catch(Exception ex)
                    {
                        Ojw.CMessage.Write_Error("Error -> PlayMotion(), " + ex.ToString());
                    }
                }

                private SMotionTable_t LineToMotionTable(int nLine)
                {
                    SMotionTable_t STable = new SMotionTable_t();
                    STable.bEn = GridMotionEditor_GetEnable(nLine);
                    STable.nCmd = GridMotionEditor_GetCommand(nLine);
                    STable.nGroup = GridMotionEditor_GetGroup(nLine);

                    STable.nTime = GridMotionEditor_GetTime(nLine);
                    STable.nDelay = GridMotionEditor_GetDelay(nLine);

                    STable.nData0 = GridMotionEditor_GetData0(nLine);
                    STable.nData1 = GridMotionEditor_GetData1(nLine);
                    STable.nData2 = GridMotionEditor_GetData2(nLine);
                    STable.nData3 = GridMotionEditor_GetData3(nLine);
                    STable.nData4 = GridMotionEditor_GetData4(nLine);
                    STable.nData5 = GridMotionEditor_GetData5(nLine);

                    STable.strCaption = m_CGridMotionEditor.GetCaption(nLine);

                    STable.abEn = new bool[m_CHeader.nMotorCnt];
                    STable.abType = new bool[m_CHeader.nMotorCnt];
                    STable.anLed = new int[m_CHeader.nMotorCnt];
                    STable.anMot = new int[m_CHeader.nMotorCnt];
                    for (int i = 0; i < m_CHeader.nMotorCnt; i++)
                    {
                        STable.abEn[i] = Grid_GetFlag_En(nLine, i);
                        STable.abType[i] = Grid_GetFlag_Type(nLine, i);
                        STable.anLed[i] = Grid_GetFlag_Led(nLine, i);
                        STable.anMot[i] = CalcAngle2Evd(i, CalcLimit(i, m_CGridMotionEditor.Get(nLine, i)));
                    }
                    return STable;
                }

                public void PlayFrame(int nLine, SMotion_t SMotion, bool b3D_Display)
                {
#if true
                    PlayFrame(nLine, LineToMotionTable(nLine), b3D_Display, 0);
#else
                    if (SMotion.nFrameSize <= 0) return;
                    if ((nLine < 0) || (nLine >= SMotion.nFrameSize)) return;

                    if ((m_bStop == false) && (m_bEms == false) && (m_bMotionEnd == false))
                    {
                        m_CMotor.ResetStop();
                        m_CMotor.DrvSrv(true, true);


                        for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++)
                        {
                            if (
                                //(m_CHeader.pSMotorInfo[nAxis]. == EType_t._0102) || // 엔코더이거나
                                //(m_CHeader.pSMotorInfo[nAxis].nMotorControlType != 0) // 위치제어가 아니라면 //// Motor Control type => 0: Position, 1: Speed type
                                //(m_abEnc[nAxis] == true) || // 엔코더이거나
                                (Grid_GetFlag_Type(nLine, nAxis) == true) // 위치제어가 아니라면
                                )
                            {
                                // 모드에 따라 계산법이 틀려지기에 모드 셋팅부터 먼저 한다.
                                m_CMotor.SetCmd_Flag_Mode(nAxis, true);//Ojw.CConvert.IntToBool(m_CHeader.pSMotorInfo[nAxis].nMotorControlType));
                                m_CMotor.SetParam_Item_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);

                                //float fTmpVal = (float)Math.Round(Convert.ToSingle(OjwGrid.GetData(nLine, nAxis)));
                                int nVal = SMotion.STable[nLine].anMot[nAxis];//CalcAngle2Evd(nAxis, fTmpVal);
                                if (nVal < 0)
                                {
                                    nVal *= -1;
                                    nVal |= 0x4000;
                                }
                                m_CMotor.SetCmd(nAxis, nVal);

                                m_CMotor.SetCmd_Flag_Led(nAxis,
                                    GetFlag_Led_Green(SMotion.STable[nLine].anLed[nAxis]),
                                    GetFlag_Led_Blue(SMotion.STable[nLine].anLed[nAxis]),
                                    GetFlag_Led_Red(SMotion.STable[nLine].anLed[nAxis])
                                    );
                                m_CMotor.SetCmd_Flag_NoAction(nAxis, !Grid_GetFlag_En(nLine, nAxis));

                                if ((m_CMotor2.IsOpen_Socket() == true) && (Grid_GetFlag_En(nLine, nAxis) == true))
                                //if (m_CMotor2.IsOpen_Socket() == true)
                                {
                                    m_CMotor2.SetParam_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);
                                    m_CMotor2.Set_Turn(nAxis, nVal);
                                    m_CMotor2.Set_Flag_Led(nAxis,
                                            GetFlag_Led_Green(SMotion.STable[nLine].anLed[nAxis]),
                                            GetFlag_Led_Blue(SMotion.STable[nLine].anLed[nAxis]),
                                            GetFlag_Led_Red(SMotion.STable[nLine].anLed[nAxis])
                                        );
                                }
                            }
                            else
                            {
                                // 모드에 따라 계산법이 틀려지기에 모드 셋팅부터 먼저 한다.
                                m_CMotor.SetCmd_Flag_Mode(nAxis, Ojw.CConvert.IntToBool(m_CHeader.pSMotorInfo[nAxis].nMotorControlType));
                                m_CMotor.SetParam_Item_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);

                                m_CMotor.SetCmd(nAxis, SMotion.STable[nLine].anMot[nAxis]);
                                m_CMotor.SetCmd_Flag_Led(nAxis,
                                    GetFlag_Led_Green(SMotion.STable[nLine].anLed[nAxis]),
                                    GetFlag_Led_Blue(SMotion.STable[nLine].anLed[nAxis]),
                                    GetFlag_Led_Red(SMotion.STable[nLine].anLed[nAxis])
                                    );
                            }
                        }
                        m_CMotor.SetMot(SMotion.STable[nLine].nTime);
                        // Sound & Buzz
                        if (GetSimulation_With_PlayFrame() == false) m_CMotor.Mpsu_Play_HeadLed_Buzz(SMotion.STable[nLine].nData4, SMotion.STable[nLine].nData3);
                    }
#endif
                }
                public void PlayFrame(SMotionTable_t STable, bool b3D_Display)
                {
#if true
                    PlayFrame(STable, b3D_Display, 0);
#else
                    if ((m_bStop == false) && (m_bEms == false) && (m_bMotionEnd == false))
                    {
                        m_CMotor.ResetStop();
                        m_CMotor.DrvSrv(true, true);
                        for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++)
                        {
                            if (
                                //(m_CHeader.pSMotorInfo[nAxis]. == EType_t._0102) || // 엔코더이거나
                                //(m_CHeader.pSMotorInfo[nAxis].nMotorControlType != 0) // 위치제어가 아니라면 //// Motor Control type => 0: Position, 1: Speed type
                                //(m_abEnc[nAxis] == true) || // 엔코더이거나
                                //(Grid_GetFlag_Type(m_nCurrntCell, nAxis) == true) // 위치제어가 아니라면
                                (STable.abType[nAxis] == true) // 위치제어가 아니라면
                                )
                            {
                                // 모드에 따라 계산법이 틀려지기에 모드 셋팅부터 먼저 한다.
                                m_CMotor.SetCmd_Flag_Mode(nAxis, true);//Ojw.CConvert.IntToBool(m_CHeader.pSMotorInfo[nAxis].nMotorControlType));
                                m_CMotor.SetParam_Item_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);

                                //float fTmpVal = (float)Math.Round(Convert.ToSingle(OjwGrid.GetData(nLine, nAxis)));
                                int nVal = STable.anMot[nAxis];//CalcAngle2Evd(nAxis, fTmpVal);
                                if (nVal < 0)
                                {
                                    nVal *= -1;
                                    nVal |= 0x4000;
                                }
                                m_CMotor.SetCmd(nAxis, nVal);

                                m_CMotor.SetCmd_Flag_Led(nAxis,
                                    GetFlag_Led_Green(STable.anLed[nAxis]),
                                    GetFlag_Led_Blue(STable.anLed[nAxis]),
                                    GetFlag_Led_Red(STable.anLed[nAxis])
                                    );
                                m_CMotor.SetCmd_Flag_NoAction(nAxis, !STable.abEn[nAxis]);

                                if ((m_CMotor2.IsOpen_Socket() == true) && (STable.abEn[nAxis] == true))
                                //if (m_CMotor2.IsOpen_Socket() == true)
                                {
                                    m_CMotor2.SetParam_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);
                                    m_CMotor2.Set_Turn(nAxis, nVal);
                                    m_CMotor2.Set_Flag_Led(nAxis,
                                            GetFlag_Led_Green(STable.anLed[nAxis]),
                                            GetFlag_Led_Blue(STable.anLed[nAxis]),
                                            GetFlag_Led_Red(STable.anLed[nAxis])
                                        );
                                }
                            }
                            else
                            {
                                // 모드에 따라 계산법이 틀려지기에 모드 셋팅부터 먼저 한다.
                                m_CMotor.SetCmd_Flag_Mode(nAxis, Ojw.CConvert.IntToBool(m_CHeader.pSMotorInfo[nAxis].nMotorControlType));
                                m_CMotor.SetParam_Item_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);

                                m_CMotor.SetCmd(nAxis, STable.anMot[nAxis]);
                                m_CMotor.SetCmd_Flag_Led(nAxis,
                                    GetFlag_Led_Green(STable.anLed[nAxis]),
                                    GetFlag_Led_Blue(STable.anLed[nAxis]),
                                    GetFlag_Led_Red(STable.anLed[nAxis])
                                    );
                            }
                        }
                        m_CMotor.SetMot(STable.nTime);
                        // Sound & Buzz
                        if (GetSimulation_With_PlayFrame() == false) m_CMotor.Mpsu_Play_HeadLed_Buzz(STable.nData4, STable.nData3);
                    }
#endif
                }
                public void PlayFrame(int nLine)
                {
#if true
                    PlayFrame(nLine, LineToMotionTable(nLine), false, 0);
#else
                    float fVal;
                    CGridView OjwGrid = m_CGridMotionEditor;
                    int nRow = nLine;// OjwGrid.m_nCurrntCell;
                    for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++)
                    {
                        if (
                            //(m_CHeader.pSMotorInfo[nAxis]. == EType_t._0102) || // 엔코더이거나
                            //(m_CHeader.pSMotorInfo[nAxis].nMotorControlType != 0) // 위치제어가 아니라면 //// Motor Control type => 0: Position, 1: Speed type
                            //(m_abEnc[nAxis] == true) || // 엔코더이거나
                            (Grid_GetFlag_Type(nRow, nAxis) == true) // 위치제어가 아니라면
                            )
                        {
                            // 모드에 따라 계산법이 틀려지기에 모드 셋팅부터 먼저 한다.
                            m_CMotor.SetCmd_Flag_Mode(nAxis, true);//Ojw.CConvert.IntToBool(m_CHeader.pSMotorInfo[nAxis].nMotorControlType));
                            m_CMotor.SetParam_Item_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);

                            //if (CheckWifi() == true)
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_mode(nAxis, Grid_GetFlag_Type(m_nCurrntCell, nAxis));

                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_mode(nAxis, Grid_GetFlag_Type(m_nCurrntCell, nAxis));

                            //int nRow = CGrid.m_nCurrntCell;
                            //int nCol = CGrid.m_nCurrntColumn;

                            float fTmpVal = (float)Math.Round(Convert.ToSingle(OjwGrid.GetData(nRow, nAxis)));
                            int nVal = CalcAngle2Evd(nAxis, fTmpVal);
                            //int nVal2 = nVal;
                            if (nVal < 0)
                            {
                                nVal *= -1;
                                nVal |= 0x4000;
                            }
                            m_CMotor.SetCmd(nAxis, nVal);
                            //if (CheckWifi() == true)
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd(nAxis, nVal);

                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd(nAxis, nVal);

                            bool bRed = (Grid_GetFlag_Led(nRow, nAxis) == 1) ? true : false;
                            bool bBlue = (Grid_GetFlag_Led(nRow, nAxis) == 2) ? true : false;
                            bool bGreen = (Grid_GetFlag_Led(nRow, nAxis) == 4) ? true : false;
                            m_CMotor.SetCmd_Flag_Led(nAxis, bGreen, bBlue, bRed);
                            m_CMotor.SetCmd_Flag_NoAction(nAxis, !Grid_GetFlag_En(nRow, nAxis));

                            if ((m_CMotor2.IsOpen_Socket() == true) && (Grid_GetFlag_En(nRow, nAxis) == true))
                            //if (m_CMotor2.IsOpen_Socket() == true)
                            {
                                m_CMotor2.SetParam_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);
                                m_CMotor2.Set_Turn(nAxis, nVal);
                                m_CMotor2.Set_Flag_Led(nAxis, bGreen, bBlue, bRed);
                            }
                            //m_CMotor.SetCmd_Flag_NoAction(nAxis, !Grid_GetFlag_En(nRow, nAxis));
                            //if (CheckWifi() == true)
                            //{
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_led(nAxis, bGreen, bBlue, bRed);
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_no_action(nAxis, !Grid_GetFlag_En(m_nCurrntCell, nAxis));
                            //}

                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_led(nAxis, bGreen, bBlue, bRed);
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_no_action(nAxis, !Grid_GetFlag_En(m_nCurrntCell, nAxis));
                        }
                        else
                        {
                            // 모드에 따라 계산법이 틀려지기에 모드 셋팅부터 먼저 한다.
                            m_CMotor.SetCmd_Flag_Mode(nAxis, Ojw.CConvert.IntToBool(m_CHeader.pSMotorInfo[nAxis].nMotorControlType));
                            m_CMotor.SetParam_Item_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);
                            //m_CMotor.SetCmd_Flag_Mode(nAxis, Grid_GetFlag_Type(m_nCurrntCell, nAxis));
                            //if (CheckWifi() == true)
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_mode(nAxis, Grid_GetFlag_Type(m_nCurrntCell, nAxis));
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_mode(nAxis, Grid_GetFlag_Type(m_nCurrntCell, nAxis));

                            fVal = (float)Math.Round((float)OjwGrid.Get(nRow, nAxis)); //GridMotionEditor_GetMotor(m_nCurrntCell, nAxis);
                            m_CMotor.SetCmd_Angle(nAxis, fVal);
                            //if (CheckWifi() == true)
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_angle(nAxis, fVal);
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_angle(nAxis, fVal);
                            bool bRed = (Grid_GetFlag_Led(nRow, nAxis) == 1) ? true : false;
                            bool bBlue = (Grid_GetFlag_Led(nRow, nAxis) == 2) ? true : false;
                            bool bGreen = (Grid_GetFlag_Led(nRow, nAxis) == 4) ? true : false;
                            m_CMotor.SetCmd_Flag_Led(nAxis, bGreen, bBlue, bRed);
                            m_CMotor.SetCmd_Flag_NoAction(nAxis, !Grid_GetFlag_En(nRow, nAxis));

                            if ((m_CMotor2.IsOpen_Socket() == true) && (Grid_GetFlag_En(nRow, nAxis) == true))
                            {
                                m_CMotor2.SetParam_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);
                                m_CMotor2.Set_Angle(nAxis, fVal);
                                m_CMotor2.Set_Flag_Led(nAxis, bGreen, bBlue, bRed);
                            }
                            //if (CheckWifi() == true)
                            //{
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_led(nAxis, bGreen, bBlue, bRed);
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_no_action(nAxis, !Grid_GetFlag_En(m_nCurrntCell, nAxis));
                            //}
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_led(nAxis, bGreen, bBlue, bRed);
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_no_action(nAxis, !Grid_GetFlag_En(m_nCurrntCell, nAxis));
                        }
                    }
                    //m_CTmr_Interval_X.Set_Interval((double)fX, (double)m_afAnimation[nAxis, 0], (double)Math.Abs(fX - m_afAnimation[nAxis, 0]) / m_dInterval_Value, m_lInterval_Time);

                    m_CMotor.SetMot((int)OjwGrid.GetTime(nRow));//m_CGridMotionEditor.GetTime(m_nCurrntCell));
                    if (m_CMotor2.IsOpen_Socket() == true)
                    {
                        m_CMotor2.Send_Motor((int)OjwGrid.GetTime(nRow));
                    }
                    //m_CMotor.Mpsu_Play_HeadLed_Buzz(Grid_GetExtLed(m_nCurrntCell), Grid_GetExtBuzz(m_nCurrntCell));


                    // Sound & Buzz
                    if (GetSimulation_With_PlayFrame() == false) m_CMotor.Mpsu_Play_HeadLed_Buzz(GridMotionEditor_GetExtLed(nRow), GridMotionEditor_GetExtBuzz(nRow));

                    //if (CheckWifi() == true)
                    //{
                    //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_request_move(m_CGridMotionEditor.GetTime(m_nCurrntCell));
                    //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_mpsu_play_headled_buzz(253, Grid_GetExtLed(m_nCurrntCell), Grid_GetExtBuzz(m_nCurrntCell));
                    //}
                    //frmMain.m_DrBluetooth.drbluetooth_set_id(frmMain.m_pnBluetoothAddress[m_nCurrentRobot]);
                    //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_request_move(m_CGridMotionEditor.GetTime(m_nCurrntCell));
                    //frmMain.m_DrBluetooth.drbluetooth_client_serial_mpsu_play_headled_buzz(253, Grid_GetExtLed(m_nCurrntCell), Grid_GetExtBuzz(m_nCurrntCell));
#endif
                }
                public void PlayFrame(int nLine, int nAddSpeedPercent)
                {
#if true                    
                    PlayFrame(nLine, LineToMotionTable(nLine), false, nAddSpeedPercent);
#else
                    bool bSock = m_CMotor2.IsOpen_Socket();
                    CGridView OjwGrid = m_CGridMotionEditor;
                    //int nRow = OjwGrid.m_nCurrntCell;
                    if (m_bStart == true)
                    {
#if !_COLOR_GRID_IN_PAINT
                        //GridMotionEditor_SetColorGrid(nLine - 1, 1);
#endif
                        if (m_bControl_Tracking)
                        {
                            if ((GetSimulation_With_PlayFrame() == false) || ((m_bSimulation_Smooth == false) && (GetSimulation_With_PlayFrame() == true))) for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) SetData(nAxis, GridMotionEditor_GetMotor(nLine, nAxis)); // 이거 나중에 실시간으로 하고 싶으면 시작단계에서 미리 계산하도록 수정하도록 한다. - 아직은 생각없음.
                            m_CGridMotionEditor.GetHandle().CurrentCell = m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[1];
                        }
                    }

                    float fPercent = 1.0f + (float)nAddSpeedPercent / 100.0f;

                    float fVal;
                    bool bRed, bBlue, bGreen;

                    if (GetSimulation_With_PlayFrame() == true) { SetSimulation_SetCurrentData(); }

                    for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++)
                    {
                        if (
                            //(m_abEnc[nAxis] == true) || // 엔코더이거나
                            //(m_CHeader.pSMotorInfo[nAxis].nMotorControlType != 0) // 위치제어가 아니라면 //// Motor Control type => 0: Position, 1: Speed type
                            (Grid_GetFlag_Type(nLine, nAxis) == true) // 위치제어가 아니라면
                            //((m_CMotor.GetCmd_Flag_Mode(nAxis) != 0) && (m_CMotor.GetCmd_Flag_Mode(nAxis) != 2)) // 위치제어가 아니라면
                            )//((nAxis >= 6) && (nAxis <= 8)) ojw5014 20120417
                        {
                            //// 동작 ////
                            // 모드에 따라 계산법이 틀려지기에 모드 셋팅부터 먼저 한다.
                            m_CMotor.SetCmd_Flag_Mode(nAxis, true);//Ojw.CConvert.IntToBool(m_CHeader.pSMotorInfo[nAxis].nMotorControlType));
                            m_CMotor.SetParam_Item_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);
                            //if (CheckWifi() == true)
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_mode(nAxis, Grid_GetFlag_Type(nLine, nAxis));
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_mode(nAxis, Grid_GetFlag_Type(nLine, nAxis));
                            if (bSock == true) m_CMotor2.SetParam_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);

                            float fTmpVal = (float)Math.Round(Convert.ToSingle(OjwGrid.GetData(nLine, nAxis)));
                            int nVal = CalcAngle2Evd(nAxis, fTmpVal);

                            //int nVal = (int)Math.Round(GridMotionEditor_GetMotor(nLine, nAxis));
                            if (bSock == true) m_CMotor2.Set_Turn(nAxis, nVal);
                            if (nVal < 0)
                            {
                                nVal *= -1;
                                nVal |= 0x4000;
                            }
                            m_CMotor.SetCmd(nAxis, nVal);
                            //if (CheckWifi() == true)
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd(nAxis, nVal);
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd(nAxis, nVal);

                            bRed = (Grid_GetFlag_Led(nLine, nAxis) == 1) ? true : false;
                            bBlue = (Grid_GetFlag_Led(nLine, nAxis) == 2) ? true : false;
                            bGreen = (Grid_GetFlag_Led(nLine, nAxis) == 4) ? true : false;
                            m_CMotor.SetCmd_Flag_Led(nAxis, bGreen, bBlue, bRed);




                            //////// 여기 함수 다시 한번 체크해라.



                            if (bSock == true)
                            {
                                m_CMotor2.Set_Flag_Led(nAxis, bGreen, bBlue, bRed);
                                if (fTmpVal == 0) m_CMotor2.Set_Flag_Stop(nAxis, true);
                                else m_CMotor2.Set_Flag_Stop(nAxis, false);
                            }
                            if (fTmpVal == 0) m_CMotor.SetCmd_Flag_Stop(nAxis, true);
                            else m_CMotor.SetCmd_Flag_Stop(nAxis, false);
                            //m_CMotor.SetCmd_Flag_Led(nAxis, bGreen, bBlue, bRed);                            
#if false
                            //m_CMotor.SetCmd_Flag_NoAction(nAxis, !Grid_GetFlag_En(nLine, nAxis));
                    
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_request_stop();
                            //if (fTmpVal == 0) frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_stop(nAxis, true);
                            //else frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_stop(nAxis, false);
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_led(nAxis, bGreen, bBlue, bRed);
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_no_action(nAxis, !Grid_GetFlag_En(nLine, nAxis));

                            ///////////
                            
                            //if (CheckWifi() == true)
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd(nAxis, nVal);

                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd(nAxis, nVal);

                            
                            //m_CMotor.SetCmd_Flag_NoAction(nAxis, true);//!Grid_GetFlag_En(m_nCurrntCell, nAxis));
                            //if (CheckWifi() == true)
                            //{
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_led(nAxis, bGreen, bBlue, bRed);
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_no_action(nAxis, !Grid_GetFlag_En(m_nCurrntCell, nAxis));
                            //}

                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_led(nAxis, bGreen, bBlue, bRed);
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_no_action(nAxis, !Grid_GetFlag_En(m_nCurrntCell, nAxis));
#endif
                            if (m_bSimulation == true)
                            {
                                SetData(nAxis, (float)nVal);
                            }
                        }
                        else
                        {
                            // 모드에 따라 계산법이 틀려지기에 모드 셋팅부터 먼저 한다.
                            m_CMotor.SetCmd_Flag_Mode(nAxis, Ojw.CConvert.IntToBool(m_CHeader.pSMotorInfo[nAxis].nMotorControlType));
                            m_CMotor.SetParam_Item_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);

                            if (bSock == true) m_CMotor2.SetParam_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);

                            fVal = (float)Math.Round((float)OjwGrid.Get(nLine, nAxis)); //GridMotionEditor_GetMotor(m_nCurrntCell, nAxis);
                            m_CMotor.SetCmd_Angle(nAxis, fVal);
                            if (bSock == true) m_CMotor2.Set_Angle(nAxis, fVal);

                            bRed = (Grid_GetFlag_Led(nLine, nAxis) == 1) ? true : false;
                            bBlue = (Grid_GetFlag_Led(nLine, nAxis) == 2) ? true : false;
                            bGreen = (Grid_GetFlag_Led(nLine, nAxis) == 4) ? true : false;
                            m_CMotor.SetCmd_Flag_Led(nAxis, bGreen, bBlue, bRed);
                            if (bSock == true) m_CMotor2.Set_Flag_Led(nAxis, bGreen, bBlue, bRed);
                            /////////////////////////////////////

                            m_CMotor.SetCmd_Flag_Stop(nAxis, false);

                            // //// 동작 ////
                            // // 모드에 따라 계산법이 틀려지기에 모드 셋팅부터 먼저 한다.
                            // //m_CMotor.SetCmd_Flag_Mode(nAxis, Ojw.CConvert.IntToBool(m_CHeader.pSMotorInfo[nAxis].nMotorControlType));
                            //// m_CMotor.SetParam_Item_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir); // 굳이 안넣어도 된다. 이젠... 그냥 잊어버릴까봐 불필요 코드 집어넣은 정도...

                            // //m_CMotor.SetCmd_Flag_Mode(nAxis, Grid_GetFlag_Type(nLine, nAxis));
                            // //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_mode(nAxis, Grid_GetFlag_Type(nLine, nAxis));

                            // fVal = (float)Math.Round((float)OjwGrid.Get(nLine, nAxis)); //fVal = GridMotionEditor_GetMotor(nLine, nAxis);
                            // m_CMotor.SetCmd_Angle(nAxis, fVal);
                            // //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_angle(nAxis, fVal);

                            // bRed = (Grid_GetFlag_Led(nLine, nAxis) == 1) ? true : false;
                            // bBlue = (Grid_GetFlag_Led(nLine, nAxis) == 2) ? true : false;
                            // bGreen = (Grid_GetFlag_Led(nLine, nAxis) == 4) ? true : false;
                            // m_CMotor.SetCmd_Flag_Led(nAxis, bGreen, bBlue, bRed);

                            // m_CMotor.SetCmd_Flag_Stop(nAxis, false);

                            //m_CMotor.SetCmd_Flag_NoAction(nAxis, !GridMotionEditor_GetFlag_En(nLine, nAxis));
                            //if (CheckWifi() == true)
                            //{
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_stop(nAxis, false);
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_led(nAxis, bGreen, bBlue, bRed);
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_no_action(nAxis, !Grid_GetFlag_En(nLine, nAxis));
                            //}
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_stop(nAxis, false);
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_led(nAxis, bGreen, bBlue, bRed);
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_no_action(nAxis, !GridMotionEditor_GetFlag_En(nLine, nAxis));
                            if (m_bSimulation == true)
                            {
                                //SetData(nAxis, (float)fVal);
                                if (GetSimulation_With_PlayFrame() == true)
                                {
                                    if (m_bSimulation_Smooth == false)
                                    {
                                        SetData(nAxis, (float)fVal);
                                    }
                                    SetSimulation_SetNextData(nAxis, fVal);
                                }
                            }
                        }
                    }
                    int nSpeedValue = (int)Math.Round((float)fPercent * (float)GridMotionEditor_GetTime(nLine));
                    int nDelayValue = (int)Math.Round((float)fPercent * (float)GridMotionEditor_GetDelay(nLine));

                    if (GetSimulation_With_PlayFrame() == false)
                    {
                        m_CMotor.SetMot(nSpeedValue);
                        if (bSock == true) m_CMotor2.Send_Motor(nSpeedValue);
                    }
                    //if ((m_bSimulation_Smooth == true) && (GetSimulation_With_PlayFrame() == true)) OjwDraw();

                    //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_request_move(nSpeedValue);
                    if (GridMotionEditor_GetCommand(nLine) != 2) // if it is not a "sync"
                    {
                        int nDelay = nSpeedValue + nDelayValue;
                        m_nSimulTime_For_Last = -nDelayValue;// nSpeedValue - nDelay;
                        if (GetSimulation_With_PlayFrame() == true) { SetSimulation_Calc(nSpeedValue, 1.0f); }

                        if (nDelay > 0) WaitAction_ByTimer(nDelay);
                        else
                        {
                            if (GetSimulation_With_PlayFrame() == true)
                            {
                                for (int i = 0; i < m_CHeader.nMotorCnt; i++)
                                    SetData(i, GetSimulation_Value(i));
                                //OjwDraw();
                            }
                        }
                    }

                    // Sound & Buzz
                    if (GetSimulation_With_PlayFrame() == false) m_CMotor.Mpsu_Play_HeadLed_Buzz(GridMotionEditor_GetExtLed(nLine), GridMotionEditor_GetExtBuzz(nLine));

                    //frmMain.m_DrBluetooth.drbluetooth_set_id(frmMain.m_pnBluetoothAddress[m_nCurrentRobot]);
                    //frmMain.m_DrBluetooth.drbluetooth_client_serial_mpsu_play_headled_buzz(0xfe, Grid_GetExtLed(nLine), Grid_GetExtBuzz(nLine));
#endif
                }
            
                public void PlayFrame(SMotionTable_t STable, bool b3D_Display, int nAddSpeedPercent) // 100% + nAddSpeedPercent
                {
                    PlayFrame(-1, STable, b3D_Display, nAddSpeedPercent);
                }
                public void PlayFrame(int nLine, SMotionTable_t STable, bool b3D_Display, int nAddSpeedPercent) // 100% + nAddSpeedPercent
                {
                    
#region Herkulex
#if false
                    bool bSock = m_CMotor2.IsOpen_Socket();
                    CGridView OjwGrid = m_CGridMotionEditor;
                    //int nRow = OjwGrid.m_nCurrntCell;
                    if (m_bStart == true)
                    {
#if !_COLOR_GRID_IN_PAINT
                        //GridMotionEditor_SetColorGrid(nLine - 1, 1);
#endif
                        if (m_bControl_Tracking)
                        {
                            if ((GetSimulation_With_PlayFrame() == false) || ((m_bSimulation_Smooth == false) && (GetSimulation_With_PlayFrame() == true))) for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) SetData(nAxis, GridMotionEditor_GetMotor(nLine, nAxis)); // 이거 나중에 실시간으로 하고 싶으면 시작단계에서 미리 계산하도록 수정하도록 한다. - 아직은 생각없음.
                            m_CGridMotionEditor.GetHandle().CurrentCell = m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[1];
                        }
                    }

                    float fPercent = 1.0f + (float)nAddSpeedPercent / 100.0f;

                    float fVal;
                    bool bRed, bBlue, bGreen;

                    if (GetSimulation_With_PlayFrame() == true) { SetSimulation_SetCurrentData(); }

                    for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++)
                    {
                        if (
                            //(m_abEnc[nAxis] == true) || // 엔코더이거나
                            //(m_CHeader.pSMotorInfo[nAxis].nMotorControlType != 0) // 위치제어가 아니라면 //// Motor Control type => 0: Position, 1: Speed type
                            (Grid_GetFlag_Type(nLine, nAxis) == true) // 위치제어가 아니라면
                            //((m_CMotor.GetCmd_Flag_Mode(nAxis) != 0) && (m_CMotor.GetCmd_Flag_Mode(nAxis) != 2)) // 위치제어가 아니라면
                            )//((nAxis >= 6) && (nAxis <= 8)) ojw5014 20120417
                        {
                            //// 동작 ////
                            // 모드에 따라 계산법이 틀려지기에 모드 셋팅부터 먼저 한다.
                            m_CMotor.SetCmd_Flag_Mode(nAxis, true);//Ojw.CConvert.IntToBool(m_CHeader.pSMotorInfo[nAxis].nMotorControlType));
                            m_CMotor.SetParam_Item_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);
                            //if (CheckWifi() == true)
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_mode(nAxis, Grid_GetFlag_Type(nLine, nAxis));
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_mode(nAxis, Grid_GetFlag_Type(nLine, nAxis));
                            if (bSock == true) m_CMotor2.SetParam_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);

                            float fTmpVal = (float)Math.Round(Convert.ToSingle(OjwGrid.GetData(nLine, nAxis)));
                            int nVal = CalcAngle2Evd(nAxis, fTmpVal);

                            //int nVal = (int)Math.Round(GridMotionEditor_GetMotor(nLine, nAxis));
                            if (bSock == true) m_CMotor2.Set_Turn(nAxis, nVal);
                            if (nVal < 0)
                            {
                                nVal *= -1;
                                nVal |= 0x4000;
                            }
                            m_CMotor.SetCmd(nAxis, nVal);
                            //if (CheckWifi() == true)
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd(nAxis, nVal);
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd(nAxis, nVal);

                            bRed = (Grid_GetFlag_Led(nLine, nAxis) == 1) ? true : false;
                            bBlue = (Grid_GetFlag_Led(nLine, nAxis) == 2) ? true : false;
                            bGreen = (Grid_GetFlag_Led(nLine, nAxis) == 4) ? true : false;
                            m_CMotor.SetCmd_Flag_Led(nAxis, bGreen, bBlue, bRed);




                            //////// 여기 함수 다시 한번 체크해라.



                            if (bSock == true)
                            {
                                m_CMotor2.Set_Flag_Led(nAxis, bGreen, bBlue, bRed);
                                if (fTmpVal == 0) m_CMotor2.Set_Flag_Stop(nAxis, true);
                                else m_CMotor2.Set_Flag_Stop(nAxis, false);
                            }
                            if (fTmpVal == 0) m_CMotor.SetCmd_Flag_Stop(nAxis, true);
                            else m_CMotor.SetCmd_Flag_Stop(nAxis, false);
                            //m_CMotor.SetCmd_Flag_Led(nAxis, bGreen, bBlue, bRed);                            
#if false
                            //m_CMotor.SetCmd_Flag_NoAction(nAxis, !Grid_GetFlag_En(nLine, nAxis));
                    
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_request_stop();
                            //if (fTmpVal == 0) frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_stop(nAxis, true);
                            //else frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_stop(nAxis, false);
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_led(nAxis, bGreen, bBlue, bRed);
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_no_action(nAxis, !Grid_GetFlag_En(nLine, nAxis));

                            ///////////
                            
                            //if (CheckWifi() == true)
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd(nAxis, nVal);

                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd(nAxis, nVal);

                            
                            //m_CMotor.SetCmd_Flag_NoAction(nAxis, true);//!Grid_GetFlag_En(m_nCurrntCell, nAxis));
                            //if (CheckWifi() == true)
                            //{
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_led(nAxis, bGreen, bBlue, bRed);
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_no_action(nAxis, !Grid_GetFlag_En(m_nCurrntCell, nAxis));
                            //}

                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_led(nAxis, bGreen, bBlue, bRed);
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_no_action(nAxis, !Grid_GetFlag_En(m_nCurrntCell, nAxis));
#endif
                            if (m_bSimulation == true)
                            {
                                SetData(nAxis, (float)nVal);
                            }
                        }
                        else
                        {
                            // 모드에 따라 계산법이 틀려지기에 모드 셋팅부터 먼저 한다.
                            m_CMotor.SetCmd_Flag_Mode(nAxis, Ojw.CConvert.IntToBool(m_CHeader.pSMotorInfo[nAxis].nMotorControlType));
                            m_CMotor.SetParam_Item_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);

                            if (bSock == true) m_CMotor2.SetParam_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);

                            fVal = (float)Math.Round((float)OjwGrid.Get(nLine, nAxis)); //GridMotionEditor_GetMotor(m_nCurrntCell, nAxis);
                            m_CMotor.SetCmd_Angle(nAxis, fVal);
                            if (bSock == true) m_CMotor2.Set_Angle(nAxis, fVal);

                            bRed = (Grid_GetFlag_Led(nLine, nAxis) == 1) ? true : false;
                            bBlue = (Grid_GetFlag_Led(nLine, nAxis) == 2) ? true : false;
                            bGreen = (Grid_GetFlag_Led(nLine, nAxis) == 4) ? true : false;
                            m_CMotor.SetCmd_Flag_Led(nAxis, bGreen, bBlue, bRed);
                            if (bSock == true) m_CMotor2.Set_Flag_Led(nAxis, bGreen, bBlue, bRed);
                            /////////////////////////////////////

                            m_CMotor.SetCmd_Flag_Stop(nAxis, false);

                            // //// 동작 ////
                            // // 모드에 따라 계산법이 틀려지기에 모드 셋팅부터 먼저 한다.
                            // //m_CMotor.SetCmd_Flag_Mode(nAxis, Ojw.CConvert.IntToBool(m_CHeader.pSMotorInfo[nAxis].nMotorControlType));
                            //// m_CMotor.SetParam_Item_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir); // 굳이 안넣어도 된다. 이젠... 그냥 잊어버릴까봐 불필요 코드 집어넣은 정도...

                            // //m_CMotor.SetCmd_Flag_Mode(nAxis, Grid_GetFlag_Type(nLine, nAxis));
                            // //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_mode(nAxis, Grid_GetFlag_Type(nLine, nAxis));

                            // fVal = (float)Math.Round((float)OjwGrid.Get(nLine, nAxis)); //fVal = GridMotionEditor_GetMotor(nLine, nAxis);
                            // m_CMotor.SetCmd_Angle(nAxis, fVal);
                            // //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_angle(nAxis, fVal);

                            // bRed = (Grid_GetFlag_Led(nLine, nAxis) == 1) ? true : false;
                            // bBlue = (Grid_GetFlag_Led(nLine, nAxis) == 2) ? true : false;
                            // bGreen = (Grid_GetFlag_Led(nLine, nAxis) == 4) ? true : false;
                            // m_CMotor.SetCmd_Flag_Led(nAxis, bGreen, bBlue, bRed);

                            // m_CMotor.SetCmd_Flag_Stop(nAxis, false);

                            //m_CMotor.SetCmd_Flag_NoAction(nAxis, !GridMotionEditor_GetFlag_En(nLine, nAxis));
                            //if (CheckWifi() == true)
                            //{
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_stop(nAxis, false);
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_led(nAxis, bGreen, bBlue, bRed);
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_no_action(nAxis, !Grid_GetFlag_En(nLine, nAxis));
                            //}
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_stop(nAxis, false);
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_led(nAxis, bGreen, bBlue, bRed);
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_no_action(nAxis, !GridMotionEditor_GetFlag_En(nLine, nAxis));
                            if (m_bSimulation == true)
                            {
                                //SetData(nAxis, (float)fVal);
                                if (GetSimulation_With_PlayFrame() == true)
                                {
                                    if (m_bSimulation_Smooth == false)
                                    {
                                        SetData(nAxis, (float)fVal);
                                    }
                                    SetSimulation_SetNextData(nAxis, fVal);
                                }
                            }
                        }
                    }
                    int nSpeedValue = (int)Math.Round((float)fPercent * (float)GridMotionEditor_GetTime(nLine));
                    int nDelayValue = (int)Math.Round((float)fPercent * (float)GridMotionEditor_GetDelay(nLine));

                    if (GetSimulation_With_PlayFrame() == false)
                    {
                        m_CMotor.SetMot(nSpeedValue);
                        if (bSock == true) m_CMotor2.Send_Motor(nSpeedValue);
                    }
                    
                    if (GridMotionEditor_GetCommand(nLine) != 2) // if it is not a "sync"
                    {
                        int nDelay = nSpeedValue + nDelayValue;
                        m_nSimulTime_For_Last = -nDelayValue;// nSpeedValue - nDelay;
                        if (GetSimulation_With_PlayFrame() == true) { SetSimulation_Calc(nSpeedValue, 1.0f); }

                        if (nDelay > 0) WaitAction_ByTimer(nDelay);
                        else
                        {
                            if (GetSimulation_With_PlayFrame() == true)
                            {
                                for (int i = 0; i < m_CHeader.nMotorCnt; i++)
                                    SetData(i, GetSimulation_Value(i));
                                //OjwDraw();
                            }
                        }
                    }

                    // Sound & Buzz
                    if (GetSimulation_With_PlayFrame() == false) m_CMotor.Mpsu_Play_HeadLed_Buzz(GridMotionEditor_GetExtLed(nLine), GridMotionEditor_GetExtBuzz(nLine));
#else



#if true
                    bool bSock = m_CMotor2.IsOpen_Socket();
                    CGridView OjwGrid = m_CGridMotionEditor;
                    //int nRow = OjwGrid.m_nCurrntCell;
                    if (m_bStart == true)
                    {
#if !_COLOR_GRID_IN_PAINT
                        //GridMotionEditor_SetColorGrid(nLine - 1, 1);
#endif

                        if (nLine >= 0)
                        {
                            if (m_bControl_Tracking)
                            {
                                if ((GetSimulation_With_PlayFrame() == false) || ((m_bSimulation_Smooth == false) && (GetSimulation_With_PlayFrame() == true))) for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++)
                                        SetData(nAxis, GridMotionEditor_GetMotor(nLine, nAxis)); // 이거 나중에 실시간으로 하고 싶으면 시작단계에서 미리 계산하도록 수정하도록 한다. - 아직은 생각없음.
                                m_CGridMotionEditor.GetHandle().CurrentCell = m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[1];
                            }
                        }
                    }

                    float fPercent = 1.0f + (float)nAddSpeedPercent / 100.0f;

                    float fVal;
                    bool bRed, bBlue, bGreen;

                    if (GetSimulation_With_PlayFrame() == true) { SetSimulation_SetCurrentData(); }

                    for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++)
                    {
                        if (
                            //(m_abEnc[nAxis] == true) || // 엔코더이거나
                            //(m_CHeader.pSMotorInfo[nAxis].nMotorControlType != 0) // 위치제어가 아니라면 //// Motor Control type => 0: Position, 1: Speed type
                            
                            ((nLine < 0) ? (STable.abType[nAxis] == true) : (Grid_GetFlag_Type(nLine, nAxis) == true)) // 위치제어가 아니라면
                            
                            //((m_CMotor.GetCmd_Flag_Mode(nAxis) != 0) && (m_CMotor.GetCmd_Flag_Mode(nAxis) != 2)) // 위치제어가 아니라면
                            )//((nAxis >= 6) && (nAxis <= 8)) ojw5014 20120417
                        {
                            //// 동작 ////
                            // 모드에 따라 계산법이 틀려지기에 모드 셋팅부터 먼저 한다.
                            m_CMotor.SetCmd_Flag_Mode(nAxis, true);//Ojw.CConvert.IntToBool(m_CHeader.pSMotorInfo[nAxis].nMotorControlType));
                            m_CMotor.SetParam_Item_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);
                            //if (CheckWifi() == true)
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_mode(nAxis, Grid_GetFlag_Type(nLine, nAxis));
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_mode(nAxis, Grid_GetFlag_Type(nLine, nAxis));
                            if (bSock == true) m_CMotor2.SetParam_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);

                            float fTmpVal = (float)Math.Round(Convert.ToSingle(
                                ((nLine < 0) ? STable.anMot[nAxis] : OjwGrid.GetData(nLine, nAxis))
                                ));
                            int nVal = CalcAngle2Evd(nAxis, fTmpVal);

                            //int nVal = (int)Math.Round(GridMotionEditor_GetMotor(nLine, nAxis));
                            if (bSock == true) m_CMotor2.Set_Turn(nAxis, nVal);
                            if (nVal < 0)
                            {
                                nVal *= -1;
                                nVal |= 0x4000;
                            }
                            m_CMotor.SetCmd(nAxis, nVal);
                            //if (CheckWifi() == true)
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd(nAxis, nVal);
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd(nAxis, nVal);

                            if (nLine < 0)
                            {
                                bRed = GetFlag_Led_Red(STable.anLed[nAxis]);//(nLine, nAxis) == 1) ? true : false;
                                bBlue = GetFlag_Led_Blue(STable.anLed[nAxis]); //(Grid_GetFlag_Led(nLine, nAxis) == 2) ? true : false;
                                bGreen = GetFlag_Led_Green(STable.anLed[nAxis]); //(Grid_GetFlag_Led(nLine, nAxis) == 4) ? true : false;
                            }
                            else
                            {
                                bRed = (Grid_GetFlag_Led(nLine, nAxis) == 1) ? true : false;
                                bBlue = (Grid_GetFlag_Led(nLine, nAxis) == 2) ? true : false;
                                bGreen = (Grid_GetFlag_Led(nLine, nAxis) == 4) ? true : false;
                            }
                            m_CMotor.SetCmd_Flag_Led(nAxis, bGreen, bBlue, bRed);
                                                        
                            if (bSock == true)
                            {
                                m_CMotor2.Set_Flag_Led(nAxis, bGreen, bBlue, bRed);
                                if (fTmpVal == 0) m_CMotor2.Set_Flag_Stop(nAxis, true);
                                else m_CMotor2.Set_Flag_Stop(nAxis, false);
                            }
                            if (fTmpVal == 0) m_CMotor.SetCmd_Flag_Stop(nAxis, true);
                            else m_CMotor.SetCmd_Flag_Stop(nAxis, false);
                            //m_CMotor.SetCmd_Flag_Led(nAxis, bGreen, bBlue, bRed);                            
#if false
                            //m_CMotor.SetCmd_Flag_NoAction(nAxis, !Grid_GetFlag_En(nLine, nAxis));
                    
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_request_stop();
                            //if (fTmpVal == 0) frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_stop(nAxis, true);
                            //else frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_stop(nAxis, false);
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_led(nAxis, bGreen, bBlue, bRed);
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_no_action(nAxis, !Grid_GetFlag_En(nLine, nAxis));

                            ///////////
                            
                            //if (CheckWifi() == true)
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd(nAxis, nVal);

                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd(nAxis, nVal);

                            
                            //m_CMotor.SetCmd_Flag_NoAction(nAxis, true);//!Grid_GetFlag_En(m_nCurrntCell, nAxis));
                            //if (CheckWifi() == true)
                            //{
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_led(nAxis, bGreen, bBlue, bRed);
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_no_action(nAxis, !Grid_GetFlag_En(m_nCurrntCell, nAxis));
                            //}

                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_led(nAxis, bGreen, bBlue, bRed);
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_no_action(nAxis, !Grid_GetFlag_En(m_nCurrntCell, nAxis));
#endif
                            if (m_bSimulation == true)
                            {
                                SetData(nAxis, (float)nVal);
                            }
                        }
                        else
                        {
                            // 모드에 따라 계산법이 틀려지기에 모드 셋팅부터 먼저 한다.
                            m_CMotor.SetCmd_Flag_Mode(nAxis, false);//Ojw.CConvert.IntToBool(m_CHeader.pSMotorInfo[nAxis].nMotorControlType));
                            m_CMotor.SetParam_Item_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);

                            if (bSock == true) m_CMotor2.SetParam_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);


                            //fVal = (float)Math.Round((float)OjwGrid.Get(nLine, nAxis)); //GridMotionEditor_GetMotor(m_nCurrntCell, nAxis);
                            //m_CMotor.SetCmd_Angle(nAxis, fVal);
                            //if (bSock == true) m_CMotor2.Set_Angle(nAxis, fVal);

                            if (nLine < 0)
                            {
                                m_CMotor.SetCmd(nAxis, STable.anMot[nAxis]);
                                if (bSock == true) m_CMotor2.Set(nAxis, STable.anMot[nAxis]);
                                bRed = GetFlag_Led_Red(STable.anLed[nAxis]);
                                bBlue = GetFlag_Led_Blue(STable.anLed[nAxis]); 
                                bGreen = GetFlag_Led_Green(STable.anLed[nAxis]);
                            }
                            else
                            {
                                fVal = (float)Math.Round((float)OjwGrid.Get(nLine, nAxis)); //GridMotionEditor_GetMotor(m_nCurrntCell, nAxis);
                                m_CMotor.SetCmd_Angle(nAxis, fVal);
                                if (bSock == true) m_CMotor2.Set_Angle(nAxis, fVal);

                                bRed = (Grid_GetFlag_Led(nLine, nAxis) == 1) ? true : false;
                                bBlue = (Grid_GetFlag_Led(nLine, nAxis) == 2) ? true : false;
                                bGreen = (Grid_GetFlag_Led(nLine, nAxis) == 4) ? true : false;
                                m_CMotor.SetCmd_Flag_Led(nAxis, bGreen, bBlue, bRed);
                            }
                            if (bSock == true) m_CMotor2.Set_Flag_Led(nAxis, bGreen, bBlue, bRed);
                            /////////////////////////////////////

                            m_CMotor.SetCmd_Flag_Stop(nAxis, false);

                            // //// 동작 ////
                            if (m_bSimulation == true)
                            {
                                //SetData(nAxis, (float)fVal);
                                if (GetSimulation_With_PlayFrame() == true)
                                {
                                    if (m_bSimulation_Smooth == false)
                                    {
                                        SetData(nAxis, (float)CalcEvd2Angle(nAxis, STable.anMot[nAxis]));
                                    }
                                    SetSimulation_SetNextData(nAxis, (float)CalcEvd2Angle(nAxis, STable.anMot[nAxis]));
                                }
                            }
                        }
                    }
                    //int nSpeedValue = (int)Math.Round((float)fPercent * (float)GridMotionEditor_GetTime(nLine));
                    //int nDelayValue = (int)Math.Round((float)fPercent * (float)GridMotionEditor_GetDelay(nLine));
#if false
                    int nSpeedValue = (int)Math.Round((float)fPercent * (float)GridMotionEditor_GetTime(nLine));
                    int nDelayValue = (int)Math.Round((float)fPercent * (float)GridMotionEditor_GetDelay(nLine));
#else
                    int nSpeedValue = 0;
                    int nDelayValue = 0;
                    if (nLine < 0)
                    {
                        nSpeedValue = (int)Math.Round((float)fPercent * (float)STable.nTime);
                        nDelayValue = (int)Math.Round((float)fPercent * (float)STable.nDelay);
                    }
                    else
                    {
                        nSpeedValue = (int)Math.Round((float)fPercent * (float)GridMotionEditor_GetTime(nLine));
                        nDelayValue = (int)Math.Round((float)fPercent * (float)GridMotionEditor_GetDelay(nLine));
                    }
                    //if (bSock == true) m_CMotor2.Set(nAxis, STable.anMot[nAxis]);
                    //bRed = GetFlag_Led_Red(STable.anLed[nAxis]);
                    //bBlue = GetFlag_Led_Blue(STable.anLed[nAxis]);
                    //bGreen = GetFlag_Led_Green(STable.anLed[nAxis]);
#endif

                    if (GetSimulation_With_PlayFrame() == false)
                    {
                        m_CMotor.SetMot(nSpeedValue);
                        if (bSock == true) m_CMotor2.Send_Motor(nSpeedValue);
                    }

                    int nSync = 0;
                    if (nLine < 0)
                    {
                        nSync = STable.nCmd;
                    }
                    else
                    {
                        nSync = GridMotionEditor_GetCommand(nLine);
                    }
#if false
                    if (GridMotionEditor_GetCommand(nLine) != 2) // if it is not a "sync"
#else
                    if (nSync != 2)
#endif
                    {
                        int nDelay = nSpeedValue + nDelayValue;
                        m_nSimulTime_For_Last = -nDelayValue;// nSpeedValue - nDelay;
                        if (GetSimulation_With_PlayFrame() == true) { SetSimulation_Calc(nSpeedValue, 1.0f); }

                        if (nDelay > 0) WaitAction_ByTimer(nDelay);
                        else
                        {
                            if (GetSimulation_With_PlayFrame() == true)
                            {
                                for (int i = 0; i < m_CHeader.nMotorCnt; i++)
                                    SetData(i, GetSimulation_Value(i));
                                //OjwDraw();
                            }
                        }
                    }

                    if (nLine < 0)
                    {
                        // Sound & Buzz
                        if (GetSimulation_With_PlayFrame() == false) m_CMotor.Mpsu_Play_HeadLed_Buzz(STable.nData4, STable.nData3);
                    }
                    else
                    {
                        // Sound & Buzz
                        if (GetSimulation_With_PlayFrame() == false) m_CMotor.Mpsu_Play_HeadLed_Buzz(GridMotionEditor_GetExtLed(nLine), GridMotionEditor_GetExtBuzz(nLine));
                    }
                    // Sound & Buzz
                    //if (GetSimulation_With_PlayFrame() == false) m_CMotor.Mpsu_Play_HeadLed_Buzz(GridMotionEditor_GetExtLed(nLine), GridMotionEditor_GetExtBuzz(nLine));

                    //frmMain.m_DrBluetooth.drbluetooth_set_id(frmMain.m_pnBluetoothAddress[m_nCurrentRobot]);
                    //frmMain.m_DrBluetooth.drbluetooth_client_serial_mpsu_play_headled_buzz(0xfe, Grid_GetExtLed(nLine), Grid_GetExtBuzz(nLine));
#else
                    if ((m_bStop == false) && (m_bEms == false) && (m_bMotionEnd == false))
                    {
                        bool bSock = m_CMotor2.IsOpen_Socket();
                        if (m_bStart == true)
                        {
#if !_COLOR_GRID_IN_PAINT
                            //GridMotionEditor_SetColorGrid(nLine - 1, 1);
#endif
                            if (nLine >= 0)
                            {
                                if (m_bControl_Tracking)
                                {
                                    if ((GetSimulation_With_PlayFrame() == false) || ((m_bSimulation_Smooth == false) && (GetSimulation_With_PlayFrame() == true))) for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) SetData(nAxis, GridMotionEditor_GetMotor(nLine, nAxis)); // 이거 나중에 실시간으로 하고 싶으면 시작단계에서 미리 계산하도록 수정하도록 한다. - 아직은 생각없음.
                                    m_CGridMotionEditor.GetHandle().CurrentCell = m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[1];
                                }
                            }
                        }

                        if (GetSimulation_With_PlayFrame() == true) { SetSimulation_SetCurrentData(); }
                        
                        float fPercent = 1.0f + (float)nAddSpeedPercent / 100.0f;
                        int nDelayValue = (int)Math.Round((float)fPercent * (float)STable.nDelay);

                        m_CMotor.ResetStop();
                        m_CMotor.DrvSrv(true, true);
                        for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++)
                        {
                            if (
                                //(m_CHeader.pSMotorInfo[nAxis]. == EType_t._0102) || // 엔코더이거나
                                //(m_CHeader.pSMotorInfo[nAxis].nMotorControlType != 0) // 위치제어가 아니라면 //// Motor Control type => 0: Position, 1: Speed type
                                //(m_abEnc[nAxis] == true) || // 엔코더이거나
                                //(Grid_GetFlag_Type(m_nCurrntCell, nAxis) == true) // 위치제어가 아니라면
                                (STable.abType[nAxis] == true) // 위치제어가 아니라면
                                )
                            {
                                // 모드에 따라 계산법이 틀려지기에 모드 셋팅부터 먼저 한다.
                                m_CMotor.SetCmd_Flag_Mode(nAxis, true);//Ojw.CConvert.IntToBool(m_CHeader.pSMotorInfo[nAxis].nMotorControlType));
                                m_CMotor.SetParam_Item_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);
                                                              
                                int nVal = (int)Math.Round((float)fPercent * (float) STable.anMot[nAxis]);
                                
                                if (nVal < 0)
                                {
                                    nVal *= -1;
                                    nVal |= 0x4000;
                                }

                                m_CMotor.SetCmd(nAxis, nVal);

                                m_CMotor.SetCmd_Flag_Led(nAxis,
                                    GetFlag_Led_Green(STable.anLed[nAxis]),
                                    GetFlag_Led_Blue(STable.anLed[nAxis]),
                                    GetFlag_Led_Red(STable.anLed[nAxis])
                                    );
                                m_CMotor.SetCmd_Flag_NoAction(nAxis, !STable.abEn[nAxis]);

                                if ((m_CMotor2.IsOpen_Socket() == true) && (STable.abEn[nAxis] == true))
                                {
                                    m_CMotor2.SetParam_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);
                                    m_CMotor2.Set_Turn(nAxis, nVal);
                                    m_CMotor2.Set_Flag_Led(nAxis,
                                            GetFlag_Led_Green(STable.anLed[nAxis]),
                                            GetFlag_Led_Blue(STable.anLed[nAxis]),
                                            GetFlag_Led_Red(STable.anLed[nAxis])
                                        );
                                }
                                //m_CMotor.SetMot(STable.nTime);
                                
                                if (m_bSimulation == true)
                                {
                                    SetData(nAxis, (float)nVal);
                                }

                                if (GetSimulation_With_PlayFrame() == false)
                                {
                                    int nSpeedValue = (int)Math.Round((float)fPercent * (float)STable.nTime);
                                    m_CMotor.SetMot(nSpeedValue);
                                    if (bSock == true) m_CMotor2.Send_Motor(nSpeedValue);
                                }
                            }
                            else
                            {
                                int nSpeedValue = (int)Math.Round((float)fPercent * (float)STable.nTime);

                                // 모드에 따라 계산법이 틀려지기에 모드 셋팅부터 먼저 한다.
                                m_CMotor.SetCmd_Flag_Mode(nAxis, false);//Ojw.CConvert.IntToBool(m_CHeader.pSMotorInfo[nAxis].nMotorControlType));
                                m_CMotor.SetParam_Item_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);

                                m_CMotor.SetCmd_Flag_NoAction(nAxis, !STable.abEn[nAxis]);

                                m_CMotor.SetCmd(nAxis, STable.anMot[nAxis]);
                                m_CMotor.SetCmd_Flag_Led(nAxis,
                                    GetFlag_Led_Green(STable.anLed[nAxis]),
                                    GetFlag_Led_Blue(STable.anLed[nAxis]),
                                    GetFlag_Led_Red(STable.anLed[nAxis])
                                    );

                                if ((m_CMotor2.IsOpen_Socket() == true) && (STable.abEn[nAxis] == true))
                                {
                                    m_CMotor2.SetParam_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);
                                    m_CMotor2.Set(nAxis, STable.anMot[nAxis]);
                                    m_CMotor2.Set_Flag_Led(nAxis,
                                            GetFlag_Led_Green(STable.anLed[nAxis]),
                                            GetFlag_Led_Blue(STable.anLed[nAxis]),
                                            GetFlag_Led_Red(STable.anLed[nAxis])
                                        );
                                }
                                //m_CMotor.SetMot(nSpeedValue);//STable.nTime);
                                
                                if (m_bSimulation == true)
                                {
                                    //SetData(nAxis, (float)fVal);
                                    if (GetSimulation_With_PlayFrame() == true)
                                    {
                                        if (m_bSimulation_Smooth == false)
                                        {
                                            SetData(nAxis, (float)nSpeedValue);
                                        }
                                        SetSimulation_SetNextData(nAxis, nSpeedValue);
                                    }
                                }

                                if (GetSimulation_With_PlayFrame() == false)
                                {
                                    m_CMotor.SetMot(nSpeedValue);
                                    if (bSock == true) m_CMotor2.Send_Motor(nSpeedValue);
                                }
                            }
                        }


                        //if (GetSimulation_With_PlayFrame() == false)
                        //{
                        //    int nSpeedValue = (int)Math.Round((float)fPercent * (float)STable.nTime);
                        //    m_CMotor.SetMot(nSpeedValue);
                        //    if (bSock == true) m_CMotor2.Send_Motor(nSpeedValue);
                        //}
                        if (nLine >= 0)
                        {
                            if (GridMotionEditor_GetCommand(nLine) != 2) // if it is not a "sync"
                            {
                                int nSpeedValue = (int)Math.Round((float)fPercent * (float)STable.nTime);
                                int nDelay = nSpeedValue + nDelayValue;
                                m_nSimulTime_For_Last = -nDelayValue;// nSpeedValue - nDelay;
                                if (GetSimulation_With_PlayFrame() == true) { SetSimulation_Calc(nSpeedValue, 1.0f); }

                                if (nDelay > 0) WaitAction_ByTimer(nDelay);
                                else
                                {
                                    if (GetSimulation_With_PlayFrame() == true)
                                    {
                                        for (int i = 0; i < m_CHeader.nMotorCnt; i++)
                                            SetData(i, GetSimulation_Value(i));
                                        //OjwDraw();
                                    }
                                }
                            }
                        }
                        // Sound & Buzz
                        if (GetSimulation_With_PlayFrame() == false) m_CMotor.Mpsu_Play_HeadLed_Buzz(STable.nData4, STable.nData3);
                    }
#endif
#endif
#endregion Herkulex
                }
                private bool m_bFirstMoving = true;
                public void SetFirstMoving(bool bFirstmoving) { m_bFirstMoving = bFirstmoving; }
                public void PlayFrame_Dynamixel(int nLine) { PlayFrame_Dynamixel(nLine, LineToMotionTable(nLine), false, 0); }
                public void PlayFrame_Dynamixel(int nLine, int nAddSpeedPercent) { PlayFrame_Dynamixel(nLine, LineToMotionTable(nLine), false, nAddSpeedPercent); }
                public void PlayFrame_Dynamixel(SMotionTable_t STable, bool b3D_Display, int nAddSpeedPercent) { PlayFrame_Dynamixel(-1, STable, b3D_Display, nAddSpeedPercent); }
                public void PlayFrame_Dynamixel(int nLine, SMotionTable_t STable, bool b3D_Display, int nAddSpeedPercent) { PlayFrame_Dynamixel(m_bFirstMoving, nLine, STable, b3D_Display, nAddSpeedPercent); }
                public void PlayFrame_Dynamixel(bool bGetPos, int nLine, SMotionTable_t STable, bool b3D_Display, int nAddSpeedPercent) // 100% + nAddSpeedPercent
                {
                    if (m_bFirstMoving == true)
                    {
                        bGetPos = true;
                        m_bFirstMoving = false; // 어찌 되었던 함수 실행하면 변수 클리어 시킨다. bGetPos 만 가지고 확인
                    }
                    #region Dynamixel
#if false
                    bool bSock = m_CMotor2.IsOpen_Socket();
                    CGridView OjwGrid = m_CGridMotionEditor;
                    //int nRow = OjwGrid.m_nCurrntCell;
                    if (m_bStart == true)
                    {
#if !_COLOR_GRID_IN_PAINT
                        //GridMotionEditor_SetColorGrid(nLine - 1, 1);
#endif
                        if (m_bControl_Tracking)
                        {
                            if ((GetSimulation_With_PlayFrame() == false) || ((m_bSimulation_Smooth == false) && (GetSimulation_With_PlayFrame() == true))) for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) SetData(nAxis, GridMotionEditor_GetMotor(nLine, nAxis)); // 이거 나중에 실시간으로 하고 싶으면 시작단계에서 미리 계산하도록 수정하도록 한다. - 아직은 생각없음.
                            m_CGridMotionEditor.GetHandle().CurrentCell = m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[1];
                        }
                    }

                    float fPercent = 1.0f + (float)nAddSpeedPercent / 100.0f;

                    float fVal;
                    bool bRed, bBlue, bGreen;

                    if (GetSimulation_With_PlayFrame() == true) { SetSimulation_SetCurrentData(); }

                    for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++)
                    {
                        if (
                            //(m_abEnc[nAxis] == true) || // 엔코더이거나
                            //(m_CHeader.pSMotorInfo[nAxis].nMotorControlType != 0) // 위치제어가 아니라면 //// Motor Control type => 0: Position, 1: Speed type
                            (Grid_GetFlag_Type(nLine, nAxis) == true) // 위치제어가 아니라면
                            //((m_CMotor.GetCmd_Flag_Mode(nAxis) != 0) && (m_CMotor.GetCmd_Flag_Mode(nAxis) != 2)) // 위치제어가 아니라면
                            )//((nAxis >= 6) && (nAxis <= 8)) ojw5014 20120417
                        {
                            //// 동작 ////
                            // 모드에 따라 계산법이 틀려지기에 모드 셋팅부터 먼저 한다.
                            m_CMotor.SetCmd_Flag_Mode(nAxis, true);//Ojw.CConvert.IntToBool(m_CHeader.pSMotorInfo[nAxis].nMotorControlType));
                            m_CMotor.SetParam_Item_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);
                            //if (CheckWifi() == true)
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_mode(nAxis, Grid_GetFlag_Type(nLine, nAxis));
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_mode(nAxis, Grid_GetFlag_Type(nLine, nAxis));
                            if (bSock == true) m_CMotor2.SetParam_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);

                            float fTmpVal = (float)Math.Round(Convert.ToSingle(OjwGrid.GetData(nLine, nAxis)));
                            int nVal = CalcAngle2Evd(nAxis, fTmpVal);

                            //int nVal = (int)Math.Round(GridMotionEditor_GetMotor(nLine, nAxis));
                            if (bSock == true) m_CMotor2.Set_Turn(nAxis, nVal);
                            if (nVal < 0)
                            {
                                nVal *= -1;
                                nVal |= 0x4000;
                            }
                            m_CMotor.SetCmd(nAxis, nVal);
                            //if (CheckWifi() == true)
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd(nAxis, nVal);
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd(nAxis, nVal);

                            bRed = (Grid_GetFlag_Led(nLine, nAxis) == 1) ? true : false;
                            bBlue = (Grid_GetFlag_Led(nLine, nAxis) == 2) ? true : false;
                            bGreen = (Grid_GetFlag_Led(nLine, nAxis) == 4) ? true : false;
                            m_CMotor.SetCmd_Flag_Led(nAxis, bGreen, bBlue, bRed);




                            //////// 여기 함수 다시 한번 체크해라.



                            if (bSock == true)
                            {
                                m_CMotor2.Set_Flag_Led(nAxis, bGreen, bBlue, bRed);
                                if (fTmpVal == 0) m_CMotor2.Set_Flag_Stop(nAxis, true);
                                else m_CMotor2.Set_Flag_Stop(nAxis, false);
                            }
                            if (fTmpVal == 0) m_CMotor.SetCmd_Flag_Stop(nAxis, true);
                            else m_CMotor.SetCmd_Flag_Stop(nAxis, false);
                            //m_CMotor.SetCmd_Flag_Led(nAxis, bGreen, bBlue, bRed);                            
#if false
                            //m_CMotor.SetCmd_Flag_NoAction(nAxis, !Grid_GetFlag_En(nLine, nAxis));
                    
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_request_stop();
                            //if (fTmpVal == 0) frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_stop(nAxis, true);
                            //else frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_stop(nAxis, false);
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_led(nAxis, bGreen, bBlue, bRed);
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_no_action(nAxis, !Grid_GetFlag_En(nLine, nAxis));

                            ///////////
                            
                            //if (CheckWifi() == true)
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd(nAxis, nVal);

                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd(nAxis, nVal);

                            
                            //m_CMotor.SetCmd_Flag_NoAction(nAxis, true);//!Grid_GetFlag_En(m_nCurrntCell, nAxis));
                            //if (CheckWifi() == true)
                            //{
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_led(nAxis, bGreen, bBlue, bRed);
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_no_action(nAxis, !Grid_GetFlag_En(m_nCurrntCell, nAxis));
                            //}

                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_led(nAxis, bGreen, bBlue, bRed);
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_no_action(nAxis, !Grid_GetFlag_En(m_nCurrntCell, nAxis));
#endif
                            if (m_bSimulation == true)
                            {
                                SetData(nAxis, (float)nVal);
                            }
                        }
                        else
                        {
                            // 모드에 따라 계산법이 틀려지기에 모드 셋팅부터 먼저 한다.
                            m_CMotor.SetCmd_Flag_Mode(nAxis, Ojw.CConvert.IntToBool(m_CHeader.pSMotorInfo[nAxis].nMotorControlType));
                            m_CMotor.SetParam_Item_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);

                            if (bSock == true) m_CMotor2.SetParam_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);

                            fVal = (float)Math.Round((float)OjwGrid.Get(nLine, nAxis)); //GridMotionEditor_GetMotor(m_nCurrntCell, nAxis);
                            m_CMotor.SetCmd_Angle(nAxis, fVal);
                            if (bSock == true) m_CMotor2.Set_Angle(nAxis, fVal);

                            bRed = (Grid_GetFlag_Led(nLine, nAxis) == 1) ? true : false;
                            bBlue = (Grid_GetFlag_Led(nLine, nAxis) == 2) ? true : false;
                            bGreen = (Grid_GetFlag_Led(nLine, nAxis) == 4) ? true : false;
                            m_CMotor.SetCmd_Flag_Led(nAxis, bGreen, bBlue, bRed);
                            if (bSock == true) m_CMotor2.Set_Flag_Led(nAxis, bGreen, bBlue, bRed);
                            /////////////////////////////////////

                            m_CMotor.SetCmd_Flag_Stop(nAxis, false);

                            // //// 동작 ////
                            // // 모드에 따라 계산법이 틀려지기에 모드 셋팅부터 먼저 한다.
                            // //m_CMotor.SetCmd_Flag_Mode(nAxis, Ojw.CConvert.IntToBool(m_CHeader.pSMotorInfo[nAxis].nMotorControlType));
                            //// m_CMotor.SetParam_Item_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir); // 굳이 안넣어도 된다. 이젠... 그냥 잊어버릴까봐 불필요 코드 집어넣은 정도...

                            // //m_CMotor.SetCmd_Flag_Mode(nAxis, Grid_GetFlag_Type(nLine, nAxis));
                            // //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_mode(nAxis, Grid_GetFlag_Type(nLine, nAxis));

                            // fVal = (float)Math.Round((float)OjwGrid.Get(nLine, nAxis)); //fVal = GridMotionEditor_GetMotor(nLine, nAxis);
                            // m_CMotor.SetCmd_Angle(nAxis, fVal);
                            // //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_angle(nAxis, fVal);

                            // bRed = (Grid_GetFlag_Led(nLine, nAxis) == 1) ? true : false;
                            // bBlue = (Grid_GetFlag_Led(nLine, nAxis) == 2) ? true : false;
                            // bGreen = (Grid_GetFlag_Led(nLine, nAxis) == 4) ? true : false;
                            // m_CMotor.SetCmd_Flag_Led(nAxis, bGreen, bBlue, bRed);

                            // m_CMotor.SetCmd_Flag_Stop(nAxis, false);

                            //m_CMotor.SetCmd_Flag_NoAction(nAxis, !GridMotionEditor_GetFlag_En(nLine, nAxis));
                            //if (CheckWifi() == true)
                            //{
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_stop(nAxis, false);
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_led(nAxis, bGreen, bBlue, bRed);
                            //    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_no_action(nAxis, !Grid_GetFlag_En(nLine, nAxis));
                            //}
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_stop(nAxis, false);
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_led(nAxis, bGreen, bBlue, bRed);
                            //frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_no_action(nAxis, !GridMotionEditor_GetFlag_En(nLine, nAxis));
                            if (m_bSimulation == true)
                            {
                                //SetData(nAxis, (float)fVal);
                                if (GetSimulation_With_PlayFrame() == true)
                                {
                                    if (m_bSimulation_Smooth == false)
                                    {
                                        SetData(nAxis, (float)fVal);
                                    }
                                    SetSimulation_SetNextData(nAxis, fVal);
                                }
                            }
                        }
                    }
                    int nSpeedValue = (int)Math.Round((float)fPercent * (float)GridMotionEditor_GetTime(nLine));
                    int nDelayValue = (int)Math.Round((float)fPercent * (float)GridMotionEditor_GetDelay(nLine));

                    if (GetSimulation_With_PlayFrame() == false)
                    {
                        m_CMotor.SetMot(nSpeedValue);
                        if (bSock == true) m_CMotor2.Send_Motor(nSpeedValue);
                    }
                    
                    if (GridMotionEditor_GetCommand(nLine) != 2) // if it is not a "sync"
                    {
                        int nDelay = nSpeedValue + nDelayValue;
                        m_nSimulTime_For_Last = -nDelayValue;// nSpeedValue - nDelay;
                        if (GetSimulation_With_PlayFrame() == true) { SetSimulation_Calc(nSpeedValue, 1.0f); }

                        if (nDelay > 0) WaitAction_ByTimer(nDelay);
                        else
                        {
                            if (GetSimulation_With_PlayFrame() == true)
                            {
                                for (int i = 0; i < m_CHeader.nMotorCnt; i++)
                                    SetData(i, GetSimulation_Value(i));
                                //OjwDraw();
                            }
                        }
                    }

                    // Sound & Buzz
                    if (GetSimulation_With_PlayFrame() == false) m_CMotor.Mpsu_Play_HeadLed_Buzz(GridMotionEditor_GetExtLed(nLine), GridMotionEditor_GetExtBuzz(nLine));
#else
                    CGridView OjwGrid = m_CGridMotionEditor;
                    if (m_bStart == true)
                    {
#if !_COLOR_GRID_IN_PAINT
                        if (nLine >= 0)
                        {
                            if (m_bControl_Tracking)
                            {
                                if ((GetSimulation_With_PlayFrame() == false) || ((m_bSimulation_Smooth == false) && (GetSimulation_With_PlayFrame() == true))) for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++)
                                        SetData(nAxis, GridMotionEditor_GetMotor(nLine, nAxis)); // 이거 나중에 실시간으로 하고 싶으면 시작단계에서 미리 계산하도록 수정하도록 한다. - 아직은 생각없음.
                                m_CGridMotionEditor.GetHandle().CurrentCell = m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[1];
                            }
                        }
                    }

                    float fPercent = 1.0f + (float)nAddSpeedPercent / 100.0f;

                    float fVal;
                    bool bRed, bBlue, bGreen;

                    if (GetSimulation_With_PlayFrame() == true) { SetSimulation_SetCurrentData(); }

#if false
                    int nSpeedValue = (int)Math.Round((float)fPercent * (float)GridMotionEditor_GetTime(nLine));
                    int nDelayValue = (int)Math.Round((float)fPercent * (float)GridMotionEditor_GetDelay(nLine));
#else
                    int nSpeedValue = 0;
                    int nDelayValue = 0;
                    if (nLine < 0)
                    {
                        nSpeedValue = (int)Math.Round((float)fPercent * (float)STable.nTime);
                        nDelayValue = (int)Math.Round((float)fPercent * (float)STable.nDelay);
                    }
                    else
                    {
                        nSpeedValue = (int)Math.Round((float)fPercent * (float)GridMotionEditor_GetTime(nLine));
                        nDelayValue = (int)Math.Round((float)fPercent * (float)GridMotionEditor_GetDelay(nLine));
                    }
#endif

                    if (bGetPos == true)
                    {
#if !_CHEKING_AUTO_FOR_DYNAMIXEL
                        Ojw.CTimer CTmr = new CTimer();                        
                        List<byte> lstError = new List<byte>();
                        lstError.Clear();
                        // 다이나믹셀은 0번 아이디를 잘 사용 안한다.
                        for (int i = 1; i < m_CHeader.nMotorCnt; i++)
                        {                            
#if !_MONSTER_LIB
                            m_CRobotis.Read_Motor(i);
                            CTmr.Set(); 
                            while (true)
                            {
                                if (m_CRobotis.Read_Motor_IsReceived() == true) break;
                                if (CTmr.Get() > 50)
                                {
                                    break;
                                }
                            }
                            m_CRobotis.m_SMotion_Pos.anMot[i] = m_CRobotis.Get_Pos_Evd(i);
#else
                            m_CMonster.Read_Pos(i);
#endif
                        }
#else
                        for (int i = 0; i < _SIZE_MAX_MOT; i++)
                        {
                            m_CRobotis.m_SMotion_Pos.anMot[i] = m_CRobotis.Get_Pos_Evd(i);
                        }
#endif
                    }

                    for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++)
                    {
#region Speed Type
                        if (
                            ((nLine < 0) ? (STable.abType[nAxis] == true) : (Grid_GetFlag_Type(nLine, nAxis) == true)) // 위치제어가 아니라면
                            )//((nAxis >= 6) && (nAxis <= 8)) ojw5014 20120417
                        {
                            ////////////// 동작 ////
                            //////////// 모드에 따라 계산법이 틀려지기에 모드 셋팅부터 먼저 한다.
                            //////////m_CMotor.SetCmd_Flag_Mode(nAxis, true);//Ojw.CConvert.IntToBool(m_CHeader.pSMotorInfo[nAxis].nMotorControlType));
                            //////////m_CMotor.SetParam_Item_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);
                            ////////////if (CheckWifi() == true)
                            ////////////    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd_flag_mode(nAxis, Grid_GetFlag_Type(nLine, nAxis));
                            ////////////frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd_flag_mode(nAxis, Grid_GetFlag_Type(nLine, nAxis));
                            //////////if (bSock == true) m_CMotor2.SetParam_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);

                            //////////float fTmpVal = (float)Math.Round(Convert.ToSingle(
                            //////////    ((nLine < 0) ? STable.anMot[nAxis] : OjwGrid.GetData(nLine, nAxis))
                            //////////    ));
                            //////////int nVal = CalcAngle2Evd(nAxis, fTmpVal);

                            ////////////int nVal = (int)Math.Round(GridMotionEditor_GetMotor(nLine, nAxis));
                            //////////if (bSock == true) m_CMotor2.Set_Turn(nAxis, nVal);
                            //////////if (nVal < 0)
                            //////////{
                            //////////    nVal *= -1;
                            //////////    nVal |= 0x4000;
                            //////////}
                            //////////m_CMotor.SetCmd(nAxis, nVal);
                            ////////////if (CheckWifi() == true)
                            ////////////    m_aDrSock[m_nCurrentRobot].drsock_client_serial_motor_set_cmd(nAxis, nVal);
                            ////////////frmMain.m_DrBluetooth.drbluetooth_client_serial_motor_set_cmd(nAxis, nVal);

                            //////////if (nLine < 0)
                            //////////{
                            //////////    bRed = GetFlag_Led_Red(STable.anLed[nAxis]);//(nLine, nAxis) == 1) ? true : false;
                            //////////    bBlue = GetFlag_Led_Blue(STable.anLed[nAxis]); //(Grid_GetFlag_Led(nLine, nAxis) == 2) ? true : false;
                            //////////    bGreen = GetFlag_Led_Green(STable.anLed[nAxis]); //(Grid_GetFlag_Led(nLine, nAxis) == 4) ? true : false;
                            //////////}
                            //////////else
                            //////////{
                            //////////    bRed = (Grid_GetFlag_Led(nLine, nAxis) == 1) ? true : false;
                            //////////    bBlue = (Grid_GetFlag_Led(nLine, nAxis) == 2) ? true : false;
                            //////////    bGreen = (Grid_GetFlag_Led(nLine, nAxis) == 4) ? true : false;
                            //////////}
                            //////////m_CMotor.SetCmd_Flag_Led(nAxis, bGreen, bBlue, bRed);

                            //////////if (bSock == true)
                            //////////{
                            //////////    m_CMotor2.Set_Flag_Led(nAxis, bGreen, bBlue, bRed);
                            //////////    if (fTmpVal == 0) m_CMotor2.Set_Flag_Stop(nAxis, true);
                            //////////    else m_CMotor2.Set_Flag_Stop(nAxis, false);
                            //////////}
                            //////////if (fTmpVal == 0) m_CMotor.SetCmd_Flag_Stop(nAxis, true);
                            //////////else m_CMotor.SetCmd_Flag_Stop(nAxis, false);
                            ////////////m_CMotor.SetCmd_Flag_Led(nAxis, bGreen, bBlue, bRed);                            

                            //////////if (m_bSimulation == true)
                            //////////{
                            //////////    SetData(nAxis, (float)nVal);
                            //////////}
                        }
#endregion Speed Type
#region Position Type
                        else
                        {                  
                            // previous   : m_SMotion_Pos.anMot[nAxis]
                            // target pos : STable.anMot[nAxis]

                            //float fRpm = (float)nSpeedValue;
                            float fRpm = 0;//m_CRobotis.CalcTime(
#if !_MONSTER_LIB                            
                            m_CRobotis.Set_Flag_Mode(nAxis, 0);//Ojw.CConvert.IntToBool(m_CHeader.pSMotorInfo[nAxis].nMotorControlType));
                            m_CRobotis.SetParam_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);
                            
                            //if (bSock == true) m_CMotor2.SetParam_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);
                            if (nLine < 0)
                            {
                                fRpm = (float)Math.Abs(m_CRobotis.CalcTime2Rpm(m_CRobotis.CalcRaw2Rpm(nAxis, STable.anMot[nAxis] - m_CRobotis.m_SMotion_Pos.anMot[nAxis]), (float)nSpeedValue));
                                m_CRobotis.Set(nAxis, STable.anMot[nAxis], fRpm);
                                //if (bSock == true) m_CRobotis.Set(nAxis, STable.anMot[nAxis]);
                                bRed = GetFlag_Led_Red(STable.anLed[nAxis]);
                                bBlue = GetFlag_Led_Blue(STable.anLed[nAxis]);
                                bGreen = GetFlag_Led_Green(STable.anLed[nAxis]);
                            }
                            else
                            {
                                fRpm = (float)Math.Abs(m_CRobotis.CalcTime2Rpm(OjwGrid.Get(nLine, nAxis) - m_CRobotis.CalcEvd2Angle(nAxis, m_CRobotis.m_SMotion_Pos.anMot[nAxis]), (float)nSpeedValue));
                                fVal = (float)Math.Round((float)OjwGrid.Get(nLine, nAxis)); //GridMotionEditor_GetMotor(m_nCurrntCell, nAxis);
                                m_CRobotis.Set_Angle(nAxis, fVal, fRpm);
                                //if (bSock == true) m_CRobotis.Set_Angle(nAxis, fVal);

                                bRed = (Grid_GetFlag_Led(nLine, nAxis) == 1) ? true : false;
                                bBlue = (Grid_GetFlag_Led(nLine, nAxis) == 2) ? true : false;
                                bGreen = (Grid_GetFlag_Led(nLine, nAxis) == 4) ? true : false;
                                //m_CRobotis.Set_Flag_Led(nAxis, bGreen, bBlue, bRed);
                            }
                            //Ojw.CMessage.Write("Rpm = {0}, aMot[{1}]:{2}, Curr:{3}", fRpm, nAxis, CalcEvd2Angle(nAxis, m_SMotion_Pos.anMot[nAxis]), OjwGrid.Get(nLine, nAxis));
                            
                            // save previous motion
                            if ((nDelayValue < 0) && (nSpeedValue > 0))
                            {
                                // -Delay 의 % 를 감안해서 빼 줌
                                m_CRobotis.m_SMotion_Pos.anMot[nAxis] = m_CRobotis.Get(nAxis) - (int)Math.Round((m_CRobotis.Get(nAxis) - m_CRobotis.m_SMotion_Pos.anMot[nAxis]) * ((float)nDelayValue / (float)nSpeedValue));
                            }
                            else
                                m_CRobotis.m_SMotion_Pos.anMot[nAxis] = m_CRobotis.Get(nAxis);
                            //if (bSock == true) m_CMotor2.Set_Flag_Led(nAxis, bGreen, bBlue, bRed);
                            /////////////////////////////////////
                            // //// 동작 ////
                            if (m_bSimulation == true)
                            {
                                if (GetSimulation_With_PlayFrame() == true)
                                {
                                    if (m_bSimulation_Smooth == false)
                                    {
                                        SetData(nAxis, (float)CalcEvd2Angle(nAxis, STable.anMot[nAxis]));
                                    }
                                    SetSimulation_SetNextData(nAxis, (float)CalcEvd2Angle(nAxis, STable.anMot[nAxis]));
                                }
                            }
#else
                            m_CMonster.SetParam_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);

                            //if (bSock == true) m_CMotor2.SetParam_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);
                            if (nLine < 0)
                            {
                                fRpm = (float)Math.Abs(m_CMonster.CalcTime2Rpm(m_CMonster.CalcRaw2Rpm(nAxis, STable.anMot[nAxis] - m_CMonster.m_SMotion_Pos.anMot[nAxis]), (float)nSpeedValue));
                                m_CMonster.Set(nAxis, STable.anMot[nAxis], fRpm);
                                //if (bSock == true) m_CMonster.Set(nAxis, STable.anMot[nAxis]);
                                bRed = GetFlag_Led_Red(STable.anLed[nAxis]);
                                bBlue = GetFlag_Led_Blue(STable.anLed[nAxis]);
                                bGreen = GetFlag_Led_Green(STable.anLed[nAxis]);
                            }
                            else
                            {
                                fRpm = (float)Math.Abs(m_CMonster.CalcTime2Rpm(OjwGrid.Get(nLine, nAxis) - m_CMonster.CalcEvd2Angle(nAxis, m_CMonster.m_SMotion_Pos.anMot[nAxis]), (float)nSpeedValue));
                                fVal = (float)Math.Round((float)OjwGrid.Get(nLine, nAxis)); //GridMotionEditor_GetMotor(m_nCurrntCell, nAxis);
                                m_CMonster.Set(nAxis, fVal, fRpm);
                                //if (bSock == true) m_CMonster.Set_Angle(nAxis, fVal);

                                bRed = (Grid_GetFlag_Led(nLine, nAxis) == 1) ? true : false;
                                bBlue = (Grid_GetFlag_Led(nLine, nAxis) == 2) ? true : false;
                                bGreen = (Grid_GetFlag_Led(nLine, nAxis) == 4) ? true : false;
                                //m_CMonster.Set_Flag_Led(nAxis, bGreen, bBlue, bRed);
                            }
                            //Ojw.CMessage.Write("Rpm = {0}, aMot[{1}]:{2}, Curr:{3}", fRpm, nAxis, CalcEvd2Angle(nAxis, m_SMotion_Pos.anMot[nAxis]), OjwGrid.Get(nLine, nAxis));

                            // save previous motion
                            if ((nDelayValue < 0) && (nSpeedValue > 0))
                            {
                                // -Delay 의 % 를 감안해서 빼 줌
                                m_CMonster.Set(nAxis, m_CMonster.Get(nAxis) - (int)Math.Round((m_CMonster.Get(nAxis) - m_CMonster.Get(nAxis)) * ((float)nDelayValue / (float)nSpeedValue)));
                            }
                            else
                                m_CMonster..anMot[nAxis] = m_CMonster.Get(nAxis);
                            //if (bSock == true) m_CMotor2.Set_Flag_Led(nAxis, bGreen, bBlue, bRed);
                            /////////////////////////////////////
                            // //// 동작 ////
                            if (m_bSimulation == true)
                            {
                                if (GetSimulation_With_PlayFrame() == true)
                                {
                                    if (m_bSimulation_Smooth == false)
                                    {
                                        SetData(nAxis, (float)CalcEvd2Angle(nAxis, STable.anMot[nAxis]));
                                    }
                                    SetSimulation_SetNextData(nAxis, (float)CalcEvd2Angle(nAxis, STable.anMot[nAxis]));
                                }
                            }
#endif

                            
                        }
#endregion Position Type
                    }

                    if (GetSimulation_With_PlayFrame() == false)
                    {
#if !_MONSTER_LIB
                        m_CRobotis.Send_Motor();
#else
                        m_CMonster.Send_Motor();
#endif
                        //if (bSock == true) m_CMotor2.Send_Motor(nSpeedValue);
                    }

                    int nSync = 0;
                    if (nLine < 0)
                    {
                        nSync = STable.nCmd;
                    }
                    else
                    {
                        nSync = GridMotionEditor_GetCommand(nLine);
                    }
#if false
                    if (GridMotionEditor_GetCommand(nLine) != 2) // if it is not a "sync"
#else
                    if (nSync != 2)
#endif
                    {
                        int nDelay = nSpeedValue + nDelayValue;
                        m_nSimulTime_For_Last = -nDelayValue;// nSpeedValue - nDelay;
                        if (GetSimulation_With_PlayFrame() == true) { SetSimulation_Calc(nSpeedValue, 1.0f); }

                        if (nDelay > 0) WaitAction_ByTimer(nDelay);
                        else
                        {
                            if (GetSimulation_With_PlayFrame() == true)
                            {
                                for (int i = 0; i < m_CHeader.nMotorCnt; i++)
                                    SetData(i, GetSimulation_Value(i));
                                //OjwDraw();
                            }
                        }
                    }

                    // Sound & Buzz
                    //if (GetSimulation_With_PlayFrame() == false) m_CMotor.Mpsu_Play_HeadLed_Buzz(GridMotionEditor_GetExtLed(nLine), GridMotionEditor_GetExtBuzz(nLine));

#else
                    if ((m_bStop == false) && (m_bEms == false) && (m_bMotionEnd == false))
                    {
                        bool bSock = m_CMotor2.IsOpen_Socket();
                        if (m_bStart == true)
                        {
#if !_COLOR_GRID_IN_PAINT
                            //GridMotionEditor_SetColorGrid(nLine - 1, 1);
#endif
                            if (nLine >= 0)
                            {
                                if (m_bControl_Tracking)
                                {
                                    if ((GetSimulation_With_PlayFrame() == false) || ((m_bSimulation_Smooth == false) && (GetSimulation_With_PlayFrame() == true))) for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++) SetData(nAxis, GridMotionEditor_GetMotor(nLine, nAxis)); // 이거 나중에 실시간으로 하고 싶으면 시작단계에서 미리 계산하도록 수정하도록 한다. - 아직은 생각없음.
                                    m_CGridMotionEditor.GetHandle().CurrentCell = m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[1];
                                }
                            }
                        }

                        if (GetSimulation_With_PlayFrame() == true) { SetSimulation_SetCurrentData(); }
                        
                        float fPercent = 1.0f + (float)nAddSpeedPercent / 100.0f;
                        int nDelayValue = (int)Math.Round((float)fPercent * (float)STable.nDelay);

                        m_CMotor.ResetStop();
                        m_CMotor.DrvSrv(true, true);
                        for (int nAxis = 0; nAxis < m_CHeader.nMotorCnt; nAxis++)
                        {
                            if (
                                //(m_CHeader.pSMotorInfo[nAxis]. == EType_t._0102) || // 엔코더이거나
                                //(m_CHeader.pSMotorInfo[nAxis].nMotorControlType != 0) // 위치제어가 아니라면 //// Motor Control type => 0: Position, 1: Speed type
                                //(m_abEnc[nAxis] == true) || // 엔코더이거나
                                //(Grid_GetFlag_Type(m_nCurrntCell, nAxis) == true) // 위치제어가 아니라면
                                (STable.abType[nAxis] == true) // 위치제어가 아니라면
                                )
                            {
                                // 모드에 따라 계산법이 틀려지기에 모드 셋팅부터 먼저 한다.
                                m_CMotor.SetCmd_Flag_Mode(nAxis, true);//Ojw.CConvert.IntToBool(m_CHeader.pSMotorInfo[nAxis].nMotorControlType));
                                m_CMotor.SetParam_Item_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);
                                                              
                                int nVal = (int)Math.Round((float)fPercent * (float) STable.anMot[nAxis]);
                                
                                if (nVal < 0)
                                {
                                    nVal *= -1;
                                    nVal |= 0x4000;
                                }

                                m_CMotor.SetCmd(nAxis, nVal);

                                m_CMotor.SetCmd_Flag_Led(nAxis,
                                    GetFlag_Led_Green(STable.anLed[nAxis]),
                                    GetFlag_Led_Blue(STable.anLed[nAxis]),
                                    GetFlag_Led_Red(STable.anLed[nAxis])
                                    );
                                m_CMotor.SetCmd_Flag_NoAction(nAxis, !STable.abEn[nAxis]);

                                if ((m_CMotor2.IsOpen_Socket() == true) && (STable.abEn[nAxis] == true))
                                {
                                    m_CMotor2.SetParam_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);
                                    m_CMotor2.Set_Turn(nAxis, nVal);
                                    m_CMotor2.Set_Flag_Led(nAxis,
                                            GetFlag_Led_Green(STable.anLed[nAxis]),
                                            GetFlag_Led_Blue(STable.anLed[nAxis]),
                                            GetFlag_Led_Red(STable.anLed[nAxis])
                                        );
                                }
                                //m_CMotor.SetMot(STable.nTime);
                                
                                if (m_bSimulation == true)
                                {
                                    SetData(nAxis, (float)nVal);
                                }

                                if (GetSimulation_With_PlayFrame() == false)
                                {
                                    int nSpeedValue = (int)Math.Round((float)fPercent * (float)STable.nTime);
                                    m_CMotor.SetMot(nSpeedValue);
                                    if (bSock == true) m_CMotor2.Send_Motor(nSpeedValue);
                                }
                            }
                            else
                            {
                                int nSpeedValue = (int)Math.Round((float)fPercent * (float)STable.nTime);

                                // 모드에 따라 계산법이 틀려지기에 모드 셋팅부터 먼저 한다.
                                m_CMotor.SetCmd_Flag_Mode(nAxis, false);//Ojw.CConvert.IntToBool(m_CHeader.pSMotorInfo[nAxis].nMotorControlType));
                                m_CMotor.SetParam_Item_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);

                                m_CMotor.SetCmd_Flag_NoAction(nAxis, !STable.abEn[nAxis]);

                                m_CMotor.SetCmd(nAxis, STable.anMot[nAxis]);
                                m_CMotor.SetCmd_Flag_Led(nAxis,
                                    GetFlag_Led_Green(STable.anLed[nAxis]),
                                    GetFlag_Led_Blue(STable.anLed[nAxis]),
                                    GetFlag_Led_Red(STable.anLed[nAxis])
                                    );

                                if ((m_CMotor2.IsOpen_Socket() == true) && (STable.abEn[nAxis] == true))
                                {
                                    m_CMotor2.SetParam_Dir(nAxis, m_CHeader.pSMotorInfo[nAxis].nMotorDir);
                                    m_CMotor2.Set(nAxis, STable.anMot[nAxis]);
                                    m_CMotor2.Set_Flag_Led(nAxis,
                                            GetFlag_Led_Green(STable.anLed[nAxis]),
                                            GetFlag_Led_Blue(STable.anLed[nAxis]),
                                            GetFlag_Led_Red(STable.anLed[nAxis])
                                        );
                                }
                                //m_CMotor.SetMot(nSpeedValue);//STable.nTime);
                                
                                if (m_bSimulation == true)
                                {
                                    //SetData(nAxis, (float)fVal);
                                    if (GetSimulation_With_PlayFrame() == true)
                                    {
                                        if (m_bSimulation_Smooth == false)
                                        {
                                            SetData(nAxis, (float)nSpeedValue);
                                        }
                                        SetSimulation_SetNextData(nAxis, nSpeedValue);
                                    }
                                }

                                if (GetSimulation_With_PlayFrame() == false)
                                {
                                    m_CMotor.SetMot(nSpeedValue);
                                    if (bSock == true) m_CMotor2.Send_Motor(nSpeedValue);
                                }
                            }
                        }


                        //if (GetSimulation_With_PlayFrame() == false)
                        //{
                        //    int nSpeedValue = (int)Math.Round((float)fPercent * (float)STable.nTime);
                        //    m_CMotor.SetMot(nSpeedValue);
                        //    if (bSock == true) m_CMotor2.Send_Motor(nSpeedValue);
                        //}
                        if (nLine >= 0)
                        {
                            if (GridMotionEditor_GetCommand(nLine) != 2) // if it is not a "sync"
                            {
                                int nSpeedValue = (int)Math.Round((float)fPercent * (float)STable.nTime);
                                int nDelay = nSpeedValue + nDelayValue;
                                m_nSimulTime_For_Last = -nDelayValue;// nSpeedValue - nDelay;
                                if (GetSimulation_With_PlayFrame() == true) { SetSimulation_Calc(nSpeedValue, 1.0f); }

                                if (nDelay > 0) WaitAction_ByTimer(nDelay);
                                else
                                {
                                    if (GetSimulation_With_PlayFrame() == true)
                                    {
                                        for (int i = 0; i < m_CHeader.nMotorCnt; i++)
                                            SetData(i, GetSimulation_Value(i));
                                        //OjwDraw();
                                    }
                                }
                            }
                        }
                        // Sound & Buzz
                        if (GetSimulation_With_PlayFrame() == false) m_CMotor.Mpsu_Play_HeadLed_Buzz(STable.nData4, STable.nData3);
                    }
#endif
#endif
                    #endregion Dynamixel
                }

                public bool GetFlag_En(int nFlag) { return (((nFlag & 0x10) != 0) ? true : false); }
                public bool GetFlag_Type(int nFlag) { return (((nFlag & 0x08) != 0) ? true : false); }
                public int GetFlag_Led(int nFlag) { return nFlag & 0x07; }
                public bool GetFlag_Led_Red(int nFlag) { return (((nFlag & 0x01) != 0) ? true : false); }
                public bool GetFlag_Led_Blue(int nFlag) { return (((nFlag & 0x02) != 0) ? true : false); }
                public bool GetFlag_Led_Green(int nFlag) { return (((nFlag & 0x04) != 0) ? true : false); }
                
#endif
                private bool m_bSimulation = false;
                private bool m_bSimulation_Smooth = true;
                public void SetSimulation_Smooth(bool bOn) { m_bSimulation_Smooth = bOn; } 
                public void SetSimulation_With_PlayFrame(bool bOn) { m_bSimulation = bOn; }
                public bool GetSimulation_With_PlayFrame() {return m_bSimulation; }
                public bool m_bControl_Tracking = false;
                //public void GridMotionEditor_Set_ControlTracking(bool bTrackOn) { m_bControl_Tracking = bTrackOn; }

                private Ojw.CTimer [] m_aCTmr_Simul = new CTimer[254];
                private float[] m_afMot_Next = new float[256];
                private float[] m_afMot_Curr = new float[256];
                public void SetSimulation_SetCurrentData() { for (int i = 0; i < m_CHeader.nMotorCnt; i++) m_aCTmr_Simul[i] = new CTimer(); Array.Copy(GetData(), m_afMot_Curr, m_CHeader.nMotorCnt); }
                //private void SetSimulation_SetNextData() { Array.Copy(m_afMot, m_afMot_Next, m_CHeader.nMotorCnt); }
                public void SetSimulation_SetNextData(int nAxis, float fValue) { m_afMot_Next[nAxis] = fValue; }
                public int m_nSimulTime_For_Last = 0;
                public void SetSimulation_Calc(int nTime, double dDiffTime)
                {
                    double dInverval_Value = nTime / dDiffTime;// -1;
                    if (dInverval_Value == 0) dInverval_Value = 1;
                    long lInverval_Time = (long)Math.Round((double)nTime / dInverval_Value);
                    //for (int i = 0; i < m_CHeader.nMotorCnt; i++) { m_aCTmr_Simul[i].Set_Interval((double)m_afMot_Curr[i], (double)m_afMot_Next[i], (double)Math.Abs(m_afMot_Curr[i] - m_afMot_Next[i]) / dInverval_Value, lInverval_Time); }
                    for (int i = 0; i < m_CHeader.nMotorCnt; i++)
                    {
                        double dDiff = (double)Math.Abs(m_afMot_Curr[i] - m_afMot_Next[i]) / dInverval_Value;
                        m_aCTmr_Simul[i].Set_Interval((double)m_afMot_Curr[i], (double)m_afMot_Next[i], dDiff, lInverval_Time); 
                    }
                }
                public float GetSimulation_Value(int nAxis) { return (float)m_aCTmr_Simul[nAxis].Get_Interval(); }
                public float GetSimulation_Value_Next(int nAxis) { return m_afMot_Next[nAxis]; }
                                            
#endif
                #region Timer ID - TID
                public const int _CNT_ROBOT = 20;
                public const int TID_MP3CHECK = 99;
                public const int TID_START = 98;
                public const int TID_TIMER = 97;
                //public const int TID_MOTION_BY_TIMER = 96;
                public const int TID_MOTIONS = 76; // 76 ~ 95
                public const int TID_MOTIONS_WAIT_TICK = 56; // 56 ~ 75
                public const int TID_SYNC = 36; // 36 ~ 55
                public const int TID_FILEBACKUP = 35;
                public const int TID_MOTION2 = 34;
                #endregion Timer ID - TID

                private bool m_bStop = false;
                private bool m_bStart = false;
                private bool m_bEms = false; // 비상정지 용, 현재로서는 아직 사용 안함
                private bool m_bMotionEnd = false;
                public void Start_Set() { m_bStart = true; }
                public void Start_Reset() { m_bStart = false; } 
                private long m_lWaitActionTimer = 0;


                private Ojw.CTimer m_CTmr_Motion_By_Timer = new CTimer();
                public void WaitAction_KillTimer()
                {
                    m_CTmr_Motion_By_Timer.Kill();
                }
                public void WaitAction_SetTimer()
                {
                    m_lWaitActionTimer = 0;
                    //Ojw.CTimer.Set(TID_MOTION_BY_TIMER);
                    m_CTmr_Motion_By_Timer.Set();
                    //return;
                }
                public bool WaitAction_ByTimer(long t)
                {
                    if (t <= 0) return true;	// t 값이 0 보다 작다면 대기문이 필요없으므로 완료를 보냄.
                    m_lWaitActionTimer += t;

                    while (
                            //(Ojw.CTimer.Check(TID_MOTION_BY_TIMER, m_lWaitActionTimer) == false) && (m_bMotionEnd == false)// && (m_bEms == false)// && (m_bPause == FALSE) && 
                            (m_CTmr_Motion_By_Timer.Check(m_lWaitActionTimer) == false) && (m_bMotionEnd == false)// && (m_bEms == false)// && (m_bPause == FALSE) && 
                        //(g_bMainRun_Action)
                        )
                    {
                        if (GetSimulation_With_PlayFrame() == true)
                        {
                            for (int i = 0; i < m_CHeader.nMotorCnt; i++)
                                SetData(i, GetSimulation_Value(i));
                            //OjwDraw();
                        }
                        Application.DoEvents();
                    }
                    return true;
                }
                //public void GridDraw_Event_RowsAdded(object sender, DataGridViewRowsAddedEventArgs e)
                //{
                //    //if ((m_CGridMotionEditor.GetHandle().Focused == true) && (m_bEditing == false))
                //    //{
                //    //    //CMessage.Write(e.RowIndex.ToString());
                //    //    SetHeader_strDrawModel(m_txtDraw.Text);
                //    //    CompileDesign();
                //    //    StringListToGrid();
                //    //}
                //}
                //public void GridDraw_Event_RowsRemoved(object sender, DataGridViewRowsRemovedEventArgs e)
                //{
                //    //if ((m_CGridMotionEditor.GetHandle().Focused == true) && (m_bEditing == false))
                //    //{
                //    //    SetHeader_strDrawModel(m_txtDraw.Text);
                //    //    //CMessage.Write(e.RowIndex.ToString());
                //    //    CompileDesign();
                //    //    StringListToGrid();
                //    //}
                //}
                //public void GridDraw_CellValueChanged(object sender, DataGridViewCellEventArgs e)
                //{
                //    if (m_bEditing == false)
                //    {
                //        DataGridView dgAngle = m_CGridMotionEditor.GetHandle();
                //        if (dgAngle.Rows[e.RowIndex].Cells[e.ColumnIndex].Selected == true)
                //        {
                //            if (e.ColumnIndex == 0)
                //            {
                //                //        if (m_CGridMotionEditor.GetEnable() == false) 
                //                //            Prop_Set_DispObject_Selected("#-1");
                //                //        //Prop_Update_Selected();
                //                CMessage.Write((m_CGridMotionEditor.GetEnable() == false) ? "false" : "true");//"e.ColumnIndex == 0:" + e.RowIndex.ToString() + "," + e.ColumnIndex.ToString());
                //                Prop_Set_DispObject_Selected("#-1");
                //                Prop_Update_Selected();
                //            }
                //            if (e.ColumnIndex == 1)
                //            {

                //                //        string strTmp = (string)m_CGridMotionEditor.GetData(e.RowIndex, e.ColumnIndex);
                //                //        m_CGridMotionEditor.SetData(e.RowIndex, e.ColumnIndex, strTmp);

                //                //        //string strDraw = String.Empty;
                //                //        //for (int i = 0; i < m_txtDraw.Lines.Length; i++)
                //                //        //{
                //                //        //    strDraw += m_txtDraw.Lines[i] + "\r\n";
                //                //        //    if (i == m_nCurrntCell)
                //                //        //        strDraw += "//\r\n";
                //                //        //}
                //                //        //Prop_Update_Selected();

                //                string strDraw = String.Empty;
                //                if (m_rtxtDraw.Lines.Length > 0)
                //                {
                //                    for (int i = 0; i < m_rtxtDraw.Lines.Length; i++)
                //                    {
                //                        if (i == e.RowIndex)
                //                        {
                //                            int nFind = m_rtxtDraw.Lines[i].IndexOf("//");
                //                            if (nFind < 0) nFind = m_rtxtDraw.Lines[i].Length;
                //                            // 기존의 주석이 있는 경우 일단 제거해야 한다.                                                
                //                            strDraw += m_rtxtDraw.Lines[i].Substring(0, nFind) + "// " + (string)Ojw.CConvert.FloatToStr(m_CGridMotionEditor.Get(e.RowIndex, 0));
                //                            //if (nFind >= 0)
                //                            //{
                //                            //    // 기존의 주석이 있는 경우 일단 제거해야 한다.                                                
                //                            //    strDraw += m_rtxtDraw.Lines[i].Substring(0, nFind) + "// " + (string)m_CGridMotionEditor.Get(e.RowIndex, 0);
                //                            //    //strDraw += "// " + (string)m_CGridMotionEditor.Get(e.RowIndex, 0);
                //                            //}
                //                            //else
                //                            //{
                //                            //    strDraw += "// " + (string)m_CGridMotionEditor.Get(e.RowIndex, 0);
                //                            //}
                //                        }
                //                        else strDraw += m_rtxtDraw.Lines[i];
                //                        if (i < m_rtxtDraw.Lines.Length - 1) strDraw += "\r\n";
                //                    }
                //                    m_rtxtDraw.Text = strDraw;
                //                }

                //                CMessage.Write((string)Ojw.CConvert.FloatToStr(m_CGridMotionEditor.Get(e.RowIndex, 0)));//"e.ColumnIndex == 1:" + e.RowIndex.ToString() + "," + e.ColumnIndex.ToString());
                //            }
                //        }
                //    }
                //}
            
                public void GridMotionEditor_Event_CellEnter(object sender, DataGridViewCellEventArgs e)
                {
                    if (m_CGridMotionEditor.GetHandle().Focused == true)// || (m_bStart == true))
                    {
                        int nLine = e.RowIndex;
                        int nPos = e.ColumnIndex;
                        //m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nPos].Style.ForeColor = Color.Red;
                        //m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nPos].Style.BackColor = Color.Red;
                        //m_bClick_dbAngle = true;
                        //if ((e.ColumnIndex == m_CGridMotionEditor.OjwGrid_GetCurrentColumn()) && (e.RowIndex == m_CGridMotionEditor.OjwGrid_GetCurrentLine())) return;
                        m_CGridMotionEditor.SetChangeCurrentCol(nPos); // OJW5014_20161031
                        m_CGridMotionEditor.SetChangeCurrentLine(nLine); // OJW5014_20161031
                        if (m_CGridMotionEditor.GetHandle().Focused == true)
                        {
                            //m_CGridMotionEditor.SetChangeCurrentLine(e.RowIndex);
                            GridMotionEditor_Draw(e.RowIndex);
                            CheckFlag(e.RowIndex); // Led 의 상태를 그린다.
                        }
                        //if (m_panelSelected != null)
                        //{
                        //    SelectObject_Clear();
                        //    SelectObject_Add(e.RowIndex);
                        //}
                    }
                }
                public void GridMotionEditor_MouseDoubleClick(object sender, MouseEventArgs e)
                {
                    DataGridView dgAngle = m_CGridMotionEditor.GetHandle();
                    OjwGrid_CellMouseDoubleClick(dgAngle, e);
                }
                private bool m_bGridMotionEditor_MouseDown = false;
                private bool m_bGridMotionEditor_MouseMove = false;
                public void GridMotionEditor_MouseDown(object sender, MouseEventArgs e)
                {
                    m_bGridMotionEditor_MouseDown = true;
                    m_bGridMotionEditor_MouseMove = false;
                }
                public void GridMotionEditor_MouseMove(object sender, MouseEventArgs e)
                {
                    if (m_bGridMotionEditor_MouseDown == true)
                        m_bGridMotionEditor_MouseMove = true;
                }
                public void GridMotionEditor_MouseUp(object sender, MouseEventArgs e)
                {
                    m_bGridMotionEditor_MouseDown = false;
                    m_bGridMotionEditor_MouseMove = false;
                }
                private void GridMotionEditor_Scroll(object sender, ScrollEventArgs e)
                {
                    if (e.ScrollOrientation == ScrollOrientation.HorizontalScroll)
                    {
                        int nWidth_Offset = 0;
                        int nWidth_Interval = 11;
                        int nWidth = (IsGridInit() == true) ? GetWidth_GridItem() : 70;
                        for (int i = 0; i < m_CHeader.nMotorCnt; i++)
                        {
                            int nMotWidth = nWidth;
                            if (m_pbtnEnable.Length < m_CHeader.nMotorCnt) continue;
                            // Enable
                            m_pbtnEnable[i].Left = m_CGridMotionEditor.GetHandle().Left + (m_CGridMotionEditor.GetHandle().RowHeadersWidth + nWidth_Offset) + nWidth_Interval - e.NewValue;
                            // Type
                            m_pbtnType[i].Left = m_pbtnEnable[i].Left;
                            // Led
                            for (int j = 0; j < 3; j++) m_pbtnLed[j, i].Left = m_pbtnEnable[i].Left + nMotWidth / 5 * 2;
                            nWidth_Interval += nWidth + nWidth_Offset;
                        }
                    }
                    //Ojw.CMessage.Write(String.Format("NewValue={0}, OldValue={1}, Orientation={2}", e.NewValue, e.OldValue, e.ScrollOrientation));
                }
                public int GridMotionEditor_GetCurrentLine() { return m_CGridMotionEditor.OjwGrid_GetCurrentLine(); }
                public int GridMotionEditor_GetCurrentColumn() { return m_CGridMotionEditor.OjwGrid_GetCurrentColumn(); }
                
                public void GridMotionEditor_SetEnable(int nLine, bool bEn) { m_CGridMotionEditor.SetEnable(nLine, bEn); }
                public bool GridMotionEditor_GetEnable(int nLine) { return m_CGridMotionEditor.GetEnable(nLine); }
            
                public void GridMotionEditor_SetCommand(int nLine, int nCommand) { m_CGridMotionEditor.SetCommand(nLine, nCommand); }
                public int GridMotionEditor_GetCommand(int nLine) { return Convert.ToInt32(m_CGridMotionEditor.GetCommand(nLine)); }

                public void GridMotionEditor_SetData0(int nLine, int value) { m_CGridMotionEditor.SetData0(nLine, value); }
                public int GridMotionEditor_GetData0(int nLine) { return m_CGridMotionEditor.GetData0(nLine); }
                public void GridMotionEditor_SetData1(int nLine, int value) { m_CGridMotionEditor.SetData1(nLine, value); }
                public int GridMotionEditor_GetData1(int nLine) { return m_CGridMotionEditor.GetData1(nLine); }
                public void GridMotionEditor_SetData2(int nLine, int value) { m_CGridMotionEditor.SetData2(nLine, value); }
                public int GridMotionEditor_GetData2(int nLine) { return m_CGridMotionEditor.GetData2(nLine); }
                public void GridMotionEditor_SetData3(int nLine, int value) { m_CGridMotionEditor.SetData3(nLine, value); }
                public int GridMotionEditor_GetData3(int nLine) { return m_CGridMotionEditor.GetData3(nLine); }
                public void GridMotionEditor_SetData4(int nLine, int value) { m_CGridMotionEditor.SetData4(nLine, value); }
                public int GridMotionEditor_GetData4(int nLine) { return m_CGridMotionEditor.GetData4(nLine); }
                public void GridMotionEditor_SetData5(int nLine, int value) { m_CGridMotionEditor.SetData5(nLine, value); }
                public int GridMotionEditor_GetData5(int nLine) { return m_CGridMotionEditor.GetData5(nLine); }            

                public void GridMotionEditor_SetGroup(int nLine, int nGroup) { m_CGridMotionEditor.SetGroup(nLine, nGroup); }
                public int GridMotionEditor_GetGroup(int nLine) { return m_CGridMotionEditor.GetGroup(nLine); }
                public void GridMotionEditor_SetTime(int nLine, int nTime) { m_CGridMotionEditor.SetTime(nLine, nTime); }//SetData(nLine, m_CGridMotionEditor.GetTableCount() - 2, nTime); }
                public int GridMotionEditor_GetTime(int nLine) { return m_CGridMotionEditor.GetTime(nLine); }//GetData(nLine, m_CGridMotionEditor.GetTableCount() - 2)); }
                public void GridMotionEditor_SetDelay(int nLine, int nDelay) { m_CGridMotionEditor.SetDelay(nLine, nDelay); }//SetData(nLine, m_CGridMotionEditor.GetTableCount() - 1, nDelay); }
                public int GridMotionEditor_GetDelay(int nLine) { return m_CGridMotionEditor.GetDelay(nLine); }//GetData(nLine, m_CGridMotionEditor.GetTableCount() - 1)); }

                public void SetFrame_X(int i, float fValue) { m_CGridMotionEditor.SetOffset_Trans_X(i, fValue); }
                public void SetFrame_Y(int i, float fValue) { m_CGridMotionEditor.SetOffset_Trans_Y(i, fValue); }
                public void SetFrame_Z(int i, float fValue) { m_CGridMotionEditor.SetOffset_Trans_Z(i, fValue); }
                public float GetFrame_X(int i) { return m_CGridMotionEditor.GetOffset_Trans_X(i); }
                public float GetFrame_Y(int i) { return m_CGridMotionEditor.GetOffset_Trans_Y(i); }
                public float GetFrame_Z(int i) { return m_CGridMotionEditor.GetOffset_Trans_Z(i); }
                public void SetFrame_Pan(int i, float fValue) { m_CGridMotionEditor.SetOffset_Rot_Pan(i, fValue); }
                public void SetFrame_Tilt(int i, float fValue) { m_CGridMotionEditor.SetOffset_Rot_Tilt(i, fValue); }
                public void SetFrame_Swing(int i, float fValue) { m_CGridMotionEditor.SetOffset_Rot_Swing(i, fValue); }
                public float GetFrame_Pan(int i) { return m_CGridMotionEditor.GetOffset_Rot_Pan(i); }
                public float GetFrame_Tilt(int i) { return m_CGridMotionEditor.GetOffset_Rot_Tilt(i); }
                public float GetFrame_Swing(int i) { return m_CGridMotionEditor.GetOffset_Rot_Swing(i); }


                private void GridMotionEditor_SetExtBuzz(int nLine, int nValue)
                {
                    if ((nLine < 0) || (m_CGridMotionEditor.GetHandle().RowCount <= nLine)) return;
                    int nPos = GridMotionEditor_GetIndex_byMotorAxis(m_CHeader.nMotorCnt - 1);
                    if (nPos > 0)
                    {
                        m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nPos + 8].Value = nValue;
                        //dgXyz.Rows[nLine].Cells[nPos + 8].Value = nValue;
                    }
                }
                private int GridMotionEditor_GetExtBuzz(int nLine)
                {
                    if ((nLine < 0) || (m_CGridMotionEditor.GetHandle().RowCount <= nLine)) return 0;
                    int nRet = 0;
                    int nPos = GridMotionEditor_GetIndex_byMotorAxis(m_CHeader.nMotorCnt - 1);
                    if (nPos > 0) nRet = (int)Ojw.CConvert.StrToFloat(m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nPos + 8].Value.ToString());
                    return nRet;
                }
                private void GridMotionEditor_SetExtLed(int nLine, int nValue)
                {
                    if ((nLine < 0) || (m_CGridMotionEditor.GetHandle().RowCount <= nLine)) return;
                    int nPos = GridMotionEditor_GetIndex_byMotorAxis(m_CHeader.nMotorCnt - 1);
                    if (nPos > 0)
                    {
                        m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nPos + 9].Value = nValue;
                        //dgXyz.Rows[nLine].Cells[nPos + 9].Value = nValue;
                    }
                }
                private int GridMotionEditor_GetExtLed(int nLine)
                {
                    if ((nLine < 0) || (m_CGridMotionEditor.GetHandle().RowCount <= nLine)) return 0;
                    int nRet = 0;
                    int nPos = GridMotionEditor_GetIndex_byMotorAxis(m_CHeader.nMotorCnt - 1);
                    if (nPos > 0) nRet = (int)Ojw.CConvert.StrToFloat(m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nPos + 9].Value.ToString());
                    return nRet;
                }
                private int GridMotionEditor_GetIndex_byMotorAxis(int nAxis)
                {
                    int nPos = -1;
                    if ((nAxis >= 0) && (nAxis < m_CHeader.nMotorCnt)) nPos = nAxis + 1;
                    //                 if (nAxis == 7) nPos = 21;
                    //                 else if ((nAxis >= 1) && (nAxis <= 6)) nPos = nAxis + 1;
                    //                 else if ((nAxis >= 8) && (nAxis <= 19)) nPos = nAxis;
                    //                 else if (nAxis == 20) nPos = 0;
                    return nPos;
                }
                private int GridMotionEditor_GetAxisNum_byIndex(int nPos)
                {
                    int nAxis = -1;
                    if ((nPos >= 1) && (nPos < m_CHeader.nMotorCnt + 1)) nAxis = nPos - 1;
                    /*
                    // Up(1), W(2), Dn(3)
                    // Up(4), W(5), Dn(6)
                    if ((nPos >= 2) && (nPos <= 7)) nAxis = nPos - 1;
                    else if ((nPos >= 8) && (nPos <= 19)) nAxis = nPos;
                    // Pan(8), W(9), Up(10), Dn(11)
                    // Tilt(12), Swing(13)
                    // Pan(14), W(15), Up(16), Dn(17)
                    // Tilt(18), Swing(19)
                    else if (nPos == 20) nAxis = 0;
                    else if (nPos == 21) nAxis = 7;
                    */
                    return nAxis;
                }
#if false
            private void Grid_SetCommand(int nLine, int nData)
                {
                    m_CGridMotionEditor.SetData2(nLine, nData);//SetCommand(j, nData);
                }
                private int Grid_GetCommand(int nLine)
                {
                    return (int)m_CGridMotionEditor.GetData2(nLine);
                }
                private void Grid_SetData0(int nLine, int nData)
                {
                    m_CGridMotionEditor.SetData3(nLine, nData);
                }
                private int Grid_GetData0(int nLine)
                {
                    return (int)m_CGridMotionEditor.GetData3(nLine);
                }
                private void Grid_SetData1(int nLine, int nData)
                {
                    m_CGridMotionEditor.SetData4(nLine, nData);
                }
                private int Grid_GetData1(int nLine)
                {
                    return (int)m_CGridMotionEditor.GetData4(nLine);
                }
                private void Grid_SetData2(int nLine, int nData)
                {
                    m_CGridMotionEditor.SetData4(nLine, nData);
                }
                private int Grid_GetData2(int nLine)
                {
                    return (int)m_CGridMotionEditor.GetData4(nLine);
                }
#endif
                public int GridMotionEditor_GetLines()
                {
                    return m_CGridMotionEditor.GetLineCount();
                }
                public int GridMotionEditor_GetCols()
                {
                    return m_CGridMotionEditor.GetTableCount() - 2; // Time, Delay
                }
                public float GridMotionEditor_GetMotor(int nLine, int nMotorID)
                {
                    try
                    {
                        int nIndex = m_CGridMotionEditor.MotorID_2_GridIndex(nMotorID);
                        float fValue = Convert.ToSingle(m_CGridMotionEditor.GetData(nLine, nIndex));
                        return fValue;
                        //return Convert.ToSingle(m_CGridMotionEditor.GetData(nLine, nMotorID));
                    }
                    catch
                    {
                        return 0.0f;
                    }
                }
                public void GridMotionEditor_SetColorGrid(int nIndex, int nCount)
                {
                    m_CGridMotionEditor.SetColorGrid(nIndex, nCount);
                }

                // 0 - (+), 1 - (-), 2 - mul, 3 - div, 4 - increment, 5 - decrement, 6 - Change, 7 - Flip Value, 8 - Interpolation, 9 - 'S'Curve, 10 - Flip Position, 11 - Evd(+), 12 - Evd(-), 13 - EvdSet, 14 - Angle(+), 15 - Angle(-), 16 - AngleSet, 
                // 17, 18, 19 - Gravity Set(18 - Tilt 만 변화, 19 - Swing 만 변화)
                // 20, 21, 22 - LED Change(20-Red, 21-Green, 22-Blue) - 0 일때 클리어, 1 일때 동작
                // 23 - Motor Enable() - LED 와 동일
                // 24 - MotorType() - LED 와 동일
                // 25 - X(+), 26 - X(-), 27 - Y(+), 28 - (Y-), 29 - Z(+), 30 - Z(-)    
                // 31 - (X[Input]), 32 - (Y[Input]), 33 - (Z[Input]), 34 - (XYZ[Input])  
                public void GridMotionEditor_Calc(ECalc_t ECalc, params float [] afValue) { GridMotionEditor_Calc(m_CGridMotionEditor.GetHandle(), ECalc, afValue); GridMotionEditor_Draw(m_CGridMotionEditor.m_nCurrntCell); }
                public void GridMotionEditor_Calc(DataGridView OjwDataGrid, ECalc_t ECalc, params float [] afValue) { m_CGridMotionEditor.Calc((int)ECalc, afValue); GridMotionEditor_Draw(m_CGridMotionEditor.m_nCurrntCell); }
                public void GridMotionEditor_Clear() 
                {
                    m_CGridMotionEditor.SetTime(1000);
                    m_CGridMotionEditor.Clear();
                    for (int i = 0; i < m_CGridMotionEditor.GetHandle().RowCount; i++)
                    {
                        for (int j = 0; j < m_CHeader.nMotorCnt; j++)
                        {
                            //nMotPos = j + 1;
                            int nMax = m_pnFlag.GetLength(0);
                            if (i < nMax)
                            {
                                m_pnFlag[i, j] = (int)(
                                    0x10 | // Enable
                                    ((m_CHeader.pSMotorInfo[j].nMotorControlType != 0) ? 0x08 : 0x00)// 위치제어가 아니라면 //0x08 //| // MotorType
                                    //0x07 // Led
                                    );

                                CheckFlag(i);
                                m_CGridMotionEditor.GetHandle().Rows[i].Cells[j].Style.ForeColor = Color.Black;
                            }
                        }
                    }
                }
                public void GridMotionEditor_Clear(int nLine)
                {
                    m_CGridMotionEditor.Clear(nLine);
                    for (int j = 0; j < m_CHeader.nMotorCnt; j++)
                    {
                        //nMotPos = j + 1;
                        int nMax = m_pnFlag.GetLength(0);
                        if (nLine < nMax)
                        {
                            m_pnFlag[nLine, j] = (int)(
                                0x10 | // Enable
                                ((m_CHeader.pSMotorInfo[j].nMotorControlType != 0) ? 0x08 : 0x00)// 위치제어가 아니라면 //0x08 //| // MotorType
                                //0x07 // Led
                                );

                            CheckFlag(nLine);
                            m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[j].Style.ForeColor = Color.Black;
                        }
                    }
                }
                public void GridMotionEditor_SetMotor(int nLine, int nMotorID, float fValue)
                {
                    //m_CGridMotionEditor.SetData(nLine, nMotorID, fValue);

                    //int nIndex = m_CGridMotionEditor.MotorID_2_GridIndex(nMotorID);
                    m_CGridMotionEditor.SetData(nLine, nMotorID, fValue);
                    //return Convert.ToSingle(m_CGridMotionEditor.GetData(nLine, nMotorID));
                }
                public void GridMotionEditor_SetSelectedGroup(int nGroup) { m_CGridMotionEditor.SetSelectedGroup(nGroup); }
                #region LED
                private Color[] m_pcLed = new Color[4] { Color.Black, Color.Red, Color.Blue, Color.LightGreen };
                public void Grid_SetFlag_En(int nLine, int nMotNum, bool bEn)
                {
                    if ((nLine < 0) || (nLine >= m_CGridMotionEditor.GetHandle().RowCount) || (nMotNum < 0) || (nMotNum >= m_CHeader.nMotorCnt)) return; 
                    m_pnFlag[nLine, nMotNum] = (byte)((m_pnFlag[nLine, nMotNum] & 0x0f) | ((bEn == true) ? 0x10 : 0x00));
#if _ENABLE_LED_FONT_COLOR
                    Color cColor = Color.FromArgb(
                        (((m_pnFlag[nLine, nMotNum] & 0x01) != 0) ? 255 : 0), // R
                        (((m_pnFlag[nLine, nMotNum] & 0x04) != 0) ? 255 : 0), // G
                        (((m_pnFlag[nLine, nMotNum] & 0x02) != 0) ? 255 : 0) // B
                    );
                    //System.Drawing.Font("援대┝", 9F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(129)));

#if _ENABLE_LED_FONT_BOLD
                    if (cColor != Color.FromArgb(0, 0, 0))//Color.Black)
                    {
                        Font fnt = this.Font;//m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font;
                        m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(m_CGridMotionEditor.GetHandle().Font, FontStyle.Bold);
                        //m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(fnt.Name, fnt.Size, System.Drawing.FontStyle.Bold, fnt.Unit, fnt.GdiCharSet);
                    }
                    else// if (m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font.Bold == true)
                    {
                        Font fnt = this.Font;//m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font;
                        m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(m_CGridMotionEditor.GetHandle().Font, FontStyle.Regular);
                        //m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(fnt.Name, fnt.Size, System.Drawing.FontStyle.Regular, fnt.Unit, fnt.GdiCharSet);
                    }
#endif
                    m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.ForeColor = ((bEn == false) ? Color.Gray : cColor);
#endif
                }
                //private void Grid_SetFlag_Type(int nLine, int nMotNum, bool bSpeedType) { if ((nLine < 0) || (nLine >= m_CGridMotionEditor.GetHandle().RowCount) || (nMotNum < 0) || (nMotNum >= m_CHeader.nMotorCnt)) return; m_pnFlag[nLine, nMotNum] = (int)((m_pnFlag[nLine, nMotNum] & 0x17) | (((bSpeedType == true) || ((nMotNum >= 6) && (nMotNum <= 8))) ? 0x08 : 0x00)); }
                public void Grid_SetFlag_Type(int nLine, int nMotNum, bool bSpeedType) { if ((nLine < 0) || (nLine >= m_CGridMotionEditor.GetHandle().RowCount) || (nMotNum < 0) || (nMotNum >= m_CHeader.nMotorCnt)) return; m_pnFlag[nLine, nMotNum] = (int)((m_pnFlag[nLine, nMotNum] & 0x17) | ((bSpeedType == true) ? 0x08 : 0x00)); }
                // 0x00 - Black, 0x01 - Red, 0x02 - Blue, 0x04 - Green
                public void Grid_SetFlag_Led(int nLine, int nMotNum, int nLed)
                {
                    if ((nLine < 0) || (nLine >= m_CGridMotionEditor.GetHandle().RowCount) || (nMotNum < 0) || (nMotNum >= m_CHeader.nMotorCnt)) return;
                    m_pnFlag[nLine, nMotNum] = (int)((m_pnFlag[nLine, nMotNum] & 0x18) | (int)(nLed & 0x07));
#if _ENABLE_LED_FONT_COLOR
                    Color cColor = Color.FromArgb(
                        (((m_pnFlag[nLine, nMotNum] & 0x01) != 0) ? 255 : 0), // R
                        (((m_pnFlag[nLine, nMotNum] & 0x04) != 0) ? 255 : 0), // G
                        (((m_pnFlag[nLine, nMotNum] & 0x02) != 0) ? 255 : 0) // B
                    );
#if _ENABLE_LED_FONT_BOLD
                    if (cColor != Color.FromArgb(0, 0, 0))//Color.Black)
                    {
                        Font fnt = this.Font;//m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font;
                        m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(m_CGridMotionEditor.GetHandle().Font, FontStyle.Bold);
                        //m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(fnt.Name, fnt.Size, System.Drawing.FontStyle.Bold, fnt.Unit, fnt.GdiCharSet);
                    }
                    else// if (m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font.Bold == true)
                    {
                        Font fnt = this.Font;//m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font;
                        m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(m_CGridMotionEditor.GetHandle().Font, FontStyle.Regular);
                        //m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(fnt.Name, fnt.Size, System.Drawing.FontStyle.Regular, fnt.Unit, fnt.GdiCharSet);
                    }
#endif
                    m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.ForeColor = ((Grid_GetFlag_En(nLine, nMotNum) == false) ? Color.Gray : cColor);
#endif
                }
                public void Grid_SetFlag_Led_Red(int nLine, int nMotNum, bool bRed)
                {
                    if ((nLine < 0) || (nLine >= m_CGridMotionEditor.GetHandle().RowCount) || (nMotNum < 0) || (nMotNum >= m_CHeader.nMotorCnt)) return;
                    // 0001 1110
                    m_pnFlag[nLine, nMotNum] = (int)((m_pnFlag[nLine, nMotNum] & 0x1e) | ((bRed == true) ? 0x01 : 0x00));
#if _ENABLE_LED_FONT_COLOR                    
                    Color cColor = Color.FromArgb(
                        (((m_pnFlag[nLine, nMotNum] & 0x01) != 0) ? 255 : 0), // R
                        (((m_pnFlag[nLine, nMotNum] & 0x04) != 0) ? 255 : 0), // G
                        (((m_pnFlag[nLine, nMotNum] & 0x02) != 0) ? 255 : 0) // B
                    );
#if _ENABLE_LED_FONT_BOLD
                    if (cColor != Color.FromArgb(0, 0, 0))//Color.Black)
                    {
                        Font fnt = this.Font;//m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font;
                        m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(m_CGridMotionEditor.GetHandle().Font, FontStyle.Bold);
                        //m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(fnt.Name, fnt.Size, System.Drawing.FontStyle.Bold, fnt.Unit, fnt.GdiCharSet);
                    }
                    else// if (m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font.Bold == true)
                    {
                        Font fnt = this.Font;//m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font;
                        m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(m_CGridMotionEditor.GetHandle().Font, FontStyle.Regular);
                        //m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(fnt.Name, fnt.Size, System.Drawing.FontStyle.Regular, fnt.Unit, fnt.GdiCharSet);
                    }
#endif
                    m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.ForeColor = ((Grid_GetFlag_En(nLine, nMotNum) == false) ? Color.Gray : cColor);
#endif
                }
                public void Grid_SetFlag_Led_Blue(int nLine, int nMotNum, bool bBlue)
                {
                    if ((nLine < 0) || (nLine >= m_CGridMotionEditor.GetHandle().RowCount) || (nMotNum < 0) || (nMotNum >= m_CHeader.nMotorCnt)) return;
                    // 0001 1101
                    m_pnFlag[nLine, nMotNum] = (int)((m_pnFlag[nLine, nMotNum] & 0x1d) | ((bBlue == true) ? 0x02 : 0x00));
#if _ENABLE_LED_FONT_COLOR
                    Color cColor = Color.FromArgb(
                        (((m_pnFlag[nLine, nMotNum] & 0x01) != 0) ? 255 : 0), // R
                        (((m_pnFlag[nLine, nMotNum] & 0x04) != 0) ? 255 : 0), // G
                        (((m_pnFlag[nLine, nMotNum] & 0x02) != 0) ? 255 : 0) // B
                    );
#if _ENABLE_LED_FONT_BOLD
                    if (cColor != Color.FromArgb(0, 0, 0))//Color.Black)
                    {
                        Font fnt = this.Font;//m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font;
                        m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(m_CGridMotionEditor.GetHandle().Font, FontStyle.Bold);
                        //m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(fnt.Name, fnt.Size, System.Drawing.FontStyle.Bold, fnt.Unit, fnt.GdiCharSet);
                    }
                    else// if (m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font.Bold == true)
                    {
                        Font fnt = this.Font;//m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font;
                        m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(m_CGridMotionEditor.GetHandle().Font, FontStyle.Regular);
                        //m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(fnt.Name, fnt.Size, System.Drawing.FontStyle.Regular, fnt.Unit, fnt.GdiCharSet);
                    }
#endif              
                    m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.ForeColor = ((Grid_GetFlag_En(nLine, nMotNum) == false) ? Color.Gray : cColor);
#endif
                }
                public void Grid_SetFlag_Led_Green(int nLine, int nMotNum, bool bGreen)
                {
                    if ((nLine < 0) || (nLine >= m_CGridMotionEditor.GetHandle().RowCount) || (nMotNum < 0) || (nMotNum >= m_CHeader.nMotorCnt)) return;
                    // 0001 1011
                    m_pnFlag[nLine, nMotNum] = (int)((m_pnFlag[nLine, nMotNum] & 0x1b) | ((bGreen == true) ? 0x04 : 0x00));
#if _ENABLE_LED_FONT_COLOR                    
                    Color cColor = Color.FromArgb(
                        (((m_pnFlag[nLine, nMotNum] & 0x01) != 0) ? 255 : 0), // R
                        (((m_pnFlag[nLine, nMotNum] & 0x04) != 0) ? 255 : 0), // G
                        (((m_pnFlag[nLine, nMotNum] & 0x02) != 0) ? 255 : 0) // B
                    );
#if _ENABLE_LED_FONT_BOLD
                    if (cColor != Color.FromArgb(0, 0, 0))//Color.Black)
                    {
                        Font fnt = this.Font;//m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font;
                        m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(m_CGridMotionEditor.GetHandle().Font, FontStyle.Bold);
                        //m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(fnt.Name, fnt.Size, System.Drawing.FontStyle.Bold, fnt.Unit, fnt.GdiCharSet);
                    }
                    else// if (m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font.Bold == true)
                    {
                        Font fnt = this.Font;//m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font;
                        m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(m_CGridMotionEditor.GetHandle().Font, FontStyle.Regular);
                        //m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.Font = new Font(fnt.Name, fnt.Size, System.Drawing.FontStyle.Regular, fnt.Unit, fnt.GdiCharSet);
                    }
#endif
                    m_CGridMotionEditor.GetHandle().Rows[nLine].Cells[nMotNum + 1].Style.ForeColor = ((Grid_GetFlag_En(nLine, nMotNum) == false) ? Color.Gray : cColor);
#endif
                }

                public bool Grid_GetFlag_En(int nLine, int nMotNum) { if ((nLine < 0) || (nLine >= m_pnFlag.GetLength(0)) || (nMotNum < 0) || (nMotNum >= m_CHeader.nMotorCnt)) return false; return (((m_pnFlag[nLine, nMotNum] & 0x10) != 0) ? true : false); }
                public bool Grid_GetFlag_Type(int nLine, int nMotNum) { if ((nLine < 0) || (nLine >= m_pnFlag.GetLength(0)) || (nMotNum < 0) || (nMotNum >= m_CHeader.nMotorCnt)) return false; return (((m_pnFlag[nLine, nMotNum] & 0x08) != 0) ? true : false); }
                public int Grid_GetFlag_Led(int nLine, int nMotNum) { if ((nLine < 0) || (nLine >= m_pnFlag.GetLength(0)) || (nMotNum < 0) || (nMotNum >= m_CHeader.nMotorCnt)) return 0; return m_pnFlag[nLine, nMotNum] & 0x07; }
                public bool Grid_GetFlag_Led_Red(int nLine, int nMotNum) { if ((nLine < 0) || (nLine >= m_pnFlag.GetLength(0)) || (nMotNum < 0) || (nMotNum >= m_CHeader.nMotorCnt)) return false; return (((m_pnFlag[nLine, nMotNum] & 0x01) != 0) ? true : false); }
                public bool Grid_GetFlag_Led_Blue(int nLine, int nMotNum) { if ((nLine < 0) || (nLine >= m_pnFlag.GetLength(0)) || (nMotNum < 0) || (nMotNum >= m_CHeader.nMotorCnt)) return false; return (((m_pnFlag[nLine, nMotNum] & 0x02) != 0) ? true : false); }
                public bool Grid_GetFlag_Led_Green(int nLine, int nMotNum) { if ((nLine < 0) || (nLine >= m_pnFlag.GetLength(0)) || (nMotNum < 0) || (nMotNum >= m_CHeader.nMotorCnt)) return false; return (((m_pnFlag[nLine, nMotNum] & 0x04) != 0) ? true : false); }
                public void CheckFlag(int nLine, int nMotNum) // nLedNum 0, 1, 2 - nLedNum
                {
                    //return;
                    if (m_pbtnEnable == null) { return; }
                    else if (m_pbtnEnable.Length <= 0) { return; }
                    if (m_pnFlag != null)
                    {
                        // En
                        m_pbtnEnable[nMotNum].BackColor = ((Grid_GetFlag_En(nLine, nMotNum) == true) ? Color.Cyan : Color.Gray);

                        //// Type
                        m_pbtnType[nMotNum].BackColor = ((Grid_GetFlag_Type(nLine, nMotNum) == true) ? Color.Yellow : Color.Gray);
                        //if (m_pbtnType[nMotNum].BackColor == Color.Gray)
                        //{
                        //    // 없다면 있는지 체크하고
                        //    if ((m_pnFlag[nLine, nMotNum] & 0x08) != 0) m_pbtnType[nMotNum].BackColor = Color.Cyan;
                        //}
                        //else
                        //{
                        //    // 있다면 클리어를 체크한다.
                        //    if ((m_pnFlag[nLine, nMotNum] & 0x08) == 0) m_pbtnType[nMotNum].BackColor = Color.Gray;
                        //}

                        // Led
                        int i = 0;
                        //m_pbtnLed[i++, nMotNum].BackColor = ((Grid_GetFlag_Led_Red(nLine, nMotNum) == true) ? Color.Red : Color.DarkRed);
                        //m_pbtnLed[i++, nMotNum].BackColor = ((Grid_GetFlag_Led_Blue(nLine, nMotNum) == true) ? Color.LightBlue : Color.DarkBlue);
                        //m_pbtnLed[i++, nMotNum].BackColor = ((Grid_GetFlag_Led_Green(nLine, nMotNum) == true) ? Color.LightGreen : Color.DarkGreen);
                        m_pbtnLed[i++, nMotNum].BackColor = ((Grid_GetFlag_Led_Red(nLine, nMotNum) == true) ? Color.Red : Color.DarkRed);
                        m_pbtnLed[i++, nMotNum].BackColor = ((Grid_GetFlag_Led_Blue(nLine, nMotNum) == true) ? Color.Blue : Color.DarkBlue);
                        m_pbtnLed[i++, nMotNum].BackColor = ((Grid_GetFlag_Led_Green(nLine, nMotNum) == true) ? Color.Green : Color.DarkGreen);
                        i = 0;
                        m_pbtnLed[i++, nMotNum].ForeColor = ((Grid_GetFlag_Led_Red(nLine, nMotNum) == true) ? Color.Yellow : Color.Black);
                        m_pbtnLed[i++, nMotNum].ForeColor = ((Grid_GetFlag_Led_Blue(nLine, nMotNum) == true) ? Color.Yellow : Color.Black);
                        m_pbtnLed[i++, nMotNum].ForeColor = ((Grid_GetFlag_Led_Green(nLine, nMotNum) == true) ? Color.Yellow : Color.Black);
                    }
                }

                public void CheckFlag(int nLine)
                {
                    if (m_pnFlag != null)
                    {
                        for (int i = 0; i < m_CHeader.nMotorCnt; i++)
                        {
                            //for (int j = 0; j < 3; j++)
                            CheckFlag(nLine, i);
                        }
                    }
                }
                #endregion LED

                public void GridMotionEditor_Draw(int nLine)
                {
                    if (m_bGridInit == true)
                    {
                        for (int i = 0; i < m_CHeader.nMotorCnt; i++)
                        {
                            float fValue = GetData(i);
                            int nID = m_CHeader.anMotorIDs[i];
                            if (m_CGridMotionEditor.CheckMotorEn(nID) == false) continue;
                            try
                            {
                                SetData(i, GridMotionEditor_GetMotor(nLine, i));
                            }
                            catch
                            {
                                SetData(i, fValue);
                            }
                        }
                    }
                }
                #endregion Grid For Motion

                #region OjwDraw()
                private int m_nStatus_GroupA = 0;
                private int m_nStatus_GroupB = 0;
                private int m_nStatus_GroupC = 0;
                private int m_nStatus_InverseKinematicsNumber = 255;
                private int[] m_anSelectedGroup = new int[3];
                private int m_nSelected_InverseKinematicsNumber = 255;
                private bool m_bStatus_Pick = false;
                private bool m_bStatus_Limit = false;
                public int GetStatus_GroupA() { return m_nStatus_GroupA; }
                public int GetStatus_GroupB() { return m_nStatus_GroupB; }
                public int GetStatus_GroupC() { return m_nStatus_GroupC; }
                public int GetStatus_Selected_InverseKinematicsNumber() { return m_nStatus_InverseKinematicsNumber; }
                public bool GetStatus_IsPicked() { return m_bStatus_Pick; }
                public bool GetStatus_IsLimit() { return m_bStatus_Limit; }
                //public bool OjwDraw(float[] afData, COjwDesignerHeader CHeader, ref String strMessage, ref int nGroupA, ref int nGroupB, ref int nGroupC, ref String strPick)
                private bool m_bDrawing = false;
                private List<int> m_lstSelect = new List<int>();
                public void SelectObject_Add(int nLine)
                {
                    m_lstSelect.Add(nLine);
                    CreateProp_Selected(nLine);                    
                }
                private bool m_bSelectObjectEnabled = true;
                public bool SelectObject_Enable() { return m_bSelectObjectEnabled; }
                public void SelectObject_Enable(bool bEn) { m_bSelectObjectEnabled = bEn; }
                public void SelectObject_Clear()
                {
                    m_lstSelect.Clear();
                }
                public bool SelectObject_Check(int nLine)
                {
                    bool bRet = false;
                    foreach (int nItem in m_lstSelect)
                    {
                        if (nItem == nLine)
                        {
                            bRet = true; 
                            break;
                        }
                    }
                    return bRet;
                }

                //private bool m_bJoystic = false;
                public void InitJoystic()
                {
                    Glut.glutInit();
                    //m_bJoystic = true;
                    int nRet = Glut.glutDeviceGet(Glut.GLUT_HAS_JOYSTICK);
                    if (nRet != 0)
                    {
                        Glut.glutJoystickFunc(new Glut.JoystickCallback(JoystickFunc), 100);
                        Glut.glutMainLoop();
                    }
                }

                private void JoystickFunc(int buttonMask, int x, int y, int z)
                {
                    CMessage.Write("Joystick:" + buttonMask.ToString());
                }

                //private int m_nFunctionNumber = -1;
                private Mutex m_mtxDraw = new Mutex();
                delegate void Ctrl_Involk(float[] afData, COjwDesignerHeader CHeader, out int nGroupA, out int nGroupB, out int nGroupC, out int nInverseKinematicsNumber, out bool bPick, out bool bLimit);

                private int m_nSeq_Pick = 0;
                private int m_nSeq_Pick_Back = 0;
                public bool GetEvent_Pick()
                {
                    if (m_nSeq_Pick_Back != m_nSeq_Pick)
                    {
                        m_nSeq_Pick_Back = m_nSeq_Pick;
                        return true;
                    }
                    return false;
                }
                public void GetEvent_Pick_Data(out int nGroup, out int nMotor, out int nServeGroup, out int nKinematicsNum)
                {
                    nGroup = m_anSelectedGroup[0];
                    nMotor = m_anSelectedGroup[1];
                    nServeGroup = m_anSelectedGroup[2];
                    nKinematicsNum = m_nSelected_InverseKinematicsNumber;
                }
                public void UserDrawing(float[] afData, COjwDesignerHeader CHeader, ref bool bLimit, ref COjwDisp CDisp)
                {
                    #region User
                    int nCntUser = OjwDispAll_User.GetCount();

#if false
                            foreach (COjwDisp CDispItem in OjwDispAll_User.GetData()) // OJW5014_20151012
                            {
                                float fAlpha = m_fAlpha;
                                CDisp = CDispItem;// OjwDispAll_User.GetData(i);
                                if (CDisp != null)
                                {
                                    if ((CDisp.nName >= 0) && (afData.Length > CDisp.nName))
                                        CDisp.fAngle = afData[CDisp.nName];// +GetData(CDisp.nName);

                                    // Limit Check(Kor: 각도의 Limit 체크) //
                                    if (CDisp.nName >= 0)
                                    {
                                        if ((CHeader.pSMotorInfo[CDisp.nName].fLimit_Down != 0) && (CHeader.pSMotorInfo[CDisp.nName].fLimit_Down >= CDisp.fAngle)) bLimit = true;
                                        if ((CHeader.pSMotorInfo[CDisp.nName].fLimit_Up != 0) && (CHeader.pSMotorInfo[CDisp.nName].fLimit_Up <= CDisp.fAngle)) bLimit = true;
                                    }

                                    OjwDraw_Class(CDisp);
                                }
                                if (m_fAlpha != fAlpha) m_fAlpha = fAlpha;
                            }
#else
                    for (int i = 0; i < nCntUser; i++)
                    {
                        float fAlpha = m_fAlpha;
                        CDisp = OjwDispAll_User.GetData(i);
                        //if (CDisp != null)
                        //{
                        //    if ((CDisp.nName >= 0) && (afData.Length > CDisp.nName))
                        //        CDisp.fAngle = afData[CDisp.nName];// +GetData(CDisp.nName);

                        //    // Limit Check(Kor: 각도의 Limit 체크) //
                        //    if (CDisp.nName >= 0)
                        //    {
                        //        if ((CHeader.pSMotorInfo[CDisp.nName].fLimit_Down != 0) && (CHeader.pSMotorInfo[CDisp.nName].fLimit_Down >= CDisp.fAngle)) bLimit = true;
                        //        if ((CHeader.pSMotorInfo[CDisp.nName].fLimit_Up != 0) && (CHeader.pSMotorInfo[CDisp.nName].fLimit_Up <= CDisp.fAngle)) bLimit = true;
                        //    }

                        //    OjwDraw_Class(CDisp);
                        //}
                        //if (m_fAlpha != fAlpha) m_fAlpha = fAlpha;
                        if (CDisp != null)
                        {
                            bool bShow = true;
                            if ((CDisp.nPickGroup_C >= 253) && (CDisp.nPickGroup_C <= 255))
                            {
                                if (m_bDhSkeleton_Direction_Show == false)
                                {
                                    bShow = false;
                                }
                            }
                            if (bShow)
                            {
                                if ((CDisp.nName >= 0) && (afData.Length > CDisp.nName))
                                    CDisp.fAngle = afData[CDisp.nName];// +GetData(CDisp.nName);

                                // Limit Check(Kor: 각도의 Limit 체크) //
                                if (CDisp.nName >= 0)
                                {
                                    if ((CHeader.pSMotorInfo[CDisp.nName].fLimit_Down != 0) && (CHeader.pSMotorInfo[CDisp.nName].fLimit_Down >= CDisp.fAngle)) bLimit = true;
                                    if ((CHeader.pSMotorInfo[CDisp.nName].fLimit_Up != 0) && (CHeader.pSMotorInfo[CDisp.nName].fLimit_Up <= CDisp.fAngle)) bLimit = true;
                                }

                                OjwDraw_Class(CDisp);
                            }
                        }
                        if (m_fAlpha != fAlpha) m_fAlpha = fAlpha;
                    }
#endif



                    #endregion User
                }
                private int m_nFirst_0_nLast_1 = 0;
                public void SetUserDrawingSequence(int nFirst_0_nLast_1)
                {
                    m_nFirst_0_nLast_1 = nFirst_0_nLast_1;
                }
                public void OjwDraw(float[] afData, COjwDesignerHeader CHeader, out int nGroupA, out int nGroupB, out int nGroupC, out int nInverseKinematicsNumber, out bool bPick, out bool bLimit)
                {
                    if (afData == null) { nGroupA = 0; nGroupB = 0; nGroupC = 0; nInverseKinematicsNumber = 0; bPick = false; bLimit = false; return; }
                    if (CHeader == null) { nGroupA = 0; nGroupB = 0; nGroupC = 0; nInverseKinematicsNumber = 0; bPick = false; bLimit = false; return; }
                    if (m_ctrlMain.InvokeRequired)
                    {
                        bLimit = false;
                        bPick = false;
                        nGroupA = nGroupB = nGroupC = 0;
                        nInverseKinematicsNumber = 255;

                        Ctrl_Involk CI = new Ctrl_Involk(OjwDraw);
                        this.Invoke(CI, afData, CHeader, nGroupA, nGroupB, nGroupC, nInverseKinematicsNumber, bPick, bLimit);
                    }
                    else
                    {
                        // 뮤텍스 대기(다중스레드 공유 위반 방지)
                        m_mtxDraw.WaitOne();

                        //if (m_bJoystic == true)
                        //{
                        //    CMessage.Write2(
                        //        " joystick " + Glut.glutDeviceGet(Glut.GLUT_HAS_JOYSTICK).ToString() +
                        //        " - buttons " + Glut.glutDeviceGet(Glut.GLUT_JOYSTICK_BUTTONS).ToString() +
                        //        " - axes " + Glut.glutDeviceGet(Glut.GLUT_JOYSTICK_AXES).ToString() + " \r\n"
                        //        );
                        //}
                        bLimit = false;
                        bPick = false;
                        nGroupA = nGroupB = nGroupC = 0;
                        nInverseKinematicsNumber = 255;

                        if (m_bFileOpening == true) return;
                        if (m_bDrawing == true) return;
                        m_bDrawing = true;

                        try
                        {
                            int i;
                            #region Pre-Checking the function control
                            //int nInverseNum = m_nFunctionNumber;
                            if (GetFunctionNumber() >= 0)
                            {
                                if (m_CHeader.pSOjwCode.Length > GetFunctionNumber())
                                {
                                    if (m_CHeader.pSOjwCode[GetFunctionNumber()].nMotor_Max > 0)
                                    {
                                        CKinematics.CInverse.SetValue_ClearAll(ref m_CHeader.pSOjwCode[GetFunctionNumber()]);
                                        //CKinematics.CInverse.SetValue_X(m_dPos_X);
                                        //CKinematics.CInverse.SetValue_Y(m_dPos_Y);
                                        //CKinematics.CInverse.SetValue_Z(m_dPos_Z);

                                        double[] adMot = new double[m_afMot.Length];
                                        //Buffer.BlockCopy(GetData(), 0, adMot, 0, adMot.Length);
                                        for (i = 0; i < m_afMot.Length; i++) adMot[i] = (double)m_afMot[i];
                                        CKinematics.CInverse.SetValue_Motor(adMot);
                                        adMot = null;

                                        CKinematics.CInverse.CalcCode(ref m_CHeader.pSOjwCode[GetFunctionNumber()]);
                                        int nMotCnt = m_CHeader.pSOjwCode[GetFunctionNumber()].nMotor_Max;
                                        for (i = 0; i < nMotCnt; i++)
                                        {
                                            int nMotNum = m_CHeader.pSOjwCode[GetFunctionNumber()].pnMotor_Number[i];
                                            SetData(nMotNum, (float)CKinematics.CInverse.GetValue_Motor(nMotNum));
                                        }
                                    }
                                    //else
                                    //{
                                    //    CalcInv(GetFunctionNumber(), GetHeader_pDhParamAll()[GetFunctionNumber()].GetMotors(), (float)m_dPos_X, (float)m_dPos_Y, (float)m_dPos_Z, 10, 0.01f);
                                    //}
                                }
                            }
                            #endregion Pre-Checking the function control

                            glDraw_Ready();


                            //float fSize_ = 1.0f;// 2.0f;
                            //float fSize_2 = 1.0f;// 5.0f;
                            //Gl.glLoadIdentity();
                            //OjwTranslate(100, 100, 0);
                            //Axis(true, Color.Red, 1.0f, Color.Green, 1.0f, Color.Blue, 1.0f, fSize_, 40000);
                            //Axis(true, Color.Red, 1.0f, Color.Green, 1.0f, Color.Blue, 1.0f, fSize_2, 200);


                            #region Dh-notation ball Drawing
                            if (IsTestDh() == true)
                            {
                                InitPosAngle();
                                OjwTranslate(m_afDhPoint[0] + m_afDhInitPoint[0], m_afDhPoint[1] + m_afDhInitPoint[1], m_afDhPoint[2] + m_afDhInitPoint[2]);
                                OjwBall_Outside(false, m_cDh, m_fDhAlpha, m_fDhSize, 20, 0, 0, 0, 0, 0, 0);

                                float fSize = m_fDhSize;// 10.0f;
                                float fMulti = fSize / 10.0f * 2.0f;
                                InitPosAngle();
                                OjwTranslate(m_afDhPoint[0] + m_afDhInitPoint[0], m_afDhPoint[1] + m_afDhInitPoint[1], m_afDhPoint[2] + m_afDhInitPoint[2]);

                                OjwTranslate(m_afDhAngle_X[0] * fMulti, m_afDhAngle_X[1] * fMulti, m_afDhAngle_X[2] * fMulti);
                                OjwBall(true, Color.Red, m_fDhAlpha, fSize, 50);

                                InitPosAngle();
                                OjwTranslate(m_afDhPoint[0] + m_afDhInitPoint[0], m_afDhPoint[1] + m_afDhInitPoint[1], m_afDhPoint[2] + m_afDhInitPoint[2]);

                                OjwTranslate(m_afDhAngle_Y[0] * fMulti, m_afDhAngle_Y[1] * fMulti, m_afDhAngle_Y[2] * fMulti);
                                OjwBall(true, Color.Green, m_fDhAlpha, fSize, 50);

                                //Axis_Y(true, Color.Green, m_fDhAlpha, 5, 20);

                                InitPosAngle();
                                OjwTranslate(m_afDhPoint[0] + m_afDhInitPoint[0], m_afDhPoint[1] + m_afDhInitPoint[1], m_afDhPoint[2] + m_afDhInitPoint[2]);
                                //OjwRotation(m_afDhAngle[0, 0], m_afDhAngle[0, 1], m_afDhAngle[0, 2]);

                                OjwTranslate(m_afDhAngle_Z[0] * fMulti, m_afDhAngle_Z[1] * fMulti, m_afDhAngle_Z[2] * fMulti);
                                OjwBall(true, Color.Blue, m_fDhAlpha, fSize, 50);

                                // Display axis and ball
                                //OjwBall_Outside(false, m_cDh, m_fDhAlpha, m_fDhSize, 20, 0, 0, 0, 0, 0, 0);

                                //Axis_X(true, Color.Coral, 1.0f, 5, 20);
                                //Axis_Y(true, Color.Green, 1.0f, 5, 20);
                                //Axis_Z(true, Color.Blue, 1.0f, 5, 20);
                                ////
                                //////////////
                            }
                            /////////////////////////
                            #endregion Dh-notation ball Drawing

                            InitPosAngle_WithAxis();

#if false
                            float fTmpX = -160;
                            float fTmpY = 90;
                            float fTmpZ = 412;
                            //OjwTranslate(fTmpX, fTmpY, fTmpZ);
                            //OjwTrack_Circle(true, Color.Red, 1.0f,
                            //                "Track.stl",
                            //    0.0f, 0.0f, 180.0f,//180.0f,
                            //    17, // Distance
                            //    90.0f, // Radius
                            //    5, // Width
                            //    1, // Height
                            //    10, // Depth
                            //    90, 0, 0, // Track_Offset(Pan, Tilt, Swing)
                            //    0, 0, 0 // Track_Offset(X, Y, Z)
                            //);
                            //OjwTranslate(-fTmpX, -fTmpY, -fTmpZ);
                            OjwTrack2(0.0f, true, Color.Red, 1.0f,
                                "Track.stl",
                                5, // Width
                                1, // Height
                                10, // Depth
                                17, // Distance
                                0, 180, 0, // Track_Offset(Pan, Tilt, Swing)
                                0.8f, -2.0f, 0, // Track_Offset(X, Y, Z)
                                0, 0, 0, // Offset(Pan, Tilt, Swing)
                                0, 0, 0, // Offset(X, Y, Z)
                                -100, 0, 30,
                                  0, 80, 60,
                                  100, 0, 30,
                                  0, -80, 60);
#endif
                            COjwDisp CDisp = new COjwDisp();
                            if (m_nFirst_0_nLast_1 == 0) UserDrawing(afData, CHeader, ref bLimit, ref CDisp);

                            #region Territory
#if true
                            if (IsTerritory() == true)
                            {
                                OjwTerritory(m_bTerritory_Fill, m_clrTerritory_Color, m_fTerritory_Alpha,
                                    m_fTerritory_Block_Width, m_fTerritory_Block_Depth,
                                    m_nTerritory_Count_Width, m_nTerritory_Count_Depth);
                                //int nW = m_nTerritory_Count_Width / 2;
                                //int nH = m_nTerritory_Count_Depth / 2;
                                //float fBlock_Width = m_fTerritory_Block_Width;
                                //float fBlock_Depth = m_fTerritory_Block_Depth;
                                //float fBlock_Height = m_fTerritory_Block_Height;
                                //InitPosAngle();

                                //// 로봇의 움직임 구현
                                //OjwRotation(m_fPan_Robot, m_fTilt_Robot, m_fSwing_Robot);
                                //OjwTranslate(m_fX_Robot % fBlock_Width, m_fY_Robot, m_fZ_Robot % fBlock_Depth);

                                ////OjwTranslate(OjwDisp.afTrans[j].x, OjwDisp.afTrans[j].y, OjwDisp.afTrans[j].z);
                                ////OjwRotation(OjwDisp.afRot[j].pan, OjwDisp.afRot[j].tilt, OjwDisp.afRot[j].swing);

                                ////int nPos = 0;
                                //for (int nTerritory_W = -nW; nTerritory_W < nW; nTerritory_W++)
                                //{
                                //    for (int nTerritory_H = -nH; nTerritory_H < nH; nTerritory_H++)
                                //    {
                                //        //OjwTranslate(fBlock_Width, 0, 0);
                                //        //nPos++;                
                                //        OjwBox_Simple(m_bTerritory_Fill, m_clrTerritory_Color, m_fTerritory_Alpha, fBlock_Width, fBlock_Height, fBlock_Depth, 0, 0, 0, fBlock_Width * (float)nTerritory_W, 0, fBlock_Depth * (float)nTerritory_H);
                                //    }
                                //    //OjwTranslate(fBlock_Depth, 0, 0);
                                //}
                            }
#endif
                            #endregion Territory

                            //// The actual part to be drawn(Kor: 실제 그려질 부분) ////
                            if (_CNT_FILEOPEN != m_nBackupCnt_HistoryFileOpen)
                            {
                                m_nBackupCnt_HistoryFileOpen = _CNT_FILEOPEN;
                                Array.Clear(m_abMake, 0, 4096);
                            }

                            int nCnt = OjwDispAll.GetCount();
                            if (IsVirtualClass() == true) nCnt++;

                            InitPosAngle();
                            
                            // 한번 다 그리면 타이머 갱신
                            m_lTmrTrack = m_CTmrDraw.Get();
                            m_CTmrDraw.Set(); //m_lTmrTrack = 0;

                            #region Main Drawing
                            //for (i = 0; i < OjwDispAll.GetCount(); i++)
                            for (i = 0; i < nCnt; i++)
                            {
                                float fAlpha = m_fAlpha;
                                if ((IsVirtualClass() == true) && ((nCnt - 1) == i))
                                {
                                    //m_fAlpha /= 2.0f; // (Set alpha for virtual object
                                    CDisp = OjwVirtualDisp;
                                }
                                else CDisp = OjwDispAll.GetData(i);
                                if (CDisp != null)
                                {
                                    if ((CDisp.nName >= 0) && (afData.Length > CDisp.nName))
                                        CDisp.fAngle = afData[CDisp.nName];// +GetData(CDisp.nName);

                                    // Limit Check(Kor: 각도의 Limit 체크) //
                                    if (CDisp.nName >= 0)
                                    {
                                        if ((CHeader.pSMotorInfo[CDisp.nName].fLimit_Down != 0) && (CHeader.pSMotorInfo[CDisp.nName].fLimit_Down >= CDisp.fAngle)) bLimit = true;
                                        if ((CHeader.pSMotorInfo[CDisp.nName].fLimit_Up != 0) && (CHeader.pSMotorInfo[CDisp.nName].fLimit_Up <= CDisp.fAngle)) bLimit = true;
                                    }
                                    
                                    m_nDrawClass_Pos = i;
                                    OjwDraw_Class(CDisp);

                                    if (
                                        (IsVirtualClass() == true) && ((nCnt - 1) == i)
                                        && 
                                        (
                                            ((GetMouseMode() >= 4) && (GetMouseMode() <= 6))    ||  // Offset Trans
                                            ((GetMouseMode() >= 7) && (GetMouseMode() <= 9))    ||  // Offset Rotation
                                            ((GetMouseMode() >= 10) && (GetMouseMode() <= 12))  ||  // Trans 1
                                            ((GetMouseMode() >= 13) && (GetMouseMode() <= 15))      // Rotation 1
                                        )
                                    )
                                    {
                                        Axis_X(true, Color.Coral, 1.0f, 5, 20);
                                        Axis_Y(true, Color.Green, 1.0f, 5, 20);
                                        Axis_Z(true, Color.Blue, 1.0f, 5, 20);
                                    }
                                }
                                if (m_fAlpha != fAlpha) m_fAlpha = fAlpha;
                            }
                            #endregion Main Drawing

                            if (m_nFirst_0_nLast_1 != 0) UserDrawing(afData, CHeader, ref bLimit, ref CDisp);

                            #region Test Drawing
                            if (IsTestCircle() == true)
                            {
                                float fX, fY, fZ;
                                float fSize = m_fTestSize;// 10.0f;
                                float fAlpha = 1.0f;
                                int nAxisLength = 20;
                                InitPosAngle();
                                GetPos_Test(out fX, out fY, out fZ);
                                OjwTranslate(fX, fY, fZ);
                                GetAngle_Test(out fX, out fY, out fZ);
                                OjwRotation(fX, fY, fZ);
                                OjwBall_Outside(true, GetColor_Test(), fAlpha, fSize, nAxisLength, 0, 0, 0, 0, 0, 0);
                                if (IsTestAxis() == true)
                                {
                                    Axis_X(true, Color.Coral, 1.0f, 5, 20);
                                    Axis_Y(true, Color.Green, 1.0f, 5, 20);
                                    Axis_Z(true, Color.Blue, 1.0f, 5, 20);
                                }
                            }
                            #endregion Test Drawing
                            
                            long lRet = glDraw_End();
                            //bPick = IsPicking();
                            //if (bPick == true)
                            bPick = (lRet > 0) ? true : false;
                            if (IsPicking() == true)
                            {
                                if (lRet > 0)
                                {
                                    int nX, nY;
                                    GetPickMousePoint(out nX, out nY);
                                    //int nGroupA, nGroupB, nGroupC;
                                    GetPickingData(out nGroupA, out nGroupB, out nGroupC, out nInverseKinematicsNumber);
                                    //                         if (strPick != null)
                                    //                         {
                                    //                             String strPickComment = OjwDispAll.GetString_PickingComment(nGroupA, nGroupB, nGroupC);
                                    //                             strPick = "Object Name = " + CConvert.IntToStr(nGroupA) + ", " + CConvert.IntToStr(nGroupB) + ", " + CConvert.IntToStr(nGroupC) + "," + strPickComment + "[" + CConvert.IntToStr(nX) + ", " + CConvert.IntToStr(nY) + "]";
                                    //                         }
                                    if (nGroupA > 0)
                                    {
                                        m_anSelectedGroup[0] = nGroupA;
                                        m_anSelectedGroup[1] = nGroupB;
                                        m_anSelectedGroup[2] = nGroupC;
                                        m_nSelected_InverseKinematicsNumber = nInverseKinematicsNumber;

                                        if (m_CGridMotionEditor != null)
                                        {
                                            if (m_CGridMotionEditor.GetHandle() != null)
                                            {
                                                if (nInverseKinematicsNumber == 255)
                                                {
                                                    if (nGroupA != 0) 
                                                    {
                                                        int nMot = nGroupB;
                                                        bool bMulti = m_CGridMotionEditor.GetHandle().MultiSelect;
                                                        //m_CGridMotionEditor.GetHandle().MultiSelect = false;
                                                        //m_CGridMotionEditor.GetHandle()[nGroupB + 1, m_CGridMotionEditor.m_nCurrntCell].Selected = true;

#if true
                                                        if (m_CHeader.anMotorIDs != null)
                                                        {
                                                            if (m_CGridMotionEditor.m_nGridMode == 1)
                                                            {
                                                                if (Array.IndexOf(m_CHeader.anMotorIDs, nMot) >= 0)
                                                                {
                                                                    int nID = nMot;// m_CHeader.anMotorIDs[i];
                                                                    int nIndex = m_lstIDs_Motion.FindIndex(x => x == nID);
                                                                    if ((m_CHeader.pSMotorInfo[nID].nMotor_Enable < 0) || (m_CHeader.pSMotorInfo[nID].nMotor_Enable > 1))
                                                                    {
                                                                        //continue;
                                                                    }
                                                                    else if (nID >= 0)
                                                                    {
                                                                        try
                                                                        {
                                                                            m_CGridMotionEditor.GetHandle().CurrentCell = m_CGridMotionEditor.GetHandle().Rows[m_CGridMotionEditor.m_nCurrntCell].Cells[nIndex + 1];
                                                                        }
                                                                        catch
                                                                        {
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            else
                                                            {
                                                                if (Array.IndexOf(m_CHeader.anMotorIDs, nMot) >= 0)
                                                                {
                                                                    m_CGridMotionEditor.GetHandle().CurrentCell = m_CGridMotionEditor.GetHandle().Rows[m_CGridMotionEditor.m_nCurrntCell].Cells[m_CGridMotionEditor.MotorID_2_GridIndex(nMot)];
                                                                }
                                                            }
                                                        }
#else
                                                        if ((nMot >= 0) && (nMot < m_CHeader.nMotorCnt))
                                                        {
                                                            m_CGridMotionEditor.GetHandle().CurrentCell = m_CGridMotionEditor.GetHandle().Rows[m_CGridMotionEditor.m_nCurrntCell].Cells[nMot + 1];
                                                        }
                                                        //m_CGridMotionEditor.GetHandle().MultiSelect = bMulti;
#endif
                                                    }
                                                }
                                            }
                                        }


                                        //////////////
                                        m_nSeq_Pick++;
                                    }

                                }
                                else if (lRet == 0)
                                {
                                    int nX, nY;
                                    GetPickMousePoint(out nX, out nY);
                                    //if (strPick != null) strPick = "Object Name = Unknown Object[" + CConvert.IntToStr(nX) + ", " + CConvert.IntToStr(nY) + "]";

                                    nGroupA = nGroupB = nGroupC = 0;
                                    Clear_IsPicking();
                                }
                                else
                                {
                                    int nX, nY;
                                    GetPickMousePoint(out nX, out nY);
                                    //if (strPick != null) strPick = "Object Name = No Found[" + CConvert.IntToStr(nX) + ", " + CConvert.IntToStr(nY) + "]";
                                    Clear_IsPicking();                                    
                                }
                                //Clear_IsPicking();
                            }
                            CDisp = null;

                            m_nStatus_GroupA = nGroupA;
                            m_nStatus_GroupB = nGroupB;
                            m_nStatus_GroupC = nGroupC;
                            m_nStatus_InverseKinematicsNumber = nInverseKinematicsNumber;

                            m_bStatus_Pick = bPick;
                            m_bStatus_Limit = bLimit;

                            m_bDrawing = false;
                        }
                        catch (System.Exception e)
                        {
                            MessageBox.Show(e.ToString());

                            m_bDrawing = false;
                        }
                        // Release Mutex
                        m_mtxDraw.ReleaseMutex();
                    }

                    // 파일을 로딩한 처음에만 필요 로딩파일 에러를 체크
                    if (m_nSeq_Compile_Back != m_nSeq_Compile)
                    {
                        m_nSeq_Compile_Back = m_nSeq_Compile;
                        if (IsNoLoadedModelingFile() == true)
                        {
                            string strMessage = String.Empty;
                            string[] pstrItem = GetNoLoadedModelingFile().Split(',');
                            bool [] abCheck = new bool[pstrItem.Length];
                            for (int i = 0; i < abCheck.Length; i++) abCheck[i] = true;

                            for (int i = 0; i < abCheck.Length - 1; i++)
                            {
                                if (abCheck[i] == true)
                                {
                                    for (int j = i + 1; j < abCheck.Length; j++)
                                    {
                                        if ((pstrItem[i].Length == 0) || (pstrItem[i] == pstrItem[j]))
                                        {
                                            abCheck[j] = false;
                                        }
                                    }
                                }
                            }
                            if (pstrItem[abCheck.Length - 1].Length == 0) abCheck[abCheck.Length - 1] = false;

                            int nCnt = 0;
                            for (int i = 0; i < abCheck.Length; i++)
                            {
                                if (abCheck[i] == true)
                                {
                                    bool bAse = false;
                                    if (
                                        (pstrItem[i].ToUpper().IndexOf(".SSTL") < 0) &&
                                        (pstrItem[i].ToUpper().IndexOf(".STL") < 0) &&
                                        (pstrItem[i].ToUpper().IndexOf(".ASE") < 0) &&
                                        (pstrItem[i].ToUpper().IndexOf(".DAT") < 0) &&
                                        (pstrItem[i].ToUpper().IndexOf(".OBJ") < 0)
                                        ) bAse = true;
#if _CHANGE_DEFAULT_FROM_ASE_TO_DAT
                                    strMessage += pstrItem[i] + ((bAse == true) ? ".DAT" : "") + ",";
#else
                                    strMessage += pstrItem[i] + ((bAse == true) ? ".ASE" : "") + ",";
#endif
                                    nCnt++;
                                }
                            }

                            String strError = String.Format("File Missing[{0}] -> " + strMessage, nCnt);
                            Ojw.CMessage.Write_Error(strError);
                            MessageBox.Show(strError);
                            //MessageBox.Show(GetNoLoadedModelingFile());
                        }
                    }
                }
                private int m_nTerritory = 0;
                private float[] m_afTerritory_Pos = new float[3];
                private float[] m_afTerritory_Rot = new float[3];

                private float m_fTerritory_Block_Width = 100.0f;
                //private float m_fTerritory_Block_Height = 0.1f;
                private float m_fTerritory_Block_Depth = 100.0f;

                private int m_nTerritory_Count_Width = 100;
                private int m_nTerritory_Count_Depth = 100;
                private bool m_bTerritory_Fill = true;
                private Color m_clrTerritory_Color = Color.SandyBrown;
                private float m_fTerritory_Alpha = 1.0f;
                public void SetTerritory_Alpha(float fAlpha) { m_fTerritory_Alpha = fAlpha; }
                public void SetTerritory_Fill(bool bFill) { m_bTerritory_Fill = bFill; }
                public void SetTerritory_Color(Color cColor) { m_clrTerritory_Color = cColor; }
                public void SetTerritory_Show(bool bShow) { m_nTerritory = (bShow == true ? 1 : 0); }
                public bool IsTerritory() { return (m_nTerritory == 0) ? false : true; }
                
                public void SetTerritory_Block_Size(float fWidth, float fDepth)
                {
                    m_fTerritory_Block_Width = fWidth;
                    //m_fTerritory_Block_Height = fHeight;
                    m_fTerritory_Block_Depth = fDepth;
                }
                public void SetTerritory_Block_Count(int nWidth, int nDepth)
                {
                    m_nTerritory_Count_Width = nWidth;
                    m_nTerritory_Count_Depth = nDepth;
                }

                public void OjwDraw(COjwDesignerHeader CHeader, out int nGroupA, out int nGroupB, out int nGroupC, out int nInverseKinematicsNumber, out bool bPick, out bool bLimit)
                {
                    OjwDraw(m_afMot, CHeader, out nGroupA, out nGroupB, out nGroupC, out nInverseKinematicsNumber, out bPick, out bLimit);
                }
                public void OjwDraw(float[] afData, out int nGroupA, out int nGroupB, out int nGroupC, out int nInverseKinematicsNumber, out bool bPick, out bool bLimit)
                {
                    OjwDraw(afData, m_CHeader, out nGroupA, out nGroupB, out nGroupC, out nInverseKinematicsNumber, out bPick, out bLimit);
                }
                public void OjwDraw(out int nGroupA, out int nGroupB, out int nGroupC, out int nInverseKinematicsNumber, out bool bPick, out bool bLimit)
                {
                    OjwDraw(m_afMot, m_CHeader, out nGroupA, out nGroupB, out nGroupC, out nInverseKinematicsNumber, out bPick, out bLimit);
                }
                public void OjwDraw()
                {
                    OjwDraw(m_afMot, m_CHeader, out m_nStatus_GroupA, out m_nStatus_GroupB, out m_nStatus_GroupC, out m_nStatus_InverseKinematicsNumber, out m_bStatus_Pick, out m_bStatus_Limit);
                }
                public void OjwDraw(float[] afData, COjwDesignerHeader CHeader)
                {
                    OjwDraw(afData, CHeader, out m_nStatus_GroupA, out m_nStatus_GroupB, out m_nStatus_GroupC, out m_nStatus_InverseKinematicsNumber, out m_bStatus_Pick, out m_bStatus_Limit);
                }
                public void OjwDraw(COjwDesignerHeader CHeader)
                {
                    OjwDraw(m_afMot, CHeader, out m_nStatus_GroupA, out m_nStatus_GroupB, out m_nStatus_GroupC, out m_nStatus_InverseKinematicsNumber, out m_bStatus_Pick, out m_bStatus_Limit);
                }
                public void OjwDraw(float[] afData)
                {
                    OjwDraw(afData, m_CHeader, out m_nStatus_GroupA, out m_nStatus_GroupB, out m_nStatus_GroupC, out m_nStatus_InverseKinematicsNumber, out m_bStatus_Pick, out m_bStatus_Limit);
                }
                public void OjwDraw_Serve(int nCmd_GroupType, // 0, 1, 2
                                            int nCmd_GroupNum,
                    //int nCmd_GroupA, int nCmd_GroupA_Or_1, int nCmd_GroupA_Or_2, // Possible combination of 3 groups.(Kor: 3개의 그룹을 조합가능하다.)
                    //int nCmd_GroupB, int nCmd_GroupB_Or_1, int nCmd_GroupB_Or_2, // Possible combination of 3 groups.(Kor: 3개의 그룹을 조합가능하다.)
                    //int nCmd_GroupC, int nCmd_GroupC_Or_1, int nCmd_GroupC_Or_2, // Possible combination of 3 groups.(Kor: 3개의 그룹을 조합가능하다.)
                                            float[] afData, COjwDesignerHeader CHeader,
                                            bool bSecondDrawingMode,
                                            out int nGroupA, out int nGroupB, out int nGroupC,
                                            out int nInverseKinematicsNumber,
                                            out bool bPick, out bool bLimit)
                {
                    bLimit = false;
                    bPick = false;
                    nGroupA = nGroupB = nGroupC = 0;
                    nInverseKinematicsNumber = 0;
                    float fMainScale = (float)GetScale();
                    try
                    {
                        if (m_bPickMouseClick_Reserve == true)
                        {
                            m_bPickMouseClick = true;
                            m_bPickMouseClick_Reserve = false;
                        }
                        // Clipping
                        if (nCmd_GroupType > 2) nCmd_GroupType = 2;
                        if (nCmd_GroupType < 0) nCmd_GroupType = 0;

                        COjwDisp CDisp = new COjwDisp();
                        int nStart = -1;
                        int nEnd = OjwDispAll.GetCount();
                        int nDrawNum = -1;
                        float[] fInitAngle = new float[3];
                        float[] fInitPos = new float[3];
                        float fScale = fMainScale;
                        for (int i = 0; i < OjwDispAll.GetCount(); i++)
                        {
#if false
                            //                     #region EtcGrouping // 앞 뒤로 2개까지 같은 그룹이 있다면 설사 다른 그룹이더라도 같은 그룹으로 묶어서 그리도록 한다.
                            //                     bool bEtcGroup = false;
                            //                     #endregion EtcGrouping
#endif
                            CDisp = OjwDispAll.GetData(i);
                            if (CDisp != null)
                            {
                                if (
                                    //((nCmd_GroupType == 0) && ((CDisp.nPickGroup_A == nCmd_GroupNum)) || (CDisp.nPickGroup_C > 0)) ||
                                    ((nCmd_GroupType == 0) && (CDisp.nPickGroup_A == nCmd_GroupNum)) ||
                                    ((nCmd_GroupType == 1) && (CDisp.nPickGroup_B == nCmd_GroupNum)) ||
                                    //((nCmd_GroupType == 2) && (CDisp.nPickGroup_C == nCmd_GroupNum))
                                    ((nCmd_GroupType == 2) && ((CDisp.nPickGroup_A == nCmd_GroupNum) && (CDisp.nPickGroup_C > 0)))
                                    //                             (
                                    //                                 (CDisp.nPickGroup_A > 0) &&
                                    //                                 (
                                    //                                     ((nCmd_GroupType == 0) && ((CDisp.nPickGroup_A == nCmd_GroupA) || (CDisp.nPickGroup_A == nCmd_GroupA_Or_1) || (CDisp.nPickGroup_A == nCmd_GroupA_Or_2))) ||
                                    //                                     ((nCmd_GroupType == 1) && (CDisp.nPickGroup_A == nCmd_GroupA) && ((CDisp.nPickGroup_B == nCmd_GroupB) || (CDisp.nPickGroup_B == nCmd_GroupB_Or_1) || (CDisp.nPickGroup_B == nCmd_GroupB_Or_2))) ||
                                    //                                     ((nCmd_GroupType == 2) && (CDisp.nPickGroup_A == nCmd_GroupA) && (CDisp.nPickGroup_B == nCmd_GroupB) && ((CDisp.nPickGroup_C == nCmd_GroupC) || (CDisp.nPickGroup_C == nCmd_GroupC_Or_1) || (CDisp.nPickGroup_C == nCmd_GroupC_Or_2)))
                                    //                                 )
                                    //                             )
                                    //||
                                    //(bEtcGroup == true)
                                )
                                {
                                    if (nStart < 0)
                                    {
                                        nStart = i;

                                        //nDrawNum = (bSecondDrawingMode == false)?3:4;
                                        if (nCmd_GroupType != 1)
                                        {
                                            nDrawNum = (bSecondDrawingMode == false) ? 3 : 4;

                                            fInitAngle[0] = CDisp.afRot[nDrawNum].pan;
                                            fInitAngle[1] = CDisp.afRot[nDrawNum].tilt;
                                            fInitAngle[2] = CDisp.afRot[nDrawNum].swing;
                                            fInitPos[0] = CDisp.afTrans[nDrawNum].x;
                                            fInitPos[1] = CDisp.afTrans[nDrawNum].y;
                                            fInitPos[2] = CDisp.afTrans[nDrawNum].z;
                                            //fScale = (bSecondDrawingMode == false) ? CDisp.fScale_Serve0 : CDisp.fScale_Serve1;
                                            fScale = (nCmd_GroupType == 0) ? CDisp.fScale_Serve0 : CDisp.fScale_Serve1;
                                            if (fScale <= 0) fScale = fMainScale;
                                        }
                                    }
                                    nEnd = i;
                                }
                            }
                        }

                        //Refresh();
#if false
                        float fMulti = 1000.0f;
                        SetLight_Position(-50 * fMulti, 0 * fMulti, 10 * fMulti, -10 * fMulti);
#else
                        //SetLight_Position(-50, 0, 10, -10);
#endif
                        //SetLight_Ambient(0.7f, 0.7f, 0.7f, 0.5f);

                        SetScale(fScale);
                        glDraw_Ready();
                        
                        // Display Axis(Kor: 축 표시)
                        if ((nDrawNum == 3) || (nDrawNum == 4))
                        {
                            Gl.glLoadIdentity();
                            //SetLight();
                            OjwRotation(fInitAngle[0], fInitAngle[1], fInitAngle[2]);
                            OjwTranslate(fInitPos[0], fInitPos[1], fInitPos[2]);
                        }
                        else
                        {
                            InitPosAngle(); //=> Instead of above coding(Kor: 위의 코딩으로 대치)
                        }
                        fInitAngle = null;
                        fInitPos = null;

                        //// The actual part to be drawn(Kor: 실제 그려질 부분) ////
                        // => Only to be drawn into the same group so laced unconditionally.
                        // Kor: => 무조건 같은 그룹으로만 엮이도록 그려야 한다.
                        if ((nStart > 0) && (nEnd > 0)) 
                        {
                            // Actually drawing the part to be drawn(Kor: 그려야 할 부분을 실제로 그리기)
                            for (int i = nStart; i <= nEnd; i++)
                            {
                                CDisp = OjwDispAll.GetData(i);
                                if (CDisp != null)
                                {

                                    if ((CDisp.nName >= 0) && (afData.Length > CDisp.nName))
                                        CDisp.fAngle = afData[CDisp.nName];// +GetData(CDisp.nName);

                                    // Limit Check(Kor: 각도의 Limit 체크) //
                                    if (CDisp.nName >= 0)
                                    {
                                        if ((CHeader.pSMotorInfo[CDisp.nName].fLimit_Down != 0) && (CHeader.pSMotorInfo[CDisp.nName].fLimit_Down >= CDisp.fAngle)) bLimit = true;
                                        if ((CHeader.pSMotorInfo[CDisp.nName].fLimit_Up != 0) && (CHeader.pSMotorInfo[CDisp.nName].fLimit_Up <= CDisp.fAngle)) bLimit = true;
                                    }
                                    OjwDraw_Class(CDisp);
                                }
                            }
                        }

                        long lRet = glDraw_End();
                        bPick = IsPicking();
                        if (bPick == true)
                        {
                            if (lRet > 0)
                            {
                                int nX, nY;
                                GetPickMousePoint(out nX, out nY);
                                //int nGroutA, nGroupB, nGroupC;
                                GetPickingData(out nGroupA, out nGroupB, out nGroupC, out nInverseKinematicsNumber);
                            }
                            else if (lRet == 0)
                            {
                                int nX, nY;
                                GetPickMousePoint(out nX, out nY);
                            }
                            else
                            {
                                int nX, nY;
                                GetPickMousePoint(out nX, out nY);
                            }
                            Clear_IsPicking();
                        }
                        CDisp = null;
                        SetScale(fMainScale);
                    }
                    catch //(System.Exception e)
                    {
                        SetScale(fMainScale);
                    }
                }
                #endregion OjwDraw()
            
                #region glDraw_End()
                public long glDraw_End()
                {
                    //Refresh();
                    if (m_bPickMouseClick == true)
                    {
                        Picking_End();
                        //////////////////////////////////

                        uint unName = Picking_Check();
                        //glFlush();
                        if (unName > 0)
                        {
                            return (long)unName;
                        }
                        return 0;
                    }
                    else
                    {                        
#if false // Test TEXT : freeglut.dll 이 있어야 함
                        if (Ojw.CFile.IsFile(string.Format(Application.StartupPath + "\\freeglut.dll")) == true)
                        {
                            Gl.glMatrixMode(Gl.GL_PROJECTION);
                            double[] adMatrix = new double[16];
                            Gl.glGetDoublev(Gl.GL_PROJECTION_MATRIX, adMatrix);
                            Gl.glLoadIdentity();
                            Gl.glOrtho(0, 800, 0, 600, -5, 5);
                            Gl.glMatrixMode(Gl.GL_MODELVIEW);
                            Gl.glLoadIdentity();
                            Gl.glPushMatrix();

                            Gl.glLoadIdentity();
                            Gl.glRasterPos2i(10, 10);
                            string strText = "Hello World";
                            for (int i = 0; i < strText.Length; i++)
                            {
                                Glut.glutBitmapCharacter(Glut.GLUT_BITMAP_9_BY_15, (int)strText[i]);
                            }
                            Gl.glPopMatrix();
                            Gl.glMatrixMode(Gl.GL_PROJECTION);
                            Gl.glLoadMatrixd(adMatrix);
                            Gl.glMatrixMode(Gl.GL_MODELVIEW);
                        }
#endif



                        //SwapBuffers();
                        glFlush();
                        //Refresh();
                        SwapBuffers();
                        //this.SwapBuffers();
                    }
                    
                    //m_bIgnore = false;
                    
                    //this.DrawGLScene();          // draw the scene
                    //SwapBuffers(hDC);            // Swap buffer (double buffering)
                    //this.SwapBuffers();
                    //SwapBuffers();
                    //this.Invalidate(false);
                    //this.SwapBuffers(this.Handle);
                    //Refresh();
                    return -1;
                }
                #endregion glDraw_End()

                #region SizeChange
                private float m_fW;
                private float m_fH;
                private void Ortho(float w, float h, float fRange)
                {
#if false
                    m_fW = w;
                    m_fH = h;
                    if (w <= h)
                        Gl.glOrtho(-fRange, fRange, -fRange, fRange * h / w, -fRange, fRange);
                    else
                        Gl.glOrtho(-fRange * , fRange * w / h, -fRange, fRange, -fRange, fRange);
#else
                    m_fW = w;
                    m_fH = h;
                    float fRatio = (h / ((w == 0) ? 1 : w));

                    if (w <= h)
                    {
                        if (IsPerspectiveMode() == false)
                        {
                            Gl.glOrtho(-fRange, fRange, -fRange * fRatio, fRange * fRatio, -fRange * 10, fRange * 10);
                            //Glu.gluLookAt(0, 0, 1000 * (m_afMot[0] / 10.0 + 1), 0, 0, 0, 0, 1, 0);
                        }
                        else
                        {
                            //Glu.gluPerspective(65, (double)w / (double)h, 0.1, 1000);
                            Glu.gluPerspective(45,//100 * ((m_fScale > 1.6f) ? 1.6 : ((m_fScale < 0.0001f) ? 0.0001 : m_fScale)),
                                (double)h / (double)w, 0.1, 10000);
                            //float fScale = 100;
                            //Gl.glScalef(fScale * m_fScale, fScale * m_fScale, 300);
                        
                            //Gl.glLoadIdentity();
                            //Glu.gluLookAt(0, 0, 1500 * m_fScale, 0, 0, 0, 0, 1, 0);
                            //Glu.gluLookAt(0, 0, 400, 0, 0, 0, 0, 1, 0);
                            //Gl.glFrustum(-fRange / fRatio, fRange / fRatio, -fRange, fRange, -fRange * 10, fRange * 10);
                        }
                    }
                    else
                    {
                        if (IsPerspectiveMode() == false)
                        {
                            Gl.glOrtho(-fRange / fRatio, fRange / fRatio, -fRange, fRange, -fRange * 10, fRange * 10);
                            //Glu.gluLookAt(0, 0, 1000 * (m_afMot[0] / 10.0 + 1), 0, 0, 0, 0, 1, 0);
                        }
                        else
                        {
                            //Glu.gluPerspective(65, (double)w / (double)h, 0.1, 1000);
                            Glu.gluPerspective(45,//100 * ((m_fScale > 1.6f) ? 1.6 : ((m_fScale < 0.0001f) ? 0.0001 : m_fScale)),
                                (double)w / (double)h, 0.1, 10000);
                            //float fScale = 100;
                            //Gl.glScalef(fScale * m_fScale, fScale * m_fScale, 300);
                            //Gl.glLoadIdentity();
                            //Glu.gluLookAt(0, 0, 1500 * m_fScale, 0, 0, 0, 0, 1, 0);

                            //Glu.gluLookAt(0, 0, 400, 0, 0, 0, 0, 1, 0);
                            //Gl.glFrustum(-fRange / fRatio, fRange / fRatio, -fRange, fRange, -fRange * 10, fRange * 10);
                        }
                    }
                    //glOrtho (-fRange, fRange*w/h, -fRange, fRange, -fRange, 1.00);
#endif
                }
                private void Ortho(float fRange)
                {
#if false
                    float w = m_fW;
                    float h = m_fH;
                    if (w <= h)
                        Gl.glOrtho(-fRange, fRange, -fRange, fRange * h / w, -fRange, fRange);
                    else
                        Gl.glOrtho(-fRange, fRange * w / h, -fRange, fRange, -fRange, fRange);
                    //glOrtho (-fRange, fRange*w/h, -fRange, fRange, -fRange, 1.00);
#else
                    float w = m_fW;
                    float h = m_fH;
                    float fRatio = (h / ((w == 0) ? 1 : w));
                    if (w <= h)
                        Gl.glOrtho(-fRange, fRange, -fRange * fRatio, fRange * fRatio, -fRange, fRange);
                    else
                        Gl.glOrtho(-fRange / fRatio, fRange / fRatio, -fRange, fRange, -fRange, fRange);
#endif
                }

                private int m_nWidth = 0;
                private int m_nHeight = 0;
                private const float _RATIO = 800.0f;
                public void SizeChange(Size s)
                {
                    m_nWidth = s.Width;
                    m_nHeight = s.Height;
                    double dW = (double)(s.Width);
                    double dH = (double)(s.Height);

                    float fRatio = _RATIO * m_fScale;

                    //Gl.glViewport(-s.Width / 2, -s.Height / 2, s.Width * 2, s.Height * 2); // 이걸 살리면 피킹이 안된다.
                    Gl.glViewport(0, 0, s.Width, s.Height);
                    //Glu.gluLookAt(0, 0, -100, 0, 0, 0, 0, 1, 0);
                    Gl.glMatrixMode(Gl.GL_PROJECTION);
                    Gl.glLoadIdentity();
                    Ortho((float)s.Width, (float)s.Height, fRatio);
#if _USE_LOOKAT
                    Glu.gluLookAt(m_afLookat[0], m_afLookat[1], m_afLookat[2], 0, 0, 0, m_afLookat_Dir[0], m_afLookat_Dir[1], m_afLookat_Dir[2]);
#endif
                    Gl.glDepthRange(-fRatio, fRatio);
                    //Gl.glDepthRange(-_RATIO, _RATIO);//(-fRatio, fRatio);
                    Gl.glMatrixMode(Gl.GL_MODELVIEW);
                    Gl.glLoadIdentity();

                    //SetLight();
                }
                #endregion SizeChange

                // Set the lights(Kor: 빛 설정)
                #region Light
                private bool m_bEnable_Light = true;
                public void Enable_Light(bool bEnable) { m_bEnable_Light = bEnable; }

                public float[] m_light0_position = new float[4] { 0.0f, 0.0f, -1000.0f, 1.0f };
                public float[] m_light1_position = new float[4] { 100.0f, 100.0f, 100.0f, 1.0f };
                //private float[] m_light0_position = new float[4] { 0.0f, 0.0f, -2000.0f, 1.0f };
                //private float[] m_light1_position = new float[4] { 2000.0f, 1000.0f, 1.0f, 1.0f };

                public float[] m_light0_direction = new float[3] { 0.5f, 0.0f, 0.5f };
                public float[] m_light1_direction = new float[3] { -0.5f, -0.5f, 1.0f };

#if false
            // bronze
            GL_AMBIENT {0.2125f,0.1275f,0.054f,1.0f};
            GL_DIFFUSE {0.714f,0.4284f,0.18144f,1.0f};
            GL_SPECULAR {0.3935f,0.2719f,0.1667f,1.0f};
            GL_SHININESS {25.6f};

#endif
                const float _LIGHT_AMBIENT =0.4f;// 0.3f;//0.5f;
                const float _LIGHT_DIFFUSE = 0.7f;//0.5f;
                const float _LIGHT_SPECULAR = 0.8f;
#if true
                public float[] m_ambient = new float[4] { _LIGHT_AMBIENT, _LIGHT_AMBIENT, _LIGHT_AMBIENT, 1.0f };
                //private float[] m_ambient = new float[4] { 0.25f, 0.25f, 0.25f, 1.0f };
                public float[] m_diffuseLight = new float[4] { _LIGHT_DIFFUSE, _LIGHT_DIFFUSE, _LIGHT_DIFFUSE, 1.0f };//{ 1.0f, 1.0f, 1.0f, 1.0f };
                public float[] m_specular = new float[4] { _LIGHT_SPECULAR, _LIGHT_SPECULAR, _LIGHT_SPECULAR, 1.0f };
#else
                private float[] m_ambient = new float[4] { 0.25f, 0.25f, 0.25f, 1.0f };
                private float[] m_diffuseLight = new float[4] { 0.4f, 0.4f, 0.4f, 1.0f };
                private float[] m_specular = new float[4] { 0.774597f, 0.774597f, 0.774597f, 1.0f };//{ 0.6f, 0.6f, 0.6f, 1.0f };
#endif
                const float _LIGHT_AMBIENT2 = 0.2f;
                const float _LIGHT_DIFFUSE2 = 0.8f;
                const float _LIGHT_SPECULAR2 = 0.774597f;
                public float[] m_ambient2 = new float[4] { _LIGHT_AMBIENT2, _LIGHT_AMBIENT2, _LIGHT_AMBIENT2, 1.0f };//{ 0.25f, 0.25f, 0.25f, 1.0f };
                public float[] m_diffuseLight2 = new float[4] { _LIGHT_DIFFUSE2, _LIGHT_DIFFUSE2, _LIGHT_DIFFUSE2, 1.0f };//{ 0.4f, 0.4f, 0.4f, 1.0f };
                public float[] m_specular2 = new float[4] { _LIGHT_SPECULAR2, _LIGHT_SPECULAR2, _LIGHT_SPECULAR2, 1.0f };//{ 0.8f, 0.8f, 0.8f, 1.0f };

#if true
                const float _MAT_DIFFUSE = 0.8f;//0.8f;
                const float _MAT_AMBIENT = 0.25f;
                const float _MAT_SPECULAR = 0.774597f;
                // chrome 
                // ambient - 0.25, 0.25, 0.25   diffuse - 0.4, 0.4, 0.4,   specular - 0.774597, 0.774597, 0.774597,   shininess - 0.6
                public float[] m_mat_diffuse = new float[4] { _MAT_DIFFUSE, _MAT_DIFFUSE, _MAT_DIFFUSE , 1.0f }; //{ 0.8f, 0.8f, 0.8f, 1.0f };//{ 0.9f, 0.9f, 0.9f, 1.0f };
                public float[] m_mat_specular = new float[4] { _MAT_SPECULAR, _MAT_SPECULAR, _MAT_SPECULAR, 1.0f };
                public float[] m_mat_ambient = new float[4] { _MAT_AMBIENT, _MAT_AMBIENT, _MAT_AMBIENT, 1.0f };//0.5f };
                public float[] m_mat_shiness = new float[1] { 0.6f * 128.0f };
#else
                // gold //
                // ambient - 0.24725 0.1995 0.0745 diffuse - 0.75164 0.60648 0.22648 specular - 0.628281 0.555802 0.366065 shininess - 0.4 
                private float[] m_mat_diffuse = new float[4] { 0.75164f, 0.60648f, 0.22648f, 1.0f };//{ 0.9f, 0.9f, 0.9f, 1.0f };
                private float[] m_mat_specular = new float[4] { 0.628281f, 0.555802f, 0.366065f, 1.0f };
                private float[] m_mat_ambient = new float[4] { 0.24725f, 0.1995f, 0.0745f, 0.5f };
                private float[] m_mat_shiness = new float[1] { 0.4f * 128.0f };
#endif
                //private float[] m_mat_diffuse = new float[4] { 1.0f, 1.0f, 1.0f, 1.0f };//{ 0.9f, 0.9f, 0.9f, 1.0f };
                //private float[] m_mat_specular = new float[4] { 0.35f, 0.35f, 0.35f, 1.0f };
                //private float[] m_mat_ambient = new float[4] { 0.5f, 0.5f, 0.5f, 0.5f };
                //private float[] m_mat_shiness = new float[1] { 80.0f };


                public float GetLight_Spot() { return m_fSpot; }
                public float GetLight_Spot2() { return m_fSpot2; }
                public void  SetLight_Spot(float fSpot) { m_fSpot = fSpot; }
                public void  SetLight_Spot2(float fSpot) { m_fSpot2 = fSpot; }
                public float GetLight_Exponent() { return m_fExponent; }
                public float GetLight_Exponent2() { return m_fExponent2; }
                public void  SetLight_Exponent(float fValue) { m_fExponent = fValue; }
                public void  SetLight_Exponent2(float fValue) { m_fExponent2 = fValue; }

                public float GetLight_Shiness(float fShiness) { return m_mat_shiness[0]; }
                public void  SetLight_Shiness(float fShiness) { m_mat_shiness[0] = fShiness; }

                //private int m_nShiness = 128;
                public float m_fSpot = 67.0f;//85.0f;//95;//85.0f;
                public float m_fExponent = 1.0f;//0.5f;//3.0f;//1.0f;//3.0f;//3.0f;//3.0f;//2.0f;//1.0f;
                public float m_fSpot2 = 85.0f;//95;//85.0f;
                public float m_fExponent2 = 0.5f;//3.0f;//5.0f;//3.0f;//3.0f;//3.0f;//2.0f;//1.0f;

                public void GetLight_Position(out float fA, out float fB, out float fC, out float fD) { fA = m_light0_position[0]; fB = m_light0_position[1]; fC = m_light0_position[2]; fD = m_light0_position[3]; }
                public void GetLight_Direction(out float fA, out float fB, out float fC) { fA = m_light0_direction[0]; fB = m_light0_direction[1]; fC = m_light0_direction[2]; }

                public void GetLight_Position2(out float fA, out float fB, out float fC, out float fD) { fA = m_light1_position[0]; fB = m_light1_position[1]; fC = m_light1_position[2]; fD = m_light1_position[3]; }
                public void GetLight_Direction2(out float fA, out float fB, out float fC) { fA = m_light1_direction[0]; fB = m_light1_direction[1]; fC = m_light1_direction[2]; }
                
                public void SetLight_Position(float fA, float fB, float fC, float fD) { m_light0_position[0] = fA; m_light0_position[1] = fB; m_light0_position[2] = fC; m_light0_position[3] = fD; }
                public void SetLight_Direction(float fA, float fB, float fC) { m_light0_direction[0] = fA; m_light0_direction[1] = fB; m_light0_direction[2] = fC; }

                public void SetLight_Position2(float fA, float fB, float fC, float fD) { m_light1_position[0] = fA; m_light1_position[1] = fB; m_light1_position[2] = fC; m_light1_position[3] = fD; }
                public void SetLight_Direction2(float fA, float fB, float fC) { m_light1_direction[0] = fA; m_light1_direction[1] = fB; m_light1_direction[2] = fC; }

                public void GetLight_Ambient(out float fA, out float fB, out float fC, out float fD) { fA = m_ambient[0]; fB = m_ambient[1]; fC = m_ambient[2]; fD = m_ambient[3]; }
                public void GetLight_diffuseLight(out float fA, out float fB, out float fC, out float fD) { fA = m_diffuseLight[0]; fB = m_diffuseLight[1]; fC = m_diffuseLight[2]; fD = m_diffuseLight[3]; }
                public void GetLight_Specular(out float fA, out float fB, out float fC, out float fD) { fA = m_specular[0]; fB = m_specular[1]; fC = m_specular[2]; fD = m_specular[3]; }

                public void SetLight_Ambient(float fA, float fB, float fC, float fD) { m_ambient[0] = fA; m_ambient[1] = fB; m_ambient[2] = fC; m_ambient[3] = fD; }
                public void SetLight_diffuseLight(float fA, float fB, float fC, float fD) { m_diffuseLight[0] = fA; m_diffuseLight[1] = fB; m_diffuseLight[2] = fC; m_diffuseLight[3] = fD; }
                public void SetLight_Specular(float fA, float fB, float fC, float fD) { m_specular[0] = fA; m_specular[1] = fB; m_specular[2] = fC; m_specular[3] = fD; }

                public void GetLight_Ambient2(out float fA, out float fB, out float fC, out float fD) { fA = m_ambient2[0]; fB = m_ambient2[1]; fC = m_ambient2[2]; fD = m_ambient2[3]; }
                public void GetLight_diffuseLight2(out float fA, out float fB, out float fC, out float fD) { fA = m_diffuseLight2[0]; fB = m_diffuseLight2[1]; fC = m_diffuseLight2[2]; fD = m_diffuseLight2[3]; }
                public void GetLight_Specular2(out float fA, out float fB, out float fC, out float fD) { fA = m_specular2[0]; fB = m_specular2[1]; fC = m_specular2[2]; fD = m_specular2[3]; }
                public void SetLight_Ambient2(float fA, float fB, float fC, float fD) { m_ambient2[0] = fA; m_ambient2[1] = fB; m_ambient2[2] = fC; m_ambient2[3] = fD; }
                public void SetLight_diffuseLight2(float fA, float fB, float fC, float fD) { m_diffuseLight2[0] = fA; m_diffuseLight2[1] = fB; m_diffuseLight2[2] = fC; m_diffuseLight2[3] = fD; }
                public void SetLight_Specular2(float fA, float fB, float fC, float fD) { m_specular2[0] = fA; m_specular2[1] = fB; m_specular2[2] = fC; m_specular2[3] = fD; }

                public void GetMaterial_Ambient(out float fA, out float fB, out float fC, out float fD) { fA = m_mat_ambient[0]; fB = m_mat_ambient[1]; fC = m_mat_ambient[2]; fD = m_mat_ambient[3]; }
                public void GetMaterial_diffuse(out float fA, out float fB, out float fC, out float fD) { fA = m_mat_diffuse[0]; fB = m_mat_diffuse[1]; fC = m_mat_diffuse[2]; fD = m_mat_diffuse[3]; }
                public void GetMaterial_Specular(out float fA, out float fB, out float fC, out float fD) { fA = m_mat_ambient[0]; fB = m_mat_ambient[1]; fC = m_mat_ambient[2]; fD = m_mat_ambient[3]; }
            
                public void SetMaterial_Ambient(float fA, float fB, float fC, float fD) { m_mat_ambient[0] = fA; m_mat_ambient[1] = fB; m_mat_ambient[2] = fC; m_mat_ambient[3] = fD; }
                public void SetMaterial_diffuse(float fA, float fB, float fC, float fD) { m_mat_diffuse[0] = fA; m_mat_diffuse[1] = fB; m_mat_diffuse[2] = fC; m_mat_diffuse[3] = fD; }
                public void SetMaterial_Specular(float fA, float fB, float fC, float fD) { m_mat_ambient[0] = fA; m_mat_ambient[1] = fB; m_mat_ambient[2] = fC; m_mat_ambient[3] = fD; }
            
                private void SetLight2()
                {
                    Gl.glEnable(Gl.GL_LIGHTING);     // Enable lighting(Kor: 조명 활성화)
                    Gl.glEnable(Gl.GL_LIGHT1);

                    Gl.glLightfv(Gl.GL_LIGHT1, Gl.GL_POSITION, m_light1_position);
                    Gl.glLightfv(Gl.GL_LIGHT1, Gl.GL_DIFFUSE, m_diffuseLight2);
                    Gl.glLightfv(Gl.GL_LIGHT1, Gl.GL_SPECULAR, m_specular2);
                    Gl.glLightfv(Gl.GL_LIGHT1, Gl.GL_AMBIENT, m_ambient2);
                    Gl.glLightfv(Gl.GL_LIGHT1, Gl.GL_SPOT_DIRECTION, m_light1_direction);// Direction of light(Kor: 빛의 방향)

                    // Set the exponent - The higher this value is increasing rapidly in the outer darkness at the center axis.
                    // Kor: 승수 설정 - 이 값이 커질수록 중심축 방향에서 외곽으로 갈수록 급격히 어두워 진다.
                    Gl.glLightf(Gl.GL_LIGHT1, Gl.GL_SPOT_EXPONENT, m_fExponent2);//+ 1); 

                    Gl.glLightf(Gl.GL_LIGHT1, Gl.GL_SPOT_CUTOFF, m_fSpot2);//60.0f); // Set the spot value(Kor: 조명각 설정(스포트라이트))


#if true
                    //Gold//
                    //ambient - 0.24725 0.1995 0.0745 diffuse - 0.75164 0.60648 0.22648 specular - 0.628281 0.555802 0.366065 shininess - 0.4 
                    //chrome // http://devernay.free.fr/cours/opengl/materials.html
                    // ambient - 0.25, 0.25, 0.25   diffuse - 0.4, 0.4, 0.4,   specular - 0.774597, 0.774597, 0.774597,   shininess - 0.6
                    float[] afmat_diffuse = new float[4] { 0.4f, 0.4f, 0.4f, 1.0f };
                    float[] afmat_specular = new float[4] { 0.774597f, 0.774597f, 0.774597f, 1.0f };//{ 0.0f, 0.0f, 0.0f, 1.0f };//{ 0.774597f, 0.774597f, 0.774597f, 1.0f };
                    float[] afmat_ambient = new float[4] { 0.25f, 0.25f, 0.25f, 1.0f };;//{ 0.0f, 0.0f, 0.0f, 1.0f };//{ 0.25f, 0.25f, 0.25f, 1.0f };
                    float[] afmat_shiness = new float[1] { 0.6f * 128.0f };

                    Gl.glMaterialfv(Gl.GL_FRONT, Gl.GL_DIFFUSE, afmat_diffuse);
                    Gl.glMaterialfv(Gl.GL_FRONT, Gl.GL_SPECULAR, afmat_specular);
                    Gl.glMaterialfv(Gl.GL_FRONT, Gl.GL_AMBIENT, afmat_ambient);
                    Gl.glMaterialfv(Gl.GL_FRONT, Gl.GL_SHININESS, afmat_shiness);
#endif

#if false
                    Gl.glMaterialfv(Gl.GL_FRONT_FACE, Gl.GL_DIFFUSE, m_mat_diffuse);
                    Gl.glMaterialfv(Gl.GL_FRONT_FACE, Gl.GL_SPECULAR, m_mat_specular);
                    //Gl.glMaterialfv(Gl.GL_FRONT, Gl.GL_AMBIENT, m_mat_ambient);
                    Gl.glMaterialfv(Gl.GL_FRONT_FACE, Gl.GL_SHININESS, m_mat_shiness);
                    //Gl.glMateriali(Gl.GL_FRONT, Gl.GL_SHININESS, m_nShiness);//128); // 1 - 128  
                    Gl.glLightModelfv(Gl.GL_LIGHT_MODEL_AMBIENT, m_mat_ambient);
#else
                    
#endif
                }
                private bool m_bDisplay_Edge = true; //컴퓨터에 따라 에지를 살리고 죽이도록 수정해야 할 듯...
                private bool m_bDetail = true;
                public void SetDisplay_Edge(bool bEn) { m_bDisplay_Edge = bEn; }
                public void SetDisplay_Detail(bool bEn) { m_bDetail = bEn; }
                private int m_nCWMode = Gl.GL_CW;//Gl.GL_CCW;//Gl.GL_CW;
                private void SetLight()
                {
                    if (m_bEnable_Light == true)
                    {
#if true



#if true                        
                        Gl.glEnable(Gl.GL_LIGHTING);     // Enable Light
                        Gl.glEnable(Gl.GL_LIGHT0);

                        Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_POSITION, m_light0_position);
                        Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_SPOT_DIRECTION, m_light0_direction); // Direction of light(Kor: 빛의 방향)
                        Gl.glLightf(Gl.GL_LIGHT0, Gl.GL_SPOT_CUTOFF, m_fSpot);//60.0f); // Set the spot value(Kor: 조명각 설정(스포트라이트))
                        // Set the exponent - The higher this value is increasing rapidly in the outer darkness at the center axis.
                        // Kor: 승수 설정 - 이 값이 커질수록 중심축 방향에서 외곽으로 갈수록 급격히 어두워 진다.
                        Gl.glLightf(Gl.GL_LIGHT0, Gl.GL_SPOT_EXPONENT, m_fExponent);

                        Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_DIFFUSE, m_diffuseLight);
                        Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_SPECULAR, m_specular);
                        Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_AMBIENT, m_ambient);
#else
                        Gl.glEnable(Gl.GL_LIGHTING);     // Enable Light
                        Gl.glEnable(Gl.GL_LIGHT0);

                        Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_POSITION, m_light0_position);
                        Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_SPOT_DIRECTION, m_light0_direction); // Direction of light(Kor: 빛의 방향)
                        Gl.glLightf(Gl.GL_LIGHT0, Gl.GL_SPOT_CUTOFF, m_fSpot);//60.0f); // Set the spot value(Kor: 조명각 설정(스포트라이트))
                        // Set the exponent - The higher this value is increasing rapidly in the outer darkness at the center axis.
                        // Kor: 승수 설정 - 이 값이 커질수록 중심축 방향에서 외곽으로 갈수록 급격히 어두워 진다.
                        Gl.glLightf(Gl.GL_LIGHT0, Gl.GL_SPOT_EXPONENT, m_fExponent);

                        Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_DIFFUSE, m_diffuseLight);
                        Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_SPECULAR, m_specular);
                        Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_AMBIENT, m_ambient);



                        // 약간의 주변광을 넣어 물체가 보이도록 한다.
                        SetLight_diffuseLight(0.2f, 0.2f, 0.2f, 1.0f);
                        Gl.glLightModelfv(Gl.GL_LIGHT_MODEL_AMBIENT, m_diffuseLight);

                        // 조명 설정
                        Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_POSITION, m_light0_position);
                        Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_DIFFUSE, m_diffuseLight);
                        Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_SPECULAR, m_specular);
                        Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_AMBIENT, m_ambient);
                        Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_SPOT_DIRECTION, m_light0_direction);// 빛의 방향

                        Gl.glLightf(Gl.GL_LIGHT0, Gl.GL_SPOT_EXPONENT, m_fExponent); // 승수 설정 - 이 값이 커질수록 중심축 방향에서 외곽으로 갈수록 급격히 어두워 진다.

                        Gl.glLightf(Gl.GL_LIGHT0, Gl.GL_SPOT_CUTOFF, m_fSpot);//60.0f); // 조명각 설정(스포트라이트)



                        //chrome // http://devernay.free.fr/cours/opengl/materials.html
                        // ambient - 0.25, 0.25, 0.25   diffuse - 0.4, 0.4, 0.4,   specular - 0.774597, 0.774597, 0.774597,   shininess - 0.6
                        float[] afmat_diffuse = new float[4] { 0.4f, 0.4f, 0.4f, 1.0f };
                        float[] afmat_specular = new float[4] { 0.774597f, 0.774597f, 0.774597f, 1.0f };
                        float[] afmat_ambient = new float[4] { 0.25f, 0.25f, 0.25f, 1.0f };
                        float[] afmat_shiness = new float[1] { 0.6f * 128.0f };

                        Gl.glMaterialfv(Gl.GL_FRONT_FACE, Gl.GL_DIFFUSE, afmat_diffuse);
                        Gl.glMaterialfv(Gl.GL_FRONT_FACE, Gl.GL_SPECULAR, afmat_specular);
                        Gl.glMaterialfv(Gl.GL_FRONT, Gl.GL_AMBIENT, afmat_ambient);
                        Gl.glMaterialfv(Gl.GL_FRONT_FACE, Gl.GL_SHININESS, afmat_shiness);
#endif






#if false
                        // The light weakens with distance.(Kor: 거리에 따른 빛의 약화)
                        float fValue = 1.0f;
                        Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_CONSTANT_ATTENUATION, ref fValue);
                        fValue = 2.0f; Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_LINEAR_ATTENUATION, ref fValue);
                        fValue = 3.0f; Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_QUADRATIC_ATTENUATION, ref fValue);
#endif
                        // Material properties are set to follow glColor value(Kor: 재질 속성이 glColor 값을 따르게끔 설정)
                        if (IsPerspectiveMode() == true)
                        {
                            Gl.glColorMaterial(Gl.GL_FRONT_FACE, Gl.GL_AMBIENT_AND_DIFFUSE);
                            //Gl.glLightModelfv(Gl.GL_LIGHT_MODEL_AMBIENT, m_ambient);//m_diffuseLight); // 중요.. 이걸 해야 밝아진다.
                            Gl.glEnable(Gl.GL_COLOR_MATERIAL);   // Enable Material color tracking

                                // Front material ambient and diffuse colors track glColor
                            //Gl.glColorMaterial(Gl.GL_FRONT, Gl.GL_AMBIENT_AND_DIFFUSE);
                            //Gl.glLightModelfv(Gl.GL_LIGHT_MODEL_AMBIENT, m_diffuseLight);
                            // Enable color tracking(Kor: 색상 트래킹을 사용하게끔 설정)
                            //Gl.glEnable(Gl.GL_COLOR_MATERIAL);

                            //Gl.glEnable(Gl.GL_CULL_FACE);    // Not drawn to overlap the back(Kor: 겹치는 뒷면을 그리지 않음)
                            Gl.glEnable(Gl.GL_DEPTH_TEST);	// Depth buffer enable - Clear face hidden(Kor: 깊이 버퍼 활성화 - 숨겨진 면 지우기)


                            //Gl.glClearDepth(8000.0f);									    // Depth Buffer Setup
                            //Gl.glDepthFunc(Gl.GL_LEQUAL);								// The Type Of Depth Testing To Do
                            Gl.glHint(Gl.GL_PERSPECTIVE_CORRECTION_HINT, Gl.GL_NICEST);	// Really Nice Perspective Calculations

                            //Gl.glLightModeli(Gl.GL_LIGHT_MODEL_LOCAL_VIEWER, Gl.GL_FALSE);
                            Gl.glLightModeli(Gl.GL_LIGHT_MODEL_TWO_SIDE, Gl.GL_TRUE);

//#if _GL_FLAT
//                            Gl.glShadeModel(Gl.GL_FLAT);							    // Enable Flat Shading
//#else
                            Gl.glShadeModel(Gl.GL_SMOOTH);							    // Enable Smooth Shading                                                     
//#endif

                            //Gl.glClearDepth(8000.0f);									    // Depth Buffer Setup
                        }
                        else
                        {
                            Gl.glColorMaterial(Gl.GL_FRONT_FACE, Gl.GL_AMBIENT_AND_DIFFUSE);
                            //Gl.glColorMaterial(Gl.GL_FRONT_AND_BACK, Gl.GL_AMBIENT_AND_DIFFUSE);

                            //Gl.glColorMaterial(Gl.GL_FRONT, Gl.GL_AMBIENT);
                            //Gl.glLightModelfv(Gl.GL_LIGHT_MODEL_AMBIENT, m_ambient);//m_diffuseLight); // 중요.. 이걸 해야 밝아진다.
                            // Enable color tracking(Kor: 색상 트래킹을 사용하게끔 설정)
                            Gl.glEnable(Gl.GL_COLOR_MATERIAL);

                            Gl.glShadeModel(Gl.GL_SMOOTH);	//구로 셰이딩
                            //Gl.glShadeModel(Gl.GL_FLAT);	//구로 셰이딩

                            //Gl.glEnable(Gl.GL_CULL_FACE);    // Not drawn to overlap the back(Kor: 겹치는 뒷면을 그리지 않음)
                            Gl.glEnable(Gl.GL_DEPTH_TEST);	// Depth buffer enable - Clear face hidden(Kor: 깊이 버퍼 활성화 - 숨겨진 면 지우기)

                            //Gl.glHint(Gl.GL_POINT_SMOOTH_HINT, Gl.GL_NICEST);
                            //Gl.glHint(Gl.GL_LINE_SMOOTH_HINT, Gl.GL_NICEST);
                            //Gl.glHint(Gl.GL_POLYGON_SMOOTH_HINT, Gl.GL_NICEST);

                            
                            Gl.glClearDepth(8000.0f);									    // Depth Buffer Setup
                            Gl.glDepthFunc(Gl.GL_LEQUAL);								// The Type Of Depth Testing To Do
                            Gl.glHint(Gl.GL_PERSPECTIVE_CORRECTION_HINT, Gl.GL_NICEST);	// Really Nice Perspective Calculations

                            Gl.glLightModeli(Gl.GL_LIGHT_MODEL_TWO_SIDE, Gl.GL_TRUE);

#if _GL_FLAT
                            Gl.glShadeModel(Gl.GL_FLAT);							    // Enable Flat Shading
#else
                            Gl.glShadeModel(Gl.GL_SMOOTH);							    // Enable Smooth Shading                                                     
#endif
                        }

                        
//#if true//!_ENABLE_PERSPECTIVE

                        // 이걸 살리면 고성능 VGA 에서 선이나 점등이 보여 마치 깨진것 처럼 보인다.
                        /*
                        bool bHint = true;
                        Gl.glEnable(Gl.GL_POINT_SMOOTH);
                        //Gl.glHint(Gl.GL_POINT_SMOOTH_HINT, Gl.GL_FASTEST);
                        Gl.glEnable(Gl.GL_LINE_SMOOTH);
                        //Gl.glHint(Gl.GL_LINE_SMOOTH_HINT, Gl.GL_FASTEST);
                        Gl.glEnable(Gl.GL_POLYGON_SMOOTH);
                        //Gl.glHint(Gl.GL_POLYGON_SMOOTH_HINT, Gl.GL_FASTEST);

                        Gl.glHint(Gl.GL_POINT_SMOOTH_HINT, bHint ? Gl.GL_NICEST : Gl.GL_FASTEST);
                        Gl.glHint(Gl.GL_LINE_SMOOTH_HINT, bHint ? Gl.GL_NICEST : Gl.GL_FASTEST);
                        Gl.glHint(Gl.GL_POLYGON_SMOOTH_HINT, bHint ? Gl.GL_NICEST : Gl.GL_FASTEST);
                        */

                        bool bHint = true;
                        Gl.glEnable(Gl.GL_LINE_SMOOTH);
                        Gl.glHint(Gl.GL_LINE_SMOOTH_HINT, bHint ? Gl.GL_NICEST : Gl.GL_FASTEST);

                        //Gl.glHint(Gl.GL_PERSPECTIVE_CORRECTION_HINT, Gl.GL_NICEST); // Really Nice Perspective Calculations
//#endif                        
                        Gl.glEnable(Gl.GL_NORMALIZE);

                        Gl.glFrontFace(m_nCWMode);//Gl.GL_CW);       // CCW 
                        
                         
                        if (IsPerspectiveMode() == true)
                        {
#if true
                            // Set Alpha Environment
                            Gl.glEnable(Gl.GL_BLEND);
                            Gl.glEnable(Gl.GL_ALPHA_TEST);


                            //Gl.glClear(Gl.GL_COLOR_BUFFER_BIT);


                            //Gl.glAlphaFunc(Gl.GL_LESS, 1.0f);
                            //Gl.glBlendFunc(Gl.GL_SRC_ALPHA, Gl.GL_SRC_COLOR); // 1
                            //Gl.glBlendFunc(Gl.GL_ONE, Gl.GL_ZERO);
                            //Gl.glBlendFunc(Gl.GL_ONE, Gl.GL_ZERO); // 원래 이거였음.
                            Gl.glBlendFunc(Gl.GL_SRC_ALPHA, Gl.GL_ONE_MINUS_SRC_ALPHA); // 1
                            // Gl.glBlendFunc(Gl.GL_SRC_ALPHA, Gl.GL_ONE_MINUS_DST_ALPHA); // -> 이걸하면 겉의 윤곽이 검어진다.
                            //Gl.glBlendFunc(Gl.GL_DST_ALPHA, Gl.GL_ONE_MINUS_SRC_ALPHA); // -> 이건 별로...

                            // 20150527
                            //Gl.glEnable(Gl.GL_CULL_FACE);   
                            //Gl.glCullFace(Gl.GL_BACK);  

                            //Gl.glEdgeFlag(Gl.GL_FALSE );
                            Gl.glEdgeFlag((m_bDisplay_Edge == true) ? Gl.GL_TRUE : Gl.GL_FALSE);//Gl.GL_TRUE); // 1
#else
                            Gl.glEnable(Gl.GL_BLEND);
                            Gl.glEnable(Gl.GL_ALPHA_TEST);
                            //Gl.glDepthMask(Gl.GL_TRUE);
                            //Gl.glAlphaFunc(Gl.GL_LESS, 1.0f);
                            //Gl.glBlendFunc(Gl.GL_SRC_ALPHA, Gl.GL_SRC_COLOR); // 1
                            //Gl.glBlendFunc(Gl.GL_SRC_ALPHA, Gl.GL_SRC_COLOR); // 1
                            Gl.glBlendFunc(Gl.GL_SRC_ALPHA, Gl.GL_ONE_MINUS_SRC_ALPHA); // 1
                            //Gl.glBlendFunc(Gl.GL_SRC_ALPHA, Gl.GL_ONE_MINUS_DST_ALPHA); // -> 이걸하면 겉의 윤곽이 검어진다.
                            //Gl.glBlendFunc(Gl.GL_DST_ALPHA, Gl.GL_ONE_MINUS_DST_ALPHA); 
                            //Gl.glBlendFunc(Gl.GL_DST_ALPHA, Gl.GL_ONE_MINUS_SRC_ALPHA); // -> 이건 별로...

                            // 20150527
                            //Gl.glEnable(Gl.GL_CULL_FACE);   
                            //Gl.glCullFace(Gl.GL_BACK);  

                            //Gl.glEdgeFlag(Gl.GL_FALSE );
                            Gl.glEdgeFlag((m_bDisplay_Edge == true) ? Gl.GL_TRUE : Gl.GL_FALSE);//Gl.GL_TRUE); // 1
#endif

#if true //20150116
#if true
                            /*Gl.glMaterialfv(Gl.GL_FRONT_FACE, Gl.GL_DIFFUSE, m_mat_diffuse);
                            Gl.glMaterialfv(Gl.GL_FRONT_FACE, Gl.GL_SPECULAR, m_mat_specular);
                            //Gl.glMaterialfv(Gl.GL_FRONT, Gl.GL_AMBIENT, m_mat_ambient);
                            Gl.glMaterialfv(Gl.GL_FRONT_FACE, Gl.GL_SHININESS, m_mat_shiness);
                            //Gl.glMateriali(Gl.GL_FRONT, Gl.GL_SHININESS, m_nShiness);//128); // 1 - 128  
                            Gl.glLightModelfv(Gl.GL_LIGHT_MODEL_AMBIENT, m_mat_ambient);*/
#else
                            //chrome // http://devernay.free.fr/cours/opengl/materials.html
                            // ambient - 0.25, 0.25, 0.25   diffuse - 0.4, 0.4, 0.4,   specular - 0.774597, 0.774597, 0.774597,   shininess - 0.6
                            float[] afmat_diffuse = new float[4] { 0.4f, 0.4f, 0.4f, 1.0f };
                            float[] afmat_specular = new float[4] { 0.774597f, 0.774597f, 0.774597f, 1.0f };
                            float[] afmat_ambient = new float[4] { 0.25f, 0.25f, 0.25f, 1.0f };
                            float[] afmat_shiness = new float[1] { 0.6f * 128.0f };

                            Gl.glMaterialfv(Gl.GL_FRONT_FACE, Gl.GL_DIFFUSE, afmat_diffuse);
                            Gl.glMaterialfv(Gl.GL_FRONT_FACE, Gl.GL_SPECULAR, afmat_specular);
                            Gl.glMaterialfv(Gl.GL_FRONT, Gl.GL_AMBIENT, afmat_ambient);
                            Gl.glMaterialfv(Gl.GL_FRONT_FACE, Gl.GL_SHININESS, afmat_shiness);
#endif
#else
                            GL_FRONT_AND_BACK
                        //Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_DIFFUSE, m_diffuseLight);
                        //Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_SPECULAR, m_specular);
                        //Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_AMBIENT, m_ambient);
#endif
                        }
                        else
                        {
                            // Set Alpha Environment
                            Gl.glEnable(Gl.GL_BLEND);
                            Gl.glEnable(Gl.GL_ALPHA_TEST);

                            //Gl.glClear(Gl.GL_COLOR_BUFFER_BIT);

                            Gl.glBlendFunc(Gl.GL_SRC_ALPHA, Gl.GL_ONE_MINUS_SRC_ALPHA); // 1
                            //Gl.glBlendFunc(Gl.GL_SRC_ALPHA, Gl.GL_ONE_MINUS_DST_ALPHA); // -> 이걸하면 겉의 윤곽이 검어진다.
                            //Gl.glBlendFunc(Gl.GL_DST_ALPHA, Gl.GL_ONE_MINUS_DST_ALPHA);
                            //Gl.glBlendFunc(Gl.GL_DST_ALPHA, Gl.GL_ONE_MINUS_SRC_ALPHA); // -> 이건 별로...

                            // 20150527
                            //Gl.glEnable(Gl.GL_CULL_FACE);   
                            //Gl.glCullFace(Gl.GL_BACK);  

                            //Gl.glEdgeFlag(Gl.GL_FALSE );
                            Gl.glEdgeFlag((m_bDisplay_Edge == true) ? Gl.GL_TRUE : Gl.GL_FALSE);//Gl.GL_TRUE); // 1

                            //float[] afEmission = new float[4] { 1f, 1f, 1f, 1.0f };
                            //float[] afEmission = new float[4] { 0.25f, 0.25f, 0.25f, 1.0f };
                            //float[] afEmission = new float[4] { 0.15f, 0.15f, 0.15f, 1.0f };
                            //Gl.glMaterialfv(Gl.GL_FRONT_AND_BACK, Gl.GL_EMISSION, afEmission); // 발광체 선언
#if false
                            float[] afmat_diffuse = new float[4] { 0.4f, 0.4f, 0.4f, 1.0f };
                            float[] afmat_specular = new float[4] { 0.774597f, 0.774597f, 0.774597f, 1.0f };
                            float[] afmat_ambient = new float[4] { 0.25f, 0.25f, 0.25f, 1.0f };
                            float[] afmat_shiness = new float[1] { 0.6f * 128.0f };

                            Gl.glMaterialfv(Gl.GL_FRONT_FACE, Gl.GL_DIFFUSE, afmat_diffuse);
                            Gl.glMaterialfv(Gl.GL_FRONT_FACE, Gl.GL_SPECULAR, afmat_specular);
                            Gl.glMaterialfv(Gl.GL_FRONT, Gl.GL_AMBIENT, afmat_ambient);
                            Gl.glMaterialfv(Gl.GL_FRONT_FACE, Gl.GL_SHININESS, afmat_shiness);
#endif




#if false
                            // 약간의 주변광을 넣어 물체가 보이도록 한다.
                            //SetLight_diffuseLight(0.2f, 0.2f, 0.2f, 1.0f);
                            Gl.glLightModelfv(Gl.GL_LIGHT_MODEL_AMBIENT, m_diffuseLight);

                            // 조명 설정
                            Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_POSITION, m_light0_position);
                            Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_DIFFUSE, m_diffuseLight);
                            Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_SPECULAR, m_specular);
                            Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_AMBIENT, m_ambient);
                            Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_SPOT_DIRECTION, m_light0_direction);// 빛의 방향

                            Gl.glLightf(Gl.GL_LIGHT0, Gl.GL_SPOT_EXPONENT, m_fExponent); // 승수 설정 - 이 값이 커질수록 중심축 방향에서 외곽으로 갈수록 급격히 어두워 진다.

                            Gl.glLightf(Gl.GL_LIGHT0, Gl.GL_SPOT_CUTOFF, m_fSpot);//60.0f); // 조명각 설정(스포트라이트)

#if true //20150116
                Gl.glMaterialfv(Gl.GL_FRONT_FACE, Gl.GL_DIFFUSE, m_mat_diffuse);
                Gl.glMaterialfv(Gl.GL_FRONT_FACE, Gl.GL_SPECULAR, m_mat_specular);
                //Gl.glMaterialfv(Gl.GL_FRONT, Gl.GL_AMBIENT, m_mat_ambient);
                Gl.glMaterialfv(Gl.GL_FRONT_FACE, Gl.GL_SHININESS, m_mat_shiness);
                //Gl.glMateriali(Gl.GL_FRONT, Gl.GL_SHININESS, m_nShiness);//128); // 1 - 128  
                Gl.glLightModelfv(Gl.GL_LIGHT_MODEL_AMBIENT, m_mat_ambient);
#endif
#endif








                        }


#else
#if true
                        ////Gl.glEnable(Gl.GL_MULTISAMPLE);
                        Gl.glEnable(Gl.GL_BLEND);
                        Gl.glBlendFunc(Gl.GL_SRC_ALPHA, Gl.GL_ONE_MINUS_SRC_ALPHA);

                        ////
                        //Gl.glEnable(Gl.GL_TEXTURE_2D);

                        Gl.glEnable(Gl.GL_POINT_SMOOTH);
                        Gl.glHint(Gl.GL_POINT_SMOOTH_HINT, Gl.GL_FASTEST);
                        //Gl.glHint(Gl.GL_POINT_SMOOTH_HINT, Gl.GL_FASTEST);
                        Gl.glEnable(Gl.GL_LINE_SMOOTH);
                        Gl.glHint(Gl.GL_LINE_SMOOTH_HINT, Gl.GL_FASTEST);
                        Gl.glEnable(Gl.GL_POLYGON_SMOOTH);
                        Gl.glHint(Gl.GL_POLYGON_SMOOTH_HINT, Gl.GL_FASTEST);

                        //Gl.glEnable(Gl.GL_AUTO_NORMAL);


                        //// 조명을 사용하게 끔 설정n
                        //Gl.glShadeModel(Gl.GL_SMOOTH);	//구로 셰이딩
                        //Gl.glShadeModel(Gl.GL_FLAT);	//구로 셰이딩
                        Gl.glEnable(Gl.GL_LIGHTING);     //조명 활성화
                        Gl.glEnable(Gl.GL_LIGHT0);

                        ////Gl.glDepthFunc(Gl.GL_ALWAYS);								// The Type Of Depth Testing To Do
                        //Gl.glDepthFunc(Gl.GL_LEQUAL);								// The Type Of Depth Testing To Do
                        //Gl.glHint(Gl.GL_PERSPECTIVE_CORRECTION_HINT, Gl.GL_FASTEST);	// Really Nice Perspective Calculations


                        //Gl.glFrontFace(Gl.GL_CCW);       // 반시계 방향의 와인딩 적용

                        // 약간의 주변광을 넣어 물체가 보이도록 한다.
                        //SetLight_diffuseLight(0.2f, 0.2f, 0.2f, 1.0f);
                        Gl.glLightModelfv(Gl.GL_LIGHT_MODEL_AMBIENT, m_diffuseLight);

                        // 조명 설정
                        Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_POSITION, m_light0_position);
                        Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_DIFFUSE, m_diffuseLight);
                        Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_SPECULAR, m_specular);
                        Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_AMBIENT, m_ambient);
                        Gl.glLightfv(Gl.GL_LIGHT0, Gl.GL_SPOT_DIRECTION, m_light0_direction);// 빛의 방향

                        Gl.glLightf(Gl.GL_LIGHT0, Gl.GL_SPOT_EXPONENT, m_fExponent); // 승수 설정 - 이 값이 커질수록 중심축 방향에서 외곽으로 갈수록 급격히 어두워 진다.

                        Gl.glLightf(Gl.GL_LIGHT0, Gl.GL_SPOT_CUTOFF, m_fSpot);//60.0f); // 조명각 설정(스포트라이트)

#if false //20150116
                Gl.glMaterialfv(Gl.GL_FRONT_FACE, Gl.GL_DIFFUSE, m_mat_diffuse);
                Gl.glMaterialfv(Gl.GL_FRONT_FACE, Gl.GL_SPECULAR, m_mat_specular);
                //Gl.glMaterialfv(Gl.GL_FRONT, Gl.GL_AMBIENT, m_mat_ambient);
                Gl.glMaterialfv(Gl.GL_FRONT_FACE, Gl.GL_SHININESS, m_mat_shiness);
                //Gl.glMateriali(Gl.GL_FRONT, Gl.GL_SHININESS, m_nShiness);//128); // 1 - 128  
                Gl.glLightModelfv(Gl.GL_LIGHT_MODEL_AMBIENT, m_mat_ambient);
#endif


                        //float[] Emission = new float[4] { 0.3f, 0.3f, 0.3f, 0.5f };//발광색(R,G,B,A)
                        //Gl.glMaterialfv(Gl.GL_FRONT, Gl.GL_EMISSION, Emission);// 발광체 선언

                        Gl.glLightModeli(Gl.GL_LIGHT_MODEL_TWO_SIDE, Gl.GL_TRUE);

                        // 재질 속성이 glColor 값을 따르게끔 설정
                        Gl.glColorMaterial(Gl.GL_FRONT_FACE, Gl.GL_AMBIENT_AND_DIFFUSE);


                        //Gl.glEnable(Gl.GL_TEXTURE_2D);
                        //Gl.glBindTexture(Gl.GL_TEXTURE_2D, g_Texture[pObject->materialID]);


                        // 색상 트래킹을 사용하게끔 설정
                        Gl.glEnable(Gl.GL_COLOR_MATERIAL);

                        //Gl.glEnable(Gl.GL_CULL_FACE);    // 겹치는 뒷면을 그리지 않음
                        //Gl.glFrontFace(Gl.GL_CCW);       // 시계 방향의 와인딩 적용
                        Gl.glEnable(Gl.GL_DEPTH_TEST);	//깊이 버퍼 활성화 - 숨겨진 면 지우기
                        //float [] fcolor = new float[4] {0.1f, 0.1f, 0.1f, 0.1f};
                        //Gl.glEnable(Gl.GL_FOG);

                        //Gl.glFog(Gl.GL_FOG, fcolor);
#else
                Gl.glEnable(GL.GL_DEPTH_TEST);
                Gl.glEnable(GL.GL_CULL_FACE);
                Gl.glFrontFace(GL.GL_CW);

                float[] ambLight = new float[4] { 0.5f, 0.5f, 0.5f, 0.5f };
                float[] specular = new float[4] { 1.0f, 1.0f, 1.0f, 1.0f };
                float[] specref = new float[4] { 1.0f, 1.0f, 1.0f, 1.0f }; 
                float [] lightPos = new float[4] {0.0f, 100.0f, 0.0f, 1.0f}; //조명의 위치를 설정한다. 

                Gl.glEnable(GL.GL_LIGHTING); //조명을 사용하도록 한다. 
                Gl.glLightModelfv(GL.GL_LIGHT_MODEL_AMBIENT, ambLight); //저장된 값으로 주변광을 설정한다. 
                Gl.glLightfv(GL.GL_LIGHT0, Gl.GL_DIFFUSE, ambLight);
                Gl.glLightfv(GL.GL_LIGHT0, Gl.GL_SPECULAR, specular);
                Gl.glLightfv(GL.GL_LIGHT0, Gl.GL_POSITION, lightPos); //조명 위치 설정 
                Gl.glEnable(GL.GL_COLOR_MATERIAL); //재질에 영향을 받도록 한다. 

                Gl.glColorMaterial(GL.GL_FRONT, Gl.GL_AMBIENT_AND_DIFFUSE); //재질 색상을 오브젝트와 텍스쳐 섹을 함께 사용한다. 

                Gl.glMaterialfv(GL.GL_FRONT, Gl.GL_SPECULAR, specref);
                Gl.glMateriali(GL.GL_FRONT, Gl.GL_SHININESS, 70);

                Gl.glEnable(GL.GL_LIGHT0); //0번 조명 사용 
#if _GL_FLAT
                    Gl.glShadeModel(Gl.GL_FLAT);							    // Enable Flat Shading
#else
                    Gl.glShadeModel(Gl.GL_SMOOTH);							    // Enable Smooth Shading                    
#endif


#endif
#endif
                        //SetLight2();
                    }
                    else
                    {
                        Gl.glEnable(Gl.GL_MULTISAMPLE);                        
                        Gl.glDisable(Gl.GL_LIGHTING);
                        Gl.glDisable(Gl.GL_LIGHT0);

                        // Enable color tracking(Kor: 색상 트래킹을 사용하게끔 설정)
                        Gl.glEnable(Gl.GL_COLOR_MATERIAL);
                    }
                }
                #endregion Light

                #endregion There are basic functions for initialization.(Kor: OpenGL 을 처음 실행시 초기화 하는 함수등 OpenGL 기본적 구현 함수)

                #region OpenGL: Rotate, move, reset, etc. The basic control functions(Kor: OpenGL 회전, 이동, 초기화등 기본제어함수)
                private float[] m_afCalcAngle = new float[3] { 0.0f, 0.0f, 0.0f };
                private float[] m_afCalcPos = new float[3] { 0.0f, 0.0f, 0.0f };
                //public float[] m_afCalcPos_Event = new float[16];// { 0.0f, 0.0f, 0.0f };
                // Init position
                #region InitPosAngle
                private bool m_bStandardAxis_Fill = true;
                private float m_fStandardAxis_Alpha = 1.0f;
                private float m_fStandardAxis_Thick = 1.0f;
                private float m_fStandardAxis_Length = 40000.0f;

                public void SetStandardAxis(bool bFill_true, float fAlpha_1f, float fThick_1, float fLength_40000f)
                {
                    m_bStandardAxis_Fill = bFill_true;
                    m_fStandardAxis_Alpha = fAlpha_1f;
                    m_fStandardAxis_Thick = fThick_1;
                    m_fStandardAxis_Length = fLength_40000f;
                }
                private void InitPosAngle_WithAxis()
                {
                    Gl.glLoadIdentity();
                    Glu.gluLookAt(0, 0, 2000 * m_fScale, 0, 0, 0, 0, 1, 0);

                    OjwRotation(m_fPan, m_fTilt, m_fSwing);
                    OjwTranslate(m_fX, m_fY, m_fZ);
                    //SetLight();
                    
                    // display axis
                    if (IsStandardAxis() == true)
                    {
#if false
                        float fSize = 1.0f;// 2.0f;
                        //float fSize2 = 1.0f;// 5.0f;
                        Axis(true, Color.Red, 1.0f, Color.Green, 1.0f, Color.Blue, 1.0f, fSize, 40000);
                        //Axis(true, Color.Red, 1.0f, Color.Green, 1.0f, Color.Blue, 1.0f, fSize2, 200);
#else
                        Axis(m_bStandardAxis_Fill, Color.Red, m_fStandardAxis_Alpha, Color.Green, m_fStandardAxis_Alpha, Color.Blue, m_fStandardAxis_Alpha, m_fStandardAxis_Thick, m_fStandardAxis_Length);
#endif
                    }


                    OjwRotation(m_fPan_Robot, m_fTilt_Robot, m_fSwing_Robot);
                    OjwTranslate(m_fX_Robot, m_fY_Robot, m_fZ_Robot);


                    //OjwRotation(m_fPan_Robot, m_fTilt_Robot, m_fSwing_Robot);
                    //OjwTranslate(m_fX_Robot, m_fY_Robot, m_fZ_Robot);
                }
                public void InitPosAngle()
                {
                    Gl.glLoadIdentity();
                    Glu.gluLookAt(0, 0, 2000 * m_fScale, 0, 0, 0, 0, 1, 0);
                    OjwRotation(m_fPan, m_fTilt, m_fSwing);
                    OjwTranslate(m_fX, m_fY, m_fZ);
                    //SetLight();
                    // 로봇의 움직임 구현 -> 이걸 지면 움직임으로 이동
                    //OjwRotation(m_fPan_Robot, m_fTilt_Robot, m_fSwing_Robot);
                    //OjwTranslate(m_fX_Robot, m_fY_Robot, m_fZ_Robot);


                    OjwRotation(m_fPan_Robot, m_fTilt_Robot, m_fSwing_Robot);
                    OjwTranslate(m_fX_Robot, m_fY_Robot, m_fZ_Robot);
                }

                public void InitPosAngle(float fPan, float fTilt, float fSwing, float fX, float fY, float fZ)
                {
                    //             Gl.glColor3f(1.0f, 1.0f, 1.0f);
                    //             Gl.glRasterPos2i(20, 60);
                    //             PrintString("THE QUICK BROWN FOX JUMPS");

                    SetAngle_Display(fPan, fTilt, fSwing);
                    SetPos_Display(fX, fY, fZ);
                    Gl.glLoadIdentity();
                    Glu.gluLookAt(0, 0, 1500 * m_fScale, 0, 0, 0, 0, 1, 0);
                    //SetLight();

                    OjwRotation(m_fPan, m_fTilt, m_fSwing);
                    OjwTranslate(m_fX, m_fY, m_fZ);

                    // 로봇의 움직임 구현 -> 이걸 지면 움직임으로 이동
                    //OjwRotation(m_fPan_Robot, m_fTilt_Robot, m_fSwing_Robot);
                    //OjwTranslate(m_fX_Robot, m_fY_Robot, m_fZ_Robot);
                }
                #endregion InitPosAngle

                #region OjwTranslate
                public void OjwTranslate(float fX, float fY, float fZ)
                {
                    Gl.glTranslatef(fX, fY, fZ);	// viewport = 0 0 0 and this is 6 deep
                }
                #endregion

                #region OjwRotation
                public void OjwRotation(float fPan, float fTilt, float fSwing)
                {
                    if (fPan != 0)
                    {
                        Gl.glRotatef(fPan, 0.0f, 1.0f, 0.0f);
                        //Rotation(0.0f, fPan, 0.0f, ref m_afCalcPos[0], ref m_afCalcPos[1], ref m_afCalcPos[2]);
                    }
                    if (fTilt != 0)
                    {
                        Gl.glRotatef(fTilt, 1.0f, 0.0f, 0.0f);
                        //Rotation(fTilt, 0.0f, 0.0f, ref m_afCalcPos[0], ref m_afCalcPos[1], ref m_afCalcPos[2]);
                    }
                    if (fSwing != 0)
                    {
                        Gl.glRotatef(fSwing, 0.0f, 0.0f, 1.0f);
                        //Rotation(0.0f, 0.0f, fSwing, ref m_afCalcPos[0], ref m_afCalcPos[1], ref m_afCalcPos[2]);
                    }
                }
                #endregion

                // Simply function to calculate only the result of the rotation
                // Kor: 단순히 회전의 결과값만 내 주는(계산해 주는) 함수
                #region Rotation
                public void Rotation(float ax, float ay, float az, ref float x, ref float y, ref float z)
                {
                    //float fr = 3.14159f / 180.0f;
                    //float ax2 = ax * fr;
                    //float ay2 = ay * fr;
                    //float az2 = az * fr;

                    float ax2 = ax * 0.01745f;
                    float ay2 = ay * 0.01745f;
                    float az2 = az * 0.01745f;

                    //    →X(Left), ↑Y(Up), ●Z(Front)
                    // Rotation(Z)(Roll)
                    /*
                     cos, -sin, 0, 0
                     sin,  cos, 0, 0
                       0,    0, 1, 0
                       0,    0, 0, 1
                     */

                    // Rotation(X)(Pitch)
                    /*
                     1,   0,    0, 0
                     0, cos, -sin, 0
                     0, sin,  cos, 0
                     0,   0,    0, 1
                     */

                    // Rotation(Y)(Yaw)
                    /*
                     cos, 0, -sin, 0
                       0, 1,    0, 0
                     sin, 0,  cos, 0
                       0, 0,    0, 1
                     */

                    float z1, x2, y2;
                    float fCx = (float)Math.Cos(ax2);
                    float fCy = (float)Math.Cos(ay2);
                    float fCz = (float)Math.Cos(az2);
                    float fSx = (float)Math.Sin(ax2);
                    float fSy = (float)Math.Sin(ay2);
                    float fSz = (float)Math.Sin(az2);

                    //x1 = x * fCy + z * fSy;   // Rotation(y)
                    //y1 = y;
                    //z1 = -x * fSy + z * fCy;

                    //x2 = x1;    // Rotation(x)
                    //y2 = y1 * fCx - z1 * fSx;
                    //z2 = y1 * fSx + z1 * fCx;

                    //x = x2 * fCz - y2 * fSz;    // Rotation(z)
                    //y = x2 * fSz + y2 * fCz;
                    //z = z2;

                    x2 = x * fCy + z * fSy;   // Rotation(y)
                    z1 = -x * fSy + z * fCy;

                    y2 = y * fCx - z1 * fSx;

                    z = y * fSx + z1 * fCx;
                    x = x2 * fCz - y2 * fSz;    // Rotation(z)
                    y = x2 * fSz + y2 * fCz;
                }
                #endregion Rotation

                #endregion OpenGL: Rotate, move, reset, etc. The basic control functions(Kor: OpenGL 회전, 이동, 초기화등 기본제어함수)

                #region Class Control
                private bool m_bEmptyBody = false;
                public void SetClass_EmptyBody(bool bEmpty)
                {
                    m_bEmptyBody = bEmpty;
                }

                private bool m_bAseFake = false;
                private int m_nAseMulti = 1;
                public void SetClass_AseFake(bool bFake, int nMulti)
                {
                    m_bAseFake = bFake;
                    m_nAseMulti = ((nMulti < 1) ? 1 : nMulti);
                }

                private const int _CNT_SECOND_COLOR = 100;
                private int m_nSecondColor_Num = 0;
                private bool[] m_abSecondColor = new bool[_CNT_SECOND_COLOR];
                private Color[] m_acSecondColor = new Color[_CNT_SECOND_COLOR];
                private int[] m_anSecondColor_GroupA = new int[_CNT_SECOND_COLOR];
                private int[] m_anSecondColor_GroupB = new int[_CNT_SECOND_COLOR];
                private int[] m_anSecondColor_GroupC = new int[_CNT_SECOND_COLOR];
                // save up to 10(Kor: 100개 까지만 저장)
                public bool SetColor_Second(int nNum, int nGroupA, int nGroupB, int nGroupC, Color cColor)
                {
                    if ((nNum < 0) || (nNum >= _CNT_SECOND_COLOR)) return false;
                    m_abSecondColor[nNum] = true;
                    m_acSecondColor[nNum] = cColor;
                    m_anSecondColor_GroupA[nNum] = nGroupA;
                    m_anSecondColor_GroupB[nNum] = nGroupB;
                    m_anSecondColor_GroupC[nNum] = nGroupC;
                    return true;
                }
                public bool AddColor_Second(int nGroupA, int nGroupB, int nGroupC, Color cColor)
                {
                    if (m_nSecondColor_Num >= _CNT_SECOND_COLOR) return false;
                    return SetColor_Second(m_nSecondColor_Num++, nGroupA, nGroupB, nGroupC, cColor);
                }
                public void ClearColor_Second()
                {
                    /*m_bSecondColor = false;*/
                    //m_anSecondColor_Group.Initialize();
                    for (int i = 0; i < _CNT_SECOND_COLOR; i++) m_abSecondColor[i] = false;
                    m_nSecondColor_Num = 0;
                }

                private bool m_bPickColor = true;
                private bool m_bPickAlpha = true;
                private Color m_cPickColor = Color.Green;//Color.FromArgb(50, 50, 255);
                private float m_fPickAlpha = 0.5f;//1.0f;
                public void SetPick_ColorMode(bool bOn)
                {
                    m_bPickColor = bOn;
                }
                public void SetPick_AlphaMode(bool bOn)
                {
                    m_bPickAlpha = bOn;
                }
                public void SetPick_ColorValue(Color cColor)
                {
                    m_cPickColor = cColor;
                }
                public void SetPick_AlphaValue(float fAlpha)
                {
                    m_fPickAlpha = fAlpha;
                }

                private int m_nFastMode = 0;
                private bool[] m_abMake = new bool[4096]; // 0x1000 ~ 0x1fff
                public void SetDrawFastMode(int nMode) // 0 - Normal, 1 - fastmode(make & draw)
                {
                    m_nFastMode = nMode;
                }
                public int GetDrawFastMode()
                {
                    return m_nFastMode;
                }

                //private float m_fRot_Pan = 0.0f;
                //private float m_fRot_Tilt = 0.0f;
                //private float m_fRot_Swing = 0.0f;
                //CTimer m_CTId_Pan = new CTimer();
                //CTimer m_CTId_Tilt = new CTimer();
                //CTimer m_CTId_Swing = new CTimer();
                //private 

                private float m_fTrackDisplay_Rot_Limit = 360.0f;
                private float m_fPanDisplay_Rot_Limit = 360.0f;
                private float m_fTiltDisplay_Rot_Limit = 360.0f;
                private float m_fSwingDisplay_Rot_Limit = 360.0f;
                private int m_nBackupCnt_HistoryFileOpen = 0;
                private int m_nDrawClass_Pos = 0;
                private const int _CNT_TRACK_BALL = 256;//*10;
                private int m_nTrackBall = 0;
                //private SVector3D_t[] m_aSVec_Track = new SVector3D_t[_CNT_TRACK_BALL];
                private STrackD_t[] m_aSTrack = new STrackD_t[_CNT_TRACK_BALL];
                private float m_fTrackValue = 0.0f;
                private int m_nSelectedMotor = -1;
                private int m_nSelectedInverseKinematics = -1;

                private bool m_bSyncSelectedMotor = false;
                public void SelectMotor_Sync_With_Mouse(bool bSync) { m_bSyncSelectedMotor = bSync; } // 마우스가 클릭되면 기존 selectedmotor 를 해제할 것인지 ...
                public void SelectMotor(int nAxis)
                {
                    m_nSelected_InverseKinematicsNumber = 255;
                    //m_nSelectedInverseKinematics = -1;
                    m_nSelectedMotor = nAxis; 
                    //m_anSelectedGroup[0] = nGroupA;
                    m_anSelectedGroup[1] = m_nSelectedMotor;// nGroupB;
                    //m_anSelectedGroup[2] = nGroupC;
                } // -1을 넣으면 선택 안함
                public void SelectInverseKinematics(int nNum) { m_nSelectedInverseKinematics = nNum; m_nSelectedMotor = -1; } // -1을 넣으면 선택 안함
                private float m_fTest = (float)Math.PI / 2.0f;

                private float[] m_afAngle_Offset = new float[1000];
                public void OjwDraw_Class(COjwDisp OjwDisp)
                {
                    bool bWheel = false;
                    float fMulti = (OjwDisp.fMulti <= 0) ? 1 : OjwDisp.fMulti;
                    //if (S3d.fMulti <= 0) S3d.fMulti = 1.0;
                    // 0x 1111 1111(Formular group)   1111 1111(group A) 1 1111 1111(group B(0~255:motor, 256~511:etc group))  111 1111(group C(0~127))
                    //uint nObjectName = (uint)OjwDisp.nPickGroup_A * 256 * 256 + (uint)OjwDisp.nPickGroup_B * 256 + (uint)OjwDisp.nPickGroup_C;
                    //uint unObjectName = (uint)(OjwDisp.nInverseKinematicsNumber & 0xff) * 256 * 256 * 256 + (uint)(OjwDisp.nPickGroup_A & 0xff) * 256 * 256 + ((uint)OjwDisp.nPickGroup_B & 0x1ff) * 128 + ((uint)OjwDisp.nPickGroup_C & 0x7f);
                    #region Kor
                    // 0x 1111 1111(수식그룹)   1111 1111(그룹 A) 1 1111 1111(그룹 B(0~255:모터, 256~511:기타그룹))  111 1111(그룹 C(0~127))
                    //uint nObjectName = (uint)OjwDisp.nPickGroup_A * 256 * 256 + (uint)OjwDisp.nPickGroup_B * 256 + (uint)OjwDisp.nPickGroup_C;
                    //uint unObjectName = (uint)(OjwDisp.nInverseKinematicsNumber & 0xff) * 256 * 256 * 256 + (uint)(OjwDisp.nPickGroup_A & 0xff) * 256 * 256 + ((uint)OjwDisp.nPickGroup_B & 0x1ff) * 128 + ((uint)OjwDisp.nPickGroup_C & 0x7f);
                    #endregion Kor
                    uint unObjectName = (uint)((OjwDisp.nInverseKinematicsNumber & 0xff) << 24) + ((uint)(OjwDisp.nPickGroup_A & 0xff) << 16) + (((uint)OjwDisp.nPickGroup_B & 0x1ff) << 7) + ((uint)OjwDisp.nPickGroup_C & 0x7f);

                    bool bMate = m_bMateMode;
                    if (bMate == true)
                    {
                    }
                    else
                    {
                        if ((m_bPickMode == true) && (unObjectName > 0)) { PushName(unObjectName); }
                    }

                    int nGroupA, nGroupB, nGroupC, nInverseKinematics;
                    Color cColor = OjwDisp.cColor;
                    GetPickingData(out nGroupA, out nGroupB, out nGroupC, out nInverseKinematics);
                    float fAlpha = OjwDisp.fAlpha;
                    if (m_bAlpha == true)
                    {
                        if (m_fAlpha < 1.0f) fAlpha = m_fAlpha;
                    }
                    //float fAlpha = (m_bAlpha) ? m_fAlpha : OjwDisp.fAlpha;
                    bool bPicked = false;
                    //if (m_bPickColor == true)
                    //{
                    
                    bool bSelectObject_DrawClass = SelectObject_Check(m_nDrawClass_Pos);
                    bool bMouseClick = ((nGroupA > 0) &&//(((nGroupA + nGroupB) > 0) && // 20160420 - 0 번 모터를 선택시 전체 그룹이 선택되는 문제 해결
                        (OjwDisp.nPickGroup_A == nGroupA) &&
                        (OjwDisp.nPickGroup_B == nGroupB)
                        ) ? true : false;

                    if (bMouseClick == true)
                    {
                        if (
                                (m_bSyncSelectedMotor == true) 
                                && 
                                (
                                    ((m_nSelectedInverseKinematics < 0) && (m_nSelectedMotor >= 0))
                                    ||
                                    ((m_nSelectedInverseKinematics >= 0) && (m_nSelectedInverseKinematics != 255))
                                )
                            )
                        {
                            bMouseClick = false;
                        }
                    }

                        if(
                        //    (((nGroupA + nGroupB) > 0) &&
                        //(OjwDisp.nPickGroup_A == nGroupA) &&
                        //(OjwDisp.nPickGroup_B == nGroupB)
                        //) 
                        //    ||
                            ((bMouseClick == true) && (m_bMousePickEnable == true)) ||
                            ((bSelectObject_DrawClass == true) && (SelectObject_Enable() == true))
                            ||
                            ((m_nSelectedInverseKinematics < 0) && ((m_nSelectedMotor >= 0) && (OjwDisp.nPickGroup_B == m_nSelectedMotor)) && (OjwDisp.nPickGroup_A > 0)) // 20160420 - 0 번 모터를 선택시 전체 그룹이 선택되는 문제 해결
                            ||
                            ((m_nSelectedInverseKinematics >= 0) && (OjwDisp.nInverseKinematicsNumber == m_nSelectedInverseKinematics) && (OjwDisp.nPickGroup_A > 0))     // 20160420 - 0 번 모터를 선택시 전체 그룹이 선택되는 문제 해결                        
                        )
                        {
                            if (m_bPickColor) cColor = m_cPickColor;// Color.FromArgb(50, 50, 255);// Color.FromArgb(100, 0, 0);
                            if (m_bPickAlpha) fAlpha = m_fPickAlpha;
                            bPicked = true;

                            //if ((bSelectObject_DrawClass == true) && (SelectObject_Enable() == true))
                            //{
                            //    m_nSelectedMotor = 
                            //}
                            //else 
                            

                            // ojw5014
                            m_nSelectedItem = m_nDrawClass_Pos; // 이거 한번 추가해 보자. 클릭해도 선택 되게...
                        }                        
                    //}

                    for (int i = 0; i < _CNT_SECOND_COLOR; i++)
                    {
                        if (m_abSecondColor[i] == true)
                        {
                            int nGA = m_anSecondColor_GroupA[i];
                            int nGB = m_anSecondColor_GroupB[i];
                            if (((nGA + nGB) > 0) &&
                            (nGA > 0) && // 20160420 - 0 번 모터를 선택시 전체 그룹이 선택되는 문제 해결
                            (nGA == OjwDisp.nPickGroup_A) &&
                            (nGB == OjwDisp.nPickGroup_B)
                            )
                            {
                                cColor = m_acSecondColor[i];
                                break;
                            }
                        }
                    }

                    if (OjwDisp.bInit == true)
                    {
                        InitPosAngle();
                        m_afCalcPos[0] = 0;
                        m_afCalcPos[1] = 0;
                        m_afCalcPos[2] = 0;
                        m_afCalcAngle[0] = 0;
                        m_afCalcAngle[1] = 0;
                        m_afCalcAngle[2] = 0;
                    }

                    //Gl.glEnable(Gl.GL_BLEND);
                    //Gl.glBlendFunc(Gl.GL_SRC_ALPHA, Gl.GL_ONE_MINUS_SRC_ALPHA);
                    //Gl.glEnable(Gl.GL_ALPHA_TEST);

                    //SetLight2();
                                        
                    for (int j = 0; j < 3; j++)
                    {
                        OjwTranslate(OjwDisp.afTrans[j].x, OjwDisp.afTrans[j].y, OjwDisp.afTrans[j].z);
                        OjwRotation(OjwDisp.afRot[j].pan, OjwDisp.afRot[j].tilt, OjwDisp.afRot[j].swing);

                        m_afCalcAngle[0] += OjwDisp.afRot[j].pan;
                        m_afCalcAngle[1] += OjwDisp.afRot[j].tilt;
                        m_afCalcAngle[2] += OjwDisp.afRot[j].swing;
                        Rotation(m_afCalcAngle[1], m_afCalcAngle[0], m_afCalcAngle[2], ref m_afCalcPos[0], ref m_afCalcPos[1], ref m_afCalcPos[2]);
                        float fCalcX = OjwDisp.afTrans[j].x;
                        float fCalcY = OjwDisp.afTrans[j].y;
                        float fCalcZ = OjwDisp.afTrans[j].z;
                        Rotation(m_afCalcAngle[1], m_afCalcAngle[0], m_afCalcAngle[2], ref fCalcX, ref fCalcY, ref fCalcZ);
                        m_afCalcPos[0] += fCalcX;
                        m_afCalcPos[1] += fCalcY;
                        m_afCalcPos[2] += fCalcZ;
                    }

                    //             if (bPicking == true)
                    //             {
                    //                 m_afCalcPos_Event[0] = m_afCalcPos[0];
                    //                 m_afCalcPos_Event[1] = m_afCalcPos[1];
                    //                 m_afCalcPos_Event[2] = m_afCalcPos[2];
                    //             }

                    bool bFilled = ((m_bEmptyBody == true) ? false : OjwDisp.bFilled);

                    //int nTrackBall = m_nTrackBall;
                    //
                    SAngle3D_t SAngle = new SAngle3D_t();
                    SAngle3D_t SAngle_Offset = new SAngle3D_t();
                    SVector3D_t SVector = new SVector3D_t();
                    SAngle3D_t SRot = new SAngle3D_t();
                    float fTrackValue = 0.0f;
                    int nTrackMode = 0;
                    
                    SAngle.pan = ((OjwDisp.nAxisMoveType == 0) ? OjwDisp.fAngle : 0) * (int)Math.Pow(-1, OjwDisp.nDir) * fMulti;
                    SAngle.tilt = ((OjwDisp.nAxisMoveType == 1) ? OjwDisp.fAngle : 0) * (int)Math.Pow(-1, OjwDisp.nDir) * fMulti;
                    SAngle.swing = ((OjwDisp.nAxisMoveType == 2) ? OjwDisp.fAngle : 0) * (int)Math.Pow(-1, OjwDisp.nDir) * fMulti;
                    SVector.x = ((OjwDisp.nAxisMoveType == 3) ? OjwDisp.fAngle : 0) * (int)Math.Pow(-1, OjwDisp.nDir) * fMulti;
                    SVector.y = ((OjwDisp.nAxisMoveType == 4) ? OjwDisp.fAngle : 0) * (int)Math.Pow(-1, OjwDisp.nDir) * fMulti;
                    SVector.z = ((OjwDisp.nAxisMoveType == 5) ? OjwDisp.fAngle : 0) * (int)Math.Pow(-1, OjwDisp.nDir) * fMulti;
                    SRot.pan = ((OjwDisp.nAxisMoveType == 6) ? OjwDisp.fAngle : 0) * (int)Math.Pow(-1, OjwDisp.nDir) * fMulti;
                    SRot.tilt = ((OjwDisp.nAxisMoveType == 7) ? OjwDisp.fAngle : 0) * (int)Math.Pow(-1, OjwDisp.nDir) * fMulti;
                    SRot.swing = ((OjwDisp.nAxisMoveType == 8) ? OjwDisp.fAngle : 0) * (int)Math.Pow(-1, OjwDisp.nDir) * fMulti;

                    /////////// Offset
                    float fAngle_Offset = 0.0f;
                    float fVar = 0.0f;
                    //float[] afVar = new float[1000];
                    float fRes = 0.0f;
                    int nID_Motor = -1;
                    int nID_Offset = -1;
                    if (OjwDisp.strAngle_Offset != null)
                    {
                        if (OjwDisp.strAngle_Offset.Length > 1) // 한개짜리 데이터 명령은 없다.
                        {
                            // ex //
                            // load;result;=;t1;*;-1;+;90;getline;20;50;result
                            // =;t1;*;-1;+;90;getpivot;result;50;20;55;40;-;90;*;-1

                            int nMode = -1; // 0 - load
                            int nArg = 0;
                            List<float> lstVar = new List<float>();
                            List<String> lstVar_Str = new List<String>();
                            lstVar.Clear();
                            lstVar.Add(0);
                            //lstVar.AddRange(m_afMot);
                            lstVar_Str.Clear();
                            lstVar_Str.Add("result");
                            //lstVar_Str.AddRange(m_astrMot);

                            float fArg1 = 0;
                            float fArg2 = 0;
                            float fArg3 = 0;
                            float fArg4 = 0;
                            float fArg5 = 0;
                            int nMotIndex = -1;
                            int nVarIndex = 0; // res
                            string[] astr = OjwDisp.strAngle_Offset.ToLower().Split(';');
                            for (int nOff = 0; nOff < astr.Length; nOff++)
                            {
                                if (nArg > 0)
                                {
                                    if (nMode == 0) // 변수 선언
                                    {
                                        bool bMot = false;
                                        if (astr[nOff].Length > 1)
                                        {
                                            if (astr[nOff][0] == 't')
                                            {
                                                string str = astr[nOff].Substring(1);
                                                if (CConvert.IsDigit(str) == true)
                                                {
                                                    bMot = true;
                                                    nMotIndex = CConvert.StrToInt(str);
                                                }
                                            }
                                        }
                                        if (bMot == false)
                                        {
                                            nMotIndex = -1;

                                            int nFind = lstVar_Str.IndexOf(astr[nOff]);
                                            if (nFind < 0)
                                            {
                                                lstVar.Add(0);
                                                lstVar_Str.Add(astr[nOff]);
                                                nVarIndex = lstVar_Str.Count - 1;
                                            }
                                            else
                                            {
                                                nVarIndex = nFind;
                                            }
                                        }
                                    }
                                    #region =, +, -. *, /, %
                                    else if ((nMode >= 1) && (nMode <= 29)) // =, +, -. *, /, %
                                    {
                                        float fMinus = 1;
                                        string strVal = astr[nOff];
                                        if (strVal.Length > 0)
                                        {
                                            if (strVal[0] == '-')
                                            {
                                                fMinus = -1;
                                                strVal = strVal.Substring(1);
                                            }
                                        }
                                        float fTmp = 0;
                                        bool bPass = true;
                                        if (CConvert.IsDigit(strVal) == true)
                                        {
                                            fTmp = CConvert.StrToFloat(strVal);
                                            fTmp *= fMinus;
                                        }
                                        else
                                        {
                                            // 변수일때
                                            int nMotIndex_Tmp = -1;
                                            if (strVal.Length > 1) // 모터변수 체크
                                            {
                                                if (strVal[0] == 't')
                                                {
                                                    string str = strVal.Substring(1);
                                                    if (CConvert.IsDigit(str) == true)
                                                    {
                                                        nMotIndex_Tmp = CConvert.StrToInt(str);
                                                    }
                                                }
                                            }
                                            if (nMotIndex_Tmp >= 0)
                                            {
                                                fTmp = m_afMot[nMotIndex_Tmp];
                                            }
                                            else
                                            {
                                                int nFind = lstVar_Str.IndexOf(strVal);
                                                if (nFind >= 0)
                                                {
                                                    fTmp = lstVar[nFind];
                                                }
                                                else bPass = false;
                                            }
                                            fTmp *= fMinus;
                                        }
                                        if (bPass == true)
                                        {
                                            if (nArg > 5)
                                            {
                                                fArg5 = fTmp; fArg4 = 0; fArg3 = 0; fArg2 = 0; fArg1 = 0;
                                            }
                                            else if (nArg > 4)
                                            {
                                                fArg4 = fTmp; fArg3 = 0; fArg2 = 0; fArg1 = 0; 
                                            }
                                            else if (nArg > 3)
                                            {
                                                fArg3 = fTmp; fArg2 = 0; fArg1 = 0; 
                                            }
                                            else if (nArg > 2)
                                            {
                                                fArg2 = fTmp; fArg1 = 0;
                                            }
                                            else if (nArg > 1)
                                                fArg1 = fTmp;
                                            else
                                            {
                                                float fGet = 0;
                                                if (nMotIndex >= 0) fGet = m_afMot[nMotIndex];
                                                else if (nVarIndex >= 0) fGet = lstVar[nVarIndex];
                                                //float fGet = (nMotIndex >= 0) ? m_afMot[nMotIndex] : lstVar[nVarIndex];
                                                switch (nMode)
                                                {
                                                    case 18: m_afAngle_Offset[(int)fTmp] = fGet; break; // set
                                                    case 19: fGet = m_afAngle_Offset[(int)fTmp]; break; // get
                                                    case 20: // Function 계산, 다만 한시점 뒤에 계산될 수 있다.
                                                    {
                                                        int nInverseNum = (int)fTmp;
                                                        #region Kinematics Control
                                                        float fPos_X, fPos_Y, fPos_Z;
                                                        CalcF(nInverseKinematics, false, out fPos_X, out fPos_Y, out fPos_Z);
                                                        m_dPos_X = (double)fPos_X;
                                                        m_dPos_Y = (double)fPos_Y;
                                                        m_dPos_Z = (double)fPos_Z;

                                                        int nMotCnt = m_CHeader.pSOjwCode[nInverseNum].nMotor_Max;
                                                        if (nMotCnt > 0)
                                                        {
                                                            CKinematics.CInverse.SetValue_ClearAll(ref m_CHeader.pSOjwCode[nInverseNum]);
                                                            CKinematics.CInverse.SetValue_X(m_dPos_X);
                                                            CKinematics.CInverse.SetValue_Y(m_dPos_Y);
                                                            CKinematics.CInverse.SetValue_Z(m_dPos_Z);

                                                            double[] adMot = new double[m_afMot.Length];
                                                            for (int i = 0; i < m_afMot.Length; i++) adMot[i] = (double)m_afMot[i];
                                                            CKinematics.CInverse.SetValue_Motor(adMot);
                                                            adMot = null;
                                                            CKinematics.CInverse.CalcCode(ref m_CHeader.pSOjwCode[nInverseNum]);
                                                            for (int i = 0; i < nMotCnt; i++)
                                                            {
                                                                int nMotNum = m_CHeader.pSOjwCode[nInverseNum].pnMotor_Number[i];
                                                                SetData(nMotNum, (float)CKinematics.CInverse.GetValue_Motor(nMotNum));
                                                            }
                                                        }
                                                        //else // 자동수식계산
                                                        //{
                                                        //    CalcInv(nInverseNum, (float)m_dPos_X, (float)m_dPos_Y, (float)m_dPos_Z, 10, 0.1f);
                                                        //}
                                                        /////////////////
                                                        #endregion Kinematics Control
                                                    }
                                                    break;
                                                    case 21: fGet = (float)Math.Abs(fTmp); break;
                                                    case 22: fGet = (float)Math.Pow(fTmp, 2.0f); break;
                                                    case 23: fGet = (float)Math.Sqrt(fTmp); break;
                                                    case 24: fGet = (float)Math.Pow(fArg1, fTmp); break;
                                                    case 25: fGet = ((fArg3 == fArg2) ? fArg1 : fTmp); break; // ==
                                                    case 26: fGet = ((fArg3 >= fArg2) ? fArg1 : fTmp); break; // ==
                                                    case 27: fGet = ((fArg3 <= fArg2) ? fArg1 : fTmp); break; // ==
                                                    case 28: fGet = ((fArg3 > fArg2) ? fArg1 : fTmp); break; // ==
                                                    case 29: fGet = ((fArg3 < fArg2) ? fArg1 : fTmp); break; // ==
                                                    case 1: fGet = fTmp; break;
                                                    case 2: fGet += fTmp; break;
                                                    case 3: fGet -= fTmp; break;
                                                    case 4: fGet *= fTmp; break;
                                                    case 5:
                                                        {
                                                            fGet /= fTmp;
                                                            if (float.IsNaN(fGet)) fGet = 0;
                                                            else if (float.IsInfinity(fGet)) fGet = 0;
                                                        }
                                                        break;
                                                    case 6: fGet %= fTmp; break;
                                                    case 7: fGet = (float)CMath.Sin((double)fTmp); break;
                                                    case 8: fGet = (float)CMath.Cos((double)fTmp); break;
                                                    case 9: fGet = (float)CMath.Tan((double)fTmp); break;
                                                    case 10: fGet = (float)CMath.ASin((double)fTmp); break;
                                                    case 11: fGet = (float)CMath.ACos((double)fTmp); break;
                                                    case 12: fGet = (float)CMath.ATan((double)fTmp); break;
                                                    case 13:
                                                        fGet = (float)CMath.ATan2((double)fArg1, (double)fTmp);
                                                        break;
                                                    case 14: // 3변의 길이가 주어질 때 각(arg : 변 Left, 변 Right, 변 가장 먼곳)
                                                        {
                                                            // T=acos((a2+b2-c2)/2ab), a, b, c(가장 멀리있는 변)
                                                            float a = fArg2; // 가장 먼저 입력한 아규먼트
                                                            float b = fArg1;
                                                            float c = fTmp;
                                                            fGet = (float)(CMath.ACos((a * a + b * b - c * c) / (2 * a * b)));
                                                            if (float.IsNaN(fGet)) fGet = 0;
                                                            else if (float.IsInfinity(fGet)) fGet = 0;
                                                        }
                                                        break;
                                                    case 15: // 2변의 길이와 사잇각이 주어질 때 변의 길이(arg : 각도, 변1, 변2)
                                                        {
                                                            // c2=a2+b2-2abCos(T), a, b, T
                                                            float T = fArg2; // 가장 먼저 입력한 아규먼트
                                                            float a = fArg1; 
                                                            float b = fTmp;
                                                            fGet = (float)Math.Sqrt(a * a + b * b - 2 * a * b * CMath.Cos(T));
                                                            if (float.IsNaN(fGet)) fGet = 0;
                                                            else if (float.IsInfinity(fGet)) fGet = 0;
                                                        }
                                                        break;
                                                    case 16: // 위의 피벗축의 각도가 변할때의 아래 축의 각도값 (index, angle, left, top, right, bottom)
                                                        {
                                                            /*
                                                                    top = 20
                                                                    ======
                                                            left=50 |      \
                                                                    |       \ right = 55
                                                                    |        \
                                                                    |         \
                                                                    ===========
                                                                      bottom = 40 일때
                                                             ex) bottom left (index 2) 의 각도값을 구하려면(내각) -> 
                                                             * 단, top-left 의 각도값이 93 도 라고 가정한다면...(이걸 나중에 t1 + 90 정도로...)
                                                                 getpivot;2;93;50;20;55;40;
                                                            */
                                                            int nIndex = (int)fArg5;
                                                            float T = fArg4; // 가장 먼저 입력한 아규먼트
                                                            float left = fArg3;
                                                            float top = fArg2;
                                                            float right = fArg1;
                                                            float bottom = fTmp;

                                                            float line = (float)Math.Sqrt(left * left + top * top - 2 * left * top * CMath.Cos(T));
                                                            
                                                            if (nIndex == 0) fGet = T;
                                                            else if (nIndex == 1)
                                                            {
                                                                float a = top;
                                                                float b = line;
                                                                float c = left;
                                                                float angle0 = (float)(CMath.ACos((a * a + b * b - c * c) / (2 * a * b)));
                                                                a = right;
                                                                b = line;
                                                                c = bottom;
                                                                float angle1 = (float)(CMath.ACos((a * a + b * b - c * c) / (2 * a * b)));
                                                                fGet = angle0 + angle1;
                                                            }
                                                            else if (nIndex == 2)
                                                            {
                                                                float a = left;
                                                                float b = line;
                                                                float c = top;
                                                                float angle0 = (float)(CMath.ACos((a * a + b * b - c * c) / (2 * a * b)));
                                                                a = bottom;
                                                                b = line;
                                                                c = right;
                                                                float angle1 = (float)(CMath.ACos((a * a + b * b - c * c) / (2 * a * b)));
                                                                fGet = angle0 + angle1;
                                                            }
                                                            else // nIndex == 3
                                                            {
                                                                float a = right;
                                                                float b = bottom;
                                                                float c = line;
                                                                fGet = (float)(CMath.ACos((a * a + b * b - c * c) / (2 * a * b)));
                                                            }
                                                            if (float.IsNaN(fGet)) fGet = 0;
                                                            else if (float.IsInfinity(fGet)) fGet = 0;
                                                            //fGet = 
                                                        }
                                                        break;
                                                    case 17: // 위의 피벗축계산식과 같으나 주어진 내각을 90도로 초기 설정된 값을 가정,
                                                        {
                                                            /*
                                                                    top = 20
                                                                    ======
                                                            left=50 |      \
                                                                    |       \ right = 55
                                                                    |        \
                                                                    |         \
                                                                    ===========
                                                                      bottom = 40 일때
                                                             ex) bottom left (index 2) 의 각도값을 구하려면(내각) -> 
                                                             * 단, top-left 의 각도값이 93 도 라고 가정한다면...(이걸 나중에 t1 + 90 정도로...)
                                                                 getpivot2;2;3;50;20;55;40;
                                                                 getpivot2;2;t1;50;20;55;40; // 모터값을 바로 연결하는 경우
                                                            */
                                                            int nIndex = (int)fArg5;
                                                            float T = fArg4 + 90;// +3.44f; // 가장 먼저 입력한 아규먼트
                                                            float left = fArg3;
                                                            float top = fArg2;
                                                            float right = fArg1;
                                                            float bottom = fTmp;

                                                            float line = (float)Math.Sqrt(left * left + top * top - 2 * left * top * CMath.Cos(T));
                                                            float line0 = (float)Math.Sqrt(left * left + top * top - 2 * left * top * CMath.Cos(90));

                                                            if (nIndex == 0) fGet = T - 90;
                                                            else if (nIndex == 1)
                                                            {
                                                                float a = top;
                                                                float b = line;
                                                                float b0 = line0;
                                                                float c = left;

                                                                float angle0_base = (float)(CMath.ACos((a * a + b0 * b0 - c * c) / (2 * a * b0)));

                                                                float angle0 = (float)(CMath.ACos((a * a + b * b - c * c) / (2 * a * b)));
                                                                a = right;
                                                                b = line;
                                                                b0 = line0;
                                                                c = bottom;
                                                                float angle1_base = (float)(CMath.ACos((a * a + b0 * b0 - c * c) / (2 * a * b0)));
                                                                float angle1 = (float)(CMath.ACos((a * a + b * b - c * c) / (2 * a * b)));
                                                                //fGet = angle0 + angle1 - 90;
                                                                //fGet = (angle0_base + angle1_base) - (angle0 + angle1);// -90;
                                                                float fVal0 = angle0_base + angle1_base;
                                                                float fVal1 = angle0 + angle1;
                                                                fGet = fVal0 - fVal1;
                                                            }
                                                            else if (nIndex == 2)
                                                            {
                                                                float a = left;
                                                                float b = line;
                                                                float b0 = line0;
                                                                float c = top;
                                                                float angle0_base = (float)(CMath.ACos((a * a + b0 * b0 - c * c) / (2 * a * b0)));
                                                                float angle0 = (float)(CMath.ACos((a * a + b * b - c * c) / (2 * a * b)));
                                                                a = bottom;
                                                                b = line;
                                                                c = right;
                                                                float angle1_base = (float)(CMath.ACos((a * a + b0 * b0 - c * c) / (2 * a * b0)));
                                                                float angle1 = (float)(CMath.ACos((a * a + b * b - c * c) / (2 * a * b)));
                                                                //fGet = angle0 + angle1 - 90;
                                                                //fGet = (angle0_base + angle1_base) - (angle0 + angle1);// -90;
                                                                float fVal0 = angle0_base + angle1_base;
                                                                float fVal1 = angle0 + angle1;
                                                                fGet = fVal1 - fVal0;
                                                            }
                                                            else // nIndex == 3
                                                            {
                                                                float a = right;
                                                                float b = bottom;
                                                                float c = line;
                                                                float c0 = line0;
                                                                //fGet = (float)(CMath.ACos((a * a + b * b - c * c) / (2 * a * b))) - 90;
                                                                float fVal0 = (float)(CMath.ACos((a * a + b * b - c0 * c0) / (2 * a * b)));
                                                                float fVal1 = (float)(CMath.ACos((a * a + b * b - c * c) / (2 * a * b)));
                                                                fGet = fVal1 - fVal0;
                                                            }
                                                            if (float.IsNaN(fGet)) fGet = 0;
                                                            else if (float.IsInfinity(fGet)) fGet = 0;
                                                            //fGet = 
                                                        }
                                                        break;
                                                }
                                                if (nMotIndex >= 0) m_afMot[nMotIndex] = fGet;
                                                else lstVar[nVarIndex] = fGet;
                                            }
                                        }
                                    }
                                    #endregion =, +, -. *, /, %

                                    nArg--;
                                    //continue;
                                }
                                if (astr[nOff] == "load")       { nMode = 0;  nArg = 1; }
                                else if (astr[nOff] == "=")     { nMode = 1;  nArg = 1; }
                                else if (astr[nOff] == "+")     { nMode = 2;  nArg = 1; }
                                else if (astr[nOff] == "-")     { nMode = 3;  nArg = 1; }
                                else if (astr[nOff] == "*")     { nMode = 4;  nArg = 1; }
                                else if (astr[nOff] == "/")     { nMode = 5;  nArg = 1; }
                                else if (astr[nOff] == "%")     { nMode = 6;  nArg = 1; }
                                else if (astr[nOff] == "sin")   { nMode = 7;  nArg = 1; }
                                else if (astr[nOff] == "cos")   { nMode = 8;  nArg = 1; }
                                else if (astr[nOff] == "tan")   { nMode = 9;  nArg = 1; }
                                else if (astr[nOff] == "asin")  { nMode = 10; nArg = 1; }
                                else if (astr[nOff] == "acos")  { nMode = 11; nArg = 1; }
                                else if (astr[nOff] == "atan")  { nMode = 12; nArg = 1; }
                                else if (astr[nOff] == "atan2") { nMode = 13; nArg = 2; }
                                else if (astr[nOff] == "getangle") { nMode = 14; nArg = 3; } // left, right, line(멀리있는 변의 길이)
                                else if (astr[nOff] == "getline") { nMode = 15; nArg = 3; } // angle, left, right, 
                                else if (astr[nOff] == "getpivot") { nMode = 16; nArg = 6; } // (index, angle, left, top, right, bottom) // index 는 topleft(0), topright(1), bottomleft(2), bottomright(3) 으로...
                                else if (astr[nOff] == "getpivot2") { nMode = 17; nArg = 6; } // (index, angle(내부적으로 90도가 더해진다.), left, top, right, bottom) // index 는 topleft(0), topright(1), bottomleft(2), bottomright(3) 으로...
                                else if (astr[nOff] == "set") { nMode = 18; nArg = 1; } // result 의 값을 m_afAngle_Offset[] 의 값으로 전달
                                else if (astr[nOff] == "get") { nMode = 19; nArg = 1; } // m_afAngle_Offset[] 의 값을 가져옴
                                else if (astr[nOff] == "function") { nMode = 20; nArg = 1; } // Inverse Kinematics Function 의 넘버링을 한번 계산함
                                else if (astr[nOff] == "abs") { nMode = 21; nArg = 1; } // 절대값 구하기
                                else if (astr[nOff] == "pow") { nMode = 22; nArg = 1; } // 
                                else if (astr[nOff] == "sqrt") { nMode = 23; nArg = 1; }
                                else if (astr[nOff] == "pow2") { nMode = 24; nArg = 2; } // 
                                else if (astr[nOff] == "==") { nMode = 25; nArg = 4; } // ==;a;b;c;d     a 와 b 가 같으면 결과에 c를 입력 아니면 d를 입력
                                else if (astr[nOff] == ">=") { nMode = 26; nArg = 4; } // >=;a;b;c;d     a 가 b 보다 크거나 같으면 결과에 c를 입력 아니면 d를 입력
                                else if (astr[nOff] == "<=") { nMode = 27; nArg = 4; } // <=;a;b;c;d     a 가 b 보다 작거나 같으면 결과에 c를 입력 아니면 d를 입력
                                else if (astr[nOff] == ">") { nMode = 28; nArg = 4; } // >=;a;b;c;d      a 가 b 보다 크면   결과에 c를 입력 아니면 d를 입력
                                else if (astr[nOff] == "<") { nMode = 29; nArg = 4; } // <=;a;b;c;d      a 가 b 보다 작으면 결과에 c를 입력 아니면 d를 입력
                            }
                            fAngle_Offset = lstVar[0];// result 의 최종 값을 입력
                            // test
                            // ex1) load;a;=;30;load;b;=;20;load;result;=;a;+;b;load;t1;=;result;/;2
                            // ex2) load;result;=;t1;*;-1;+;90;getline;20;50;result     -> 최초가 load;result 이기 때문이 맨 앞의 구절은 사실은 필요 없다.
                            //for (int i = 0; i < lstVar.Count; i++)
                            //{
                                //CMessage.Write("[{0}]{1}: {2}", i, lstVar_Str[i], lstVar[i]);
                            //}
#if false
                            // t : motor -> t1 = motor 1
                            // sin : sin -> sin30
                            // cos : cos -> cos30
                            // tan : tan30 -> tan30
                            // asin, acos, atan
                            int nMode = -1; // 0 +, 1 -, 2 *, 3 /, 4 =, 5 t
                            int nSub = 0;
                            string[] astr = OjwDisp.strAngle_Offset.ToLower().Split('|');
                            for (int nOff = 0; nOff < astr.Length; nOff++)
                            {
                                if      (astr[nOff] == "+") { nMode = 0; }
                                else if (astr[nOff] == "-") { nMode = 1; }
                                else if (astr[nOff] == "*") { nMode = 2; }
                                else if (astr[nOff] == "/") { nMode = 3; }
                                else if (astr[nOff] == "%") { nMode = 4; }
                                else if (astr[nOff] == "=") { nMode = 5; }
                                else if (astr[nOff] == "set") { nMode = 6; } // fRes 를 현재 모터값에 대입한다.
                                else if (astr[nOff] == "get") { nMode = 7; } // fRes <= 현재모터값

                                else if (astr[nOff] == "sin") { nMode = 10; }
                                else if (astr[nOff] == "cos") { nMode = 11; }
                                else if (astr[nOff] == "tan") { nMode = 12; }
                                else if (astr[nOff] == "asin") { nMode = 13; }
                                else if (astr[nOff] == "acos") { nMode = 14; }
                                else if (astr[nOff] == "atan") { nMode = 15; }

                                else if (astr[nOff] == "t") { nMode = 16; nSub = 1; }
                                else if (astr[nOff] == "v") { nMode = 17; nSub = 1; }
                                else if (astr[nOff] == "=>t") { nMode = 18; nSub = 1; }
                                else if (astr[nOff] == "=>v") { nMode = 19; nSub = 1; }
                                else if (astr[nOff] == "!t") { nMode = 20; nSub = 1; }
                                else if (astr[nOff] == "!v") { nMode = 21; nSub = 1; }
                                //else if (astr[nOff] == "!v") { nMode = 19; nSub = 1; } // !v|0|3  -> result = v0  와 동일
#if false
                                else
                                {
                                    switch (nMode)
                                    {
                                        case 10: fVar = (float)Ojw.CMath.Sin(CConvert.StrToFloat(astr[nOff])); break;
                                        case 11: fVar = (float)Ojw.CMath.Cos(CConvert.StrToFloat(astr[nOff])); break;
                                        case 12: fVar = (float)Ojw.CMath.Tan(CConvert.StrToFloat(astr[nOff])); break;
                                        case 13: fVar = (float)Ojw.CMath.ASin(CConvert.StrToFloat(astr[nOff])); break;
                                        case 14: fVar = (float)Ojw.CMath.ACos(CConvert.StrToFloat(astr[nOff])); break;
                                        case 15: fVar = (float)Ojw.CMath.ATan(CConvert.StrToFloat(astr[nOff])); break;
                                        case 16: fVar = m_afMot[CConvert.StrToInt(astr[nOff])]; break;
                                        case 17: fVar = afVar[CConvert.StrToInt(astr[nOff])]; break;
                                        case 18: m_afMot[CConvert.StrToInt(astr[nOff])] = fRes; break;
                                        case 19: afVar[CConvert.StrToInt(astr[nOff])] = fRes; break;
                                        default: fVar = CConvert.StrToFloat(astr[nOff]); break;
                                    }
                                    fRes = fVar;
                                    nMode = -1;
                                }
#endif

                                

                                
                                bool bIgnore = false;
                                if ((nMode >= 0) && (nMode < 16)) // 아규먼트가 없는 경우
                                {
                                    switch (nMode)
                                    {
                                        case 0: fVar += fRes; nMode = -1; break;
                                        case 1: fVar -= fRes; nMode = -1; break;
                                        case 2: fVar *= fRes; nMode = -1; break;
                                        case 3: fVar /= fRes; nMode = -1; break;
                                        case 4: fVar %= fRes; nMode = -1; break;
                                        case 5: fVar = fRes; fAngle_Offset = fRes; nMode = -1; break;
                                        // set
                                        case 6: 
                                            {
                                                SAngle.pan = ((OjwDisp.nAxisMoveType == 0) ? fRes : 0) * (int)Math.Pow(-1, OjwDisp.nDir) * fMulti;
                                                SAngle.tilt = ((OjwDisp.nAxisMoveType == 1) ? fRes : 0) * (int)Math.Pow(-1, OjwDisp.nDir) * fMulti;
                                                SAngle.swing = ((OjwDisp.nAxisMoveType == 2) ? fRes : 0) * (int)Math.Pow(-1, OjwDisp.nDir) * fMulti;
                                                SVector.x = ((OjwDisp.nAxisMoveType == 3) ? fRes : 0) * (int)Math.Pow(-1, OjwDisp.nDir) * fMulti;
                                                SVector.y = ((OjwDisp.nAxisMoveType == 4) ? fRes : 0) * (int)Math.Pow(-1, OjwDisp.nDir) * fMulti;
                                                SVector.z = ((OjwDisp.nAxisMoveType == 5) ? fRes : 0) * (int)Math.Pow(-1, OjwDisp.nDir) * fMulti;
                                                SRot.pan = ((OjwDisp.nAxisMoveType == 6) ? fRes : 0) * (int)Math.Pow(-1, OjwDisp.nDir) * fMulti;
                                                SRot.tilt = ((OjwDisp.nAxisMoveType == 7) ? fRes : 0) * (int)Math.Pow(-1, OjwDisp.nDir) * fMulti;
                                                SRot.swing = ((OjwDisp.nAxisMoveType == 8) ? fRes : 0) * (int)Math.Pow(-1, OjwDisp.nDir) * fMulti;
                                                bIgnore = true;
                                            }
                                            break;
                                        // get
                                        case 7: 
                                            {
                                                fRes = OjwDisp.fAngle; 
                                                nMode = -1; 
                                                bIgnore = true; 
                                            }
                                            break;
                                        case 10: fVar = (float)Ojw.CMath.Sin(fRes); nMode = -1; break;
                                        case 11: fVar = (float)Ojw.CMath.Cos(fRes); nMode = -1; break;
                                        case 12: fVar = (float)Ojw.CMath.Tan(fRes); nMode = -1; break;
                                        case 13: fVar = (float)Ojw.CMath.ASin(fRes); nMode = -1; break;
                                        case 14: fVar = (float)Ojw.CMath.ACos(fRes); nMode = -1; break;
                                        case 15: fVar = (float)Ojw.CMath.ATan(fRes); nMode = -1; break;
                                        default: fVar = CConvert.StrToFloat(astr[nOff]); nMode = -1; break;
                                    }
                                    if (bIgnore == false)
                                        fRes = fVar;
                                    // t|1|sin|*|150|/|300|asin|*|-1
                                    //fAngle_Offset = fRes;

                                }
                                else if (nMode >= 16) // 아규먼트가 있는 경우
                                {
                                    if (nSub > 0)
                                    {
                                        nSub--;
                                    }
                                    else
                                    {
                                        switch (nMode)
                                        {
                                            case 16: fRes = m_afMot[CConvert.StrToInt(astr[nOff])]; nMode = -1; break;
                                            case 17: fRes = m_afAngle_Offset[CConvert.StrToInt(astr[nOff])]; nMode = -1; break;
                                            case 18: nID_Motor = CConvert.StrToInt(astr[nOff]); m_afMot[nID_Motor] = fRes; nMode = -1; break;
                                            case 19: nID_Offset = CConvert.StrToInt(astr[nOff]); m_afAngle_Offset[nID_Offset] = fRes; nMode = -1; break;
                                            case 20: fRes = -m_afMot[CConvert.StrToInt(astr[nOff])]; nMode = -1; break;
                                            case 21: fRes = -m_afAngle_Offset[CConvert.StrToInt(astr[nOff])]; nMode = -1; break;
                                            default: fRes = CConvert.StrToFloat(astr[nOff]); nMode = -1; break;
                                        }

                                        // t|1|sin|150|*|/300|asin|*|-1
                                        //fAngle_Offset = fRes;
                                        nSub = 0;
                                    }
                                }
                                else
                                {
                                    fRes = CConvert.StrToFloat(astr[nOff]);
                                }
                            }
#endif
                        }
                    }
                    
                    // test - ojw5014
                    if (OjwDisp.nPickGroup_C == -3)
                    {
                        if (OjwDisp.nTextureStatus == 1)
                        {
                            // OjwDisp.cColor = Color.White;
                            // test 용 이미지 출력
                            LoadTextures("1.png"); //LoadTextures(OjwDisp.strTexture);
                            OjwDisp.nTextureStatus = 0;
                        }
                        Gl.glEnable(Gl.GL_TEXTURE_2D);
                        //OjwDisp.nPickGroup_C = 0;
                    }
                    else
                    {
                        //Gl.glDisable(Gl.GL_TEXTURE_2D);
                    }


                    if (OjwDisp.nAxisMoveType < 3)
                    {
                        // val2 = val % 60000
                        // result = val2 * 360 / 60000      (rpm)
#if false
                        SAngle_Offset.pan = ((OjwDisp.nAxisMoveType == 0) ? OjwDisp.fAngle_Offset : 0) * (int)Math.Pow(-1, OjwDisp.nDir);
                        SAngle_Offset.tilt = ((OjwDisp.nAxisMoveType == 1) ? OjwDisp.fAngle_Offset : 0) * (int)Math.Pow(-1, OjwDisp.nDir);
                        SAngle_Offset.swing = ((OjwDisp.nAxisMoveType == 2) ? OjwDisp.fAngle_Offset : 0) * (int)Math.Pow(-1, OjwDisp.nDir);
                        OjwRotation(SAngle.pan + SAngle_Offset.pan, SAngle.tilt + SAngle_Offset.tilt, SAngle.swing + SAngle_Offset.swing);
#else
                        //OjwRotation(SAngle.pan, SAngle.tilt, SAngle.swing);
                        SAngle_Offset.pan = ((OjwDisp.nAxisMoveType == 0) ? fAngle_Offset : 0) * (int)Math.Pow(-1, OjwDisp.nDir);
                        SAngle_Offset.tilt = ((OjwDisp.nAxisMoveType == 1) ? fAngle_Offset : 0) * (int)Math.Pow(-1, OjwDisp.nDir);
                        SAngle_Offset.swing = ((OjwDisp.nAxisMoveType == 2) ? fAngle_Offset : 0) * (int)Math.Pow(-1, OjwDisp.nDir);
                        OjwRotation(SAngle.pan + SAngle_Offset.pan, SAngle.tilt + SAngle_Offset.tilt, SAngle.swing + SAngle_Offset.swing);
#endif


                        if (bPicked == true)
                        {
                            //float fThick = 10.0f;
                            //float fLength = 50.0f;
                            //Axis_X(true, Color.Red, 1.0f, fThick, fLength);
                            //Axis_Y(true, Color.Green, 1.0f, fThick, fLength);
                            //Axis_Z(true, Color.Blue, 1.0f, fThick, fLength);
                        }
                    }
                    else if ((OjwDisp.nAxisMoveType >= 3) && (OjwDisp.nAxisMoveType < 6))
                    {
                        OjwTranslate(SVector.x, SVector.y, SVector.z);

                        #region 클릭하면 축이 나타나게...
#if false
                        if (bPicked == true)
                        {
                            float fThick = 10.0f;
                            float fLength = 50.0f;
                            Axis_X(true, Color.Red, 1.0f, fThick, fLength);
                            Axis_Y(true, Color.Green, 1.0f, fThick, fLength);
                            Axis_Z(true, Color.Blue, 1.0f, fThick, fLength);
                        }
#endif
                        #endregion 클릭하면 축이 나타나게...
                    }
                    else if (OjwDisp.nAxisMoveType == 10) // 트랙 전용 ( 각도 회전 )
                    {
                        fTrackValue = (OjwDisp.fAngle * (int)Math.Pow(-1, OjwDisp.nDir));
                    }
                    else if (OjwDisp.nAxisMoveType == 11) // 트랙 전용 ( RPM 회전 )
                    {
                        if (OjwDisp.nPickGroup_A > 0)// && (m_lTmrTrack == 0)) //if (OjwDisp.GetData_AxisName() >= 0)
                        {
                            float fAngle = GetData(OjwDisp.nPickGroup_B);
                            fTrackValue = (fAngle * (int)Math.Pow(-1, OjwDisp.nDir + 1));

#if _RPM_TEST
                            fTrackValue = (float)(CTimer.GetCurrentTime() % 60000) * fTrackValue * 360.0f / 60000.0f;
#else
                            //if (OjwDisp.strDispObject.IndexOf('!') == 1) // Track Axis
                            //{
                                //long lTmr = m_CTmrDraw.Get();
                                //if (lTmr != 0) m_lTmrTrack = lTmr;
                                float fTmr = (float)m_lTmrTrack;
                                fTrackValue = fTmr * fTrackValue * 360.0f * m_fTest / 1000.0f;//fTrackValue = (float)(m_CTmrDraw.Get() % 60000) * fTrackValue * 360.0f / 1000.0f;
                                //OjwDisp.fAngle = 0.0f;
                                m_afTrack[OjwDisp.nPickGroup_B] = (m_afTrack[OjwDisp.nPickGroup_B] + fTrackValue);
                                if (m_fTrackDisplay_Rot_Limit != 0.0f) m_afTrack[OjwDisp.nPickGroup_B] %= m_fTrackDisplay_Rot_Limit;
                                fTrackValue = m_afTrack[OjwDisp.nPickGroup_B];
                            //}
                            //else fTrackValue = m_fTrackValue;
#endif
                        }
                    }
                    else if (OjwDisp.nAxisMoveType == 12) // 트랙 stack('?') 전용 ( 각도 회전 위 )
                    {
                        fTrackValue = (OjwDisp.fAngle * (int)Math.Pow(-1, OjwDisp.nDir));
                        nTrackMode = 1; // 회전
                    }
                    else if (OjwDisp.nAxisMoveType == 13) // 트랙 stack('?') 전용 ( 각도 회전 아래 )
                    {
                        fTrackValue = (OjwDisp.fAngle * (int)Math.Pow(-1, OjwDisp.nDir));
                        nTrackMode = 2; // 회전
                    }
                    else if (OjwDisp.nAxisMoveType == 14) // 트랙 stack('?') 전용 ( RPM 회전 위 )
                    {
                        if (OjwDisp.nPickGroup_A > 0)// && (m_lTmrTrack == 0)) //if (OjwDisp.GetData_AxisName() >= 0)
                        {
                            float fAngle = GetData(OjwDisp.nPickGroup_B);
                            fTrackValue = (fAngle * (int)Math.Pow(-1, OjwDisp.nDir + 1));
#if _RPM_TEST
                            fTrackValue = (float)(CTimer.GetCurrentTime() % 60000) * fTrackValue * 360.0f / 60000.0f;
#else
                            //if (OjwDisp.strDispObject.IndexOf('!') == 1) // Track Axis
                            //{
                                //long lTmr = m_CTmrDraw.Get();
                                //if (lTmr != 0) m_lTmrTrack = lTmr;
                                float fTmr = (float)m_lTmrTrack;
                                fTrackValue = fTmr * fTrackValue * 360.0f * m_fTest / 1000.0f;//fTrackValue = (float)(m_CTmrDraw.Get() % 60000) * fTrackValue * 360.0f / 1000.0f;
                                //OjwDisp.fAngle = 0.0f;
                                m_afTrack[OjwDisp.nPickGroup_B] = (m_afTrack[OjwDisp.nPickGroup_B] + fTrackValue);
                                if (m_fTrackDisplay_Rot_Limit != 0.0f) m_afTrack[OjwDisp.nPickGroup_B] %= m_fTrackDisplay_Rot_Limit;
                                fTrackValue = m_afTrack[OjwDisp.nPickGroup_B];
                            //}
                            //else fTrackValue = m_fTrackValue;
#endif
                        }
                        nTrackMode = 1; // 회전
                    }
                    else if (OjwDisp.nAxisMoveType == 15) // 트랙 stack('?') 전용 ( RPM 회전 아래 )
                    {
                        if (OjwDisp.nPickGroup_A > 0)// && (m_lTmrTrack == 0)) //if (OjwDisp.GetData_AxisName() >= 0)
                        {
                            float fAngle = GetData(OjwDisp.nPickGroup_B);
                            fTrackValue = (fAngle * (int)Math.Pow(-1, OjwDisp.nDir + 1));
#if _RPM_TEST
                            fTrackValue = (float)(CTimer.GetCurrentTime() % 60000) * fTrackValue * 360.0f / 60000.0f;
#else
                            //if (OjwDisp.strDispObject.IndexOf('!') == 1) // Track Axis
                            //{
                                //long lTmr = m_CTmrDraw.Get();
                                //if (lTmr != 0) m_lTmrTrack = lTmr;
                                float fTmr = (float)m_lTmrTrack;
                                fTrackValue = fTmr * fTrackValue * 360.0f * m_fTest / 1000.0f;//fTrackValue = (float)(m_CTmrDraw.Get() % 60000) * fTrackValue * 360.0f / 1000.0f;
                                //OjwDisp.fAngle = 0.0f;
                                m_afTrack[OjwDisp.nPickGroup_B] = (m_afTrack[OjwDisp.nPickGroup_B] + fTrackValue);
                                if (m_fTrackDisplay_Rot_Limit != 0.0f) m_afTrack[OjwDisp.nPickGroup_B] %= m_fTrackDisplay_Rot_Limit;
                                fTrackValue = m_afTrack[OjwDisp.nPickGroup_B];
                            //}
                            //else fTrackValue = m_fTrackValue;
#endif
                        }
                        nTrackMode = 2; // 회전
                    }
                    else // CW & CCW
                    {
                        // 속도 제어의 경우 이 값은 필요 없으니 삭제 한다.
                        OjwDisp.fAngle = 0.0f;
                        int nID = OjwDisp.GetData_AxisName();
                        if (nID >= 0)
                        {
                            bWheel = true; // 속도제어
#if false//_RPM_TEST
                            if (m_fPanDisplay_Rot_Limit != 0.0f) SRot.pan %= m_fPanDisplay_Rot_Limit;
                            if (m_fTiltDisplay_Rot_Limit != 0.0f) SRot.tilt %= m_fTiltDisplay_Rot_Limit;
                            if (m_fSwingDisplay_Rot_Limit != 0.0f) SRot.swing %= m_fSwingDisplay_Rot_Limit;

                            SRot.pan = (float)(CTimer.GetCurrentTime() % 60000) * SRot.pan * 360.0f / 60000.0f;// (float)(((double)(SAngle.pan / 360.0) * (double)CTimer.GetCurrentTime() / 60000.0) % 360.0);
                            SRot.tilt = (float)(CTimer.GetCurrentTime() % 60000) * SRot.tilt * 360.0f / 60000.0f;// (float)(((double)(SAngle.tilt / 360.0) * (double)CTimer.GetCurrentTime() / 60000.0) % 360.0);
                            SRot.swing = (float)(CTimer.GetCurrentTime() % 60000) * SRot.swing * 360.0f / 60000.0f;// (float)(((double)(SAngle.swing / 360.0) * (double)CTimer.GetCurrentTime() / 60000.0) % 360.0);
                            OjwRotation(
                                SRot.pan + SAngle_Offset.pan,
                                SRot.tilt + SAngle_Offset.tilt,
                                SRot.swing + SAngle_Offset.swing
                                );
#else                      
                            // Rps / 1000 = 360 / 1000;
                            SRot.pan = (float)(m_lTmrTrack) * SRot.pan * 360.0f / 1000.0f;// (float)(((double)(SAngle.pan / 360.0) * (double)CTimer.GetCurrentTime() / 60000.0) % 360.0);
                            SRot.tilt = (float)(m_lTmrTrack) * SRot.tilt * 360.0f / 1000.0f;// (float)(((double)(SAngle.tilt / 360.0) * (double)CTimer.GetCurrentTime() / 60000.0) % 360.0);
                            SRot.swing = (float)(m_lTmrTrack) * SRot.swing * 360.0f / 1000.0f;// (float)(((double)(SAngle.swing / 360.0) * (double)CTimer.GetCurrentTime() / 60000.0) % 360.0);
                            
                            m_pSRot[nID].pan = (m_pSRot[nID].pan + SRot.pan);
                            m_pSRot[nID].tilt = (m_pSRot[nID].tilt + SRot.tilt);
                            m_pSRot[nID].swing = (m_pSRot[nID].swing + SRot.swing);

                            if (m_fPanDisplay_Rot_Limit != 0.0f) m_pSRot[nID].pan %= m_fPanDisplay_Rot_Limit;
                            if (m_fTiltDisplay_Rot_Limit != 0.0f) m_pSRot[nID].tilt %= m_fTiltDisplay_Rot_Limit;
                            if (m_fSwingDisplay_Rot_Limit != 0.0f) m_pSRot[nID].swing %= m_fSwingDisplay_Rot_Limit;

                            //OjwRotation(SRot.pan + SAngle_Offset.pan, SRot.tilt + SAngle_Offset.tilt, SRot.swing + SAngle_Offset.swing);
                            OjwRotation(
                                m_pSRot[nID].pan + SAngle_Offset.pan,
                                m_pSRot[nID].tilt + SAngle_Offset.tilt,
                                m_pSRot[nID].swing + SAngle_Offset.swing
                                );
                            //m_pSTmrTrack[nID].Set();
#endif
                        }
                    }

                    if (bWheel == true)
                    {
                        //int nID = OjwDisp.GetData_AxisName();
                        //m_pSRot[nID].pan = m_pSRot[nID].tilt = m_pSRot[nID].pan = m_pSRot[nID].swing = 0.0f;
                    }
                    else
                    {
                        int nID = OjwDisp.GetData_AxisName();
                        if ((nID >= 0) && (nID < m_pSRot.Length))
                            m_pSRot[nID].pan = m_pSRot[nID].tilt = m_pSRot[nID].pan = m_pSRot[nID].swing = 0.0f;
                    }

                    if (OjwDisp.strDispObject == "#-1")
                    {
                    }
                    else if (OjwDisp.strDispObject == "#0")
                        OjwBox(bFilled, cColor, fAlpha, OjwDisp.fWidth_Or_Radius, OjwDisp.fHeight_Or_Depth, OjwDisp.fDepth_Or_Cnt);
                    else if (OjwDisp.strDispObject == "#1")
                        OjwCircle(bFilled, cColor, fAlpha, OjwDisp.fWidth_Or_Radius, OjwDisp.fHeight_Or_Depth, (int)Math.Round(OjwDisp.fDepth_Or_Cnt));
                    else if (OjwDisp.strDispObject == "#2")
                        OjwBall(bFilled, cColor, fAlpha, OjwDisp.fWidth_Or_Radius, (int)Math.Round(OjwDisp.fDepth_Or_Cnt));
                    else if (OjwDisp.strDispObject == "#3")
                        OjwCase(bFilled, cColor, fAlpha, true, false, OjwDisp.fGap, OjwDisp.fWidth_Or_Radius, OjwDisp.fHeight_Or_Depth, OjwDisp.fDepth_Or_Cnt, OjwDisp.fThickness, OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing, OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z);
                    else if (OjwDisp.strDispObject == "#4")
                        OjwCase(bFilled, cColor, fAlpha, true, true, OjwDisp.fGap, OjwDisp.fWidth_Or_Radius, OjwDisp.fHeight_Or_Depth, OjwDisp.fDepth_Or_Cnt, OjwDisp.fThickness, OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing, OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z);
                    else if (OjwDisp.strDispObject == "#5")
                        OjwCase_half(bFilled, cColor, fAlpha, true, false, OjwDisp.fGap, OjwDisp.fWidth_Or_Radius, OjwDisp.fHeight_Or_Depth, OjwDisp.fDepth_Or_Cnt, OjwDisp.fThickness, OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing, OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z);
                    else if (OjwDisp.strDispObject == "#6")
                        OjwCase_half(bFilled, cColor, fAlpha, true, true, OjwDisp.fGap, OjwDisp.fWidth_Or_Radius, OjwDisp.fHeight_Or_Depth, OjwDisp.fDepth_Or_Cnt, OjwDisp.fThickness, OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing, OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z);
                    else if (OjwDisp.strDispObject == "#7")
                        OjwBox_Outside(bFilled, cColor, fAlpha, OjwDisp.fWidth_Or_Radius, OjwDisp.fHeight_Or_Depth, OjwDisp.fDepth_Or_Cnt, OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing, OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z);
                    else if (OjwDisp.strDispObject == "#8")
                        OjwCircle_Outside(bFilled, cColor, fAlpha, OjwDisp.fWidth_Or_Radius, OjwDisp.fHeight_Or_Depth, (int)Math.Round(OjwDisp.fDepth_Or_Cnt), OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing, OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z);
                    else if (OjwDisp.strDispObject == "#9")
                        OjwBall_Outside(bFilled, cColor, fAlpha, OjwDisp.fWidth_Or_Radius, (int)Math.Round(OjwDisp.fDepth_Or_Cnt), OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing, OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z);
                    else if (OjwDisp.strDispObject == "#10")
                        OjwCone_Outside(bFilled, cColor, fAlpha, OjwDisp.fWidth_Or_Radius, OjwDisp.fHeight_Or_Depth, (int)Math.Round(OjwDisp.fDepth_Or_Cnt), OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing, OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z);
                    else if (OjwDisp.strDispObject == "#11")
                        Axis_X(bFilled, cColor, fAlpha, OjwDisp.fWidth_Or_Radius, OjwDisp.fHeight_Or_Depth, OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing, OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z);
                    else if (OjwDisp.strDispObject == "#12")
                        Axis_Y(bFilled, cColor, fAlpha, OjwDisp.fWidth_Or_Radius, OjwDisp.fHeight_Or_Depth, OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing, OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z);
                    else if (OjwDisp.strDispObject == "#13")
                        Axis_Z(bFilled, cColor, fAlpha, OjwDisp.fWidth_Or_Radius, OjwDisp.fHeight_Or_Depth, OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing, OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z);
                    else if (OjwDisp.strDispObject == "#14")
                        Axis(bFilled, cColor, fAlpha, cColor, fAlpha, cColor, fAlpha, OjwDisp.fWidth_Or_Radius, OjwDisp.fHeight_Or_Depth, OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing, OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z);
                    // Added

                    else if (OjwDisp.strDispObject == "#15")
                    {
                        OjwPoint(cColor, fAlpha,
                            OjwDisp.Points[0].x, OjwDisp.Points[0].y, OjwDisp.Points[0].z,
                            OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing,
                            OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z
                                    );
                    }
                    else if (OjwDisp.strDispObject == "#16")
                    {
                        OjwPoints(cColor, fAlpha,
                                OjwDisp.Points,
                                OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing,
                                OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z
                                        );
                    }
                    else if (OjwDisp.strDispObject == "#17")
                    {
                        if (OjwDisp.Points.Count >= 2)
                        {
                            OjwLine(cColor, fAlpha,
                                OjwDisp.Points[0].x, OjwDisp.Points[0].y, OjwDisp.Points[0].z,
                                OjwDisp.Points[1].x, OjwDisp.Points[1].y, OjwDisp.Points[1].z,
                                OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing,
                                OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z
                                        );
                        }
                    }
                    else if (OjwDisp.strDispObject == "#18")
                    {
                        // For Test
                        //OjwDisp.Points.Clear();
                        //OjwDisp.Points.Add(new SVector3D_t(10, 10, 10));
                        //OjwDisp.Points.Add(new SVector3D_t(10, 10+30, 10));
                        //OjwDisp.Points.Add(new SVector3D_t(10, 10+30, 10+30));
                        ////OjwDisp.Points.Add(new SVector3D_t(10, 10, 10));
                        /////////////////////////////////////////////
                        OjwLines(
                            (((OjwDisp.Points[OjwDisp.Points.Count - 1].x == OjwDisp.Points[0].x) && (OjwDisp.Points[OjwDisp.Points.Count - 1].y == OjwDisp.Points[0].y) && (OjwDisp.Points[OjwDisp.Points.Count - 1].z == OjwDisp.Points[0].z)) ? bFilled : false),
                            cColor, fAlpha,
                                OjwDisp.Points,
                                OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing,
                                OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z
                                        );
                        //OjwLines(bFilled, cColor, fAlpha,
                        //        OjwDisp.Points,
                        //        OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing,
                        //        OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z
                        //                );
                    }
                    else if (OjwDisp.strDispObject == "#19") // Skeleton Bar
                    {
                        if (m_bSkeleton == true)
                        {
                            float fSkeletonAlpha = 1.0f;
                            OjwCircle_Outside(bFilled, cColor, fSkeletonAlpha, OjwDisp.fWidth_Or_Radius, OjwDisp.fHeight_Or_Depth, (int)Math.Round(OjwDisp.fDepth_Or_Cnt), OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing, OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z);
                        }
                    }
                    else if (OjwDisp.strDispObject == "#20") // Skeleton Axis
                    {
                        if (m_bSkeleton == true)
                        {
                            float fSkeletonAlpha = 1.0f;
                            OjwBall_Outside(bFilled, cColor, fSkeletonAlpha, OjwDisp.fWidth_Or_Radius, (int)Math.Round(OjwDisp.fDepth_Or_Cnt), OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing, OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z);
                        }
                    }
                    else
                    {
                        //if (GetDrawFastMode() == 0)
                        //{
                        if (
                            (OjwDisp.strDispObject.IndexOf('?') == 0) || // start
                            (OjwDisp.strDispObject.IndexOf("!?") == 0) // Track Axis
                            )
                        {
                            if (OjwDisp.strDispObject.IndexOf('!') == 1) // Track Axis
                            {
                                m_fTrackValue = fTrackValue;
                            }
                            m_aSTrack[m_nTrackBall].fX = OjwDisp.fWidth_Or_Radius;
                            m_aSTrack[m_nTrackBall].fY = OjwDisp.fHeight_Or_Depth;
                            m_aSTrack[m_nTrackBall].fR = OjwDisp.fDepth_Or_Cnt;
                            m_aSTrack[m_nTrackBall].nConnectedAxis = OjwDisp.nName; // 실제 모터를 연결하는 거라 반드시 OjwDisp.nAxisMoveType = -1 이어야 한다.
                            m_aSTrack[m_nTrackBall].fCenter_X = OjwDisp.afTrans[3].x;
                            m_aSTrack[m_nTrackBall].fCenter_Y = OjwDisp.afTrans[3].y;
                            m_aSTrack[m_nTrackBall].nMode = nTrackMode;
                            m_aSTrack[m_nTrackBall].nDir = OjwDisp.nDir;
                            m_nTrackBall++;
                            //if (OjwDisp.fGap < 0)
                            //{
                            //    for (int i = 0; i < m_nTrackBall; i++)
                            //    {
                            //        OjwTranslate(m_aSTrack[i].fX, m_aSTrack[i].fY, 0.0f);
                            //        OjwCircle_Outside(bFilled, cColor, fAlpha, m_aSTrack[i].fR, (float)Math.Abs(OjwDisp.fGap), 50, 0, 0, 0, 0, 0, 0);
                            //        //OjwBall_Outside(bFilled, cColor, fAlpha, m_aSTrack[i].fR, 50, OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing, OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z);
                            //        OjwTranslate(-m_aSTrack[i].fX, -m_aSTrack[i].fY, 0.0f);
                            //        OjwTranslate(m_aSTrack[i].fCenter_X, m_aSTrack[i].fCenter_Y, 0.0f);
                            //        OjwCircle_Outside(bFilled, Color.Red, fAlpha, 10, (float)Math.Abs(OjwDisp.fGap), 50, 0, 0, 0, 0, 0, 0);
                            //        //OjwBall_Outside(bFilled, Color.Red, fAlpha, 10, 50, OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing, OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z);
                            //        OjwTranslate(-m_aSTrack[i].fCenter_X, -m_aSTrack[i].fCenter_Y, 0.0f);
                            //    }
                            //}
                        }
                        else if (
                            (OjwDisp.strDispObject.IndexOf('/') == 0) ||// end
                            (OjwDisp.strDispObject.IndexOf("/!") == 0) // Track Axis
                            )
                        {
                            int nPos = 1;
                            if (OjwDisp.strDispObject.IndexOf('!') == 1) // Track Axis
                            {
                                m_fTrackValue = fTrackValue;
                                nPos++;
                            }
                            m_aSTrack[m_nTrackBall].fX = OjwDisp.fWidth_Or_Radius;
                            m_aSTrack[m_nTrackBall].fY = OjwDisp.fHeight_Or_Depth;
                            m_aSTrack[m_nTrackBall].fR = OjwDisp.fDepth_Or_Cnt;

                            m_aSTrack[m_nTrackBall].nConnectedAxis = OjwDisp.nName; // 실제 모터를 연결하는 거라 반드시 OjwDisp.nAxisMoveType = -1 이어야 한다.
                            m_aSTrack[m_nTrackBall].fCenter_X = OjwDisp.afTrans[3].x;
                            m_aSTrack[m_nTrackBall].fCenter_Y = OjwDisp.afTrans[3].y;
                            m_aSTrack[m_nTrackBall].nMode = nTrackMode;
                            m_aSTrack[m_nTrackBall].nDir = OjwDisp.nDir;

                            m_nTrackBall++;

#if false
                            if (OjwDisp.fGap != 0)
                            {
                                for (int i = 0; i < m_nTrackBall; i++)
                                {
                                    OjwTranslate(m_aSTrack[i].fX, m_aSTrack[i].fY, 0.0f);
                                    OjwCircle_Outside(bFilled, cColor, fAlpha, m_aSTrack[i].fR, (float)Math.Abs(OjwDisp.fGap), 50, 0, 0, 0, 0, 0, 0);
                                    //OjwBall_Outside(bFilled, cColor, fAlpha, m_aSTrack[i].fR, 50, OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing, OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z);
                                    OjwTranslate(-m_aSTrack[i].fX, -m_aSTrack[i].fY, 0.0f);
                                    OjwTranslate(m_aSTrack[i].fCenter_X, m_aSTrack[i].fCenter_Y, 0.0f);
                                    OjwCircle_Outside(bFilled, Color.Red, fAlpha, 10, (float)Math.Abs(OjwDisp.fGap), 50, 0, 0, 0, 0, 0, 0);
                                    //OjwBall_Outside(bFilled, Color.Red, fAlpha, 10, 50, OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing, OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z);
                                    OjwTranslate(-m_aSTrack[i].fCenter_X, -m_aSTrack[i].fCenter_Y, 0.0f);
                                }
                            }
#endif
                            // Rotation 적용
                            //float fX, fY, fR;
                            //int nConnectedAxis; // 연결된 모터 번호
                            //float fAxis_X;      // 회전 해야 할 좌표 기준 점(X)
                            //float fAxis_Y;      // 회전 해야 할 좌표 기준 점(Y)
                            //int nMode;          // Mode(0 : 변화없음, 1 : 회전, 2 : 축 이동(fAxis_X 각도 연관 - 나중에 구현하자. 지금 바빠)) //float fOffsetPan, float fOffsetTilt, float fOffsetSwing,    // Ratation(Offset)
                            //float fDir = 0;           // 방향(0 : 정, 1 : 반대)
#if false
                            float [] afValue = new float[m_nTrackBall * 3];
                            int j = 0;
                            for (int i = 0; i < m_nTrackBall; i++)
                            {
                                afValue[j++] = m_aSTrack[i].fX;
                                afValue[j++] = m_aSTrack[i].fY;
                                afValue[j++] = m_aSTrack[i].fR; 
                                //afValue[j++] = OjwDisp.afRot[3].pan; // test용 2번 모터 연결
                                //afValue[j++] = OjwDisp.afTrans[3].x;
                                //afValue[j++] = OjwDisp.afTrans[3].y;
                                //afValue[j++] = OjwDisp.afTrans[3].x;
                                //afValue[j++] = ;
                            }
                            float fDiv = (OjwDisp.fThickness == 0) ? 1.0f : OjwDisp.fThickness;
                            OjwTrack2(fTrackValue, bFilled, cColor, fAlpha, OjwDisp.strDispObject.Substring(1),
                                Math.Abs(OjwDisp.fGap), OjwDisp.fHeight_Or_Depth, OjwDisp.fDepth_Or_Cnt, OjwDisp.fThickness,
                                OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing,
                                OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z,
                                //0, 0, 0, 0, 0, 0,
                                afValue);
#else
                            STrackD_t[] aSValue = new STrackD_t[m_nTrackBall];
                            //int j = 0;
                            for (int i = 0; i < m_nTrackBall; i++)
                            {
                                aSValue[i] = new STrackD_t();
                                aSValue[i].fX = m_aSTrack[i].fX;
                                aSValue[i].fY = m_aSTrack[i].fY;
                                aSValue[i].fR = m_aSTrack[i].fR;

                                aSValue[i].nConnectedAxis = m_aSTrack[i].nConnectedAxis; // 실제 모터를 연결하는 거라 반드시 OjwDisp.nAxisMoveType = -1 이어야 한다.
                                aSValue[i].fCenter_X = m_aSTrack[i].fCenter_X;
                                aSValue[i].fCenter_Y = m_aSTrack[i].fCenter_Y;
                                aSValue[i].nMode = m_aSTrack[i].nMode;
                                aSValue[i].nDir = m_aSTrack[i].nDir;
                            }





                            float fDiv = (OjwDisp.fThickness == 0) ? 1.0f : OjwDisp.fThickness;
                            OjwTrack(m_fTrackValue, bFilled, cColor, fAlpha, OjwDisp.strDispObject.Substring(nPos),
                                OjwDisp.fGap, OjwDisp.fHeight_Or_Depth, OjwDisp.fDepth_Or_Cnt, OjwDisp.fThickness,
                                OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing,
                                OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z,
                                aSValue);
#endif
                            m_nTrackBall = 0;
                        }
                        else if (OjwDisp.strDispObject.IndexOf('#') < 0)
                            OjwAse_Outside(bFilled, cColor, fAlpha, OjwDisp.fWidth_Or_Radius, OjwDisp.fHeight_Or_Depth, (int)Math.Round(OjwDisp.fDepth_Or_Cnt), OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing, OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z, OjwDisp.strDispObject);
                        //}
                    }
                    //if (nTrackBall == m_nTrackBall) // 연속된 트랙이 아니라면...
                    //{
                    //    m_nTrackBall = 0;
                    //}

                    //else if ((OjwDisp.nDispModel >= 0x1000) && (OjwDisp.nDispModel < 0x2000))
                    //{
                    //    if (GetDrawFastMode() == 0)
                    //    {
                    //        //OjwAse_Outside(bFilled, cColor, fAlpha, OjwDisp.fWidth_Or_Radius, OjwDisp.fHeight_Or_Depth, (int)Math.Round(OjwDisp.fDepth_Or_Cnt), OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing, OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z, (int)(OjwDisp.nDispModel & 0xfff));
                    //        OjwAse_Outside(bFilled, cColor, fAlpha, OjwDisp.fWidth_Or_Radius, OjwDisp.fHeight_Or_Depth, (int)Math.Round(OjwDisp.fDepth_Or_Cnt), OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing, OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z, OjwDisp.strDispObject);
                    //    }
                    //    else
                    //    {
                    //        if (m_abMake[OjwDisp.nDispModel - 0x1000] == false)
                    //        {
                    //            OjwAse_Outside_make(OjwDisp.fWidth_Or_Radius, OjwDisp.fHeight_Or_Depth, (int)Math.Round(OjwDisp.fDepth_Or_Cnt), OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing, OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z, (int)(OjwDisp.nDispModel & 0xfff));
                    //            m_abMake[OjwDisp.nDispModel - 0x1000] = true;
                    //        }
                    //        OjwAse_Outside2(bFilled, cColor, fAlpha, OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing, OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z, (int)(OjwDisp.nDispModel & 0xfff));
                    //    }

                    //}
                    //else
                    //    OjwBox(bFilled, cColor, fAlpha, OjwDisp.fWidth_Or_Radius, OjwDisp.fHeight_Or_Depth, OjwDisp.fDepth_Or_Cnt);

                    //OjwRotation(-SAngle_Offset.pan, -SAngle_Offset.tilt, -SAngle_Offset.swing);

                    //Rotation(-SAngle_Offset.tilt, -SAngle_Offset.pan, -SAngle_Offset.swing, ref m_afCalcPos[0], ref m_afCalcPos[1], ref m_afCalcPos[2]);


                    //if (bPicking == true)
                    //{
                    //m_afCalcPos_Event[0] = m_afCalcPos[0];
                    //m_afCalcPos_Event[1] = m_afCalcPos[1];
                    //m_afCalcPos_Event[2] = m_afCalcPos[2];

                    //Gl.glLoadMatrixf(m_afCalcPos_Event);
                    //Gl.glLoadMatrixf(m_afCalcPos_Event);

                    //bPicking = false;
                    //}

                    if (bMate == true)
                    {
                    }
                    else
                    {
                        if ((m_bPickMode == true) && (unObjectName > 0))
                        {
                            PopName();
                            //Gl.glPopMatrix();
                        }
                    }
                }
                public void SetSkeletonView(bool bOn) { m_bSkeleton = bOn; }
                private bool m_bSkeleton = false;
                //unsafe public float* pM = malloc(sizeof(float) * 16);
                // nDispModel(0-Box, 1-Circle), nInit(0 - none, 1 - Init), nEmpty(1 - Empty, 0 - Fill),
                // nTexture(-1 - None, 0~ - Texture Number),  => 용도변경 (fMulti -> 0 보다 작으면 안됨(방향은 nDir이...) 3D 의 동작각의 배수
                public bool StringLine_To_Class(String strData, out COjwDisp CDisp)
                {
                    float[,] afTrans2 = new float[5, 3];
                    float[,] afRot2 = new float[5, 3];
                    System.Array.Clear(afTrans2, 0, afTrans2.Length);
                    System.Array.Clear(afRot2, 0, afRot2.Length);
                    CDisp = new COjwDisp();
                    System.Array.Clear(CDisp.afTrans, 0, CDisp.afTrans.Length);
                    System.Array.Clear(CDisp.afRot, 0, CDisp.afRot.Length);

                    CDisp.cColor = Color.White;
                    CDisp.fAlpha = 1.0f;
                    CDisp.strDispObject = "#-1";
                    CDisp.bInit = false;
                    CDisp.bFilled = false;
                    CDisp.fMulti = 0;

                    CDisp.SOffset_Rot.pan = CDisp.SOffset_Rot.tilt = CDisp.SOffset_Rot.swing = 0.0f;
                    CDisp.SOffset_Trans.x = CDisp.SOffset_Trans.y = CDisp.SOffset_Trans.z = 0.0f;

                    CDisp.fWidth_Or_Radius = CDisp.fHeight_Or_Depth = CDisp.fDepth_Or_Cnt = CDisp.fThickness = CDisp.fGap = 0;

                    //CDisp.nAxis = CDisp.nName = CDisp.nDispModel = -1;
                    CDisp.nAxisMoveType = CDisp.nName = -1;
                    CDisp.nDir = 0;
                    CDisp.fAngle = 0.0f;
                    CDisp.strAngle_Offset = "";
                    CDisp.strCaption = "";

                    // Picking
                    CDisp.nPickGroup_A = 0;
                    CDisp.nPickGroup_B = 0;
                    CDisp.nPickGroup_C = 0;
                    CDisp.nInverseKinematicsNumber = 0;
                    CDisp.fScale_Serve0 = 0.35f;
                    CDisp.fScale_Serve1 = 0.35f;
                    CDisp.nInverseKinematicsNumber_AfterCalc = 0;
                    CDisp.strPickGroup_Comment = "";

                    try
                    {
                        bool bRet = false;
                        String[] pstrData = strData.Split(',');
                        if (pstrData.Length >= 54)
                        {
                            /*
                                    16 + 3 + 3 + 3 * 5 + 3 * 5 = 52
                                    int nName, Color cColorData, float fAlpha(new one), int nModel, bool bFill, int fMulti, bool bInitialize, float fW, float fH, float fD, float fT, float fGapData, string strMessage,
                                    int nAxisData, int nDirData, float fAngleData, string strAngle_OffsetData
                                    SVector3D_t fOffset_Translation, SAngle3D_t fOffset_Rotation, 
                                    SVector3D_t[] afTranslation, SAngle3D_t[] afRotation, 
                                    nObjectPickGroup_A, nObjectPickGroup_B, nObjectPickGroup_C, strObjectPickGroup_Comment
                            */

                            int i = 0, j = 0, k = 0;
                            bool bName = false;
                            bool bColor = false;
                            bool bAlpha = false;
                            bool bDispObject = false;
                            bool bEmpty = false;
                            bool bMul_3DAngle = false;
                            bool bInit = false;

                            bool bW = false;
                            bool bH = false;
                            bool bD = false;
                            bool bT = false;
                            bool bGap = false;

                            bool bAxis = false;
                            bool bDir = false;
                            bool bAngle = false;
                            bool bAngle_Offset = false;

                            // Offset
                            bool bOffsetX = false;
                            bool bOffsetY = false;
                            bool bOffsetZ = false;
                            bool bOffsetPan = false;
                            bool bOffsetTilt = false;
                            bool bOffsetSwing = false;

                            // Picking
                            bool bObjectPickGroup_A = false;
                            bool bObjectPickGroup_B = false;
                            bool bObjectPickGroup_C = false;
                            bool bObjectPickGroup_InverseKinematics = false;
                            bool bObjectScale_Serve0 = false;
                            bool bObjectScale_Serve1 = false;
                            bool bMotorType = false;
                            bool bMotorControl_MousePoint = false;
                            bool bObjectPickGroup_Comment = false;
                            int nReserveData = 0;
                            foreach (string strItem in pstrData)
                            {
                                if (bName == false)
                                {
                                    bName = true;
                                    CDisp.nName = CConvert.StrToInt(strItem);
                                }
                                else if (bColor == false)
                                {
                                    bColor = true;
                                    int nHex = strItem.IndexOf("0x");
                                    if (nHex >= 0)
                                        CDisp.cColor = Color.FromArgb(CConvert.HexStrToInt(strItem.Substring(nHex + 2)));
                                    else
                                        CDisp.cColor = Color.FromArgb(CConvert.StrToInt(strItem));
                                }
                                else if (bAlpha == false)
                                {
                                    bAlpha = true;
                                    CDisp.fAlpha = CConvert.StrToFloat(strItem);
                                }
                                else if (bDispObject == false)
                                {
                                    bDispObject = true;
                                    //if (Ojw.CConvert.IsDigit(strItem) == false) CDisp.nDispModel = 0x1000;
                                    //else CDisp.nDispModel = CConvert.StrToInt(strItem);
#if false
                                    if (CDisp.nDispModel < 0x1000)
                                    {
                                        // Normal command
                                        CDisp.strDispObject = String.Empty;
                                    }
                                    else
                                    {
                                        // ASE Data
                                        CDisp.strDispObject = strItem;
                                    }
#else
#if _DHF_FILE
                                    //if (m_CHeader.strVersion != null)
                                    //{
                                    //    if (m_CHeader.strVersion.ToUpper().IndexOf("DHF") >= 0)
                                    //    {
                                    //        int nData = CConvert.StrToInt(strItem);
                                    //        if (nData >= 0x1000) CDisp.strDispObject = CConvert.IntToStr(nData - 0x1000);
                                    //        else CDisp.strDispObject = "#" + strItem;
                                    //    }
                                    //    else CDisp.strDispObject = strItem;
                                    //}
                                    //else 
                                        CDisp.strDispObject = strItem;
#else
                                    CDisp.strDispObject = strItem;
#endif

#endif
                                    ////if ((CDisp.nDispModel >= 0x1000) && (CDisp.nDispModel < 0x2000)) CDisp.strDispObject = CConvert.IntToStr(CConvert.StrToInt(strItem) - 0x1000);
                                    ////else CDisp.strDispObject = strItem;
                                    //if (m_CHeader.strVersion != null)
                                    //{
                                    //    if (m_CHeader.strVersion.ToUpper().IndexOf("DHF") >= 0)
                                    //    {
                                    //        if ((CDisp.nDispModel >= 0x1000) && (CDisp.nDispModel < 0x2000))
                                    //        {
                                    //            CDisp.strDispObject = CConvert.IntToStr(CConvert.StrToInt(strItem) - 0x1000);
                                    //            CDisp.nDispModel = 0x1000;
                                    //        }
                                    //        else
                                    //        {

                                    //        }
                                    //    }
                                    //    else
                                    //    {
                                    //        m_CHeader.strVersion = _STR_EXT.ToUpper() + C3d._STR_EXT_VERSION;
                                    //        CDisp.strDispObject = strItem;
                                    //    }
                                    //}
                                    //else
                                    //{
                                    //    m_CHeader.strVersion = _STR_EXT.ToUpper() + C3d._STR_EXT_VERSION;
                                    //    CDisp.strDispObject = strItem;
                                    //}
                                }
                                else if (bEmpty == false)
                                {
                                    bEmpty = true;
                                    CDisp.bFilled = CConvert.StrToBool(strItem);
                                }
                                else if (bMul_3DAngle == false)
                                {
                                    bMul_3DAngle = true;
                                    CDisp.fMulti = CConvert.StrToFloat(strItem);
                                }
                                else if (bInit == false)
                                {
                                    bInit = true;
                                    CDisp.bInit = CConvert.StrToBool(strItem);
                                }

                                else if (bW == false)
                                {
                                    bW = true;
                                    CDisp.fWidth_Or_Radius = CConvert.StrToFloat(strItem);
                                }
                                else if (bH == false)
                                {
                                    bH = true;
                                    CDisp.fHeight_Or_Depth = CConvert.StrToFloat(strItem);
                                }
                                else if (bD == false)
                                {
                                    bD = true;
                                    CDisp.fDepth_Or_Cnt = CConvert.StrToFloat(strItem);
                                }
                                else if (bT == false)
                                {
                                    bT = true;
                                    CDisp.fThickness = CConvert.StrToFloat(strItem);
                                }
                                else if (bGap == false)
                                {
                                    bGap = true;
                                    CDisp.fGap = CConvert.StrToFloat(strItem);
                                }

                                else if (bAxis == false)
                                {
                                    bAxis = true;
                                    CDisp.nAxisMoveType = CConvert.StrToInt(strItem);
                                }
                                else if (bDir == false)
                                {
                                    bDir = true;
                                    CDisp.nDir = CConvert.StrToInt(strItem);
                                }
                                else if (bAngle == false)
                                {
                                    bAngle = true;
                                    CDisp.fAngle = CConvert.StrToFloat(strItem);
                                }
                                else if (bAngle_Offset == false)
                                {
                                    bAngle_Offset = true;
                                    CDisp.strAngle_Offset = strItem;
                                }

                                // Offset
                                else if (bOffsetX == false)
                                {
                                    bOffsetX = true;
                                    CDisp.SOffset_Trans.x = CConvert.StrToFloat(strItem);
                                }
                                else if (bOffsetY == false)
                                {
                                    bOffsetY = true;
                                    CDisp.SOffset_Trans.y = CConvert.StrToFloat(strItem);
                                }
                                else if (bOffsetZ == false)
                                {
                                    bOffsetZ = true;
                                    CDisp.SOffset_Trans.z = CConvert.StrToFloat(strItem);
                                }
                                else if (bOffsetPan == false)
                                {
                                    bOffsetPan = true;
                                    CDisp.SOffset_Rot.pan = CConvert.StrToFloat(strItem);
                                }
                                else if (bOffsetTilt == false)
                                {
                                    bOffsetTilt = true;
                                    CDisp.SOffset_Rot.tilt = CConvert.StrToFloat(strItem);
                                }
                                else if (bOffsetSwing == false)
                                {
                                    bOffsetSwing = true;
                                    CDisp.SOffset_Rot.swing = CConvert.StrToFloat(strItem);
                                }

                                else if (nReserveData < (5 * 2 * 3))
                                {
                                    nReserveData++;
                                    if (k == 0)
                                    {
                                        // T3, R3,    T3, R3,  ...... , T3, R3
                                        afTrans2[i, j] = (float)CConvert.StrToFloat(strItem);
                                        if (j >= 2) { k = 1; j = 0; }
                                        else j++;
                                    }
                                    else
                                    {
                                        afRot2[i, j] = (float)CConvert.StrToFloat(strItem);
                                        if (j >= 2) { k = 0; i++; j = 0; }
                                        else j++;
                                    }
                                }

                                else if (bObjectPickGroup_A == false)
                                {
                                    bObjectPickGroup_A = true;
                                    CDisp.nPickGroup_A = CConvert.StrToInt(strItem);
                                }
                                else if (bObjectPickGroup_B == false)
                                {
                                    bObjectPickGroup_B = true;
                                    CDisp.nPickGroup_B = CConvert.StrToInt(strItem);
                                }
                                else if (bObjectPickGroup_C == false)
                                {
                                    bObjectPickGroup_C = true;
                                    CDisp.nPickGroup_C = CConvert.StrToInt(strItem);
                                }
                                else if (bObjectPickGroup_InverseKinematics == false)
                                {
                                    bObjectPickGroup_InverseKinematics = true;
                                    CDisp.nInverseKinematicsNumber = CConvert.StrToInt(strItem);
                                }
                                else if (bObjectScale_Serve0 == false)
                                {
                                    bObjectScale_Serve0 = true;
                                    CDisp.fScale_Serve0 = CConvert.StrToFloat(strItem);
                                }
                                else if (bObjectScale_Serve1 == false)
                                {
                                    bObjectScale_Serve1 = true;
                                    CDisp.fScale_Serve1 = CConvert.StrToFloat(strItem);
                                }
                                else if (bMotorType == false)
                                {
                                    bMotorType = true;
                                    CDisp.nMotorType = CConvert.StrToInt(strItem);
                                }
                                else if (bMotorControl_MousePoint == false)
                                {
                                    bMotorControl_MousePoint = true;
                                    CDisp.nMotorControl_MousePoint = CConvert.StrToInt(strItem);
                                }
                                else if (bObjectPickGroup_Comment == false)
                                {
                                    bObjectPickGroup_Comment = true;
                                    CDisp.strPickGroup_Comment = strItem;
                                }
                            }
                            bRet = true;
                        }

                        for (int i = 0; i < 5; i++)
                        {
                            CDisp.afTrans[i].x = afTrans2[i, 0];
                            CDisp.afTrans[i].y = afTrans2[i, 1];
                            CDisp.afTrans[i].z = afTrans2[i, 2];

                            CDisp.afRot[i].pan = afRot2[i, 0];
                            CDisp.afRot[i].tilt = afRot2[i, 1];
                            CDisp.afRot[i].swing = afRot2[i, 2];
                        }

                        pstrData = null;
                        afTrans2 = null;
                        afRot2 = null;

                        return bRet;
                    }
                    catch //(Exception e)
                    {
                        //                 for (int i = 0; i < 5; i++)
                        //                 {
                        //                     OjwDisp.afTrans[i].x = afTrans2[i, 0];
                        //                     OjwDisp.afTrans[i].y = afTrans2[i, 1];
                        //                     OjwDisp.afTrans[i].z = afTrans2[i, 2];
                        // 
                        //                     OjwDisp.afRot[i].pan = afRot2[i, 0];
                        //                     OjwDisp.afRot[i].tilt = afRot2[i, 1];
                        //                     OjwDisp.afRot[i].swing = afRot2[i, 2];
                        //                 }

                        afTrans2 = null;
                        afRot2 = null;

                        return false;
                    }
                }

                private const int _X = 0;
                private const int _Y = 1;
                private const int _Z = 2;
                private const int _PAN = 0;
                private const int _TILT = 1;
                private const int _SWING = 2;
                public bool TextBox_To_CodeString(TextBox txtData, out COjwDisp[] pCDisp)
                {
                    // Draw the values of the txtData.(Kor: txtData 의 값들을 그림)
                    bool bRet = false;
                    bool bRet2 = false;
                    String strData;
                    //String strTmp;
                    pCDisp = null;
                    //int nLine = 0;
                    if (txtData.Lines.Length > 0)
                    {
                        bRet = true;
                        pCDisp = new COjwDisp[txtData.Lines.Length];
                        for (int i = 0; i < txtData.Lines.Length; i++)
                        {
                            String strCaption = "";
                            strData = txtData.Lines[i];
                            int nFind = strData.IndexOf("//");
                            if (nFind >= 0)
                            {
                                strCaption = strData.Substring(nFind + 2, strData.Length - nFind - 2);

                                strData = strData.Substring(0, nFind);
                            }
                            strData = strData.Trim();
                            strData = CConvert.RemoveChar(strData, '[');
                            strData = CConvert.RemoveChar(strData, ']');

                            // Actual interpretation(Kor: 실제 해석)
                            //if (strData != "")
                            //{
                                //bRet2 = StringLine_To_Class(strData, out pCDisp[nLine]);
                                //pCDisp[nLine].strCaption = strCaption;
                                //nLine++;
                            //}

                            bRet2 = StringLine_To_Class(strData, out pCDisp[i]);
                            pCDisp[i].strCaption = strCaption;

                            if (bRet2 == false) bRet = false;
                        }
                    }
                    return bRet;
                }

                public String TextBox_To_CodeString(TextBox txtData)
                {
                    String strMessage = "";
                    // Draw the values of the txtData.(Kor: txtData 의 값들을 그림)
                    bool bRet = false;
                    String strData;
                    String strTmp;
                    COjwDisp CDisp = new COjwDisp();
                    if (txtData.Lines.Length > 0)
                    {
                        for (int i = 0; i < txtData.Lines.Length; i++)
                        {
                            String strCaption = "";
                            strData = txtData.Lines[i];
                            int nFind = strData.IndexOf("//");
                            if (nFind >= 0)
                            {
                                strCaption = strData.Substring(nFind + 2, strData.Length - nFind - 2);

                                strData = strData.Substring(0, nFind);
                                CDisp.strCaption = strCaption;
                            }
                            strData = strData.Trim();
                            strData = CConvert.RemoveChar(strData, '[');
                            strData = CConvert.RemoveChar(strData, ']');

                            // Actual interpretation(Kor: 실제 해석)
                            bRet = StringLine_To_Class(strData, out CDisp);
                            if (CDisp.nAxisMoveType >= 0)
                            {
                                string strTmpCaption = "(";
                                strTmpCaption += ((CDisp.nAxisMoveType == 0) ? "[P]," : "P,");
                                strTmpCaption += ((CDisp.nAxisMoveType == 1) ? "[T]," : "T,");
                                strTmpCaption += ((CDisp.nAxisMoveType == 2) ? "[S]" : "S");
                                //strTmpCaption += ") - 축번호 : Axis" + CConvert.IntToStr(CDisp.nName) + ((CDisp.nName < 0) ? "<동작 축 설정에 이상발견(-). 확인요망>" : "");
                                strTmpCaption += ") - Axis Number : Axis" + CConvert.IntToStr(CDisp.nName) + ((CDisp.nName < 0) ? "<Found over operation axis settings(-). Check it.>" : "");
                                if (strCaption.IndexOf(strTmpCaption, 0) < 0) strCaption += strTmpCaption;
                                if (CDisp.strCaption.IndexOf(strTmpCaption, 0) < 0) CDisp.strCaption += strTmpCaption;
                                strTmpCaption = null;
                            }

                            if (bRet == true)
                            {
                                strMessage += "// ======================================\r\n// [" + CDisp.cColor.Name.ToString() + "][" + strCaption.Trim() + "]\r\n// ======================================\r\n";

                                if (CDisp.bInit == true) strMessage += "InitPosAngle();\r\n";
                                for (int j = 0; j < 5; j++)
                                {
                                    strTmp = "";
                                    if ((CDisp.afTrans[j].x != 0) || (CDisp.afTrans[j].y != 0) || (CDisp.afTrans[j].x != 0)) strTmp = "OjwTranslate(" + CConvert.FloatToStr(CDisp.afTrans[j].x) + "f, " + CConvert.FloatToStr(CDisp.afTrans[j].y) + "f, " + CConvert.FloatToStr(CDisp.afTrans[j].z) + "f, [" + CConvert.IntToStr(CDisp.nPickGroup_A) + ", " + CConvert.IntToStr(CDisp.nPickGroup_B) + ", " + CConvert.IntToStr(CDisp.nPickGroup_C) + ", " + ((CDisp.strPickGroup_Comment == null) ? "None" : CDisp.strPickGroup_Comment) + "]);\r\n";
                                    strMessage += strTmp;
                                    strTmp = "";
                                    if ((CDisp.afRot[j].pan != 0) || (CDisp.afRot[j].tilt != 0) || (CDisp.afRot[j].swing != 0)) strTmp = "OjwRotation(" + CConvert.FloatToStr(CDisp.afRot[j].pan) + "f, " + CConvert.FloatToStr(CDisp.afRot[j].tilt) + "f, " + CConvert.FloatToStr(CDisp.afRot[j].swing) + "f, [" + CConvert.IntToStr(CDisp.nPickGroup_A) + ", " + CConvert.IntToStr(CDisp.nPickGroup_B) + ", " + CConvert.IntToStr(CDisp.nPickGroup_C) + ", " + ((CDisp.strPickGroup_Comment == null) ? "None" : CDisp.strPickGroup_Comment) + "]);\r\n";
                                    strMessage += strTmp;
                                }
                                if      (CDisp.strDispObject == "#0") 
                                    strMessage += "OjwBox( " + ((CDisp.bFilled == true) ? "true" : "false") + ", " + "cColor[" + CDisp.cColor.Name.ToString() + "], " + CConvert.FloatToStr(CDisp.fWidth_Or_Radius) + "f, " + CConvert.FloatToStr(CDisp.fHeight_Or_Depth) + "f, " + CConvert.FloatToStr(CDisp.fDepth_Or_Cnt) + "f, [" + CConvert.IntToStr(CDisp.nPickGroup_A) + ", " + CConvert.IntToStr(CDisp.nPickGroup_B) + ", " + CConvert.IntToStr(CDisp.nPickGroup_C) + ", " + ((CDisp.strPickGroup_Comment == null) ? "None" : CDisp.strPickGroup_Comment) + "]);\r\n";
                                else if (CDisp.strDispObject == "#1")
                                    strMessage += "OjwCircle( " + ((CDisp.bFilled == true) ? "true" : "false") + ", " + "cColor[" + CDisp.cColor.Name.ToString() + "], " + CConvert.FloatToStr(CDisp.fWidth_Or_Radius) + "f, " + CConvert.FloatToStr(CDisp.fHeight_Or_Depth) + "f, " + CConvert.FloatToStr(CDisp.fDepth_Or_Cnt) + "f, [" + CConvert.IntToStr(CDisp.nPickGroup_A) + ", " + CConvert.IntToStr(CDisp.nPickGroup_B) + ", " + CConvert.IntToStr(CDisp.nPickGroup_C) + ", " + ((CDisp.strPickGroup_Comment == null) ? "None" : CDisp.strPickGroup_Comment) + "]);\r\n";
                                else if (CDisp.strDispObject == "#2")
                                    strMessage += "OjwBall( " + ((CDisp.bFilled == true) ? "true" : "false") + ", " + "cColor[" + CDisp.cColor.Name.ToString() + "], " + CConvert.FloatToStr(CDisp.fWidth_Or_Radius) + "f, " + CConvert.FloatToStr(CDisp.fDepth_Or_Cnt) + ", [" + CConvert.IntToStr(CDisp.nPickGroup_A) + ", " + CConvert.IntToStr(CDisp.nPickGroup_B) + ", " + CConvert.IntToStr(CDisp.nPickGroup_C) + ", " + ((CDisp.strPickGroup_Comment == null) ? "None" : CDisp.strPickGroup_Comment) + "]);\r\n";
                                else if (CDisp.strDispObject == "#3")
                                    strMessage += "OjwCase( " + ((CDisp.bFilled == true) ? "true" : "false") + ", " + "cColor[" + CDisp.cColor.Name.ToString() + "], true, false, " + CConvert.FloatToStr(CDisp.fGap) + "f, " + CConvert.FloatToStr(CDisp.fWidth_Or_Radius) + "f, " + CConvert.FloatToStr(CDisp.fHeight_Or_Depth) + "f, " + CConvert.FloatToStr(CDisp.fDepth_Or_Cnt) + "f, " + CConvert.FloatToStr(CDisp.fThickness) + "f, [" + CConvert.IntToStr(CDisp.nPickGroup_A) + ", " + CConvert.IntToStr(CDisp.nPickGroup_B) + ", " + CConvert.IntToStr(CDisp.nPickGroup_C) + ", " + ((CDisp.strPickGroup_Comment == null) ? "None" : CDisp.strPickGroup_Comment) + "]);\r\n";
                                else if (CDisp.strDispObject == "#4")
                                    strMessage += "OjwCase( " + ((CDisp.bFilled == true) ? "true" : "false") + ", " + "cColor[" + CDisp.cColor.Name.ToString() + "], true, true, " + CConvert.FloatToStr(CDisp.fGap) + "f, " + CConvert.FloatToStr(CDisp.fWidth_Or_Radius) + "f, " + CConvert.FloatToStr(CDisp.fHeight_Or_Depth) + "f, " + CConvert.FloatToStr(CDisp.fDepth_Or_Cnt) + "f, " + CConvert.FloatToStr(CDisp.fThickness) + "f, [" + CConvert.IntToStr(CDisp.nPickGroup_A) + ", " + CConvert.IntToStr(CDisp.nPickGroup_B) + ", " + CConvert.IntToStr(CDisp.nPickGroup_C) + ", " + ((CDisp.strPickGroup_Comment == null) ? "None" : CDisp.strPickGroup_Comment) + "]);\r\n";
                                else if (CDisp.strDispObject == "#5")
                                    strMessage += "OjwCase_half( " + ((CDisp.bFilled == true) ? "true" : "false") + ", " + "cColor[" + CDisp.cColor.Name.ToString() + "], true, false, " + CConvert.FloatToStr(CDisp.fGap) + "f, " + CConvert.FloatToStr(CDisp.fWidth_Or_Radius) + "f, " + CConvert.FloatToStr(CDisp.fHeight_Or_Depth) + "f, " + CConvert.FloatToStr(CDisp.fDepth_Or_Cnt) + "f, " + CConvert.FloatToStr(CDisp.fThickness) + "f, [" + CConvert.IntToStr(CDisp.nPickGroup_A) + ", " + CConvert.IntToStr(CDisp.nPickGroup_B) + ", " + CConvert.IntToStr(CDisp.nPickGroup_C) + ", " + ((CDisp.strPickGroup_Comment == null) ? "None" : CDisp.strPickGroup_Comment) + "]);\r\n";
                                else if (CDisp.strDispObject == "#6")
                                    strMessage += "OjwCase_half( " + ((CDisp.bFilled == true) ? "true" : "false") + ", " + "cColor[" + CDisp.cColor.Name.ToString() + "], true, true, " + CConvert.FloatToStr(CDisp.fGap) + "f, " + CConvert.FloatToStr(CDisp.fWidth_Or_Radius) + "f, " + CConvert.FloatToStr(CDisp.fHeight_Or_Depth) + "f, " + CConvert.FloatToStr(CDisp.fDepth_Or_Cnt) + "f, " + CConvert.FloatToStr(CDisp.fThickness) + "f, [" + CConvert.IntToStr(CDisp.nPickGroup_A) + ", " + CConvert.IntToStr(CDisp.nPickGroup_B) + ", " + CConvert.IntToStr(CDisp.nPickGroup_C) + ", " + ((CDisp.strPickGroup_Comment == null) ? "None" : CDisp.strPickGroup_Comment) + "]);\r\n";
                                else if (CDisp.strDispObject == "#7")
                                    strMessage += "OjwBox_Outside( " + ((CDisp.bFilled == true) ? "true" : "false") + ", " + "cColor[" + CDisp.cColor.Name.ToString() + "], " + CConvert.FloatToStr(CDisp.fWidth_Or_Radius) + "f, " + CConvert.FloatToStr(CDisp.fHeight_Or_Depth) + "f, " + CConvert.FloatToStr(CDisp.fDepth_Or_Cnt) + "f, " + CConvert.FloatToStr(CDisp.SOffset_Trans.x) + "f, " + CConvert.FloatToStr(CDisp.SOffset_Trans.y) + "f, " + CConvert.FloatToStr(CDisp.SOffset_Trans.z) + "f, " + CConvert.FloatToStr(CDisp.SOffset_Rot.pan) + "f, " + CConvert.FloatToStr(CDisp.SOffset_Rot.tilt) + "f, " + CConvert.FloatToStr(CDisp.SOffset_Rot.swing) + "f, [" + CConvert.IntToStr(CDisp.nPickGroup_A) + ", " + CConvert.IntToStr(CDisp.nPickGroup_B) + ", " + CConvert.IntToStr(CDisp.nPickGroup_C) + ", " + ((CDisp.strPickGroup_Comment == null) ? "None" : CDisp.strPickGroup_Comment) + "]);\r\n";

                                else if (CDisp.strDispObject == "#8")
                                    strMessage += "OjwCircle_Outside( " + ((CDisp.bFilled == true) ? "true" : "false") + ", " + "cColor[" + CDisp.cColor.Name.ToString() + "], " + CConvert.FloatToStr(CDisp.fWidth_Or_Radius) + "f, " + CConvert.FloatToStr(CDisp.fHeight_Or_Depth) + "f, " + CConvert.FloatToStr(CDisp.fDepth_Or_Cnt) + ", " + CConvert.FloatToStr(CDisp.SOffset_Trans.x) + "f, " + CConvert.FloatToStr(CDisp.SOffset_Trans.y) + "f, " + CConvert.FloatToStr(CDisp.SOffset_Trans.z) + "f, " + CConvert.FloatToStr(CDisp.SOffset_Rot.pan) + "f, " + CConvert.FloatToStr(CDisp.SOffset_Rot.tilt) + "f, " + CConvert.FloatToStr(CDisp.SOffset_Rot.swing) + "f, [" + CConvert.IntToStr(CDisp.nPickGroup_A) + ", " + CConvert.IntToStr(CDisp.nPickGroup_B) + ", " + CConvert.IntToStr(CDisp.nPickGroup_C) + ", " + ((CDisp.strPickGroup_Comment == null) ? "None" : CDisp.strPickGroup_Comment) + "]);\r\n";
                                else if (CDisp.strDispObject == "#9")
                                    strMessage += "OjwBall_Outside( " + ((CDisp.bFilled == true) ? "true" : "false") + ", " + "cColor[" + CDisp.cColor.Name.ToString() + "], " + CConvert.FloatToStr(CDisp.fWidth_Or_Radius) + "f, " + CConvert.FloatToStr(CDisp.fDepth_Or_Cnt) + ", " + CConvert.FloatToStr(CDisp.SOffset_Trans.x) + "f, " + CConvert.FloatToStr(CDisp.SOffset_Trans.y) + "f, " + CConvert.FloatToStr(CDisp.SOffset_Trans.z) + "f, " + CConvert.FloatToStr(CDisp.SOffset_Rot.pan) + "f, " + CConvert.FloatToStr(CDisp.SOffset_Rot.tilt) + "f, " + CConvert.FloatToStr(CDisp.SOffset_Rot.swing) + "f, [" + CConvert.IntToStr(CDisp.nPickGroup_A) + ", " + CConvert.IntToStr(CDisp.nPickGroup_B) + ", " + CConvert.IntToStr(CDisp.nPickGroup_C) + ", " + ((CDisp.strPickGroup_Comment == null) ? "None" : CDisp.strPickGroup_Comment) + "]);\r\n";
                                else if (CDisp.strDispObject == "#10")
                                    strMessage += "OjwCone_Outside( " + ((CDisp.bFilled == true) ? "true" : "false") + ", " + "cColor[" + CDisp.cColor.Name.ToString() + "], " + CConvert.FloatToStr(CDisp.fWidth_Or_Radius) + "f, " + CConvert.FloatToStr(CDisp.fHeight_Or_Depth) + "f, " + CConvert.FloatToStr(CDisp.fDepth_Or_Cnt) + ", " + CConvert.FloatToStr(CDisp.SOffset_Trans.x) + "f, " + CConvert.FloatToStr(CDisp.SOffset_Trans.y) + "f, " + CConvert.FloatToStr(CDisp.SOffset_Trans.z) + "f, " + CConvert.FloatToStr(CDisp.SOffset_Rot.pan) + "f, " + CConvert.FloatToStr(CDisp.SOffset_Rot.tilt) + "f, " + CConvert.FloatToStr(CDisp.SOffset_Rot.swing) + "f, [" + CConvert.IntToStr(CDisp.nPickGroup_A) + ", " + CConvert.IntToStr(CDisp.nPickGroup_B) + ", " + CConvert.IntToStr(CDisp.nPickGroup_C) + ", " + ((CDisp.strPickGroup_Comment == null) ? "None" : CDisp.strPickGroup_Comment) + "]);\r\n";
                                else if (CDisp.strDispObject == "#11")
                                    strMessage += "Axis_X( " + ((CDisp.bFilled == true) ? "true" : "false") + ", " + "cColor[" + CDisp.cColor.Name.ToString() + "], " + CConvert.FloatToStr(CDisp.fWidth_Or_Radius) + "f, " + CConvert.FloatToStr(CDisp.fHeight_Or_Depth) + "f, [" + CConvert.IntToStr(CDisp.nPickGroup_A) + ", " + CConvert.IntToStr(CDisp.nPickGroup_B) + ", " + CConvert.IntToStr(CDisp.nPickGroup_C) + ", " + ((CDisp.strPickGroup_Comment == null) ? "None" : CDisp.strPickGroup_Comment) + "]);\r\n";
                                else if (CDisp.strDispObject == "#12")
                                    strMessage += "Axis_Y( " + ((CDisp.bFilled == true) ? "true" : "false") + ", " + "cColor[" + CDisp.cColor.Name.ToString() + "], " + CConvert.FloatToStr(CDisp.fWidth_Or_Radius) + "f, " + CConvert.FloatToStr(CDisp.fHeight_Or_Depth) + "f, [" + CConvert.IntToStr(CDisp.nPickGroup_A) + ", " + CConvert.IntToStr(CDisp.nPickGroup_B) + ", " + CConvert.IntToStr(CDisp.nPickGroup_C) + ", " + ((CDisp.strPickGroup_Comment == null) ? "None" : CDisp.strPickGroup_Comment) + "]);\r\n";
                                else if (CDisp.strDispObject == "#13")
                                    strMessage += "Axis_Z( " + ((CDisp.bFilled == true) ? "true" : "false") + ", " + "cColor[" + CDisp.cColor.Name.ToString() + "], " + CConvert.FloatToStr(CDisp.fWidth_Or_Radius) + "f, " + CConvert.FloatToStr(CDisp.fHeight_Or_Depth) + "f, [" + CConvert.IntToStr(CDisp.nPickGroup_A) + ", " + CConvert.IntToStr(CDisp.nPickGroup_B) + ", " + CConvert.IntToStr(CDisp.nPickGroup_C) + ", " + ((CDisp.strPickGroup_Comment == null) ? "None" : CDisp.strPickGroup_Comment) + "]);\r\n";
                                else if (CDisp.strDispObject == "#14")
                                    strMessage += "Axis( " + ((CDisp.bFilled == true) ? "true" : "false") + ", " + "cColor[" + CDisp.cColor.Name.ToString() + "], " + "cColor[" + CDisp.cColor.Name.ToString() + "], " + "cColor[" + CDisp.cColor.Name.ToString() + "], " + CConvert.FloatToStr(CDisp.fWidth_Or_Radius) + "f, " + CConvert.FloatToStr(CDisp.fHeight_Or_Depth) + "f, [" + CConvert.IntToStr(CDisp.nPickGroup_A) + ", " + CConvert.IntToStr(CDisp.nPickGroup_B) + ", " + CConvert.IntToStr(CDisp.nPickGroup_C) + ", " + ((CDisp.strPickGroup_Comment == null) ? "None" : CDisp.strPickGroup_Comment) + "]);\r\n";
                                else //if ((CDisp.nDispModel >= 0x1000) && (CDisp.nDispModel < 0x2000))
                                    strMessage += "OjwAse_Outside( " + ((CDisp.bFilled == true) ? "true" : "false") + ", " + "cColor[" + CDisp.cColor.Name.ToString() + "], " + CConvert.FloatToStr(CDisp.fWidth_Or_Radius) + "f, " + CConvert.FloatToStr(CDisp.fHeight_Or_Depth) + "f, " + CConvert.FloatToStr(CDisp.fDepth_Or_Cnt) + ", " + CConvert.FloatToStr(CDisp.SOffset_Trans.x) + "f, " + CConvert.FloatToStr(CDisp.SOffset_Trans.y) + "f, " + CConvert.FloatToStr(CDisp.SOffset_Trans.z) + "f, " + CConvert.FloatToStr(CDisp.SOffset_Rot.pan) + "f, " + CConvert.FloatToStr(CDisp.SOffset_Rot.tilt) + "f, " + CConvert.FloatToStr(CDisp.SOffset_Rot.swing) + "f, [" + CConvert.IntToStr(CDisp.nPickGroup_A) + ", " + CConvert.IntToStr(CDisp.nPickGroup_B) + ", " + CConvert.IntToStr(CDisp.nPickGroup_C) + ", " + ((CDisp.strPickGroup_Comment == null) ? "None" : CDisp.strPickGroup_Comment) + ", 0x1000 + " + CDisp.strDispObject + "]);\r\n";
                                //OjwAse_Outside(bFilled, cColor, fAlpha, OjwDisp.fWidth_Or_Radius, OjwDisp.fHeight_Or_Depth, (int)Math.Round(OjwDisp.fDepth_Or_Cnt), OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing, OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z, (int)(OjwDisp.nDispModel & 0xfff));
                                
                                    

                            }
                        }
                    }

                    ///////////////////////
                    //OjwMessage(txtDraw_String, strMessage);
                    CDisp = null;
                    return strMessage;

                    //             afTrans = null;
                    //             afRot = null;
                }

                public string ClassToString(COjwDisp OjwDisp)
                {
                    String strData = "";
                    // Color, T,R, T,R, T,R, T,R, T,R
                    int nRoundPoint = 3; //Color.FromName("");


                    /*
                                    int nName, Color cColorData, int nModel, bool bFill, int fMulti, bool bInitialize, float fW, float fH, float fD, float fT, float fGapData, string strMessage,
                                    int nAxisData, int nDirData, float fAngleData, string strAngle_OffsetData
                                    SVector3D_t fOffset_Translation, SAngle3D_t fOffset_Rotation, 
                                    SVector3D_t[] afTranslation, SAngle3D_t[] afRotation, 
                                    Picking Group A(int), B(int), C(int) ,     Comment(String),
                     */


                    // ID, Model(Circle, ...), ColorR, ColorG, ColorB
                    strData =
                        "[" +
                        CConvert.IntToStr(OjwDisp.nName) +
                        "]," +
                        CConvert.IntToStr(OjwDisp.cColor.ToArgb()) + "," + 
                        // new item(alpha) added in here
                        Ojw.CConvert.FloatToStr(OjwDisp.fAlpha) + "," +
                        OjwDisp.strDispObject + "," + //CConvert.IntToStr(OjwDisp.nDispModel) + "," +
                        // bFilled, fMul_3DAngle, bInit
                        CConvert.BoolToStr(OjwDisp.bFilled) + "," + CConvert.FloatToStr(OjwDisp.fMulti) + "," + CConvert.BoolToStr(OjwDisp.bInit) + "," +

                        "[" +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.fWidth_Or_Radius, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.fHeight_Or_Depth, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.fDepth_Or_Cnt, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.fThickness, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.fGap, nRoundPoint)) +
                        "]," +

                        "[" +
                        // Axis(None, Pan, Tilt, Swing), Dir, Angle, Angle_Offset
                        CConvert.IntToStr(OjwDisp.nAxisMoveType) + "," + CConvert.IntToStr(OjwDisp.nDir) + "," + CConvert.FloatToStr((float)Math.Round(OjwDisp.fAngle, nRoundPoint)) + "," + OjwDisp.strAngle_Offset +
                        "]," +

                        // Offset(X,Y,Z,  P,T,S)
                        "[" +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.SOffset_Trans.x, nRoundPoint)) + "," + CConvert.FloatToStr((float)Math.Round(OjwDisp.SOffset_Trans.y, nRoundPoint)) + "," + CConvert.FloatToStr((float)Math.Round(OjwDisp.SOffset_Trans.z, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.SOffset_Rot.pan, nRoundPoint)) + "," + CConvert.FloatToStr((float)Math.Round(OjwDisp.SOffset_Rot.tilt, nRoundPoint)) + "," + CConvert.FloatToStr((float)Math.Round(OjwDisp.SOffset_Rot.swing, nRoundPoint)) +
                        "]," +

                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afTrans[0].x, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afTrans[0].y, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afTrans[0].z, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afRot[0].pan, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afRot[0].tilt, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afRot[0].swing, nRoundPoint)) + "," +

                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afTrans[1].x, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afTrans[1].y, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afTrans[1].z, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afRot[1].pan, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afRot[1].tilt, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afRot[1].swing, nRoundPoint)) + "," +

                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afTrans[2].x, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afTrans[2].y, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afTrans[2].z, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afRot[2].pan, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afRot[2].tilt, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afRot[2].swing, nRoundPoint)) + "," +

                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afTrans[3].x, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afTrans[3].y, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afTrans[3].z, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afRot[3].pan, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afRot[3].tilt, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afRot[3].swing, nRoundPoint)) + "," +

                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afTrans[4].x, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afTrans[4].y, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afTrans[4].z, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afRot[4].pan, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afRot[4].tilt, nRoundPoint)) + "," +
                        CConvert.FloatToStr((float)Math.Round(OjwDisp.afRot[4].swing, nRoundPoint)) + "],[" +
                        CConvert.IntToStr(OjwDisp.nPickGroup_A) + "," +
                        CConvert.IntToStr(OjwDisp.nPickGroup_B) + "," +
                        CConvert.IntToStr(OjwDisp.nPickGroup_C) + ",[" +
                        CConvert.IntToStr(OjwDisp.nInverseKinematicsNumber) + "],[" +
                        CConvert.FloatToStr(OjwDisp.fScale_Serve0) + "," +
                        CConvert.FloatToStr(OjwDisp.fScale_Serve1) + "],[" +
                        CConvert.IntToStr(OjwDisp.nMotorType) + "," +
                        CConvert.IntToStr(OjwDisp.nMotorControl_MousePoint) + "]," +
                        ((OjwDisp.strPickGroup_Comment == null) ? "None" : OjwDisp.strPickGroup_Comment) +
                        "]";
                    return strData;
                }
                #endregion Class Control
            
                #region Picking
                private bool m_bMateMode = false; // 픽킹시 mate 기능 활성화
                public void SetPickingMode_Mate(bool bEn) { m_bMateMode = bEn; } // 이걸 셋 하면 기존 클릭 기능이 막히고 Mate 를 위한 클릭이 된다.

                private bool m_bPickMode = false;
                private const int _PICK_BUFFER_SIZE = 64;
                private uint[] m_puiPick = new uint[_PICK_BUFFER_SIZE];
                public void Picking_Ready(int nX, int nY)
                {
                    m_bPickMode = true;

                    m_unObjectName = 0; // Init variables for picking group(Kor: 픽킹 그룹핑 변수 초기화)
                    int[] viewport = new int[4];

                    // select buffer(Kor: 선택 버퍼 설정)
                    Gl.glSelectBuffer(_PICK_BUFFER_SIZE, m_puiPick);
#if false
                    viewport[0] = 0;// (int)(-m_nWidth / 2 * m_fScale);
                    viewport[1] = 0;// (int)(-m_nHeight / 2 * m_fScale);
                    viewport[2] = (int)(m_nWidth * 2);
                    viewport[3] = (int)(m_nHeight * 2);
#else
                    // get the view port(Kor: 뷰포트 얻기)
                    Gl.glGetIntegerv(Gl.GL_VIEWPORT, viewport);
#endif


                    // Init Names(Kor: 이름 초기화)
                    InitNames();

                    // Switch to the projection. And storage arrays(Kor: 투영으로 전환하고 배열을 저장)
                    Gl.glMatrixMode(Gl.GL_PROJECTION);
                    Gl.glPushMatrix();

                    // Switch to the rendering mode(Kor: 렌더링 모드 변경)
                    Gl.glRenderMode(Gl.GL_SELECT);

                    // Making the size of the unit cube clipping region in which the mouse pointer [x, y], the horizontal and vertical expansion by two pixels.
                    // Kor: 마우스 포인터가 있는 x,y 에 단위 크기의 육면체 클리핑 영역을 만들고, 수평 수직 방향으로 두 픽셀씩 확장한다.
                    Gl.glLoadIdentity();
                    //Gl.gluPickMatrix(nX, viewport[3] - nY, 2, 2, viewport);
                    //Glu.gluPickMatrix((double)nX, (double)(viewport[3] - nY), 1.0, 1.0, viewport);
                    Glu.gluPickMatrix((double)nX, (double)(viewport[3] - nY), 1.0, 1.0, viewport);

                    // Application of projection matrices(Kor: 투영 행렬의 적용)
#if false
            int nRatio = 100;
            //Gl.gluPerspective(65.0f, aspect_ratio, 0, -nRatio);
            //Gl.glOrtho(-nRatio, nRatio, -nRatio, nRatio, -nRatio, nRatio);
            Ortho(nRatio);
            Gl.glDepthRange(-nRatio, nRatio);
#else
                    float fRatio = (float)(_RATIO * m_fScale);// Math.Round(_RATIO * m_fScale);
                    Ortho((float)m_nWidth, (float)m_nHeight, fRatio);
                    Gl.glDepthRange(-fRatio, fRatio);
#endif
                    // In the case of Perspective projection(Kor: 원근투영의 경우)
                    /*
                    float fAspect = (float)viewport[2] / (float)viewport[3];
                    Gl.gluPerspective(45.0f, fAspect, 1.0, 425.0);
                    */
                    //

                    Gl.glMatrixMode(Gl.GL_MODELVIEW);

                    // Should begin rendering the scene.(Kor: 이후 장면 렌더링을 시작해야 한다.)

                    // Initialize
                    viewport = null;
                }

                public uint Picking_Check()
                {
                    int nHits = Gl.glRenderMode(Gl.GL_RENDER); // get the hit counts(Kor: 히트 수 수집)
                    // If one of the hit once, outputs information(Kor: 한번의 히트일 경우, 정보를 출력)
                    if (nHits > 0)
                    {
                        // m_puiPick[0] // the number of collisions with object(Kor: Object 와의 충돌횟수)
                        // m_puiPick[1] // Min means a value of the object collided with the collision point and the set area.(Kor: 설정된 공간과 충돌한 object 와의 충돌 지점의 Min값을 의미한다.)
                        // m_puiPick[2] // Max means a value of the object collided with the collision point and the set area.(Kor: 설정된 공간과 충돌한 object 와의 충돌 지점의 Max값을 의미한다.)
                        // m_puiPick[3 ...] The total number of records [m_puiPick[0]](Kor: m_puiPick[0] 에 기록된 수 만큼...)
                        // => repeat all(Kor: 이게 반복)

                        //uint nNearID = (uint)m_puiPick[3];
                        //uint nNearDepth = (uint)m_puiPick[1];
                        int nPos = 0;
#if false
                        // 16 = 64 / 14
                        for (int i = 0; i < nHits; i++)
                        {
                            if (m_puiPick[nPos * 4 + 1] > m_puiPick[i * 4 + 1])
                            {
                                nPos = i;
                                //break;
                                //nNearDepth = m_puiPick[i * 4 + 1];
                                //nNearID = m_puiPick[i * 4 + 3];
                            }
                        }
                        m_unObjectName = (uint)m_puiPick[nPos * 4 + 3];// nNearID;// m_puiPick[3]; // 선택된 Object의 ID
                        return (uint)m_puiPick[nPos * 4 + 3];//nNearID;// m_puiPick[3];
#else
                        int nObj = 0;
                        bool bFind = false;
                        uint unObjMin = 0xffffffff;
                        //uint unObjMax = 0;
                        for (int i = 0; i < nHits; i++)
                        {
                            int nSize = (int)m_puiPick[nPos++];
                            // Min
                            uint unMin = (uint)m_puiPick[nPos];
                            nPos++;
                            // Max
                            uint unMax = (uint)m_puiPick[nPos];
                            nPos++;
#if false
                            //for (int j = 0; j < nSize; j++)
                            {
                                //if (m_puiPick[nPos++] > nObj)
                                //{
                                //    nObj = nPos - 1;
                                //}
                                if ((bFind == false) || (unObjMin >= unMin))
                                //if ((bFind == false) || (unObjMax < unMax))
                                {
                                    unObjMin = unMin;
                                    //unObjMax = unMax;
                                    bFind = true;
                                    nObj = nPos;

                                    nPos += nSize;
                                }
                            }
#else
                            for (int j = 0; j < nSize; j++)
                            {
                                if ((bFind == false) || (unObjMin >= unMin))
                                {
                                    unObjMin = unMin;
                                    bFind = true;

                                    if (m_puiPick[nPos] >= m_puiPick[nObj])
                                    {
                                        nObj = nPos;
                                    }
                                }
                                nPos++;
                            }
#endif
                        }
                        m_unObjectName = (uint)m_puiPick[nObj];// nNearID;// m_puiPick[3]; // Selected Object's ID(Kor: 선택된 Object의 ID)
                        return m_unObjectName;
#endif
                    }
                    return 0;
                }

                public void Picking_End()
                {
                    // Projection matrix recovery(Kor: 투영행렬 복구)
                    Gl.glMatrixMode(Gl.GL_PROJECTION);
                    Gl.glPopMatrix();
                    //Gl.glFlush();
                    // Switch to normal rendering mode(Kor: 보통의 렌더링 모드로 전환)
                    Gl.glMatrixMode(Gl.GL_MODELVIEW);
                    m_bPickMode = false;
                    m_bPickMouseClick = false;
                    m_bPickingData = true;
                }

                private bool m_bPickingData = false;
                public bool IsPicking()
                {
                    return m_bPickingData;
                }
                public void Clear_IsPicking()
                {
                    m_bPickingData = false;
                }
                
                uint m_unObjectName = 0;
                public bool GetPickingData(out int nGroupA, out int nGroupB, out int nGroupC, out int nInverseKinematicsNumber)
                {
                    // 0x 1111 1111(Formular group)   1111 1111(group A) 1 1111 1111(group B(0~255:motor, 256~511:etc group))  111 1111(group C(0~127))
                    // Kor: 0x 1111 1111(수식그룹)   1111 1111(그룹 A) 1 1111 1111(그룹 B(0~255:모터, 256~511:기타그룹))  111 1111(그룹 C(0~127))
                    nInverseKinematicsNumber = (int)((m_unObjectName >> 24) & 0xff); // High byte group number formula(Kor: 상위 바이트는 수식그룹번호)
                    nGroupA = (int)((m_unObjectName >> 16) & 0xff); // High byte group number formula(Kor: 상위 바이트는 수식그룹번호)
                    //nGroupB = (int)((m_unObjectName >> 8) & 0xff);
                    //nGroupC = (int)(m_unObjectName & 0xff);
                    nGroupB = (int)((m_unObjectName >> 7) & 0x1ff);
                    nGroupC = (int)(m_unObjectName & 0x7f);
                    return (((m_unObjectName & 0xffffff) != 0) ? true : false);
                }
                #endregion Picking

                #region SetName
                public void InitNames()
                {
                    if (m_bPickMode == true)
                    {
                        Gl.glInitNames();
                        Gl.glPushName(0);
                        //m_unName = 1;
                    }
                }
                public void SetName(uint i)
                {
                    if (m_bPickMode == true)
                        Gl.glLoadName(i);
                }
                public void PushName(uint i)
                {
                    if (m_bPickMode == true)
                        Gl.glPushName(i);
                }
                public void PopName()
                {
                    if (m_bPickMode == true)
                        Gl.glPopName();
                }
                #endregion SetName

                #region Push / Pop
                public void Push()
                {
                    Gl.glPushMatrix();
                }
                public void Pop()
                {
                    Gl.glPopMatrix();
                }
                #endregion Push / Pop

                #region Collection functions of OpenGL actually draw(Kor: OpenGL을 실제로 그리는 함수 모음)
                // Box which rotates around the center of the upper surface(Kor: 윗면의 중심을 기준으로 회전하는 상자)
                #region OjwBox_Text
                //public void OjwPolygon(int a, int b, int c, int d)
                //{
                //    float[,] vertices = new float[8,3];
                //    int i = 0;
                //    vertices[i, 0] = -1.0f;
                //    vertices[i, 1] = -1.0f;
                //    vertices[i, 2] = 1.0f;
                //    i++;

                //    Gl.glVertex3fv(vertices[a]
                //}
                public void OjwBox_Text(bool bFill, Color color,
                                    float fW, float fH, float fD            // put the size(Kor: Size 기입)
                                )
                {
                    m_fColor[0] = ((float)(color.R) / 255.0f);  // R
                    m_fColor[1] = ((float)(color.G) / 255.0f);  // G
                    m_fColor[2] = ((float)(color.B) / 255.0f);  // B
                    Gl.glColor3fv(m_fColor); // Color with an array of floats
                    float fX1 = -fW / 2.0f;
                    float fX2 = fW / 2.0f;
                    float fY1 = 0;
                    float fY2 = -fH;
                    float fZ1 = -fD / 2.0f;
                    float fZ2 = fD / 2.0f;
                    // x2 -> direction : right(Kor: 증분방향 : 오른쪽)
                    // Y2 -> direction : Up(Kor: 증분방향 : 위쪽)
                    // Z2 -> direction : The inside of the screen(Kor: 증분방향 : 화면의 안쪽)
                    // Criteria screen : See picture below(Kor: 기준화면 : 밑 그림 참조)
                    // 0, 0, 0 -> State in the middle of the screen as a starting point and went inside by a factor of 5
                    // Kor: 0, 0, 0 -> 화면의 가운데를 시작점으로 하고 안쪽으로 5만큼 들어간 상태
                    
                    /*
                        000000000
                      0 0 ★  0 0
                    000000000   0
                    0   0   0   0
                    0   000000000  
                    0 0     0 0
                    000000000  
                    ( Center position )
                    */

                    //Gl.glBindTexture(Gl.GL_TEXTURE_2D, m_puiTexture[0]);									// Select Our Texture

                    int uiType = (bFill == true) ? Gl.GL_POLYGON : Gl.GL_LINE_LOOP;//Gl.GL_LINE_LOOP;// Gl.GL_QUADS;//

                    Gl.glBegin(uiType);															// Draw A Cube Using Quads
#if false
            // Front Face
            Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(-1.0f, -1.0f, 1.0f);				// Bottom Left Of The Texture and Quad
            Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(1.0f, -1.0f, 1.0f);				// Bottom Right Of The Texture and Quad
            Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(1.0f, 1.0f, 1.0f);				// Top Right Of The Texture and Quad
            Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(-1.0f, 1.0f, 1.0f);				// Top Left Of The Texture and Quad
            // Back Face
            Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(-1.0f, -1.0f, -1.0f);				// Bottom Right Of The Texture and Quad
            Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(-1.0f, 1.0f, -1.0f);				// Top Right Of The Texture and Quad
            Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(1.0f, 1.0f, -1.0f);				// Top Left Of The Texture and Quad
            Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(1.0f, -1.0f, -1.0f);				// Bottom Left Of The Texture and Quad
            // Top Face
            Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(-1.0f, 1.0f, -1.0f);				// Top Left Of The Texture and Quad
            Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(-1.0f, 1.0f, 1.0f);				// Bottom Left Of The Texture and Quad
            Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(1.0f, 1.0f, 1.0f);				// Bottom Right Of The Texture and Quad
            Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(1.0f, 1.0f, -1.0f);				// Top Right Of The Texture and Quad
            // Bottom Face
            Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(-1.0f, -1.0f, -1.0f);				// Top Right Of The Texture and Quad
            Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(1.0f, -1.0f, -1.0f);				// Top Left Of The Texture and Quad
            Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(1.0f, -1.0f, 1.0f);				// Bottom Left Of The Texture and Quad
            Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(-1.0f, -1.0f, 1.0f);				// Bottom Right Of The Texture and Quad
            // Right Face
            Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(1.0f, -1.0f, -1.0f);				// Bottom Right Of The Texture and Quad
            Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(1.0f, 1.0f, -1.0f);				// Top Right Of The Texture and Quad
            Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(1.0f, 1.0f, 1.0f);				// Top Left Of The Texture and Quad
            Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(1.0f, -1.0f, 1.0f);				// Bottom Left Of The Texture and Quad
            // Left Face
            Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(-1.0f, -1.0f, -1.0f);				// Bottom Left Of The Texture and Quad
            Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(-1.0f, -1.0f, 1.0f);				// Bottom Right Of The Texture and Quad
            Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(-1.0f, 1.0f, 1.0f);				// Top Right Of The Texture and Quad
            Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(-1.0f, 1.0f, -1.0f);				// Top Left Of The Texture and Quad
#else
                    //byte[] buffer = new byte[];
                    //IntPtr 
                    //Gl.glDrawElements(Gl.GL_LINE_LOOP, 4, Gl.GL_UNSIGNED_BYTE, ip);
                    // Front Face
                    Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2);				// Bottom Left Of The Texture and Quad
                    Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ2);				// Bottom Right Of The Texture and Quad
                    Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ2);				// Top Right Of The Texture and Quad
                    Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ2);				// Top Left Of The Texture and Quad
                    // Back Face
                    Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ1);				// Bottom Right Of The Texture and Quad
                    Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1);				// Top Right Of The Texture and Quad
                    Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ1);				// Top Left Of The Texture and Quad
                    Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ1);				// Bottom Left Of The Texture and Quad
                    // Top Face
                    Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1);				// Top Left Of The Texture and Quad
                    Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY1, fZ2);				// Bottom Left Of The Texture and Quad
                    Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY1, fZ2);				// Bottom Right Of The Texture and Quad
                    Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ1);				// Top Right Of The Texture and Quad
                    // Bottom Face
                    Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY2, fZ1);				// Top Right Of The Texture and Quad
                    Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX2, fY2, fZ1);				// Top Left Of The Texture and Quad
                    Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ2);				// Bottom Left Of The Texture and Quad
                    Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2);				// Bottom Right Of The Texture and Quad
                    // Right Face
                    Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ1);				// Bottom Right Of The Texture and Quad
                    Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ1);				// Top Right Of The Texture and Quad
                    Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ2);				// Top Left Of The Texture and Quad
                    Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ2);				// Bottom Left Of The Texture and Quad
                    // Left Face
                    Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ1);				// Bottom Left Of The Texture and Quad
                    Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2);				// Bottom Right Of The Texture and Quad
                    Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ2);				// Top Right Of The Texture and Quad
                    Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1);				// Top Left Of The Texture and Quad
#endif
                    Gl.glEnd();
                }
                #endregion OjwBox_Text

                private int m_uiMode = Gl.GL_RENDER;
                public void OjwSetMode(int uiMode)
                {
                    m_uiMode = uiMode;
                }

                #region StandardAxis
                private bool m_bStandardAxis = false;
                public bool IsStandardAxis() { return m_bStandardAxis; }
                public void SetStandardAxis(bool bEn) { m_bStandardAxis = bEn; }
                #endregion StandardAxis

                #region VirtualvClass
                private bool m_bVirtualClass = false;
                COjwDisp OjwVirtualDisp = new COjwDisp();
                public void SetVirtualClass_Enable(bool bOn) { m_bVirtualClass = bOn; }
                public void SetVirtualClass_Data(COjwDisp CDisp) { OjwVirtualDisp = CDisp; }
                public COjwDisp GetVirtualClass_Data() { return OjwVirtualDisp.Clone(); }
                public void InitVirtualClass() { OjwVirtualDisp.InitData(); }
                public bool IsVirtualClass() { return m_bVirtualClass; }
                public void AddVirtualClassToReal()
                {
                    String strResult = String.Empty;

                    Convert_CDisp_To_String(GetVirtualClass_Data(), ref strResult);
                    strResult = Ojw.CConvert.RemoveString(strResult, "\r\n");
                    AddHeader_strDrawModel(strResult);
                    CompileDesign();

                    //DispModelString();
                    InitVirtualClass();
                    Prop_Update_VirtualObject();

                    // Event 발생
                    Event_ItemAdd.RunEvent();
                }


                #endregion TestClass

                #region TestDh
                private bool m_bTestDh = false;
                private float[] m_afDhInitPoint = new float[3] { 0.0f, 0.0f, 0.0f };
                private float[] m_afDhPoint = new float[3] { 0.0f, 0.0f, 0.0f };
                //private float[] m_afDhAngle = new float[3] { 0.0f, 0.0f, 0.0f };
                private float[] m_afDhAngle_X = new float[3];// { 0.0f, 0.0f, 0.0f };
                private float[] m_afDhAngle_Y = new float[3];// { 0.0f, 0.0f, 0.0f };
                private float[] m_afDhAngle_Z = new float[3];// { 0.0f, 0.0f, 0.0f };
                private float m_fDhSize = 10.0f;
                private float m_fDhAlpha = 1.0f;
                private Color m_cDh = Color.Red;
                public void SetTestDh(bool bEn) { m_bTestDh = bEn; }
                public bool IsTestDh() { return m_bTestDh; }
                public void SetTestDh_InitPos(float fX, float fY, float fZ) { m_afDhInitPoint[0] = fX; m_afDhInitPoint[1] = fY; m_afDhInitPoint[2] = fZ; }
                public void SetTestDh_Pos(float fX, float fY, float fZ) { m_afDhPoint[0] = fX; m_afDhPoint[1] = fY; m_afDhPoint[2] = fZ; }
                //public void SetTestDh_Angle(float fX, float fY, float fZ) { m_afDhAngle[0] = fX; m_afDhAngle[1] = fY; m_afDhAngle[2] = fZ; }
                public void SetTestDh_Angle(float[] afX, float[] afY, float[] afZ)
                {
                    Array.Copy(afX, 0, m_afDhAngle_X, 0, 3);
                    Array.Copy(afY, 0, m_afDhAngle_Y, 0, 3);
                    Array.Copy(afZ, 0, m_afDhAngle_Z, 0, 3);
                    //int _X = 0;
                    //int _Y = 1;
                    //int _Z = 2;
                    //for (int i = 0; i < 3; i++)
                    //{
                    //    m_afDhAngle[i, _X] = afX[i];
                    //    m_afDhAngle[i, _Y] = afY[i];
                    //    m_afDhAngle[i, _Z] = afZ[i];
                    //}
                }
                public void SetTestDh_Size(float fSize) { m_fDhSize = fSize; }
                public void SetTestDh_Color(Color cColor) { m_cDh = cColor; }
                public void SetTestDh_Alpha(float fAlpha) { m_fDhAlpha = fAlpha; }
                #endregion TestDh

                #region TestCircle
                private bool m_bTestCircle = false;
                private bool m_bTestAxis = false;
                private Color m_cColor_Test = Color.Red;
                public float[] m_afPos_Test = new float[3];
                public float[] m_afAngle_Test = new float[3];
                public void SetTestCircle(bool bOn)
                {
                    m_bTestCircle = bOn;
                }
                public void SetTestAxis(bool bOn)
                {
                    m_bTestAxis = bOn;
                }

                public bool IsTestCircle() { return m_bTestCircle; }
                public bool IsTestAxis() { return m_bTestAxis; }
                public void SetColor_Test(Color cColor) { m_cColor_Test = cColor; }
                public Color GetColor_Test() { return m_cColor_Test; }
                private float m_fTestSize = 10.0f;
                public void SetSize_Test(float fSize) { m_fTestSize = fSize; }
                public void SetPos_Test(float fX, float fY, float fZ)
                {
                    m_afPos_Test[0] = fX;
                    m_afPos_Test[1] = fY;
                    m_afPos_Test[2] = fZ;
                }
                public void GetPos_Test(out float fX, out float fY, out float fZ)
                {
                    fX = m_afPos_Test[0];
                    fY = m_afPos_Test[1];
                    fZ = m_afPos_Test[2];
                }
                public void SetAngle_Test(float fPan, float fTilt, float fSwing)
                {
                    m_afAngle_Test[0] = fPan;
                    m_afAngle_Test[1] = fTilt;
                    m_afAngle_Test[2] = fSwing;
                }
                public void GetAngle_Test(out float fX, out float fY, out float fZ)
                {
                    fX = m_afAngle_Test[0];
                    fY = m_afAngle_Test[1];
                    fZ = m_afAngle_Test[2];
                }
                #endregion TestCircle

                #region OpenNurbs
                public void OjwModeling()
                {
                    return;
                    //             for (int i = 0; i < model.m_object_table.Count(); i++)
                    //             {
                    //                 // Get a model object
                    //                 IOnXModel_Object model_obj = model.m_object_table[i];
                    //                 if (model_obj == null) continue;
                    //                 
                    //                 // Get the geometry of the object
                    //                 IOnObject obj = model_obj.m_object;
                    //                 if (obj == null) continue;
                    // 
                    //                 // Is the geometry a curve?
                    //                 IOnCurve crv = OnCurve.ConstCast(obj);
                    //                 if (crv != null)
                    //                 {
                    //                     // OnCurve is a virtual class. So, if we want the curve's data,
                    //                     // then we need to cast the curve object as one of the implemented
                    //                     // curve types
                    // 
                    //                     // Is the curve a line?
                    //                     IOnLineCurve line_crv = OnLineCurve.ConstCast(crv);
                    //                     if (line_crv != null)
                    //                     {
                    //                         // TODO: process line curve
                    //                         continue;
                    //                     }
                    // 
                    //                     // Is the curve a polyline?
                    //                     IOnPolylineCurve pline_crv = OnPolylineCurve.ConstCast(crv);
                    //                     if (pline_crv != null)
                    //                     {
                    //                         // TODO: process polyline curve
                    //                         continue;
                    //                     }
                    // 
                    //                     // Is the curve an arc (or circle)?
                    //                     IOnArcCurve arc_crv = OnArcCurve.ConstCast(crv);
                    //                     if (arc_crv != null)
                    //                     {
                    //                         // TODO: process arc curve
                    //                         continue;
                    //                     }
                    // 
                    //                     // Is the curve a polycurve?
                    //                     IOnPolyCurve poly_crv = OnPolyCurve.ConstCast(crv);
                    //                     if (poly_crv != null)
                    //                     {
                    //                         // TODO: process poly curve
                    //                         continue;
                    //                     }
                    // 
                    //                     // Is the curve a NURBS curve?
                    //                     IOnNurbsCurve nurbs_crv = OnNurbsCurve.ConstCast(crv);
                    //                     if (nurbs_crv != null)
                    //                     {
                    //                         // TODO: process NURBS curve
                    //                         continue;
                    //                     }
                    //                 }
                    //             }
                }
                #endregion OpenNurbs

                // Box which rotates around the center of the upper surface(Kor: 윗면의 중심을 기준으로 회전하는 상자)
                #region OjwBox
                public void OjwBox(bool bFill, Color color, float fAlpha,
                                    float fW, float fH, float fD            // Input the Size(Kor: Size 기입)
                                )
                {
                    int nLoopCount = ((bFill == true) ? 2 : 1);
                    for (int nLoop = 0; nLoop < nLoopCount; nLoop++)
                    {
                        int nSub = _COLOR_GAP;
                        Color cColor = color;// ((nLoop == 0) ? color : Color.DarkGray);
                        m_fColor[0] = ((float)((nLoop == 0) ? cColor.R : cColor.R - nSub) / 255.0f);  // R
                        m_fColor[1] = ((float)((nLoop == 0) ? cColor.G : cColor.G - nSub) / 255.0f);  // G
                        m_fColor[2] = ((float)((nLoop == 0) ? cColor.B : cColor.B - nSub) / 255.0f);  // B
                        m_fColor[3] = fAlpha;// m_fAlpha;//
                        for (int j = 0; j < 3; j++)
                        {
                            if (m_fColor[j] < 0) m_fColor[j] = ((float)(((j == 0) ? cColor.R : ((j == 1) ? cColor.G : cColor.B)) + nSub) / 255.0f);//0.0f;
                        }
                        Gl.glColor4fv(m_fColor);
                        //Gl.glPolygonMode(Gl.GL_FRONT, (int)((bFill == true) ? Gl.GL_FILL : Gl.GL_POINT));
                        //Gl.glPolygonMode(Gl.GL_BACK, (int)((bFill == true) ? Gl.GL_LINE : Gl.GL_LINE));
                        //Gl.glColor3fv(m_fColor); // Color with an array of floats

#if _ABS_POS
                        float fX1 = (-fW + m_fAbsPos_X) / 2.0f;
                        float fX2 = (fW + m_fAbsPos_X) / 2.0f;// fX / 2.0f;
                        float fY1 = m_fAbsPos_Y;// fY / 2.0f;
                        float fY2 = (-fH + m_fAbsPos_Y); // / 2.0f;
                        float fZ1 = (-fD + m_fAbsPos_Z) / 2.0f;
                        float fZ2 = (fD + m_fAbsPos_Z) / 2.0f;
#else
                        float fX1 = -fW / 2.0f;
                        float fX2 = fW / 2.0f;
                        float fY1 = 0;
                        float fY2 = -fH;
                        float fZ1 = -fD / 2.0f;
                        float fZ2 = fD / 2.0f;
#endif
                        // x2 -> direction : right(Kor: 증분방향 : 오른쪽)
                        // Y2 -> direction : Up(Kor: 증분방향 : 위쪽)
                        // Z2 -> direction : The inside of the screen(Kor: 증분방향 : 화면의 안쪽)
                        // Criteria screen : See picture below(Kor: 기준화면 : 밑 그림 참조)
                        // 0, 0, 0 -> State in the middle of the screen as a starting point and went inside by a factor of 5
                        // Kor: 0, 0, 0 -> 화면의 가운데를 시작점으로 하고 안쪽으로 5만큼 들어간 상태
                        /*
                            000000000
                          0 0 ★  0 0
                        000000000   0
                        0   0   0   0
                        0   000000000  
                        0 0     0 0
                        000000000  
                        ( Center position )
                        */

                        //int uiType = (bFill == true) ? Gl.GL_QUADS : Gl.GL_LINE_LOOP;//Gl.GL_LINE_LOOP;// Gl.GL_QUADS;//
                        //int uiType = (bFill == true) ? Gl.GL_POLYGON : Gl.GL_LINE_LOOP;
                        
                        int uiType = ((bFill == true) ? ((nLoop == 0) ? Gl.GL_POLYGON : Gl.GL_LINE_LOOP) : Gl.GL_LINE_LOOP);
                        int uiTypeTop = (bFill == true) ? Gl.GL_FILL : Gl.GL_LINE;
                        //int uiType = Gl.GL_TRIANGLE_FAN;// (bFill == true) ? Gl.GL_TRIANGLE_FAN : Gl.GL_LINE_LOOP;
                        Gl.glPolygonMode(Gl.GL_FRONT, uiTypeTop);
                        Gl.glPolygonMode(Gl.GL_BACK, uiTypeTop);
                        //Gl.glPolygonMode(Gl.GL_FRONT, (int)((bFill == true) ? Gl.GL_FILL : Gl.GL_POINT));
                        //Gl.glPolygonMode(Gl.GL_BACK, (int)((bFill == true) ? Gl.GL_LINE : Gl.GL_LINE));
                        Gl.glBegin(uiType);

                        //if (m_uiMode == Gl.GL_SELECT) Gl.glLoadName(111);

                        //Gl.glBindTexture(Gl.GL_TEXTURE_2D, m_puiTexture[0]);									// Select Our Texture
                        //Gl.glBegin(uiType);
#if true
                        // Front Face
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ2);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ2);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ2);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2);				// Bottom Left Of The Texture and Quad

                        Gl.glEnd();// end drawing the cube	
                        Gl.glBegin(uiType);

                        // Back Face
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ1);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ1);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ1);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ1);				// Bottom Right Of The Texture and Quad

                        Gl.glEnd();// end drawing the cube	
                        Gl.glBegin(uiType);

                        // Top Face
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY1, fZ2);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY1, fZ2);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ1);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1);				// Top Left Of The Texture and Quad

                        Gl.glEnd();// end drawing the cube	
                        Gl.glBegin(uiType);

                        // Bottom Face
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY2, fZ1);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX2, fY2, fZ1);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ2);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY2, fZ1);				// Top Right Of The Texture and Quad

                        Gl.glEnd();// end drawing the cube	
                        Gl.glBegin(uiType);

                        // Right Face
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ1);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ1);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ2);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ2);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ1);				// Bottom Right Of The Texture and Quad

                        Gl.glEnd();// end drawing the cube	
                        Gl.glBegin(uiType);

                        // Left Face
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ1);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ2);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ1);				// Bottom Left Of The Texture and Quad
#else
                        // Front Face
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ2);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ2);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ2);				// Top Left Of The Texture and Quad
                        // Back Face
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ1);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ1);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ1);				// Bottom Left Of The Texture and Quad
                        // Top Face
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY1, fZ2);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY1, fZ2);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ1);				// Top Right Of The Texture and Quad
                        // Bottom Face
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY2, fZ1);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX2, fY2, fZ1);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ2);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2);				// Bottom Right Of The Texture and Quad
                        // Right Face
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ1);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ1);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ2);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ2);				// Bottom Left Of The Texture and Quad
                        // Left Face
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ1);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ2);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1);				// Top Left Of The Texture and Quad
#endif
                        Gl.glEnd();// end drawing the cube	
                    }
                }
                #endregion OjwBox;

                // Box which rotates around the center of the upper surface(Making remotely moving box by offset)
                // Kor: 윗면의 중심을 기준으로 회전하는 상자(원격 상자 만들기)
                #region OjwBox_Outside
                public void OjwBox_Outside(bool bFill, Color color, float fAlpha,
                                    float fW, float fH, float fD,            
                                    float fOffsetPan, float fOffsetTilt, float fOffsetSwing,   // Rotation Axis(Offset)
                                    float fOffsetX, float fOffsetY, float fOffsetZ // Offset Position
                                )
                {
                    int nLoopCount = ((bFill == true) ? 2 : 1);
                    for (int nLoop = 0; nLoop < nLoopCount; nLoop++)
                    {
                        int nSub = _COLOR_GAP;
                        Color cColor = color;// ((nLoop == 0) ? color : Color.DarkGray);
                        m_fColor[0] = ((float)((nLoop == 0) ? cColor.R : cColor.R - nSub) / 255.0f);  // R
                        m_fColor[1] = ((float)((nLoop == 0) ? cColor.G : cColor.G - nSub) / 255.0f);  // G
                        m_fColor[2] = ((float)((nLoop == 0) ? cColor.B : cColor.B - nSub) / 255.0f);  // B
                        m_fColor[3] = fAlpha;// m_fAlpha;//
                        for (int j = 0; j < 3; j++)
                        {
                            if (m_fColor[j] < 0) m_fColor[j] = ((float)(((j == 0) ? cColor.R : ((j == 1) ? cColor.G : cColor.B)) + nSub) / 255.0f);//0.0f;
                        }
                        Gl.glColor4fv(m_fColor);
                        //Gl.glColor3fv(m_fColor); // Color with an array of floats

                        Gl.glPushMatrix();
                        float fX1 = -fW / 2.0f;
                        float fX2 = fW / 2.0f;
                        float fY1 = 0;
                        float fY2 = -fH;
                        float fZ1 = -fD / 2.0f;
                        float fZ2 = fD / 2.0f;
                        // x2 -> direction : right(Kor: 증분방향 : 오른쪽)
                        // Y2 -> direction : Up(Kor: 증분방향 : 위쪽)
                        // Z2 -> direction : The inside of the screen(Kor: 증분방향 : 화면의 안쪽)
                        // Criteria screen : See picture below(Kor: 기준화면 : 밑 그림 참조)
                        // 0, 0, 0 -> State in the middle of the screen as a starting point and went inside by a factor of 5
                        // Kor: 0, 0, 0 -> 화면의 가운데를 시작점으로 하고 안쪽으로 5만큼 들어간 상태
                        /*
                            000000000
                          0 0 ★  0 0
                        000000000   0
                        0   0   0   0
                        0   000000000  
                        0 0     0 0
                        000000000  
                        ( center position )
                        */

                        //int uiType = (bFill == true) ? Gl.GL_QUADS : Gl.GL_LINE_LOOP;//Gl.GL_LINE_LOOP;// Gl.GL_QUADS;//
                        ////int uiType = (bFill == true) ? Gl.GL_POLYGON : Gl.GL_LINE_LOOP;//Gl.GL_LINE_LOOP;// Gl.GL_QUADS;//
                        
                        
                        int uiType = ((bFill == true) ? ((nLoop == 0) ? Gl.GL_POLYGON : Gl.GL_LINE_LOOP) : Gl.GL_LINE_LOOP);
                        int uiTypeTop = (bFill == true) ? Gl.GL_FILL : Gl.GL_LINE;
                        //int uiType = Gl.GL_TRIANGLE_FAN;// (bFill == true) ? Gl.GL_TRIANGLE_FAN : Gl.GL_LINE_LOOP;
                        Gl.glPolygonMode(Gl.GL_BACK, uiTypeTop);
                        Gl.glPolygonMode(Gl.GL_FRONT, uiTypeTop);
                        //Gl.glBegin(uiType);

                        SVector3D_t[] aSPos = new SVector3D_t[24];
                        int i = 0;
                        // Front Face		
                        aSPos[i].x = fX1; aSPos[i].y = fY2; aSPos[i].z = fZ2; i++;// Bottom Left Of The Texture and Quad
                        aSPos[i].x = fX2; aSPos[i].y = fY2; aSPos[i].z = fZ2; i++;// Bottom Right Of The Texture and Quad
                        aSPos[i].x = fX2; aSPos[i].y = fY1; aSPos[i].z = fZ2; i++;// Top Right Of The Texture and Quad
                        aSPos[i].x = fX1; aSPos[i].y = fY1; aSPos[i].z = fZ2; i++;// Top Left Of The Texture and Quad

                        // Back Face			
                        aSPos[i].x = fX1; aSPos[i].y = fY1; aSPos[i].z = fZ1; i++;// Top Right Of The Texture and Quad
                        aSPos[i].x = fX2; aSPos[i].y = fY1; aSPos[i].z = fZ1; i++;// Top Left Of The Texture and Quad
                        aSPos[i].x = fX2; aSPos[i].y = fY2; aSPos[i].z = fZ1; i++;// Bottom Left Of The Texture and Quad
                        aSPos[i].x = fX1; aSPos[i].y = fY2; aSPos[i].z = fZ1; i++;// Bottom Right Of The Texture and Quad

                        // Top Face		
                        aSPos[i].x = fX1; aSPos[i].y = fY1; aSPos[i].z = fZ1; i++;// Top Left Of The Texture and Quad
                        aSPos[i].x = fX1; aSPos[i].y = fY1; aSPos[i].z = fZ2; i++;// Bottom Left Of The Texture and Quad
                        aSPos[i].x = fX2; aSPos[i].y = fY1; aSPos[i].z = fZ2; i++;// Bottom Right Of The Texture and Quad
                        aSPos[i].x = fX2; aSPos[i].y = fY1; aSPos[i].z = fZ1; i++;// Top Right Of The Texture and Quad

                        // Bottom Face		
                        aSPos[i].x = fX2; aSPos[i].y = fY2; aSPos[i].z = fZ1; i++;// Top Left Of The Texture and Quad
                        aSPos[i].x = fX2; aSPos[i].y = fY2; aSPos[i].z = fZ2; i++;// Bottom Left Of The Texture and Quad
                        aSPos[i].x = fX1; aSPos[i].y = fY2; aSPos[i].z = fZ2; i++;// Bottom Right Of The Texture and Quad
                        aSPos[i].x = fX1; aSPos[i].y = fY2; aSPos[i].z = fZ1; i++;// Top Right Of The Texture and Quad

                        // Right Face		
                        aSPos[i].x = fX2; aSPos[i].y = fY2; aSPos[i].z = fZ1; i++;// Bottom Right Of The Texture and Quad
                        aSPos[i].x = fX2; aSPos[i].y = fY1; aSPos[i].z = fZ1; i++;// Top Right Of The Texture and Quad
                        aSPos[i].x = fX2; aSPos[i].y = fY1; aSPos[i].z = fZ2; i++;// Top Left Of The Texture and Quad
                        aSPos[i].x = fX2; aSPos[i].y = fY2; aSPos[i].z = fZ2; i++;// Bottom Left Of The Texture and Quad
                        // Left Face				
                        aSPos[i].x = fX1; aSPos[i].y = fY2; aSPos[i].z = fZ2; i++;// Bottom Right Of The Texture and Quad
                        aSPos[i].x = fX1; aSPos[i].y = fY1; aSPos[i].z = fZ2; i++;// Top Right Of The Texture and Quad
                        aSPos[i].x = fX1; aSPos[i].y = fY1; aSPos[i].z = fZ1; i++;// Top Left Of The Texture and Quad
                        aSPos[i].x = fX1; aSPos[i].y = fY2; aSPos[i].z = fZ1; i++;// Bottom Left Of The Texture and Quad
                        int nCnt = i;

                        for (i = 0; i < nCnt; i++)
                        {
                            // Rotation
                            Rotation(fOffsetTilt, fOffsetPan, fOffsetSwing, ref aSPos[i].x, ref aSPos[i].y, ref aSPos[i].z);

                            // Translation
                            aSPos[i].x += fOffsetX;
                            aSPos[i].y += fOffsetY;
                            aSPos[i].z += fOffsetZ;
                        }
                        i = 0;

                        float[] afObject = new float[4] { (float)(color.R), (float)(color.G), (float)(color.B), 1.0f };

                        Gl.glBegin(uiType);

                        //Gl.glMaterialfv(Gl.GL_FRONT, Gl.GL_DIFFUSE, afObject); // Object attributes assigned(Kor: 물체 특성할당)

#if true

                        // Front Face
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;			// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(aSPos[i - 4].x, aSPos[i - 4].y, aSPos[i - 4].z); 			// Bottom Left Of The Texture and Quad

                        Gl.glEnd();// end drawing the cube	
                        Gl.glBegin(uiType);
                        //Gl.glMaterialfv(Gl.GL_FRONT, Gl.GL_DIFFUSE, afObject); // Object attributes assigned(Kor: 물체 특성할당)

                        // Back Face
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(aSPos[i - 4].x, aSPos[i - 4].y, aSPos[i - 4].z); 				// Bottom Right Of The Texture and Quad

                        Gl.glEnd();// end drawing the cube	
                        Gl.glBegin(uiType);
                        //Gl.glMaterialfv(Gl.GL_FRONT, Gl.GL_DIFFUSE, afObject); // Object attributes assigned(Kor: 물체 특성할당)

                        // Top Face
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(aSPos[i - 4].x, aSPos[i - 4].y, aSPos[i - 4].z); 				// Top Left Of The Texture and Quad

                        Gl.glEnd();// end drawing the cube	
                        Gl.glBegin(uiType);
                        //Gl.glMaterialfv(Gl.GL_FRONT, Gl.GL_DIFFUSE, afObject); // Object attributes assigned(Kor: 물체 특성할당)

                        // Bottom Face
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(aSPos[i - 4].x, aSPos[i - 4].y, aSPos[i - 4].z); 				// Top Right Of The Texture and Quad

                        Gl.glEnd();// end drawing the cube	
                        Gl.glBegin(uiType);
                        //Gl.glMaterialfv(Gl.GL_FRONT, Gl.GL_DIFFUSE, afObject); // Object attributes assigned(Kor: 물체 특성할당)

                        // Right Face
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(aSPos[i - 4].x, aSPos[i - 4].y, aSPos[i - 4].z); 				// Bottom Right Of The Texture and Quad

                        Gl.glEnd();// end drawing the cube	
                        Gl.glBegin(uiType);
                        //Gl.glMaterialfv(Gl.GL_FRONT, Gl.GL_DIFFUSE, afObject); // Object attributes assigned(Kor: 물체 특성할당)

                        // Left Face
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(aSPos[i - 4].x, aSPos[i - 4].y, aSPos[i - 4].z); 				// Bottom Left Of The Texture and Quad

#else
                        // Front Face
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;			// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Left Of The Texture and Quad
                        // Back Face
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Left Of The Texture and Quad
                        // Top Face
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Right Of The Texture and Quad
                        // Bottom Face
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Right Of The Texture and Quad
                        // Right Face
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Left Of The Texture and Quad
                        // Left Face
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Left Of The Texture and Quad
#endif
                        Gl.glEnd();// end drawing the cube	
                        Gl.glPopMatrix();
                    }
                }
                public void OjwTerritory(bool bFill, Color color, float fAlpha, float fW, float fD, int nCount_Width, int nCount_Depth)
                {
                    int nLoopCount = ((bFill == true) ? 2 : 1);
                    for (int nLoop = 0; nLoop < nLoopCount; nLoop++)
                    {
                        int nSub = _COLOR_GAP;
                        Color cColor = color;// ((nLoop == 0) ? color : Color.DarkGray);
                        m_fColor[0] = ((float)((nLoop == 0) ? cColor.R : cColor.R - nSub) / 255.0f);  // R
                        m_fColor[1] = ((float)((nLoop == 0) ? cColor.G : cColor.G - nSub) / 255.0f);  // G
                        m_fColor[2] = ((float)((nLoop == 0) ? cColor.B : cColor.B - nSub) / 255.0f);  // B
                        m_fColor[3] = fAlpha;// m_fAlpha;//
                        for (int j = 0; j < 3; j++)
                        {
                            if (m_fColor[j] < 0) m_fColor[j] = ((float)(((j == 0) ? cColor.R : ((j == 1) ? cColor.G : cColor.B)) + nSub) / 255.0f);//0.0f;
                        }
                        Gl.glColor4fv(m_fColor);

                        Gl.glPushMatrix();
                        float fX1 = -fW / 2.0f;
                        float fX2 = fW / 2.0f;
                        float fY1 = 0;
                        float fZ1 = -fD / 2.0f;
                        float fZ2 = fD / 2.0f;
                        int uiType = ((bFill == true) ? ((nLoop == 0) ? Gl.GL_POLYGON : Gl.GL_LINE_LOOP) : Gl.GL_LINE_LOOP);
                        int uiTypeTop = (bFill == true) ? Gl.GL_FILL : Gl.GL_LINE;
                        //int uiType = Gl.GL_TRIANGLE_FAN;// (bFill == true) ? Gl.GL_TRIANGLE_FAN : Gl.GL_LINE_LOOP;
                        Gl.glPolygonMode(Gl.GL_BACK, uiTypeTop);
                        Gl.glPolygonMode(Gl.GL_FRONT, uiTypeTop);

                        SVector3D_t[] aSPos = new SVector3D_t[24];
                        int i = 0;
                        // Top Face		
                        aSPos[i].x = fX1; aSPos[i].y = fY1; aSPos[i].z = fZ1; i++;// Top Left Of The Texture and Quad
                        aSPos[i].x = fX1; aSPos[i].y = fY1; aSPos[i].z = fZ2; i++;// Bottom Left Of The Texture and Quad
                        aSPos[i].x = fX2; aSPos[i].y = fY1; aSPos[i].z = fZ2; i++;// Bottom Right Of The Texture and Quad
                        aSPos[i].x = fX2; aSPos[i].y = fY1; aSPos[i].z = fZ1; i++;// Top Right Of The Texture and Quad

                        int nCnt = i;

#if false
                        for (i = 0; i < nCnt; i++)
                        {
                            // Rotation
                            Rotation(fOffsetTilt, fOffsetPan, fOffsetSwing, ref aSPos[i].x, ref aSPos[i].y, ref aSPos[i].z);

                            // Translation
                            aSPos[i].x += fOffsetX;
                            aSPos[i].y += fOffsetY;
                            aSPos[i].z += fOffsetZ;
                        }
                        i = 0;

                        float[] afObject = new float[4] { (float)(color.R), (float)(color.G), (float)(color.B), 1.0f };

                        Gl.glBegin(uiType);

                        // Top Face
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(aSPos[i - 4].x, aSPos[i - 4].y, aSPos[i - 4].z); 				// Top Left Of The Texture and Quad

                        Gl.glEnd();// end drawing the Territory	
#else
                        int nW = nCount_Width / 2;
                        int nH = nCount_Depth / 2;
                        float fBlock_Width = fW;
                        float fBlock_Depth = fD;
                        InitPosAngle();

                        // 로봇의 움직임 구현
                        //OjwRotation(m_fPan_Robot, m_fTilt_Robot, m_fSwing_Robot);
                        //OjwTranslate(m_fX_Robot % fBlock_Width, m_fY_Robot, m_fZ_Robot % fBlock_Depth);
                        float fGap = -20.0f;
                        for (int nTerritory_W = -nW; nTerritory_W < nW; nTerritory_W++)
                        {
                            for (int nTerritory_H = -nH; nTerritory_H < nH; nTerritory_H++)
                            {
                                Gl.glBegin(uiType);
                                i = 0;
                                // Top Face
                                Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(aSPos[i].x - fGap + fBlock_Width * (float)nTerritory_W, aSPos[i].y, aSPos[i].z + fGap + fBlock_Depth * (float)nTerritory_H); i++;				// Top Left Of The Texture and Quad
                                Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(aSPos[i].x + fGap + fBlock_Width * (float)nTerritory_W, aSPos[i].y, aSPos[i].z + fGap + fBlock_Depth * (float)nTerritory_H); i++;				// Bottom Left Of The Texture and Quad
                                Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(aSPos[i].x + fGap + fBlock_Width * (float)nTerritory_W, aSPos[i].y, aSPos[i].z - fGap + fBlock_Depth * (float)nTerritory_H); i++;				// Bottom Right Of The Texture and Quad
                                Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(aSPos[i].x - fGap + fBlock_Width * (float)nTerritory_W, aSPos[i].y, aSPos[i].z - fGap + fBlock_Depth * (float)nTerritory_H); i++;				// Top Right Of The Texture and Quad
                                //Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(aSPos[i - 4].x, aSPos[i - 4].y, aSPos[i - 4].z); 				// Top Left Of The Texture and Quad

                                Gl.glEnd();// end drawing the Territory	
                                //OjwBox_Simple(m_bTerritory_Fill, m_clrTerritory_Color, m_fTerritory_Alpha, fBlock_Width, fBlock_Height, fBlock_Depth, 0, 0, 0, fBlock_Width * (float)nTerritory_W, 0, fBlock_Depth * (float)nTerritory_H);
                            }
                        }
#endif
                        Gl.glPopMatrix();
                    }
                }
#if false
                public void OjwTrack_Circle(bool bFill, Color color, float fAlpha,
                    string strTrackFile, 
                    float fAngle, float fAngle_Start, float fAngle_End,
                    float fDistance, float fRadius,
                    float fTrack_W, float fTrack_H, float fTrack_D, 
                    float fTrack_OffsetPan, float fTrack_OffsetTilt, float fTrack_OffsetSwing,    // Ratation(Offset)
                    float fTrack_OffsetX, float fTrack_OffsetY, float fTrack_OffsetZ              // Translation(Offset)
                    )
                {
                    if (strTrackFile != null)
                    {
                        #region File Check & Load
                        if (OjwAse_GetIndex(strTrackFile) < 0)
                        {
                            //string strObject = "Track.stl";
                            String strFileName = Application.StartupPath.Trim('\\') + GetAseFile_Path() + strTrackFile + ((strTrackFile.IndexOf('.') < 0) ? ".ase" : "");
                            FileInfo f = new FileInfo(strFileName);
                            if (f.Exists == true)
                            {
                                if (CFile.GetExe(strFileName).ToUpper() == "ASE")
                                    OjwFileOpen_3D_ASE(strFileName);
                                else if ((CFile.GetExe(strFileName).ToUpper() == "STL") || (CFile.GetExe(strFileName).ToUpper() == "STL*"))
                                    OjwFileOpen_3D_STL(strFileName);
                            }
                        }
                        #endregion File Check & Load

                        //fAngle_Start = (fAngle_Start + 360) % 360;
                        //fAngle_End = (fAngle_End + 360) % 360;
                        //float fMax = Math.Abs(fAngle_End - fAngle_Start);

                        // 원호의 길이 = 2 * pi * r * (각도 / 360)
                        // fDistance = 2 * Math.PI * fRadius * (fDegree / 360.0f);
                        float fDegree = (fDistance * 360.0f) / (2.0f * (float)Math.PI * fRadius);
                        int nCnt = (int)Math.Round(Math.Abs((fAngle_End - fAngle_Start) / fDegree));//(360.0f - fAngle);
                        float fTmp;
                        for (int i = 0; i <= nCnt; i++)
                        {
                            fTmp = (fAngle_Start + fDegree * i) % 360.0f;
                            if ((fTmp >= fAngle_Start) && (fTmp <= fAngle_End))
                            {
                                OjwRotation(0.0f, fTmp, 0.0f);
                                OjwTranslate(0.0f, fRadius, 0.0f);

                                OjwAse_Outside(bFill, color, fAlpha, fTrack_W, fTrack_H, fTrack_D,
                                    fTrack_OffsetPan, fTrack_OffsetTilt, fTrack_OffsetSwing,
                                    fTrack_OffsetX, fTrack_OffsetY, fTrack_OffsetZ, strTrackFile);

                                OjwTranslate(0.0f, -fRadius, 0.0f);
                                OjwRotation(0.0f, -fTmp, 0.0f);
                            }
                            //OjwBox_Outside(bFill, color, fAlpha, fTrack_W, fTrack_H, fTrack_D, 0, 0, 0, j * fTrack_Distance, 0, 0);
                            //OjwBox_Outside(bFill, Color.Blue, fAlpha, fTrack_W, fTrack_H, fTrack_D, 0, 0, 0, j * fTrack_Distance, 10, 0);
                        }
                    }
                    else
                    {
                    }


                    
                }
                //public void OjwTrack_Line(bool bFill, Color color, float fAlpha,
                //        string strTrackFile,
                //        float fDistance, float fLength,
                //        float fTrack_W, float fTrack_H, float fTrack_D,
                //        float fTrack_OffsetPan, float fTrack_OffsetTilt, float fTrack_OffsetSwing,    // Ratation(Offset)
                //        float fTrack_OffsetX, float fTrack_OffsetY, float fTrack_OffsetZ              // Translation(Offset)
                //        )
                //{
                //    if (strTrackFile != null)
                //    {
                //        #region File Check & Load
                //        if (OjwAse_GetIndex(strTrackFile) < 0)
                //        {
                //            //string strObject = strTrackFile;
                //            String strFileName = Application.StartupPath.Trim('\\') + GetAseFile_Path() + strTrackFile + ((strTrackFile.IndexOf('.') < 0) ? ".ase" : "");
                //            FileInfo f = new FileInfo(strFileName);
                //            if (f.Exists == true)
                //            {
                //                if (CFile.GetExe(strFileName).ToUpper() == "ASE")
                //                    OjwFileOpen_3D_ASE(strFileName);
                //                else if ((CFile.GetExe(strFileName).ToUpper() == "STL") || (CFile.GetExe(strFileName).ToUpper() == "STL*"))
                //                    OjwFileOpen_3D_STL(strFileName);
                //            }
                //        }
                //        #endregion File Check & Load

                //        int nCnt = (int)Math.Round(fLength / fDistance);
                //        float fTmp;
                //        for (int i = 0; i <= nCnt; i++)
                //        {
                //            fTmp = fDistance * i;
                //                OjwRotation(0.0f, fTmp, 0.0f);
                //                OjwTranslate(0.0f, fRadius, 0.0f);

                //                OjwAse_Outside(bFill, color, fAlpha, fTrack_W, fTrack_H, fTrack_D,
                //                    fTrack_OffsetPan, fTrack_OffsetTilt, fTrack_OffsetSwing,
                //                    fTrack_OffsetX, fTrack_OffsetY, fTrack_OffsetZ, strTrackFile);

                //                OjwTranslate(0.0f, -fRadius, 0.0f);
                //                OjwRotation(0.0f, -fTmp, 0.0f);
                //            //OjwBox_Outside(bFill, color, fAlpha, fTrack_W, fTrack_H, fTrack_D, 0, 0, 0, j * fTrack_Distance, 0, 0);
                //            //OjwBox_Outside(bFill, Color.Blue, fAlpha, fTrack_W, fTrack_H, fTrack_D, 0, 0, 0, j * fTrack_Distance, 10, 0);
                //        }
                //    }
                //    else
                //    {
                //    }



                //}

                public void OjwTrack2(float fAngleMove, bool bFill, Color color, float fAlpha,
                    string strTrackFile,
                    float fTrack_W, float fTrack_H, float fTrack_D, float fTrack_Distance,
                    //int nConnectedAxis, float fAxis_X, float fAxis_Y, int nMode,// 연결된 모터, 회전 해야 할 좌표 기준 점, Mode(0 : 회전, 1 : 축 이동(fAxis_X 각도 연관)) //float fOffsetPan, float fOffsetTilt, float fOffsetSwing,    // Ratation(Offset)
                    
                    float fTrack_OffsetPan, float fTrack_OffsetTilt, float fTrack_OffsetSwing,    // Ratation(Offset)
                    float fTrack_OffsetX, float fTrack_OffsetY, float fTrack_OffsetZ,              // Translation(Offset)    
                    //float fOffsetX, float fOffsetY, float fOffsetZ,              // Translation(Offset)
                    params float[] afValue // x, y, radius
                    )
                {
                    int nArg = 3;// +5;
                    if ((afValue.Length) % nArg != 0) return;
                    if (fTrack_Distance == 0) fTrack_Distance = 0.001f;
                    int nCnt = afValue.Length / nArg;
                    float fX, fY, fR;
                    
                    // Rotation 적용
                    //int nConnectedAxis; // 연결된 모터 번호
                    //float fAxis_X;      // 회전 해야 할 좌표 기준 점(X)
                    //float fAxis_Y;      // 회전 해야 할 좌표 기준 점(Y)
                    //int nMode;          // Mode(0 : 변화없음, 1 : 회전, 2 : 축 이동(fAxis_X 각도 연관 - 나중에 구현하자. 지금 바빠)) //float fOffsetPan, float fOffsetTilt, float fOffsetSwing,    // Ratation(Offset)
                    //float fDir = 0;           // 방향(0 : 정, 1 : 반대)
                    //for (int nNum = 0; nNum < nCnt; nNum++)
                    //{
                    //    fX = afValue[nArg * nNum + 0];
                    //    fY = afValue[nArg * nNum + 1];
                    //    fR = afValue[nArg * nNum + 2];
                    //}

                    if (strTrackFile != null)
                    {
                        if (OjwAse_GetIndex(strTrackFile) < 0)
                        {
                            //string strObject = strTrackFile;
                            String strFileName = Application.StartupPath.Trim('\\') + GetAseFile_Path() + strTrackFile + ((strTrackFile.IndexOf('.') < 0) ? ".ase" : "");
                            FileInfo f = new FileInfo(strFileName);
                            if (f.Exists == true)
                            {
                                if (CFile.GetExe(strFileName).ToUpper() == "ASE")
                                    OjwFileOpen_3D_ASE(strFileName);
                                else if ((CFile.GetExe(strFileName).ToUpper() == "STL") || (CFile.GetExe(strFileName).ToUpper() == "STL*"))
                                    OjwFileOpen_3D_STL(strFileName);
                            }
                        }
                    }

                    // 기준 원 그려보자
                    ////////////////////////////
                    float fX1, fY1, fR1;
                    float fX2, fY2, fR2;
#if true
                    //if (nCnt == 1)
                    //{
                    //    for (int nNum = 0; nNum < nCnt; nNum++)
                    //    {
                    //        fX = afValue[nArg * nNum + 0];
                    //        fY = afValue[nArg * nNum + 1];
                    //        fR = afValue[nArg * nNum + 2];
                    //        //OjwBall_Outside(bFill, color, fAlpha, fR, 50, 0, 0, 0, fX, fY, 0);
                    //        OjwBall_Outside(bFill, color, 0.5f, fR, 50, 0, 0, 0, fX, fY, 0);

                    //        fAxis_X = afValue[nArg * nNum + 4];
                    //        fAxis_Y = afValue[nArg * nNum + 5];
                    //        OjwBall_Outside(bFill, Color.Red, 0.5f, 10, 50, 0, 0, 0, fAxis_X, fAxis_Y, 0);
                    //    }
                    //}
#endif
                    float fAngle, fAngle2, fLength, fLength_Out;
                    //Color[] aclrTestColor = new Color[4] {Color.White, Color.Blue, Color.Violet, Color.Gold};
                    // First
                    int nNum_Next, nNum_Next2;
                    for (int nNum = 0; nNum < nCnt; nNum++)
                    {
                        fX = afValue[3 * nNum + 0];
                        fY = afValue[3 * nNum + 1];
                        fR = afValue[3 * nNum + 2];
                        nNum_Next = (nNum < nCnt - 1) ? (nNum + 1) : (nNum - nCnt + 1);
                        fX1 = afValue[3 * nNum_Next + 0];
                        fY1 = afValue[3 * nNum_Next + 1];
                        fR1 = afValue[3 * nNum_Next + 2];

                        nNum_Next2 = ((nNum < nCnt - 2) ? (nNum + 2) : (nNum - nCnt + 2)) % nCnt;
                        fX2 = afValue[3 * nNum_Next2 + 0];
                        fY2 = afValue[3 * nNum_Next2 + 1];
                        fR2 = afValue[3 * nNum_Next2 + 2];

                        fAngle = (float)Ojw.CMath.ATan2((fX1 - fX), (fY1 - fY));
                        fAngle2 = (float)Ojw.CMath.ATan2((fX2 - fX1), (fY2 - fY1));
                        fLength = (float)Math.Sqrt((fX1 - fX) * (fX1 - fX) + (fY1 - fY) * (fY1 - fY));
                        fLength_Out = (float)Math.Sqrt(fLength * fLength - (fR1 - fR) * (fR1 - fR));

                        OjwTranslate(fX, fY, 0);
                        OjwRotation(0, 0, fAngle);
                        OjwTranslate(0, fR, 0);

                        float fAngleGap = (float)Ojw.CMath.ATan2(fLength, (fR1 - fR)); //(float)Ojw.CMath.ATan2(fLength_Out, (fR1 - fR));
                        OjwRotation(0, 0, fAngleGap);



                        // 시작 위치 각도를 거리로 환산해서 구하기
                        float fAngleTest = fAngleMove % fTrack_Distance; // 모터 회전 5도
                        float fStartPos = -fAngleTest * (2.0f * (float)Math.PI * fR1) / 360.0f;

                        // 기준위치 표시 - 나중에 삭제
                        //OjwBall_Outside(bFill, aclrTestColor[nNum], fAlpha, fR / 10, 50, 0, 0, 0, 0, 0, 0);
                        float fPos = fStartPos;// -fTrack_Distance; // 시작위치 조정이 가능
                        if (nCnt > 1)
                        {
                            while (fPos <= fLength_Out)
                            {
                                if (strTrackFile.Length > 0)
                                {
                                    //OjwBall_Outside(bFill, Color.Green, fAlpha, fR / 10, 50, 0, 0, 0, fPos, 0, 0);
                                    OjwAse_Outside(bFill, color, fAlpha, fTrack_W, fTrack_H, fTrack_D,
                                            fTrack_OffsetPan, fTrack_OffsetTilt, fTrack_OffsetSwing,
                                            fTrack_OffsetX + fPos, fTrack_OffsetY, fTrack_OffsetZ, strTrackFile);
                                }
                                else
                                {                                    
                                    //OjwBox_Outside(bFill, color, fAlpha, fTrack_W, 10, fTrack_Distance,
                                    //        0, 0, 0, fPos, 0, -fTrack_W / 2.0f);
                                    OjwCircle_Outside(bFill, color, fAlpha, fTrack_Distance / 3, fTrack_W, 10,
                                               0, 0, 0, fPos, 0, -fTrack_W / 2.0f);
                                    OjwBox_Outside(bFill, color, fAlpha, fTrack_Distance, 10, fTrack_W,
                                            0, 0, 0, fPos, 0, 0);//-fTrack_W / 2.0f);
                                }
                                fPos += fTrack_Distance;
                            }
                        }
                        OjwRotation(0, 0, -fAngleGap);
                        OjwTranslate(0, -fR, 0);
                        OjwRotation(0, 0, -fAngle);
                        OjwTranslate(-fX, -fY, 0);

                        // 거리오차
                        float fDiff = fLength_Out - (fPos - fTrack_Distance);

                        // Rotation
                        OjwTranslate(fX1, fY1, 0);
                        //OjwTranslate(0, fR, 0);
                        //float fPos_X, fPos_Y;
                        float fAngleDiff = (-fDiff * 360.0f) / (2.0f * (float)Math.PI * fR1);
                        // 원호의 길이 = 2 * pi * r * (각도 / 360)
                        // fDistance = 2 * Math.PI * fRadius * (fDegree / 360.0f);
                        float fDegree = (fTrack_Distance * 360.0f) / (2.0f * (float)Math.PI * fR1);
                        float fTmp = (fAngle - fAngle2 + 360.0f) % 360.0f;
                        int j = 0;
                        if (nCnt == 1)
                        {
                            float fR_Height = fR1 - fR1 * (float)Ojw.CMath.Cos(fDegree / 2.0f);
                            float fR_Bottom = fR1 * (float)Ojw.CMath.Sin(fDegree / 2.0f);
                            float fDeg = (float)Ojw.CMath.ATan2(fR_Bottom, fR_Height);

                            for (j = 0; j < (int)(360 / fDegree); j++)
                            {
                                OjwRotation(0, 0, -fAngleDiff + (fAngle + 90.0f));
                                //OjwRotation(0, 0, fAngle + 90.0f - fAngleDiff);

                                OjwTranslate(fR1, 0, 0);
                                OjwRotation(0, 0, fDeg);

                                //OjwRotation(0, 0, fAngle + 90.0f - fAngleDiff);
                                //OjwBall_Outside(bFill, Color.Cyan, fAlpha, fR / 10, 50, 0, 0, 0, fR1, 0, 0);


                                if (strTrackFile.Length > 0)
                                {
                                    OjwAse_Outside(bFill, color, fAlpha, fTrack_W, fTrack_H, fTrack_D,
                                        fTrack_OffsetPan, fTrack_OffsetTilt, fTrack_OffsetSwing - 90.0f - fDegree,// / 2,//fDegree,// / 2,
                                        fTrack_OffsetX, fTrack_OffsetY, fTrack_OffsetZ, strTrackFile);
                                }
                                else
                                {                                    
                                    OjwCircle_Outside(bFill, color, fAlpha, fTrack_Distance / 3, fTrack_W, 10,
                                               0, 0, -90.0f - fDegree, 0, 0, -fTrack_W / 2.0f);
                                    OjwBox_Outside(bFill, color, fAlpha, fTrack_Distance, 10, fTrack_W,
                                            0, 0, -90.0f - fDegree, 0, 0, 0);//-fTrack_W / 2.0f);
                                }
                                //OjwRotation(0, 0, -(fAngle + 90.0f - fAngleDiff));
                                
                                OjwRotation(0, 0, -fDeg);
                                OjwTranslate(-fR1, 0, 0);
                                //OjwRotation(0, 0, -(fAngle + 90.0f - fAngleDiff));
                                OjwRotation(0, 0, fAngleDiff - (fAngle + 90.0f));


                                fAngleDiff += fDegree;
                                //j++;
                            }
                        }
                        else
                        {
                            // 각도를 반으로 나눈 부분에 수직 수선이 내려진다.
                            // 
                            float fR_Height = fR1 - fR1 * (float)Ojw.CMath.Cos(fDegree / 2.0f);
                            float fR_Bottom = fR1 * (float)Ojw.CMath.Sin(fDegree / 2.0f);
                            float fDeg = (float)Ojw.CMath.ATan2(fR_Bottom, fR_Height);
                            //while ((fAngleDiff + fDegree / 2) < fTmp)
                            //while ((fAngleDiff + fDegree) <= fTmp)
                            while (fAngleDiff < fTmp)
                            {
                                //if (j != 0)
                                {
                                    OjwRotation(0, 0, fAngle + 90.0f - fAngleDiff);
                                    OjwTranslate(fR1, 0, 0);

                                    OjwRotation(0, 0, fDeg);

                                    if (strTrackFile.Length > 0)
                                    {
                                        //OjwRotation(0, 0, fAngle + 90.0f - fAngleDiff);
                                        //OjwBall_Outside(bFill, Color.Cyan, fAlpha, fR / 10, 50, 0, 0, 0, fR1, 0, 0);
                                        OjwAse_Outside(bFill, color, fAlpha, fTrack_W, fTrack_H, fTrack_D,
                                            fTrack_OffsetPan, fTrack_OffsetTilt, fTrack_OffsetSwing - 90.0f - fDegree,// / 2,
                                            fTrack_OffsetX, fTrack_OffsetY, fTrack_OffsetZ, strTrackFile);
                                        //OjwRotation(0, 0, -(fAngle + 90.0f - fAngleDiff));
                                    }
                                    else
                                    {

                                        OjwCircle_Outside(bFill, color, fAlpha, fTrack_Distance / 3, fTrack_W, 10,
                                                   0, 0, -90.0f - fDegree, 0, 0, -fTrack_W / 2.0f);
                                        OjwBox_Outside(bFill, color, fAlpha, fTrack_Distance, 10, fTrack_W,
                                                0, 0, -90.0f - fDegree, 0, 0, 0);//-fTrack_W / 2.0f);
                                    }
                                    OjwRotation(0, 0, -fDeg);
                                    OjwTranslate(-fR1, 0, 0);
                                    OjwRotation(0, 0, -(fAngle + 90.0f - fAngleDiff));
                                }
                                fAngleDiff += fDegree;
                                j++;
                            }
                        }
                        OjwTranslate(-fX1, -fY1, 0);
                    }
                }
                public void OjwTrack_Line(bool bFill, Color color, float fAlpha,
                    string strTrackFile,
                    float fTrack_W, float fTrack_H, float fTrack_D, float fTrack_Distance,
                    float fTrack_OffsetPan, float fTrack_OffsetTilt, float fTrack_OffsetSwing,    // Ratation(Offset)
                    float fTrack_OffsetX, float fTrack_OffsetY, float fTrack_OffsetZ,              // Translation(Offset)    
                    float fOffsetPan, float fOffsetTilt, float fOffsetSwing,    // Ratation(Offset)
                    float fOffsetX, float fOffsetY, float fOffsetZ,              // Translation(Offset)
                    params float[] afValue // x, y, radius
                    )
                {
                    int nDiv = 3;
                    int nCnt_Wheel = afValue.Length / nDiv;
                    if (afValue.Length % nDiv != 0) return;

                    float fAngle, fAngle2, fAngle_Dif, fLength, fLength_Out, nCnt;
                    int nX2, nY2, nR2, nX1, nY1, nR1, nX0, nY0, nR0, nNext2, nNext, nCurr;
                    for (int i = 0; i < nCnt_Wheel; i++)
                    {
                        if (i == nCnt_Wheel - 1)
                        {
                            nNext2 = 1;
                            nNext = 0;
                            nCurr = i;
                        }
                        else if (i == nCnt_Wheel - 2)
                        {
                            nNext2 = 0;
                            nNext = i + 1;
                            nCurr = i;
                        }
                        else
                        {
                            nNext2 = i + 2;
                            nNext = i + 1;
                            nCurr = i;
                        }
                        nX2 = nNext2 * nDiv;
                        nY2 = nNext2 * nDiv + 1;
                        nR2 = nNext2 * nDiv + 2;
                        nX1 = nNext * nDiv;
                        nY1 = nNext * nDiv + 1;
                        nR1 = nNext * nDiv + 2;
                        nX0 = nCurr * nDiv;
                        nY0 = nCurr * nDiv + 1;
                        nR0 = nCurr * nDiv + 2;
                        fAngle = (float)Ojw.CMath.ATan2((afValue[nX1] - afValue[nX0]), (afValue[nY1] - afValue[nY0]));
                        fAngle2 = (float)Ojw.CMath.ATan2((afValue[nX2] - afValue[nX1]), (afValue[nY2] - afValue[nY1]));
                        fLength = (float)Math.Sqrt((afValue[nX1] - afValue[nX0]) * (afValue[nX1] - afValue[nX0]) + (afValue[nY1] - afValue[nY0]) * (afValue[nY1] - afValue[nY0]));
                        fLength_Out = (float)Math.Sqrt(fLength * fLength - (afValue[nR1] - afValue[nR0]) * (afValue[nR1] - afValue[nR0]));
                        //nCnt = (int)Math.Round(fLength / fTrack_Distance);

                        //fAngle += (float)Ojw.CMath.ATan2(fLength, (afValue[nR1] - afValue[nR0]));
#if true
                #region Line
                        nCnt = (int)Math.Round(fLength_Out / (fTrack_Distance));
                        // Offset
                        OjwTranslate(fOffsetX, fOffsetY, fOffsetZ);
                        OjwRotation(fOffsetPan, fOffsetTilt, fOffsetSwing);


                        OjwTranslate(afValue[nX0], afValue[nY0], 0);
                        // For Test
                        //OjwBall_Outside(bFill, color, fAlpha, afValue[nR0], 50, 0, 0, 0, 0, 0, 0);
                        OjwRotation(0, 0, fAngle);
                        OjwTranslate(0, afValue[nR0], 0);
                        fAngle_Dif = (float)Ojw.CMath.ATan2(fLength, (afValue[nR1] - afValue[nR0]));
                        OjwRotation(0, 0, fAngle_Dif);

                        if (strTrackFile != null)
                        {

                #region Test
                            if (OjwAse_GetIndex(strTrackFile) < 0)
                            {
                                //string strObject = strTrackFile;
                                String strFileName = Application.StartupPath.Trim('\\') + GetAseFile_Path() + strTrackFile + ((strTrackFile.IndexOf('.') < 0) ? ".ase" : "");
                                FileInfo f = new FileInfo(strFileName);
                                if (f.Exists == true)
                                {
                                    if (CFile.GetExe(strFileName).ToUpper() == "ASE")
                                        OjwFileOpen_3D_ASE(strFileName);
                                    else if ((CFile.GetExe(strFileName).ToUpper() == "STL") || (CFile.GetExe(strFileName).ToUpper() == "STL*"))
                                        OjwFileOpen_3D_STL(strFileName);
                                }
                            }
                #endregion Test

                            for (int j = 0; j < nCnt; j++)
                            {
                                OjwAse_Outside(bFill, color, fAlpha, fTrack_W, fTrack_H, fTrack_D,
                                    fTrack_OffsetPan, fTrack_OffsetTilt, fTrack_OffsetSwing,
                                    j * fTrack_Distance + fTrack_OffsetX, fTrack_OffsetY, fTrack_OffsetZ, strTrackFile);

                                //OjwBox_Outside(bFill, color, fAlpha, fTrack_W, fTrack_H, fTrack_D, 0, 0, 0, j * fTrack_Distance, 0, 0);
                                //OjwBox_Outside(bFill, Color.Blue, fAlpha, fTrack_W, fTrack_H, fTrack_D, 0, 0, 0, j * fTrack_Distance, 10, 0);
                            }
                            //fLength_Out = 2.0f * (float)Math.PI * afValue[nR1];
                            //nCnt = (int)Math.Round(fLength_Out / (fTrack_Distance));

                            for (int j = 0; j < nCnt; j++)
                            {
                                OjwAse_Outside(bFill, color, fAlpha, fTrack_W, fTrack_H, fTrack_D,
                                    fTrack_OffsetPan, fTrack_OffsetTilt, fTrack_OffsetSwing,
                                    j * fTrack_Distance + fTrack_OffsetX, fTrack_OffsetY, fTrack_OffsetZ, strTrackFile);

                                //OjwBox_Outside(bFill, color, fAlpha, fTrack_W, fTrack_H, fTrack_D, 0, 0, 0, j * fTrack_Distance, 0, 0);
                                //OjwBox_Outside(bFill, Color.Blue, fAlpha, fTrack_W, fTrack_H, fTrack_D, 0, 0, 0, j * fTrack_Distance, 10, 0);
                            }
                        }
                        else
                        {
                            for (int j = 0; j < nCnt; j++)
                            {
                                OjwBox_Outside(bFill, color, fAlpha, fTrack_W, fTrack_H, fTrack_D,
                                    fTrack_OffsetPan, fTrack_OffsetTilt, fTrack_OffsetSwing,
                                    j * fTrack_Distance + fTrack_OffsetX, fTrack_OffsetY, fTrack_OffsetZ);
                                //OjwBox_Outside(bFill, Color.Blue, fAlpha, fTrack_W, fTrack_H, fTrack_D, fOffsetPan, fOffsetTilt, fOffsetSwing, j * fTrack_Distance + fOffsetX, fOffsetY + 10, fOffsetZ);
                            }
                        }
                        OjwRotation(0, 0, -fAngle_Dif);
                        OjwTranslate(0, -afValue[nR0], 0);
                        OjwRotation(0, 0, -fAngle);
                        OjwTranslate(-afValue[nX0], -afValue[nY0], 0);

                        // Offset
                        OjwRotation(-fOffsetPan, -fOffsetTilt, -fOffsetSwing);
                        OjwTranslate(-fOffsetX, -fOffsetY, -fOffsetZ);
                #endregion Line
#endif
#if false
                #region Circle
                        // 원호의 길이 = 2 * pi * r * (각도 / 360)
                        // fDistance = 2 * Math.PI * fRadius * (fDegree / 360.0f);
                        float fDegree = (fTrack_Distance * 360.0f) / (2.0f * (float)Math.PI * afValue[nR1]);
                        if (fAngle >= 180.0f)
                            fAngle -= 360.0f;
                        if (fAngle2 >= 180.0f)
                            fAngle2 -= 360.0f;
                        nCnt = (int)Math.Round((Math.Abs(fAngle) + Math.Abs(fAngle2)) / fDegree);



                        // Offset
                        OjwTranslate(fOffsetX, fOffsetY, fOffsetZ);
                        OjwRotation(fOffsetPan, fOffsetTilt, fOffsetSwing); 
                        
                        OjwTranslate(afValue[nX1], afValue[nY1], 0);
                        OjwRotation(0, 0, fAngle);
                        //OjwTranslate(0, afValue[nR1], 0);                        

                        float fTmp;
                        for (int j = 0; j <= nCnt; j++)
                        {
                            fTmp = ((fAngle + 90.0f) + fDegree * j) % 360.0f;
                            //if ((fTmp >= (fAngle + 90.0f)) && (fTmp <= (90.0f - fAngle2)))
                            {



                                //OjwRotation(fTmp, 0.0f, 0.0f);
                                OjwTranslate(afValue[nR1], 0.0f, 0.0f);

                                OjwAse_Outside(bFill, color, fAlpha, fTrack_W, fTrack_H, fTrack_D,
                                    fTrack_OffsetPan, fTrack_OffsetTilt, fTrack_OffsetSwing,
                                    fTrack_OffsetX, fTrack_OffsetY, fTrack_OffsetZ, strTrackFile);

                                OjwTranslate(-afValue[nR1], 0.0f, 0.0f);
                                //OjwRotation(-fTmp, 0.0f, 0.0f);
                            }
                        }

                        //OjwTranslate(0, -afValue[nR1], 0);
                        OjwRotation(0, 0, -fAngle);
                        OjwTranslate(-afValue[nX1], -afValue[nY1], 0);

                        // Offset
                        OjwRotation(-fOffsetPan, -fOffsetTilt, -fOffsetSwing);
                        OjwTranslate(-fOffsetX, -fOffsetY, -fOffsetZ);

                #endregion Circle
#else
                #region Circle
                        // 원호의 길이 = 2 * pi * r * (각도 / 360)
                        // fDistance = 2 * Math.PI * fRadius * (fDegree / 360.0f);
                        float fDegree = (fTrack_Distance * 360.0f) / (2.0f * (float)Math.PI * afValue[nR1]);
                        if (fAngle >= 180.0f)
                            fAngle -= 360.0f;
                        if (fAngle2 >= 180.0f)
                            fAngle2 -= 360.0f;
                        if (-fAngle >= 180.0f)
                            fAngle += 360.0f;
                        if (-fAngle2 >= 180.0f)
                            fAngle2 += 360.0f;
                        //if (i != 0) continue;
                        nCnt = (int)Math.Round((Math.Abs(fAngle) + Math.Abs(fAngle2)) / fDegree);
                        float fTmp;

                        OjwTranslate(0, afValue[nR1], 0);
                        OjwRotation(fAngle2, 0, 0);

                        for (int j = 0; j <= nCnt; j++)
                        {
                            fTmp = (fAngle + fDegree * j) % 360.0f;
                            //if ((fTmp >= fAngle) && (fTmp <= fAngle2))
                            {
                                //OjwRotation(0.0f, 0.0f, fTmp);
                                //OjwTranslate(0.0f, afValue[nR1], 0.0f);

                                OjwAse_Outside(bFill, color, fAlpha, fTrack_W, fTrack_H, fTrack_D,
                                    fTrack_OffsetPan, fTrack_OffsetTilt, fTrack_OffsetSwing,
                                    fTrack_OffsetX, fTrack_OffsetY, fTrack_OffsetZ, strTrackFile);

                                //OjwTranslate(0.0f, -afValue[nR1], 0.0f);
                                //OjwRotation(0.0f, 0.0f, -fTmp);
                            }
                            //OjwBox_Outside(bFill, color, fAlpha, fTrack_W, fTrack_H, fTrack_D, 0, 0, 0, j * fTrack_Distance, 0, 0);
                            //OjwBox_Outside(bFill, Color.Blue, fAlpha, fTrack_W, fTrack_H, fTrack_D, 0, 0, 0, j * fTrack_Distance, 10, 0);
                        }


                        OjwRotation(-fAngle2, 0, 0);
                        OjwTranslate(0, -afValue[nR1], 0);
                #endregion Circle
#endif
                    }
                }
#endif
                public void OjwTrack(float fAngleMove, bool bFill, Color color, float fAlpha,
                    string strTrackFile,
                    float fTrack_W, float fTrack_H, float fTrack_D, float fTrack_Distance,
                    //int nConnectedAxis, float fAxis_X, float fAxis_Y, int nMode,// 연결된 모터, 회전 해야 할 좌표 기준 점, Mode(0 : 회전, 1 : 축 이동(fAxis_X 각도 연관)) //float fOffsetPan, float fOffsetTilt, float fOffsetSwing,    // Ratation(Offset)

                    float fTrack_OffsetPan, float fTrack_OffsetTilt, float fTrack_OffsetSwing,    // Ratation(Offset)
                    float fTrack_OffsetX, float fTrack_OffsetY, float fTrack_OffsetZ,              // Translation(Offset)    
                    //float fOffsetX, float fOffsetY, float fOffsetZ,              // Translation(Offset)
                    params STrackD_t[] aSValue // x, y, radius
                    )
                {
                    float fX, fY, fR;
                    float fX1, fY1, fR1;
                    float fX2, fY2, fR2;
                    int nNum_Next, nNum_Next2;
                    float fAngle, fAngle2, fLength, fLength_Out;

                    //int nArg = 3 + 5;
                    if (fTrack_Distance == 0) fTrack_Distance = 0.001f;
                    int nCnt = aSValue.Length;
#if true
                    // Rotation 적용
                    int nConnectedAxis; // 연결된 모터 번호
                    float fAxis_X;      // 회전 해야 할 좌표 기준 점(X)
                    float fAxis_Y;      // 회전 해야 할 좌표 기준 점(Y)
                    int nMode;          // Mode(0 : 변화없음, 1 : 회전, 2 : 축 이동(fAxis_X 각도 연관 - 나중에 구현하자. 지금 바빠)) //float fOffsetPan, float fOffsetTilt, float fOffsetSwing,    // Ratation(Offset)
                    float fDir = 0;           // 방향(0 : 정, 1 : 반대)
                    for (int nNum = 0; nNum < nCnt; nNum++)
                    {
                        //fR = aSValue[nNum].fR;
#if true
                        nConnectedAxis = aSValue[nNum].nConnectedAxis;
                        fAxis_X = aSValue[nNum].fCenter_X;
                        fAxis_Y = aSValue[nNum].fCenter_Y;
                        nMode = aSValue[nNum].nMode;
                        fDir = ((aSValue[nNum].nDir == 0) ? 1.0f : -1.0f);
                        if (nMode == 1) // 위로 굴곡 허용
                        {
                            //float fCurv = -GetData(nConnectedAxis) * fDir;
                            //if (fCurv > 0)
                            //{
                                //double dX = (double)aSValue[nNum].fX;
                                //double dY = (double)aSValue[nNum].fY;
                                //double dZ = 0.0;
                                
                                ////fX = fAxis_X + (aSValue[nNum].fX - fAxis_X) * (float)CMath.Cos(GetData(nConnectedAxis) * fDir);
                                ////fY = fAxis_Y + (aSValue[nNum].fY - fAxis_Y) * (float)CMath.Sin(GetData(nConnectedAxis) * fDir);
                                //CMath.CalcRot(0.0, 0.0, (double)GetData(nConnectedAxis), ref dX, ref dY, ref dZ);
                                //aSValue[nNum].fX = (float)dX;
                                //aSValue[nNum].fY = (float)dY;
                                ////aSValue[nNum].fX = fAxis_X + (aSValue[nNum].fX - fAxis_X) * (float)CMath.Cos(fCurv) + (aSValue[nNum].fY - fAxis_Y) * (float)CMath.Sin(fCurv);
                                ////aSValue[nNum].fY = fAxis_Y - (aSValue[nNum].fX - fAxis_X) * (float)CMath.Sin(fCurv) + (aSValue[nNum].fY - fAxis_Y) * (float)CMath.Cos(fCurv);

                                float x = aSValue[nNum].fX;
                                float y = aSValue[nNum].fY;
                                float t = GetData(nConnectedAxis) * fDir;

                                aSValue[nNum].fX = ((x - fAxis_X) * (float)CMath.Cos(t) - (y - fAxis_Y) * (float)CMath.Sin(t)) + fAxis_X;
                                aSValue[nNum].fY = ((x - fAxis_X) * (float)CMath.Sin(t) + (y - fAxis_Y) * (float)CMath.Cos(t)) + fAxis_Y;
            
                            //}
                        }
                        else if (nMode == 2) // 아래로 굴곡 허용
                        {
                            float x = aSValue[nNum].fX;
                            float y = aSValue[nNum].fY;
                            float t = GetData(nConnectedAxis) * fDir;

                            aSValue[nNum].fX = ((x - fAxis_X) * (float)CMath.Cos(t) - (y - fAxis_Y) * (float)CMath.Sin(t)) + fAxis_X;
                            aSValue[nNum].fY = ((x - fAxis_X) * (float)CMath.Sin(t) + (y - fAxis_Y) * (float)CMath.Cos(t)) + fAxis_Y;
                        }
                        //else if (nMode == 2)
                        //{

                        //}
                        else
                        {
                            //fX = aSValue[nNum].fX;
                            //fY = aSValue[nNum].fY;
                        }

                        if (fTrack_W < 0)
                        {
                            //fTrack_W = -fTrack_W;
                            OjwTranslate(aSValue[nNum].fX, aSValue[nNum].fY, 0.0f);
                            OjwCircle_Outside(bFill, color, fAlpha, aSValue[nNum].fR, -fTrack_W, 50, 0, 0, 0, 0, 0, 0);
                            //OjwBall_Outside(bFilled, cColor, fAlpha, aSValue[nNum].fR, 50, OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing, OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z);
                            OjwTranslate(-aSValue[nNum].fX, -aSValue[nNum].fY, 0.0f);
                            OjwTranslate(aSValue[nNum].fCenter_X, aSValue[nNum].fCenter_Y, 0.0f);
                            OjwCircle_Outside(bFill, Color.Red, fAlpha, 10, -fTrack_W, 50, 0, 0, 0, 0, 0, 0);
                            //OjwBall_Outside(bFilled, Color.Red, fAlpha, 10, 50, OjwDisp.SOffset_Rot.pan, OjwDisp.SOffset_Rot.tilt, OjwDisp.SOffset_Rot.swing, OjwDisp.SOffset_Trans.x, OjwDisp.SOffset_Trans.y, OjwDisp.SOffset_Trans.z);
                            OjwTranslate(-aSValue[nNum].fCenter_X, -aSValue[nNum].fCenter_Y, 0.0f);                          
                        }
#else
                        fX = aSValue[nNum].fX;
                        fY = aSValue[nNum].fY;
#endif

                    }
                    if (fTrack_W < 0) fTrack_W = -fTrack_W;
#if true
                    // 궤적검사
                    //int nNum_Prev;
                    int nCnt2 = 0;
                    bool[] abChanged = new bool[nCnt];
                    abChanged.Initialize();
                    //float fTest = 0.0f;
                    for (int nNum = 0; nNum < nCnt; nNum++)
                    {
                        fX = aSValue[nNum].fX;
                        fY = aSValue[nNum].fY;
                        fR = aSValue[nNum].fR;
                        nNum_Next = (nNum < nCnt - 1) ? (nNum + 1) : (nNum - nCnt + 1);
                        fX1 = aSValue[nNum_Next].fX;
                        fY1 = aSValue[nNum_Next].fY;
                        fR1 = aSValue[nNum_Next].fR;

                        nNum_Next2 = ((nNum < nCnt - 2) ? (nNum + 2) : (nNum - nCnt + 2)) % nCnt;
                        //nNum_Prev = (((nNum - 1) < 0) ? (nCnt - 1) : (nNum - 1)) % nCnt;
                        fX2 = aSValue[nNum_Next2].fX;
                        fY2 = aSValue[nNum_Next2].fY;
                        fR2 = aSValue[nNum_Next2].fR;

                        fAngle = (float)Ojw.CMath.ATan2((fX1 - fX), (fY1 - fY));
                        fAngle2 = (float)Ojw.CMath.ATan2((fX2 - fX1), (fY2 - fY1));
                        fLength = (float)Math.Sqrt((fX1 - fX) * (fX1 - fX) + (fY1 - fY) * (fY1 - fY));
                        fLength_Out = (float)Math.Sqrt(fLength * fLength - (fR1 - fR) * (fR1 - fR));
                        float fAngleGap = (float)Ojw.CMath.ATan2(fLength, (fR1 - fR));
                        float fTmp = (fAngle - fAngle2 + 360.0f) % 360.0f;
                        //float fMax_X = ((fX1 + fR1) >= (fX2 + fR2)) ? (fX1 + fR) : (fX2 + fR2);
                        //float fMin_X = ((fX1 + fR1) >= (fX2 + fR2)) ? (fX2 + fR2) : (fX1 + fR);
                        //float fMax_Y = ((fY1 + fR1) >= (fY2 + fR2)) ? (fY1 + fR) : (fY2 + fR2);
                        //float fMin_Y = ((fY1 + fR1) >= (fY2 + fR2)) ? (fY2 + fR2) : (fY1 + fR);
                        //if (
                        //    ((fX + fR) > fMax_X) ||
                        //    ((fY + fR) > fMax_Y) ||
                        //    ((fX + fR) < fMin_X) ||
                        //    ((fY + fR) < fMin_Y)
                        //    )
                        //if ((aSValue[nNum_Next2].fX == aSValue[nNum].fX) && (aSValue[nNum_Next2].fY == aSValue[nNum].fY))
                        //{
                        //    abChanged[nNum_Next] = true;
                        //}
                        //else 
                        //fTest += fTmp;
                        if (Math.Round(fTmp) > 180)// || (Math.Round(fTmp) == 0))//181)
                        {
                            //for (int j = nNum; j < nCnt; j++)
                            //{
                            //    nNum_Next = (j < nCnt - 1) ? (j + 1) : (j - nCnt + 1);
                            //    nNum_Next2 = ((j < nCnt - 2) ? (j + 2) : (j - nCnt + 2)) % nCnt;
                            //    aSValue[nNum_Next].fX = aSValue[nNum_Next2].fX;
                            //    aSValue[nNum_Next].fY = aSValue[nNum_Next2].fY;
                            //    aSValue[nNum_Next].fR = aSValue[nNum_Next2].fR;
                            //}
                            //nCnt2++;
                            aSValue[nNum_Next].fX = (aSValue[nNum].fX + aSValue[nNum_Next2].fX) / 2.0f;
                            aSValue[nNum_Next].fY = (aSValue[nNum].fY + aSValue[nNum_Next2].fY) / 2.0f;
                            aSValue[nNum_Next].fR = (aSValue[nNum].fR + aSValue[nNum_Next2].fR) / 2.0f;
                            nCnt2++;
                            abChanged[nNum_Next] = true;
                        }
                        //if fX1 
                    }
                    //if (nNum == 4) Ojw.CMessage.Write("{0}", fTest);
                    //nCnt -= nCnt2;
#endif
#endif
                    string strTrack = string.Empty;
                    if (strTrackFile != null)
                    {



                        //int nOld = strTrackFile.LastIndexOf('*');
                        //if (nOld == strTrackFile.Length - 1)
                        //{
                        //    strTrackFile = strTrackFile.Substring(0, strTrackFile.Length - 1);
                        //}

                        //if (strTrackFile.Length == 0) return;


                        strTrack = strTrackFile.Substring(0, strTrackFile.Length - ((strTrackFile.LastIndexOf('*') == (strTrackFile.Length - 1)) ? 1 : 0));
                        if (OjwAse_GetIndex(strTrack) < 0)
                        {
                            //string strObject = strTrackFile;
#if _CHANGE_DEFAULT_FROM_ASE_TO_DAT
                            String strFileName = Application.StartupPath.Trim('\\') + GetAseFile_Path() + strTrackFile + ((strTrackFile.IndexOf('.') < 0) ? ".dat" : "");
#else
                            String strFileName = Application.StartupPath.Trim('\\') + GetAseFile_Path() + strTrackFile + ((strTrackFile.IndexOf('.') < 0) ? ".ase" : "");
#endif
                            FileInfo f;
                            int nOld = strFileName.LastIndexOf('*');
                            //MessageBox.Show(strFileName + "," + strFileName.Length.ToString() + ',' + nOld.ToString());
                            if (nOld == strFileName.Length - 1) f = new FileInfo(strFileName.Substring(0, strFileName.Length - 1));
                            else f = new FileInfo(strFileName);
                            if (f.Exists == true)
                            {
                                if (CFile.GetExe(strFileName).ToUpper() == "ASE")
                                    OjwFileOpen_3D_ASE(strFileName);
                                else if (CFile.GetExe(strFileName).ToUpper() == "SSTL")
                                    OjwFileOpen_3D_SSTL(strFileName);
                                else if ((CFile.GetExe(strFileName).ToUpper() == "STL") || (CFile.GetExe(strFileName).ToUpper() == "STL*"))
                                    OjwFileOpen_3D_STL(strFileName);
                                else if (CFile.GetExe(strFileName).ToUpper() == "DAT")
                                    OjwFileOpen_3D_Dat(strFileName);
                                else if (CFile.GetExe(strFileName).ToUpper() == "OBJ")
                                    OjwFileOpen_3D_OBJ(strFileName);
                            }
                        }
                    }

                    // 기준 원 그려보자
                    ////////////////////////////
#if false
                    //if (nCnt == 1)
                    //{
                    //    for (int nNum = 0; nNum < nCnt; nNum++)
                    //    {
                    //        fX = afValue[nArg * nNum + 0];
                    //        fY = afValue[nArg * nNum + 1];
                    //        fR = afValue[nArg * nNum + 2];
                    //        //OjwBall_Outside(bFill, color, fAlpha, fR, 50, 0, 0, 0, fX, fY, 0);
                    //        OjwBall_Outside(bFill, color, 0.5f, fR, 50, 0, 0, 0, fX, fY, 0);

                    //        fAxis_X = afValue[nArg * nNum + 4];
                    //        fAxis_Y = afValue[nArg * nNum + 5];
                    //        OjwBall_Outside(bFill, Color.Red, 0.5f, 10, 50, 0, 0, 0, fAxis_X, fAxis_Y, 0);
                    //    }
                    //}
#endif
                    //Color[] aclrTestColor = new Color[4] {Color.White, Color.Blue, Color.Violet, Color.Gold};
                    // First
                    float fSum = 0.0f;
                    for (int nNum = 0; nNum < nCnt; nNum++)
                    {
                        fX = aSValue[nNum].fX;
                        fY = aSValue[nNum].fY;
                        fR = aSValue[nNum].fR;
                        nNum_Next = (nNum < nCnt - 1) ? (nNum + 1) : (nNum - nCnt + 1);
                        fX1 = aSValue[nNum_Next].fX;
                        fY1 = aSValue[nNum_Next].fY;
                        fR1 = aSValue[nNum_Next].fR;

                        nNum_Next2 = ((nNum < nCnt - 2) ? (nNum + 2) : (nNum - nCnt + 2)) % nCnt;
                        fX2 = aSValue[nNum_Next2].fX;
                        fY2 = aSValue[nNum_Next2].fY;
                        fR2 = aSValue[nNum_Next2].fR;

                        fAngle = (float)Ojw.CMath.ATan2((fX1 - fX), (fY1 - fY));
                        fAngle2 = (float)Ojw.CMath.ATan2((fX2 - fX1), (fY2 - fY1));
                        fLength = (float)Math.Sqrt((fX1 - fX) * (fX1 - fX) + (fY1 - fY) * (fY1 - fY));
                        fLength_Out = (float)Math.Sqrt(fLength * fLength - (fR1 - fR) * (fR1 - fR));

                        OjwTranslate(fX, fY, 0);
                        OjwRotation(0, 0, fAngle);
                        OjwTranslate(0, fR, 0);

                        float fAngleGap = (float)Ojw.CMath.ATan2(fLength, (fR1 - fR)); //(float)Ojw.CMath.ATan2(fLength_Out, (fR1 - fR));
                        OjwRotation(0, 0, fAngleGap);
                        
                        // 시작 위치 각도를 거리로 환산해서 구하기
                        //float fAngleTest = fAngleMove % fTrack_Distance; // 모터 회전 ?도
                        //float fStartPos = -fAngleTest * (2.0f * (float)Math.PI * fR1) / 360.0f;
                        float fAngleTest = fAngleMove * (2.0f * (float)Math.PI * fR1) / 360.0f; // 모터 회전 ?도
                        float fStartPos = (fAngleTest % fTrack_Distance) * -1;// ((fAngleMove >= 0) ? -1 : 1);
                        //Ojw.CMessage.Write("Pos={0} -> {1} -> {2}", fAngleMove, fAngleTest, fStartPos);
                        // 기준위치 표시 - 나중에 삭제
                        //OjwBall_Outside(bFill, aclrTestColor[nNum], fAlpha, fR / 10, 50, 0, 0, 0, 0, 0, 0);
                        float fPos = fStartPos;// -fTrack_Distance; // 시작위치 조정이 가능
                        if (nCnt > 1)
                        {
                            while (fPos <= fLength_Out)
                            {
                                if (strTrack.Length > 0)
                                {
                                    //OjwBall_Outside(bFill, Color.Green, fAlpha, fR / 10, 50, 0, 0, 0, fPos, 0, 0);
                                    OjwAse_Outside(bFill, color, fAlpha, fTrack_W, fTrack_H, fTrack_D,
                                            fTrack_OffsetPan, fTrack_OffsetTilt, fTrack_OffsetSwing,
                                            fTrack_OffsetX + fPos, fTrack_OffsetY, fTrack_OffsetZ, strTrack);
                                }
                                else
                                {
                                    //OjwBox_Outside(bFill, color, fAlpha, fTrack_W, 10, fTrack_Distance,
                                    //        0, 0, 0, fPos, 0, -fTrack_W / 2.0f);
                                    OjwCircle_Outside(bFill, color, fAlpha, fTrack_Distance / 3, fTrack_W, 10,
                                               0, 0, 0, fPos, 0, -fTrack_W / 2.0f);
                                    OjwBox_Outside(bFill, color, fAlpha, fTrack_Distance, 10, fTrack_W,
                                            0, 0, 0, fPos, 0, 0);//-fTrack_W / 2.0f);
                                }
                                fPos += fTrack_Distance;
                            }
                        }
                        OjwRotation(0, 0, -fAngleGap);
                        OjwTranslate(0, -fR, 0);
                        OjwRotation(0, 0, -fAngle);
                        OjwTranslate(-fX, -fY, 0);

                        // 거리오차
                        float fDiff = fLength_Out - (fPos - fTrack_Distance);

                        // Rotation
                        OjwTranslate(fX1, fY1, 0);
                        //OjwTranslate(0, fR, 0);
                        //float fPos_X, fPos_Y;
                        float fAngleDiff = (-fDiff * 360.0f) / (2.0f * (float)Math.PI * fR1);
                        // 원호의 길이 = 2 * pi * r * (각도 / 360)
                        // fDistance = 2 * Math.PI * fRadius * (fDegree / 360.0f);
                        float fDegree = (fTrack_Distance * 360.0f) / (2.0f * (float)Math.PI * fR1);
                        float fTmp = (fAngle - fAngle2 + 360.0f) % 360.0f;
                        
                        //Color colorTmp = (abChanged[nNum_Next] == true) ? Color.Red : color;
                        //Color colorTmp = (nNum == 4) ? Color.Red : color;
                        Color colorTmp = color;
                        int j = 0;
#if false
                        if (nCnt == 1)
                        {
                            #region 1 Circle
                            float fR_Height = fR1 - fR1 * (float)Ojw.CMath.Cos(fDegree / 2.0f);
                            float fR_Bottom = fR1 * (float)Ojw.CMath.Sin(fDegree / 2.0f);
                            float fDeg = (float)Ojw.CMath.ATan2(fR_Bottom, fR_Height);

                            for (j = 0; j < (int)(360 / fDegree); j++)
                            {
                                OjwRotation(0, 0, -fAngleDiff + (fAngle + 90.0f));
                                //OjwRotation(0, 0, fAngle + 90.0f - fAngleDiff);

                                OjwTranslate(fR1, 0, 0);
                                OjwRotation(0, 0, fDeg);

                                //OjwRotation(0, 0, fAngle + 90.0f - fAngleDiff);
                                //OjwBall_Outside(bFill, Color.Cyan, fAlpha, fR / 10, 50, 0, 0, 0, fR1, 0, 0);
                                
                                if (strTrackFile.Length > 0)
                                {
                                    OjwAse_Outside(bFill, colorTmp, fAlpha, fTrack_W, fTrack_H, fTrack_D,
                                        fTrack_OffsetPan, fTrack_OffsetTilt, fTrack_OffsetSwing - 90.0f - fDegree / 2,//fDegree,// / 2,
                                        fTrack_OffsetX, fTrack_OffsetY, fTrack_OffsetZ, strTrackFile);
                                }
                                else
                                {
                                    //OjwBox_Outside(bFill, colorTmp, fAlpha, fTrack_W, 10, fTrack_Distance,
                                    //        0, 0, -90.0f - fDegree, 0, 0, -fTrack_W / 2.0f);
                                    OjwCircle_Outside(bFill, colorTmp, fAlpha, fTrack_Distance / 3, fTrack_W, 10,
                                                0, 0, -90.0f - fDegree, 0, 0, -fTrack_W / 2.0f);
                                    OjwBox_Outside(bFill, colorTmp, fAlpha, fTrack_Distance, 10, fTrack_W,
                                            0, 0, -90.0f - fDegree, 0, 0, 0);//-fTrack_W / 2.0f);
                                }

                                //OjwRotation(0, 0, -(fAngle + 90.0f - fAngleDiff));


                                OjwRotation(0, 0, -fDeg);
                                OjwTranslate(-fR1, 0, 0);
                                //OjwRotation(0, 0, -(fAngle + 90.0f - fAngleDiff));
                                OjwRotation(0, 0, fAngleDiff - (fAngle + 90.0f));


                                fAngleDiff += fDegree;
                                //j++;
                            }
                            #endregion 1 Circle
                        }
                        else
#endif
                        {
                            // 각도를 반으로 나눈 부분에 수직 수선이 내려진다.
                            // 
                            float fR_Height = fR1 - fR1 * (float)Ojw.CMath.Cos(fDegree / 2.0f);
                            float fR_Bottom = fR1 * (float)Ojw.CMath.Sin(fDegree / 2.0f);
                            float fDeg = (float)Ojw.CMath.ATan2(fR_Bottom, fR_Height);
                            //while ((fAngleDiff + fDegree / 2) < fTmp)
                            //while ((fAngleDiff + fDegree) <= fTmp)
                            //if (fTmp > 180)
                            //{
                            //    fTmp = 360.0f - fTmp;
                            //    fDegree = -fDegree;
                            //}
                            fSum += fTmp;
                            if ((abChanged[nNum_Next] == false) && (fSum != 720.0f))
                            {
                                //fTmp = 360.0f - fTmp;
                                //fDegree = -fDegree;
                                while (Math.Abs(fAngleDiff) < Math.Abs(fTmp))
                                {
                                    //if (j != 0)
                                    {
                                        OjwRotation(0, 0, fAngle + 90.0f - fAngleDiff);
                                        OjwTranslate(fR1, 0, 0);

                                        OjwRotation(0, 0, fDeg);


                                        if (strTrack.Length > 0)
                                        {
                                            //OjwRotation(0, 0, fAngle + 90.0f - fAngleDiff);
                                            //OjwBall_Outside(bFill, Color.Cyan, fAlpha, fR / 10, 50, 0, 0, 0, fR1, 0, 0);
                                            OjwAse_Outside(bFill, colorTmp, fAlpha, fTrack_W, fTrack_H, fTrack_D,
                                                fTrack_OffsetPan, fTrack_OffsetTilt, fTrack_OffsetSwing - 90.0f - fDegree,// / 2,
                                                fTrack_OffsetX, fTrack_OffsetY, fTrack_OffsetZ, strTrack);
                                            //OjwRotation(0, 0, -(fAngle + 90.0f - fAngleDiff));
                                        }
                                        else
                                        {
                                            OjwCircle_Outside(bFill, colorTmp, fAlpha, fTrack_Distance / 3, fTrack_W, 10,
                                                    0, 0, -90.0f - fDegree, 0, 0, -fTrack_W / 2.0f);
                                            OjwBox_Outside(bFill, colorTmp, fAlpha, fTrack_Distance, 10, fTrack_W,
                                                    0, 0, -90.0f - fDegree, 0, 0, 0);//-fTrack_W / 2.0f);
                                        }
                                    
                                        OjwRotation(0, 0, -fDeg);
                                        OjwTranslate(-fR1, 0, 0);
                                        OjwRotation(0, 0, -(fAngle + 90.0f - fAngleDiff));
                                    }
                                    fAngleDiff += fDegree;
                                    j++;
                                }
                            }
                        }
                        OjwTranslate(-fX1, -fY1, 0);

                    }
                }
                #endregion OjwBox_Outside

                // Case which rotates around the center of the upper surface
                // Kor: 윗면의 중심을 기준으로 회전하는 'ㄷ' 자형 상자
                #region OjwCase
                public void OjwCase(bool bFill, Color color, float fAlpha, bool bRound, bool bInverseType, float fAspectGap,
                                    float fW, float fH, float fD, float fThickness,            
                                    float fOffsetPan, float fOffsetTilt, float fOffsetSwing,    // Ratation(Offset)
                                    float fOffsetX, float fOffsetY, float fOffsetZ              // Translation(Offset)
                                )
                {
                    int nLoopCount = 1;// ((bFill == true) ? 2 : 1);
                    for (int nLoop = 0; nLoop < nLoopCount; nLoop++)
                    {
                        int nSub = _COLOR_GAP;
                        Color cColor = color;// ((nLoop == 0) ? color : Color.DarkGray);
                        m_fColor[0] = ((float)((nLoop == 0) ? cColor.R : cColor.R - nSub) / 255.0f);  // R
                        m_fColor[1] = ((float)((nLoop == 0) ? cColor.G : cColor.G - nSub) / 255.0f);  // G
                        m_fColor[2] = ((float)((nLoop == 0) ? cColor.B : cColor.B - nSub) / 255.0f);  // B
                        m_fColor[3] = fAlpha;// m_fAlpha;//
                        for (int j = 0; j < 3; j++)
                        {
                            if (m_fColor[j] < 0) m_fColor[j] = ((float)(((j == 0) ? cColor.R : ((j == 1) ? cColor.G : cColor.B)) + nSub) / 255.0f);//0.0f;
                        }
                        Gl.glColor4fv(m_fColor);
                        //Gl.glColor3fv(m_fColor); // Color with an array of floats

                        Gl.glPushMatrix();

                        OjwTranslate(fOffsetX, fOffsetY, fOffsetZ);
                        OjwRotation(fOffsetPan, fOffsetTilt, fOffsetSwing);


                        float fT = fThickness;
                        // x2 -> direction : right(Kor: 증분방향 : 오른쪽)
                        // Y2 -> direction : Up(Kor: 증분방향 : 위쪽)
                        // Z2 -> direction : The inside of the screen(Kor: 증분방향 : 화면의 안쪽)
                        // Criteria screen : See picture below(Kor: 기준화면 : 밑 그림 참조)
                        // 0, 0, 0 -> State in the middle of the screen as a starting point and went inside by a factor of 5
                        // Kor: 0, 0, 0 -> 화면의 가운데를 시작점으로 하고 안쪽으로 5만큼 들어간 상태
                        /*
                            000000000
                          0 0 ★  0 0
                        000000000   0
                        0   0   0   0
                        0   000000000  
                        0 0     0 0
                        000000000  
                        ( Center Position )
                        */

                        //uint uiType = (bFill == true) ? Gl.GL_SMOOTH : Gl.GL_LINE_LOOP;//Gl.GL_QUADS : Gl.GL_LINE_LOOP;//Gl.GL_LINE_LOOP;// Gl.GL_QUADS;//
                        //int uiType = (bFill == true) ? Gl.GL_QUADS : Gl.GL_LINE_LOOP;//Gl.GL_QUADS : Gl.GL_LINE_LOOP;//Gl.GL_LINE_LOOP;// Gl.GL_QUADS;//
                        //int uiType = ((bFill == true) ? ((nLoop == 0) ? Gl.GL_QUADS : Gl.GL_LINE_LOOP) : Gl.GL_LINE_LOOP);

                        //int uiType = ((bFill == true) ? ((nLoop == 0) ? Gl.GL_POLYGON : Gl.GL_POLYGON_STIPPLE) : Gl.GL_LINE_LOOP);
                        int uiType = ((bFill == true) ? ((nLoop == 0) ? Gl.GL_POLYGON : Gl.GL_LINE_LOOP) : Gl.GL_LINE_LOOP);
                        int uiTypeTop = (bFill == true) ? Gl.GL_FILL : Gl.GL_LINE;
                        //int uiType = Gl.GL_TRIANGLE_FAN;// (bFill == true) ? Gl.GL_TRIANGLE_FAN : Gl.GL_LINE_LOOP;
                        Gl.glPolygonMode(Gl.GL_BACK, uiTypeTop);
                        Gl.glPolygonMode(Gl.GL_FRONT, uiTypeTop);
                        //Gl.glBegin(uiType);


                        //Gl.GL_POLYGON : Gl.GL_TRIANGLES
                        float fMinus = (fW >= 0) ? 1.0f : -1.0f;
                        float fX1 = -(fW + fT * 2 * fMinus) / 2.0f;
                        float fX2 = (fW + fT * 2 * fMinus) / 2.0f;
                        float fY1 = (bInverseType == false) ? 0.0f : -(fH - fT);
                        float fY2 = (bInverseType == false) ? (-fT) : (-fH);
                        float fZ1 = -fD / 2.0f + ((bInverseType == true) ? fAspectGap : 0);
                        float fZ2 = fD / 2.0f + ((bInverseType == true) ? fAspectGap : 0);

                        //// Top or Bottom ////
                        Gl.glBegin(uiType);

                        //OjwTranslate(fOffsetX, fOffsetY, fOffsetZ);
                        //OjwRotation(fOffsetPan, fOffsetTilt, fOffsetSwing);

                        // Front Face
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ2);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ2);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ2);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2);				// Bottom Left Of The Texture and Quad
                        // Back Face
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ1);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ1);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ1);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ1);				// Bottom Right Of The Texture and Quad
                        // Top Face
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY1, fZ2);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY1, fZ2);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ1);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1);				// Top Left Of The Texture and Quad
                        // Bottom Face
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY2, fZ1);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX2, fY2, fZ1);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ2);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY2, fZ1);				// Top Right Of The Texture and Quad
                        // Right Face
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ1);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ1);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ2);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ2);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ1);				// Bottom Right Of The Texture and Quad
                        // Left Face
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ1);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ2);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ1);				// Bottom Left Of The Texture and Quad

                        Gl.glEnd();

                        fX1 = (-fW - fT * 2 * fMinus) / 2.0f;
                        fX2 = -fW / 2.0f;// fX / 2.0f;
                        fY1 = -((bInverseType == false) ? fT : 0);
                        fY2 = -(fH - ((bInverseType == true) ? fT : 0));
                        fZ1 = -fD / 2.0f;
                        fZ2 = fD / 2.0f;

                        if (bInverseType == true) fAspectGap = -fAspectGap;
                        float fTop = 0;// (bInverseType == true) ? fAspectGap * 0 : 0;
                        float fBottom = (bInverseType == false) ? fAspectGap : -fAspectGap;
                        //// Left ////
                        Gl.glBegin(uiType);

                        // Front Face
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2 + fBottom);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ2 + fBottom);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ2 + fTop);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ2 + fTop);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2 + fBottom);				// Bottom Left Of The Texture and Quad
                        // Back Face
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ1 + fBottom);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1 + fTop);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ1 + fTop);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ1 + fBottom);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ1 + fBottom);				// Bottom Right Of The Texture and Quad
                        // Top Face
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1 + fTop);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY1, fZ2 + fTop);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY1, fZ2 + fTop);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ1 + fTop);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1 + fTop);				// Top Left Of The Texture and Quad
                        // Bottom Face
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY2, fZ1 + fBottom);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX2, fY2, fZ1 + fBottom);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ2 + fBottom);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2 + fBottom);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY2, fZ1 + fBottom);				// Top Right Of The Texture and Quad
                        // Right Face
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ1 + fBottom);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ1 + fTop);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ2 + fTop);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ2 + fBottom);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ1 + fBottom);				// Bottom Right Of The Texture and Quad
                        // Left Face
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ1 + fBottom);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2 + fBottom);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ2 + fTop);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1 + fTop);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ1 + fBottom);				// Bottom Left Of The Texture and Quad

                        Gl.glEnd();

                        //Gl.glBegin(uiType);
                        if ((bRound == true) && (nLoop == 0))
                        {
                            float fH2 = (bInverseType == false) ? fH : 0;
                            float fGap = 0.1f;
                            float fT2 = (fThickness - fGap * 2.0f) * fMinus;
                            Gl.glPushMatrix();
                            OjwTranslate((-fW / 2.0f - ((fMinus == 1.0f) ? fT2 : -fGap * 2.0f) - fGap), -fH2, ((bInverseType == false) ? fAspectGap : 0));
                            OjwRotation(90, 0, 0);
                            OjwCircle(bFill, color, fAlpha, fD / 2.0f, fT2 * fMinus, 30);

                            OjwTranslate(0, 0, (fW + fT2 + fGap * 2.0f * fMinus));
                            OjwCircle(bFill, color, fAlpha, fD / 2.0f, fT2 * fMinus, 30);
                            Gl.glPopMatrix();
                        }
                        //Gl.glEnd();

                        fX1 = (fW + fT * 2 * fMinus) / 2.0f;
                        fX2 = fW / 2.0f;// fX / 2.0f;
                        fY1 = -((bInverseType == false) ? fT : 0);
                        fY2 = -(fH - ((bInverseType == true) ? fT : 0));
                        fZ1 = -fD / 2.0f;
                        fZ2 = fD / 2.0f;

                        //// Right ////
                        Gl.glBegin(uiType);

                        // Front Face
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2 + fBottom);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ2 + fBottom);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ2 + fTop);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ2 + fTop);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2 + fBottom);				// Bottom Left Of The Texture and Quad
                        // Back Face
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ1 + fBottom);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1 + fTop);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ1 + fTop);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ1 + fBottom);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ1 + fBottom);				// Bottom Right Of The Texture and Quad
                        // Top Face
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1 + fTop);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY1, fZ2 + fTop);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY1, fZ2 + fTop);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ1 + fTop);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1 + fTop);				// Top Left Of The Texture and Quad
                        // Bottom Face
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY2, fZ1 + fBottom);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX2, fY2, fZ1 + fBottom);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ2 + fBottom);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2 + fBottom);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY2, fZ1 + fBottom);				// Top Right Of The Texture and Quad
                        // Right Face
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ1 + fBottom);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ1 + fTop);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ2 + fTop);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ2 + fBottom);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ1 + fBottom);				// Bottom Right Of The Texture and Quad
                        // Left Face
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ1 + fBottom);				// Bottom Left Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2 + fBottom);				// Bottom Right Of The Texture and Quad
                        Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ2 + fTop);				// Top Right Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1 + fTop);				// Top Left Of The Texture and Quad
                        Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ1 + fBottom);				// Bottom Left Of The Texture and Quad

                        Gl.glEnd();

                        //if (bRound == true)
                        //{
                        //    float fH2 = (bInverseType == false) ? fH : 0;
                        //    float fGap = 0.1f;
                        //    float fT2 = (fThickness - fGap * 2.0f) * fMinus;
                        //    Gl.glPushMatrix();
                        //    OjwTranslate((fW / 2.0f - ((fMinus == 1.0f) ? fT2 : -fGap * 2.0f) + fT2 - fGap + fGap * 2.0f * fMinus), -fH2, ((bInverseType == false) ? fAspectGap : 0));
                        //    //OjwTranslate((fW / 2.0f - ((fMinus == 1.0f) ? fT2 : -fGap * 2.0f) - fGap), -fH2, ((bInverseType == false) ? fAspectGap : 0));
                        //    OjwRotation(90, 0, 0);
                        //    OjwCircle(bFill, color, fD / 2.0f, fT2 * fMinus, 30);

                        //    //OjwCircle(bFill, color, fD / 2.0f, fT2 * fMinus, 30);
                        //    Gl.glPopMatrix();
                        //}

                        Gl.glPopMatrix();
                    }
                }
                #endregion OjwCase

                // half-Case which rotates around the center of the upper surface
                // Kor: 윗면의 중심을 기준으로 회전하는 'ㄷ' 자형 상자 반쪽
                #region OjwCase_half
                public void OjwCase_half(bool bFill, Color color, float fAlpha, bool bRound, bool bInverseType, float fAspectGap,
                                    float fW, float fH, float fD, float fThickness,
                                    float fOffsetPan, float fOffsetTilt, float fOffsetSwing,    // Ratation(Offset)
                                    float fOffsetX, float fOffsetY, float fOffsetZ              // Translation(Offset)
                                )
                {
                    Gl.glPushMatrix();

                    OjwTranslate(fOffsetX, fOffsetY, fOffsetZ);
                    OjwRotation(fOffsetPan, fOffsetTilt, fOffsetSwing);



                    m_fColor[0] = ((float)(color.R) / 255.0f);  // R
                    m_fColor[1] = ((float)(color.G) / 255.0f);  // G
                    m_fColor[2] = ((float)(color.B) / 255.0f);  // B
                    m_fColor[3] = fAlpha;  // B
                    Gl.glColor4fv(m_fColor); // Color with an array of floats

                    fW *= 2.0f;
                    float fT = fThickness;
                    fW -= (fW < 0) ? fT * 2 : 0;

                    int uiType = (bFill == true) ? Gl.GL_QUADS : Gl.GL_LINE_LOOP;//Gl.GL_LINE_LOOP;// Gl.GL_QUADS;//
                    int uiTypeTop = (bFill == true) ? Gl.GL_FILL : Gl.GL_LINE;
                    //int uiType = Gl.GL_TRIANGLE_FAN;// (bFill == true) ? Gl.GL_TRIANGLE_FAN : Gl.GL_LINE_LOOP;
                    Gl.glPolygonMode(Gl.GL_BACK, uiTypeTop);
                    Gl.glPolygonMode(Gl.GL_FRONT, uiTypeTop);
                    //Gl.glBegin(uiType);


                    float fMinus = (fW >= 0) ? 1.0f : -1.0f;
                    float fX1 = -(fW + fT * 2 * fMinus) / 2.0f;
                    float fX2 = 0;
                    float fY1 = (bInverseType == false) ? 0.0f : -(fH - fT);
                    float fY2 = (bInverseType == false) ? (-fT) : (-fH);
                    float fZ1 = -fD / 2.0f + ((bInverseType == true) ? fAspectGap : 0);
                    float fZ2 = fD / 2.0f + ((bInverseType == true) ? fAspectGap : 0);

                    if (fW < 0) fX1 -= fT;

                    //// Top or Bottom ////
                    Gl.glBegin(uiType);

                    // Front Face
                    Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2);				// Bottom Left Of The Texture and Quad
                    Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ2);				// Bottom Right Of The Texture and Quad
                    Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ2);				// Top Right Of The Texture and Quad
                    Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ2);				// Top Left Of The Texture and Quad
                    // Back Face
                    Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ1);				// Bottom Right Of The Texture and Quad
                    Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1);				// Top Right Of The Texture and Quad
                    Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ1);				// Top Left Of The Texture and Quad
                    Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ1);				// Bottom Left Of The Texture and Quad
                    // Top Face
                    Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1);				// Top Left Of The Texture and Quad
                    Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY1, fZ2);				// Bottom Left Of The Texture and Quad
                    Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY1, fZ2);				// Bottom Right Of The Texture and Quad
                    Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ1);				// Top Right Of The Texture and Quad
                    // Bottom Face
                    Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY2, fZ1);				// Top Right Of The Texture and Quad
                    Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX2, fY2, fZ1);				// Top Left Of The Texture and Quad
                    Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ2);				// Bottom Left Of The Texture and Quad
                    Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2);				// Bottom Right Of The Texture and Quad
                    // Right Face
                    Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ1);				// Bottom Right Of The Texture and Quad
                    Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ1);				// Top Right Of The Texture and Quad
                    Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ2);				// Top Left Of The Texture and Quad
                    Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ2);				// Bottom Left Of The Texture and Quad
                    // Left Face
                    Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ1);				// Bottom Left Of The Texture and Quad
                    Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2);				// Bottom Right Of The Texture and Quad
                    Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ2);				// Top Right Of The Texture and Quad
                    Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1);				// Top Left Of The Texture and Quad

                    Gl.glEnd();

                    //if (bStandard == true)
                    //{
                    fX1 = (-fW - fT * 2 * fMinus) / 2.0f;
                    fX2 = -fW / 2.0f;
                    fY1 = -((bInverseType == false) ? fT : 0);
                    fY2 = -(fH - ((bInverseType == true) ? fT : 0));
                    fZ1 = -fD / 2.0f;
                    fZ2 = fD / 2.0f;

                    if (fW < 0) fX1 -= fT * 2;

                    if (bInverseType == true) fAspectGap = -fAspectGap;
                    float fTop = 0;// (bInverseType == true) ? fAspectGap * 0 : 0;
                    float fBottom = (bInverseType == false) ? fAspectGap : -fAspectGap;
                    //// Left  or Right ////
                    Gl.glBegin(uiType);

                    // Front Face
                    Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2 + fBottom);				// Bottom Left Of The Texture and Quad
                    Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ2 + fBottom);				// Bottom Right Of The Texture and Quad
                    Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ2 + fTop);				// Top Right Of The Texture and Quad
                    Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ2 + fTop);				// Top Left Of The Texture and Quad
                    // Back Face
                    Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ1 + fBottom);				// Bottom Right Of The Texture and Quad
                    Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1 + fTop);				// Top Right Of The Texture and Quad
                    Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ1 + fTop);				// Top Left Of The Texture and Quad
                    Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ1 + fBottom);				// Bottom Left Of The Texture and Quad
                    // Top Face
                    Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1 + fTop);				// Top Left Of The Texture and Quad
                    Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY1, fZ2 + fTop);				// Bottom Left Of The Texture and Quad
                    Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY1, fZ2 + fTop);				// Bottom Right Of The Texture and Quad
                    Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ1 + fTop);				// Top Right Of The Texture and Quad
                    // Bottom Face
                    Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY2, fZ1 + fBottom);				// Top Right Of The Texture and Quad
                    Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX2, fY2, fZ1 + fBottom);				// Top Left Of The Texture and Quad
                    Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ2 + fBottom);				// Bottom Left Of The Texture and Quad
                    Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2 + fBottom);				// Bottom Right Of The Texture and Quad
                    // Right Face
                    Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ1 + fBottom);				// Bottom Right Of The Texture and Quad
                    Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ1 + fTop);				// Top Right Of The Texture and Quad
                    Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX2, fY1, fZ2 + fTop);				// Top Left Of The Texture and Quad
                    Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX2, fY2, fZ2 + fBottom);				// Bottom Left Of The Texture and Quad
                    // Left Face
                    Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ1 + fBottom);				// Bottom Left Of The Texture and Quad
                    Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(fX1, fY2, fZ2 + fBottom);				// Bottom Right Of The Texture and Quad
                    Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ2 + fTop);				// Top Right Of The Texture and Quad
                    Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(fX1, fY1, fZ1 + fTop);				// Top Left Of The Texture and Quad

                    Gl.glEnd();

                    if (bRound == true)
                    {
                        float fH2 = (bInverseType == false) ? fH : 0;
                        float fGap = 0.1f;
                        float fT2 = (fThickness - fGap * 2.0f) * fMinus;
                        Gl.glPushMatrix();

                        OjwTranslate((-fW / 2.0f - ((fMinus == 1.0f) ? (fT2) : (-fGap * 2.0f + fT)) - fGap), -fH2, ((bInverseType == false) ? fAspectGap : 0));
                        OjwRotation(90, 0, 0);
                        OjwCircle(bFill, color, fAlpha, fD / 2.0f, fT2 * fMinus, 30);

                        Gl.glPopMatrix();
                    }

                    Gl.glPopMatrix();
                }
                #endregion OjwCase_half

                // Circle which rotates around the center of the upper surface윗면의 중심을 기준으로 회전하는 Circle
                #region OjwCircle
                public void OjwCircle(bool bFill, Color color, float fAlpha, float fR, float fD, int nSolidCnt)
                {

                    //fR *= fScale;
                    //fD *= fScale;

                    Glu.GLUquadric quadObj;
                    // Create quadric object
                    int nLoopCount = 1;// ((bFill == true) ? 2 : 1);
                    for (int nLoop = 0; nLoop < nLoopCount; nLoop++)
                    {
                        int nSub = _COLOR_GAP;
                        Color cColor = color;// ((i == 0) ? color : Color.DarkGray);
                        m_fColor[0] = ((float)((nLoop == 0) ? cColor.R : cColor.R - nSub) / 255.0f);  // R
                        m_fColor[1] = ((float)((nLoop == 0) ? cColor.G : cColor.G - nSub) / 255.0f);  // G
                        m_fColor[2] = ((float)((nLoop == 0) ? cColor.B : cColor.B - nSub) / 255.0f);  // B
                        m_fColor[3] = fAlpha;// m_fAlpha;//
                        for (int j = 0; j < 3; j++)
                        {
                            if (m_fColor[j] < 0) m_fColor[j] = ((float)(((j == 0) ? cColor.R : ((j == 1) ? cColor.G : cColor.B)) + nSub) / 255.0f);//0.0f;
                        }
                        Gl.glColor4fv(m_fColor);
                        //Gl.glColor3fv(m_fColor); // Color with an array of floats

                        quadObj = Glu.gluNewQuadric();

                        Gl.glPushMatrix();
#if false
                        //Gl.glBlendFunc(Gl.GL_SRC_ALPHA, Gl.GL_ONE_MINUS_SRC_ALPHA);
                        //Gl.glEnable(Gl.GL_BLEND);
                        //Gl.glEnable(Gl.GL_LINE_SMOOTH);

                        // GLU_LINE -> Wire Frame
                        // GLU_FILL -> Solid
                        // GLU_POINT -> Point
                        // GLU_SILHOUETTE -> Only the outer edges with a line figure(Kor: 선으로 외부모서리만을 그림)
                        Glu.gluQuadricDrawStyle(quadObj, (bFill == true) ? ((nLoop == 0) ? Glu.GLU_FILL : Glu.GLU_SILHOUETTE) : Glu.GLU_LINE);

                        // GLU_NONE -> Do not generate normal vector(Kor: 법선벡터 생성 안함)
                        // GLU_FLAT -> The surface normal vector to produce it seem shorn(Kor: 면이 깎인 것처럼 보이도록 법선벡터 생성)
                        // GLU_SMOOTH -> The normal vector of the corner to create an object looks smooth(Kor: 물체의 모서리가 부드럽게 보이도록 법선벡터 생성)
                        Glu.gluQuadricNormals(quadObj, Glu.GLU_SMOOTH);

                        // Specifies the direction of the normal vector(Kor: 법선벡터의 방향을 지정)
                        // GLU_INSIDE -> Makes the direction of the normal vector to the inside.(Kor: 법선벡터의 방향을 안쪽으로)
                        // GLU_OUTSIDE -> Makes the direction of the normal vector to the outside.(Kor: 법선벡터의 방향을 바깥쪽으로)
                        Glu.gluQuadricOrientation(quadObj, Glu.GLU_INSIDE);
                        Glu.gluDisk(quadObj, 0, fR, nSolidCnt, 1);

                        Glu.gluQuadricOrientation(quadObj, Glu.GLU_OUTSIDE);
                        Glu.gluCylinder(quadObj, fR, fR, fD, nSolidCnt, 2);
#if false
                        // 시작원의 반지름(도우넛 모양이 가능 - 이 값이 클수록 구멍이 넓어짐), 외곽원의 반지름, 원을 이루는 선의 갯수
                        //Glu.gluDisk(quadObj, 0, fR, nSolidCnt, 1);
#endif
                        Gl.glTranslated(0, 0, fD);

                        Glu.gluQuadricOrientation(quadObj, Glu.GLU_OUTSIDE);
                        Glu.gluDisk(quadObj, 0, fR, nSolidCnt, 1);

                        //if (m_bPickMode == true)
                        //{
                        //    PopName();
                        //}
#else
                        // GLU_LINE -> Wire Frame
                        // GLU_FILL -> Solid
                        // GLU_POINT -> Point
                        // GLU_SILHOUETTE -> Only the outer edges with a line figure(Kor: 선으로 외부모서리만을 그림)
                        Glu.gluQuadricDrawStyle(quadObj, (bFill == true) ? ((nLoop == 0) ? Glu.GLU_FILL : Glu.GLU_SILHOUETTE) : Glu.GLU_LINE);

                        // GLU_NONE -> Do not generate normal vector(Kor: 법선벡터 생성 안함)
                        // GLU_FLAT -> The surface normal vector to produce it seem shorn(Kor: 면이 깎인 것처럼 보이도록 법선벡터 생성)
                        // GLU_SMOOTH -> The normal vector of the corner to create an object looks smooth(Kor: 물체의 모서리가 부드럽게 보이도록 법선벡터 생성)
                        Glu.gluQuadricNormals(quadObj, Glu.GLU_SMOOTH);

                        // Specifies the direction of the normal vector(Kor: 법선벡터의 방향을 지정)
                        // GLU_INSIDE -> Makes the direction of the normal vector to the inside.(Kor: 법선벡터의 방향을 안쪽으로)
                        // GLU_OUTSIDE -> Makes the direction of the normal vector to the outside.(Kor: 법선벡터의 방향을 바깥쪽으로)
                        //Glu.gluQuadricOrientation(quadObj, Glu.GLU_INSIDE);

                        OjwRotation(180.0f, 0.0f, 0.0f);
                        Glu.gluDisk(quadObj, 0, fR, nSolidCnt, 1);
                        OjwRotation(-180.0f, 0.0f, 0.0f);

                        //Glu.gluQuadricOrientation(quadObj, Glu.GLU_OUTSIDE);
                        Glu.gluCylinder(quadObj, fR, fR, fD, nSolidCnt, 2);

                        Gl.glTranslated(0, 0, fD);

                        //Glu.gluQuadricOrientation(quadObj, Glu.GLU_OUTSIDE);
                        Glu.gluDisk(quadObj, 0, fR, nSolidCnt, 1);
#endif
                        Gl.glPopMatrix();

                        Glu.gluDeleteQuadric(quadObj); // remove object
                    }
                    //if (m_bPickMode == true) PopName();

                }
                #endregion OjwCircle

                // A cylinder which rotates around the center of the upper surface(Kor: 윗면의 중심을 기준으로 회전하는 원기둥)
                #region OjwCircle_Outside
                public void OjwCircle_Outside(bool bFill, Color color, float fAlpha, float fR, float fD, int nSolidCnt,
                                    float fOffsetPan, float fOffsetTilt, float fOffsetSwing,    // Rotate(Offset)
                                    float fOffsetX, float fOffsetY, float fOffsetZ              // Translate(Offset)
                                    )
                {
                    int nLoopCount = 1;// ((bFill == true) ? 2 : 1);
                    for (int nLoop = 0; nLoop < nLoopCount; nLoop++)
                    {
                        int nSub = _COLOR_GAP;
                        Color cColor = color;// ((nLoop == 0) ? color : Color.DarkGray);
                        m_fColor[0] = ((float)((nLoop == 0) ? cColor.R : cColor.R - nSub) / 255.0f);  // R
                        m_fColor[1] = ((float)((nLoop == 0) ? cColor.G : cColor.G - nSub) / 255.0f);  // G
                        m_fColor[2] = ((float)((nLoop == 0) ? cColor.B : cColor.B - nSub) / 255.0f);  // B
                        m_fColor[3] = fAlpha;// m_fAlpha;//
                        for (int j = 0; j < 3; j++)
                        {
                            if (m_fColor[j] < 0) m_fColor[j] = ((float)(((j == 0) ? cColor.R : ((j == 1) ? cColor.G : cColor.B)) + nSub) / 255.0f);//0.0f;
                        }
                        Gl.glColor4fv(m_fColor);
                        //Gl.glColor3fv(m_fColor); // Color with an array of floats

                        //fR *= fScale;
                        //fD *= fScale;


                        Glu.GLUquadric quadObj;


                        // Create quadric object
                        quadObj = Glu.gluNewQuadric();

                        Gl.glPushMatrix();

                        OjwTranslate(fOffsetX, fOffsetY, fOffsetZ);
                        OjwRotation(fOffsetPan, fOffsetTilt, fOffsetSwing);
#if false
                        //Gl.glBlendFunc(Gl.GL_SRC_ALPHA, Gl.GL_ONE_MINUS_SRC_ALPHA);
                        //Gl.glEnable(Gl.GL_BLEND);
                        //Gl.glEnable(Gl.GL_LINE_SMOOTH);

                        // GLU_LINE -> Wire Frame
                        // GLU_FILL -> Solid
                        // GLU_POINT -> Point
                        // GLU_SILHOUETTE -> Only the outer edges with a line figure(Kor: 선으로 외부모서리만을 그림)
                        //Glu.gluQuadricDrawStyle(quadObj, (bFill == true) ? Glu.GLU_FILL : Glu.GLU_LINE);
                        Glu.gluQuadricDrawStyle(quadObj, (bFill == true) ? ((nLoop == 0) ? Glu.GLU_FILL : Glu.GLU_SILHOUETTE) : Glu.GLU_LINE);

                        // GLU_NONE -> Do not generate normal vector(Kor: 법선벡터 생성 안함)
                        // GLU_FLAT -> The surface normal vector to produce it seem shorn(Kor: 면이 깎인 것처럼 보이도록 법선벡터 생성)
                        // GLU_SMOOTH -> The normal vector of the corner to create an object looks smooth(Kor: 물체의 모서리가 부드럽게 보이도록 법선벡터 생성)
                        Glu.gluQuadricNormals(quadObj, Glu.GLU_SMOOTH);

                        // Specifies the direction of the normal vector(Kor: 법선벡터의 방향을 지정)
                        // GLU_INSIDE -> Makes the direction of the normal vector to the inside.(Kor: 법선벡터의 방향을 안쪽으로)
                        // GLU_OUTSIDE -> Makes the direction of the normal vector to the outside.(Kor: 법선벡터의 방향을 바깥쪽으로)
                        Glu.gluQuadricOrientation(quadObj, Glu.GLU_INSIDE);
                        // The radius of the circle(The higher the number, the hole is widened)(Kor: 시작원의 반지름(도우넛 모양이 가능 - 이 값이 클수록 구멍이 넓어짐), 외곽원의 반지름, 원을 이루는 선의 갯수)
                        Glu.gluDisk(quadObj, 0, fR, nSolidCnt, 1);

                        Glu.gluQuadricOrientation(quadObj, Glu.GLU_OUTSIDE);
                        Glu.gluCylinder(quadObj, fR, fR, fD, nSolidCnt, 1);

                        Gl.glTranslated(0, 0, fD);

                        Glu.gluQuadricOrientation(quadObj, Glu.GLU_OUTSIDE);
                        Glu.gluDisk(quadObj, 0, fR, nSolidCnt, 1);

                        //OjwTranslate(-fOffsetX, -fOffsetY, -fOffsetZ);
                        //OjwRotation(-fOffsetPan, -fOffsetTilt, -fOffsetSwing);
#else
                        int uiTypeTop = (bFill == true) ? Gl.GL_FILL : Gl.GL_LINE;
                        //int uiType = Gl.GL_TRIANGLE_FAN;// (bFill == true) ? Gl.GL_TRIANGLE_FAN : Gl.GL_LINE_LOOP;
                        Gl.glPolygonMode(Gl.GL_BACK, uiTypeTop);
                        Gl.glPolygonMode(Gl.GL_FRONT, uiTypeTop);

                        // GLU_LINE -> Wire Frame
                        // GLU_FILL -> Solid
                        // GLU_POINT -> Point
                        // GLU_SILHOUETTE -> Only the outer edges with a line figure(Kor: 선으로 외부모서리만을 그림)
                        //Glu.gluQuadricDrawStyle(quadObj, (bFill == true) ? Glu.GLU_FILL : Glu.GLU_LINE);
                        Glu.gluQuadricDrawStyle(quadObj, (bFill == true) ? ((nLoop == 0) ? Glu.GLU_FILL : Glu.GLU_SILHOUETTE) : Glu.GLU_LINE);

                        // GLU_NONE -> Do not generate normal vector(Kor: 법선벡터 생성 안함)
                        // GLU_FLAT -> The surface normal vector to produce it seem shorn(Kor: 면이 깎인 것처럼 보이도록 법선벡터 생성)
                        // GLU_SMOOTH -> The normal vector of the corner to create an object looks smooth(Kor: 물체의 모서리가 부드럽게 보이도록 법선벡터 생성)
                        Glu.gluQuadricNormals(quadObj, Glu.GLU_SMOOTH);


                        // Specifies the direction of the normal vector(Kor: 법선벡터의 방향을 지정)
                        // GLU_INSIDE -> Makes the direction of the normal vector to the inside.(Kor: 법선벡터의 방향을 안쪽으로)
                        // GLU_OUTSIDE -> Makes the direction of the normal vector to the outside.(Kor: 법선벡터의 방향을 바깥쪽으로)
                        //Glu.gluQuadricOrientation(quadObj, Glu.GLU_OUTSIDE);
                        

                        // The radius of the circle(The higher the number, the hole is widened)(Kor: 시작원의 반지름(도우넛 모양이 가능 - 이 값이 클수록 구멍이 넓어짐), 외곽원의 반지름, 원을 이루는 선의 갯수)

                        OjwRotation(180.0f, 0.0f, 0.0f);
                        Glu.gluDisk(quadObj, 0, fR, nSolidCnt, 1);
                        OjwRotation(-180.0f, 0.0f, 0.0f);




                        Glu.gluCylinder(quadObj, fR, fR, fD, nSolidCnt, 1);

                        Gl.glTranslated(0, 0, fD);

                        //Glu.gluQuadricOrientation(quadObj, Glu.GLU_OUTSIDE);
                        Glu.gluDisk(quadObj, 0, fR, nSolidCnt, 1);
#endif
                        Gl.glPopMatrix();

                        Glu.gluDeleteQuadric(quadObj);
                        //if (m_bPickMode == true) PopName();
                    }
                }
                #endregion OjwCircle_Outside

                // Ball to the middle of the center(Kor: 가운데를 중심으로 하는 공)
                #region OjwBall
                public void OjwBall(bool bFill, Color color, float fAlpha, float fR, int nSolidCnt)
                {
                    //if ((nTexture >= 0) && (nTexture < _CNT_TEXTURE)) Gl.glBindTexture(Gl.GL_TEXTURE_2D, m_puiTexture[nTexture]);									// Select Texture

                    m_fColor[0] = ((float)(color.R) / 255.0f);  // R
                    m_fColor[1] = ((float)(color.G) / 255.0f);  // G
                    m_fColor[2] = ((float)(color.B) / 255.0f);  // B
                    m_fColor[3] = fAlpha;  // B
                    Gl.glColor4fv(m_fColor); // Color with an array of floats

                    //fR *= fScale;
                    //#if false//_TAO
                    //#else
                    Glu.GLUquadric quadObj;
                    // Create quadric object
                    quadObj = Glu.gluNewQuadric();

                    Glu.gluQuadricDrawStyle(quadObj, (bFill == true) ? Glu.GLU_FILL : Glu.GLU_LINE);
                    Glu.gluSphere(quadObj, fR, nSolidCnt, 16);										// Draw Another Sphere Using New Texture
                    Glu.gluDeleteQuadric(quadObj);
                    //#endif
                }
                #endregion OjwBall
           
                // Ball to the middle of the center(Kor: 가운데를 중심으로 하는 공)
                #region OjwBall_Outside
                public void OjwBall_Outside(bool bFill, Color color, float fAlpha, float fR, int nSolidCnt,
                                    float fOffsetPan, float fOffsetTilt, float fOffsetSwing,    // Rotate(Offset)
                                    float fOffsetX, float fOffsetY, float fOffsetZ              // Translate(Offset)
                                    )
                {
                    m_fColor[0] = ((float)(color.R) / 255.0f);  // R
                    m_fColor[1] = ((float)(color.G) / 255.0f);  // G
                    m_fColor[2] = ((float)(color.B) / 255.0f);  // B
                    m_fColor[3] = fAlpha;
                    Gl.glColor4fv(m_fColor); // Color with an array of floats

                    Glu.GLUquadric quadObj;
                    // Create quadric object
                    quadObj = Glu.gluNewQuadric();

                    Gl.glPushMatrix();
                    OjwTranslate(fOffsetX, fOffsetY, fOffsetZ);
                    OjwRotation(fOffsetPan, fOffsetTilt, fOffsetSwing);
                    Glu.gluQuadricDrawStyle(quadObj, (bFill == true) ? Glu.GLU_FILL : Glu.GLU_LINE);
                    Glu.gluSphere(quadObj, fR, nSolidCnt, 16);										// Draw Another Sphere Using New Texture
                    Gl.glPopMatrix();

                    Glu.gluDeleteQuadric(quadObj); 
                }
                #endregion OjwBall_Outside

                // Cone to the center of the bottom of the center(Kor: 밑면의 가운데를 중심으로 하는 원뿔)
                #region OjwCone_Outside
                public void OjwCone_Outside(bool bFill, Color color, float fAlpha, float fR, float fHeight, int nSolidCnt,
                                    float fOffsetPan, float fOffsetTilt, float fOffsetSwing,    // Rotate(Offset)
                                    float fOffsetX, float fOffsetY, float fOffsetZ              // Translate(Offset)
                                    )
                {
                    //if ((nTexture >= 0) && (nTexture < _CNT_TEXTURE)) Gl.glBindTexture(Gl.GL_TEXTURE_2D, m_puiTexture[nTexture]);									// Select Texture

                    m_fColor[0] = ((float)(color.R) / 255.0f);  // R
                    m_fColor[1] = ((float)(color.G) / 255.0f);  // G
                    m_fColor[2] = ((float)(color.B) / 255.0f);  // B
                    m_fColor[3] = fAlpha;
                    Gl.glColor3fv(m_fColor); // Color with an array of floats

                    //fR *= fScale;
                    //fHeight *= fScale;

                    Gl.glPushMatrix();


                    int uiTypeTop = (bFill == true) ? Gl.GL_FILL : Gl.GL_LINE;
                    //    glPolygonMode(GL_BACK, GL_LINE);
                    Gl.glPolygonMode(Gl.GL_BACK, uiTypeTop);
                    Gl.glPolygonMode(Gl.GL_FRONT, uiTypeTop);
                    
                    OjwTranslate(fOffsetX, fOffsetY, fOffsetZ);
                    OjwRotation(fOffsetPan, fOffsetTilt, fOffsetSwing);

                    float angle;
                    float x, y;

                    int uiType = Gl.GL_TRIANGLE_FAN;// (bFill == true) ? Gl.GL_TRIANGLE_FAN : Gl.GL_LINE_LOOP;
                    Gl.glBegin(uiType);
                    // Center of fan is at the origin
                    Gl.glVertex3f(0.0f, 0.0f, fHeight);
                    for (angle = 0.0f; angle < (2.0f * (float)Math.PI); angle += ((float)Math.PI / ((float)nSolidCnt / 2.0f)))
                    {
                        // Calculate x and y position of the next vertex
                        x = fR * (float)Math.Sin(-angle);
                        y = fR * (float)Math.Cos(-angle);
                        // Specify the next vertex for the triangle fan
                        Gl.glVertex2f(x, y);
                    }
                    angle = 2.0f * (float)Math.PI;
                    x = fR * (float)Math.Sin(angle);
                    y = fR * (float)Math.Cos(angle);
                    Gl.glVertex2f(x, y);
                    // Done drawing the fan that covers the bottom
                    Gl.glEnd();



                    // Begin a new triangle fan to cover the bottom
                    Gl.glBegin(uiType);
                    // Center of fan is at the origin
                    Gl.glVertex3f(0.0f, 0.0f, 0.0f);
                    for (angle = 0.0f; angle < (2.0f * (float)Math.PI); angle += ((float)Math.PI / ((float)nSolidCnt / 2.0f)))
                    {
                        // Calculate x and y position of the next vertex
                        x = fR * (float)Math.Sin(angle);
                        y = fR * (float)Math.Cos(angle);
                        // Specify the next vertex for the triangle fan
                        Gl.glVertex3f(x, y, 0.0f);
                    }
                    angle = 2.0f * (float)Math.PI;
                    x = fR * (float)Math.Sin(angle);
                    y = fR * (float)Math.Cos(angle);
                    Gl.glVertex2f(x, y);
                    Gl.glEnd();

                    Gl.glPopMatrix();
                }
                #endregion OjwCone_Outside

                // Axis to set up a collection of functions for display(Kor: 디스플레이용 축 설정 관련 함수 모음)
                #region Axis-All
                public void Axis(bool bFill, Color cX, float fAlphaX, Color cY, float fAlphaY, Color cZ, float fAlphaZ, float fThick, float fLength)
                {
                    Axis_X(bFill, cX, fAlphaX, fThick, fLength, 0, 0, 0, 0, 0, 0);
                    Axis_Y(bFill, cY, fAlphaY, fThick, fLength, 0, 0, 0, 0, 0, 0);
                    Axis_Z(bFill, cZ, fAlphaZ, fThick, fLength, 0, 0, 0, 0, 0, 0);
                }

                public void Axis(bool bFill, Color cX, float fAlphaX, Color cY, float fAlphaY, Color cZ, float fAlphaZ, float fThick, float fLength,
                                    float fOffsetPan, float fOffsetTilt, float fOffsetSwing,    // rotate(offset)
                                    float fOffsetX, float fOffsetY, float fOffsetZ              // translate(offset)
                                    )
                {
                    Gl.glPushMatrix();
                    OjwTranslate(fOffsetX, fOffsetY, fOffsetZ);
                    OjwRotation(fOffsetPan, fOffsetTilt, fOffsetSwing);
                    Axis_X(bFill, cX, fAlphaX, fThick, fLength, 0, 0, 0, 0, 0, 0);
                    Axis_Y(bFill, cY, fAlphaY, fThick, fLength, 0, 0, 0, 0, 0, 0);
                    Axis_Z(bFill, cZ, fAlphaZ, fThick, fLength, 0, 0, 0, 0, 0, 0);
                    Gl.glPopMatrix();
                }

                public void Axis_X(bool bFill, Color color, float fAlpha, float fThick, float fLength)
                {
                    Axis_X(bFill, color, fAlpha, fThick, fLength, 0, 0, 0, 0, 0, 0);
                }

                public void Axis_Y(bool bFill, Color color, float fAlpha, float fThick, float fLength)
                {
                    Axis_Y(bFill, color, fAlpha, fThick, fLength, 0, 0, 0, 0, 0, 0);
                }

                public void Axis_Z(bool bFill, Color color, float fAlpha, float fThick, float fLength)
                {
                    Axis_Z(bFill, color, fAlpha, fThick, fLength, 0, 0, 0, 0, 0, 0);
                }

                public void Axis_X(bool bFill, Color color, float fAlpha, float fThick, float fLength,
                                    float fOffsetPan, float fOffsetTilt, float fOffsetSwing,    // rotate(offset)
                                    float fOffsetX, float fOffsetY, float fOffsetZ              // translate(offset)
                                    )
                {

                    Gl.glPushMatrix();
                    float fDir = ((fLength < 0) ? -1.0f : 1.0f);
                    if (fLength < 0) fLength = -fLength;
                    float fLength2 = fThick * 1.5f;
                    
                    OjwTranslate(fOffsetX, fOffsetY, fOffsetZ);
                    OjwRotation(fOffsetPan, fOffsetTilt, fOffsetSwing);

                    OjwBall(bFill, color, fAlpha, fThick / 2.0f, 30);
                    OjwCircle_Outside(bFill, color, fAlpha, fThick / 2.0f, fLength, 30, 90.0f * fDir, 0, 0, 0, 0, 0);
                    OjwCone_Outside(bFill, color, fAlpha, fThick, fLength2, 30, 90.0f * fDir, 0, 0, fLength * fDir, 0, 0);
                    
                    Gl.glPopMatrix();
                }

                public void Axis_Y(bool bFill, Color color, float fAlpha, float fThick, float fLength,
                                    float fOffsetPan, float fOffsetTilt, float fOffsetSwing,    // rotate(offset)
                                    float fOffsetX, float fOffsetY, float fOffsetZ              // translate(offset)
                                    )
                {
                    Gl.glPushMatrix();
                    float fDir = ((fLength < 0) ? -1.0f : 1.0f);
                    if (fLength < 0) fLength = -fLength;
                    float fLength2 = fThick * 1.5f;

                    OjwTranslate(fOffsetX, fOffsetY, fOffsetZ);
                    OjwRotation(fOffsetPan, fOffsetTilt, fOffsetSwing);

                    OjwRotation(0, 0, 90);
                    OjwBall(bFill, color, fAlpha, fThick / 2.0f, 30);
                    OjwCircle_Outside(bFill, color, fAlpha, fThick / 2.0f, fLength, 30, 90.0f * fDir, 0, 0, 0, 0, 0);
                    OjwCone_Outside(bFill, color, fAlpha, fThick, fLength2, 30, 90.0f * fDir, 0, 0, fLength * fDir, 0, 0);
                    
                    //OjwCircle_Outside(bFill, color, fAlpha, fThick / 2.0f, fLength, 30, fOffsetPan, fOffsetTilt - 90.0f * fDir, fOffsetSwing, fOffsetX, fOffsetY, fOffsetZ);
                    //OjwCone_Outside(bFill, color, fAlpha, fThick, fLength2, 30, fOffsetPan, fOffsetTilt - 90.0f * fDir, fOffsetSwing, fOffsetX, fOffsetY + fLength * fDir, fOffsetZ);
                    Gl.glPopMatrix();
                }

                public void Axis_Z(bool bFill, Color color, float fAlpha, float fThick, float fLength,
                                    float fOffsetPan, float fOffsetTilt, float fOffsetSwing,    // rotate(offset)
                                    float fOffsetX, float fOffsetY, float fOffsetZ              // translate(offset)
                                    )
                {
#if false
                    Gl.glPushMatrix();
                    //float fDir = ((fLength < 0) ? -1.0f : 1.0f);
                    //float fAngle = ((fDir < 0) ? 180.0f : 0.0f);
                    if (fLength < 0)
                    {
                        fLength = -fLength;
                        OjwRotation(180, 0, 0);
                    }
                    //float fDir = ((fLength < 0) ? 180.0f : 1.0f);
                    //if (fLength < 0) fLength = -fLength;
                    float fLength2 = fThick * 1.5f;

                    OjwTranslate(fOffsetX, fOffsetY, fOffsetZ);
                    OjwRotation(fOffsetPan, fOffsetTilt, fOffsetSwing);

                    OjwBall(bFill, color, fAlpha, fThick / 2.0f, 30);
                    OjwCircle_Outside(bFill, color, fAlpha, fThick / 2.0f, fLength, 30, fOffsetPan, fOffsetTilt, fOffsetSwing, fOffsetX, fOffsetY, fOffsetZ);
                    OjwCone_Outside(bFill, color, fAlpha, fThick, fLength2, 30, fOffsetPan, fOffsetTilt, fOffsetSwing, fOffsetX, fOffsetY, fOffsetZ + fLength);
                    Gl.glPopMatrix();
#else
                    Gl.glPushMatrix();
                    float fDir = ((fLength < 0) ? -1.0f : 1.0f);
                    if (fLength < 0) fLength = -fLength;
                    float fLength2 = fThick * 1.5f;

                    OjwTranslate(fOffsetX, fOffsetY, fOffsetZ);
                    OjwRotation(fOffsetPan, fOffsetTilt, fOffsetSwing);

                    OjwRotation(-90, 0, 0);

                    OjwBall(bFill, color, fAlpha, fThick / 2.0f, 30);
                    OjwCircle_Outside(bFill, color, fAlpha, fThick / 2.0f, fLength, 30, 90.0f * fDir, 0, 0, 0, 0, 0);
                    OjwCone_Outside(bFill, color, fAlpha, fThick, fLength2, 30, 90.0f * fDir, 0, 0, fLength * fDir, 0, 0);

                    Gl.glPopMatrix();
#endif
                }
                #endregion Axis-All
                            
                #region OjwAse_Outside
                #region File(by Name)
                public int OjwAse_GetIndex(String strIndex)
                {
#if true
                    int nIndex = -1;
#if _CHANGE_DEFAULT_FROM_ASE_TO_DAT
                    // Default -> dat
                    if (strIndex.IndexOf('.') < 0) strIndex += ".dat";
#else
                    // Default -> ase
                    if (strIndex.IndexOf('.') < 0) strIndex += ".ase";
#endif
                    for (int i = 0; i < m_lstModel.Count; i++)
                    {
                        if (m_lstModel[i] == strIndex) { nIndex = i; break; }
                    }
                    return nIndex;
#else
                    int nIndex = -1;
                    for (int i = 0; i < m_lstModel.Count; i++)
                    {
                        if (m_lstModel[i] == strIndex) { nIndex = i; break; }
                    }
                    return nIndex;
#endif
                }
                private List<string> m_lststrModelingFiles = new List<string>();
                private string m_strNoLoaded_ModelingFile = "";
                // 3D 모델링 파일의 부품이 로드 되었는지 확인...(stl, ase, dat)
                public bool IsNoLoadedModelingFile() { return (m_strNoLoaded_ModelingFile.Length > 0) ? true : false; }
                public string GetNoLoadedModelingFile() { return m_strNoLoaded_ModelingFile; }
                public void OjwAse_Outside(bool bFill, Color color, float fAlpha,
                                    float fW, float fH, float fD,            
                                    float fOffsetPan, float fOffsetTilt, float fOffsetSwing,   // rotate(offset)
                                    float fOffsetX, float fOffsetY, float fOffsetZ, // translate(offset)
                                    String strIndex_Ase  // File Index name(Kor: 파일 인덱싱 이름)
                                )
                {
                    int nOld = strIndex_Ase.LastIndexOf('*');
                    if (nOld == strIndex_Ase.Length - 1)
                    {
                        strIndex_Ase = strIndex_Ase.Substring(0, strIndex_Ase.Length - 1);
                    }        

                    if (strIndex_Ase.Length == 0) return;

                    int nIndex_Ase = OjwAse_GetIndex(strIndex_Ase);
                    if ((nIndex_Ase >= m_nCnt_Obj_Ase) || (nIndex_Ase < 0))
                    {
                        if (m_nSeq_Compile_Back != m_nSeq_Compile)
                        {
                            //m_nSeq_Compile_Back = m_nSeq_Compile;
                            m_strNoLoaded_ModelingFile += strIndex_Ase + ",";
                        }
                        return;
                    }

                    bool bStl = false;
                    if (
#if _CHANGE_DEFAULT_FROM_ASE_TO_DAT
                        (strIndex_Ase.ToUpper().IndexOf('.') < 0) ||
#endif
                        (strIndex_Ase.ToUpper().IndexOf(".DAT") >= 0) ||
                        (strIndex_Ase.ToUpper().IndexOf(".SSTL") >= 0) ||
                        (strIndex_Ase.ToUpper().IndexOf(".STL") >= 0)
                        ) bStl = true;
                    bool bDat = false;
                    if (
                        //(strIndex_Ase.ToUpper().IndexOf(".SSTL") >= 0) ||
#if _CHANGE_DEFAULT_FROM_ASE_TO_DAT
                        (strIndex_Ase.ToUpper().IndexOf('.') < 0) ||
#endif
                        (strIndex_Ase.ToUpper().IndexOf(".DAT") >= 0) 
                        ) bDat = true;

                    Color cColor = color;
                    m_fColor[0] = ((float)cColor.R / 255.0f);  // R
                    m_fColor[1] = ((float)cColor.G / 255.0f);  // G
                    m_fColor[2] = ((float)cColor.B / 255.0f);  // B
                    m_fColor[3] = fAlpha;// m_fAlpha;

                    Gl.glPushMatrix();
#if _STL_CW
                    Gl.glFrontFace((bStl == true) ? Gl.GL_CW : Gl.GL_CCW);
#else



                    OjwTranslate(fOffsetX, fOffsetY, fOffsetZ);
                    OjwRotation(0, 0, fOffsetSwing);
                    OjwRotation(0, fOffsetTilt, 0);
                    OjwRotation(fOffsetPan, 0, 0);

                    Gl.glPushMatrix(); // setlight2()
                    SetLight();
                    SetLight2();
                    Gl.glFrontFace(((bDat == true) ? Gl.GL_CW : Gl.GL_CCW)); // 20150528 수정 - 이게 맞다.





                    //Gl.glFrontFace(Gl.GL_CCW); // 20150528 수정 - 이게 맞다.
                    Gl.glFrontFace(((bDat == true) ? Gl.GL_CW : Gl.GL_CCW)); // 20150528 수정 - 이게 맞다.
                    //Gl.glFrontFace((bStl == true) ? Gl.GL_CCW : Gl.GL_CCW);
#endif
#if true // 1
#if _STL_CW
                    Gl.glPolygonMode(Gl.GL_BACK,
                            (int)(
                                (bFill == true) ?
                                    ((m_bDetail == true) ? Gl.GL_LINE : Gl.GL_FILL) : ((m_bDetail == true) ? Gl.GL_POINT : Gl.GL_LINE)
                            )
                        );
                    Gl.glPolygonMode(Gl.GL_FRONT, (int)((bFill == true) ? Gl.GL_FILL : Gl.GL_LINE));
#else       // original    
                    if (IsPerspectiveMode() == true)
                    {
                        Gl.glPolygonMode(Gl.GL_FRONT,
                                (int)(
                                    (bFill == true) ?
                                        Gl.GL_FILL : Gl.GL_LINE//((m_bDetail == true) ? Gl.GL_POINT : Gl.GL_FILL) : ((m_bDetail == true) ? Gl.GL_POINT : Gl.GL_LINE)
                                )
                            );
                        //Gl.glPolygonMode(Gl.GL_FRONT, (int)((bFill == true) ? Gl.GL_POINT : Gl.GL_POINT));

#if _VIEW_THE_OUTLINE
                        //Gl.glPolygonMode(Gl.GL_BACK, (int)((bFill == true) ? ((m_bDetail == true) ? Gl.GL_POINT : Gl.GL_POINT) : ((m_bDetail == true) ? Gl.GL_LINE : Gl.GL_POINT)));
                        Gl.glPolygonMode(Gl.GL_BACK, (int)((bFill == true) ? ((m_bDetail == true) ? Gl.GL_LINE : Gl.GL_LINE) : ((m_bDetail == true) ? Gl.GL_LINE : Gl.GL_POINT)));
#endif
                        //Gl.glPolygonMode(Gl.GL_FRONT,
                        //        (int)(
                        //            (bFill == true) ?
                        //                ((m_bDetail == true) ? Gl.GL_LINE : Gl.GL_LINE) : ((m_bDetail == true) ? Gl.GL_POINT : Gl.GL_LINE)
                        //        )
                        //    );
                    }
                    else
                    {
                        Gl.glPolygonMode(Gl.GL_FRONT,
                                (int)(
                                    (bFill == true) ?
                                        Gl.GL_FILL : Gl.GL_LINE//((m_bDetail == true) ? Gl.GL_POINT : Gl.GL_FILL) : ((m_bDetail == true) ? Gl.GL_POINT : Gl.GL_LINE)
                                )
                            );
                        //Gl.glPolygonMode(Gl.GL_FRONT, (int)((bFill == true) ? Gl.GL_POINT : Gl.GL_POINT));
#if _VIEW_THE_OUTLINE
                        Gl.glPolygonMode(Gl.GL_BACK, (int)((bFill == true) ? ((m_bDetail == true) ? Gl.GL_LINE : Gl.GL_LINE) : ((m_bDetail == true) ? Gl.GL_LINE : Gl.GL_POINT)));
                        //Gl.glPolygonMode(Gl.GL_BACK, (int)((bFill == true) ? ((m_bDetail == true) ? Gl.GL_LINE : Gl.GL_POINT) : ((m_bDetail == true) ? Gl.GL_LINE : Gl.GL_POINT)));
#endif
                        //Gl.glPolygonMode(Gl.GL_FRONT,
                        //        (int)(
                        //            (bFill == true) ?
                        //                ((m_bDetail == true) ? Gl.GL_LINE : Gl.GL_LINE) : ((m_bDetail == true) ? Gl.GL_POINT : Gl.GL_LINE)
                        //        )
                        //    );
#if false
                        Gl.glPolygonMode(Gl.GL_FRONT, (int)((bFill == true) ? Gl.GL_FILL : Gl.GL_LINE));
                        //Gl.glPolygonMode(Gl.GL_FRONT, (int)((bFill == true) ? Gl.GL_POINT : Gl.GL_POINT));
                        Gl.glPolygonMode(Gl.GL_BACK, (int)((bFill == true) ? Gl.GL_LINE : Gl.GL_LINE));
#endif

                    }

#endif
#else
                    //Gl.glEdgeFlag(Gl.GL_TRUE);
                    Gl.glPolygonMode(Gl.GL_FRONT, Gl.GL_FILL);
                    Gl.glPolygonMode(Gl.GL_BACK, Gl.GL_FILL);
                    //Gl.glPolygonMode(Gl.GL_FRONT, (int)((bFill == true) ? Gl.GL_FILL : Gl.GL_LINE));
                    //Gl.glPolygonMode(Gl.GL_BACK, (int)((bFill == true) ? Gl.GL_FILL : Gl.GL_LINE));
                    //Gl.glPolygonMode(Gl.GL_FRONT, (int)((bFill == true) ? Gl.GL_LINES : Gl.GL_POINT));
                    //Gl.glPolygonMode(Gl.GL_BACK, (int)((bFill == true) ? Gl.GL_FILL : Gl.GL_LINE));
                    //Gl.glPolygonMode(Gl.GL_BACK, (int)((bFill == true) ? Gl.GL_LINE : Gl.GL_LINE));
#endif
                    int uiType = (bDat == true) ? Gl.GL_TRIANGLES : Gl.GL_TRIANGLES;// Gl.GL_POLYGON;// Gl.GL_TRIANGLES;//(int)((bFill == true) ? Gl.GL_TRIANGLES : Gl.GL_LINE_STRIP);//Gl.GL_TRIANGLES;// 

                    Gl.glColor4fv(m_fColor);

                    
                    float fX1 = -fW / 2.0f;
                    float fX2 = fW / 2.0f;
                    float fY2 = -fH;
                    float fZ1 = -fD / 2.0f;
                    float fZ2 = fD / 2.0f;

                    if (m_lstOjwAse[nIndex_Ase].Data_GetCnt() <= 0) return;
#if false
                    //SVector3D_t[] aSPos = new SVector3D_t[m_lstOjwAse[nIndex_Ase].Face_GetCnt() * 3];
                    //int nPos = 0;
                    //int nPos2;
                    //foreach (SPoint3D_t SPnt in pSData)
                    //{
                    //    nPos2 = nPos * 3;
                    //    aSPos[nPos2] = m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.x);
                    //    aSPos[nPos2 + 1] = m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.y);
                    //    aSPos[nPos2 + 2] = m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.z);
                    //    nPos++;
                    //}
#endif
                    //SetLight();
                    //SetLight2();
                    Gl.glBegin(uiType);
                    //Gl.glEdgeFlag(Gl.GL_FALSE);  
                    // Draw        
#if false
                    foreach (SVector3D_t SVector3D in aSPos)
                    {
                        Gl.glVertex3f(SVector3D.x, SVector3D.y, SVector3D.z);
                    }
                    aSPos = null;
#else
#if true
                    //CTimer CTmr = new CTimer();
                    //CTmr.Set();
#if false
                    SPoint3D_t[] pSData = m_lstOjwAse[nIndex_Ase].Face_Get();
                    foreach (SPoint3D_t SPnt in pSData)
                    {
                        SVector3D_t SVtx_x = m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.x);
                        SVector3D_t SVtx_y = m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.y);
                        SVector3D_t SVtx_z = m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.z);

                        Gl.glVertex3f(SVtx_x.x, SVtx_x.y, SVtx_x.z);
                        Gl.glVertex3f(SVtx_y.x, SVtx_y.y, SVtx_y.z);
                        Gl.glVertex3f(SVtx_z.x, SVtx_z.y, SVtx_z.z);

                        //Gl.glVertex3f(m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.x).x, m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.x).y, m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.x).z);
                        //Gl.glVertex3f(m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.y).x, m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.y).y, m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.y).z);
                        //Gl.glVertex3f(m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.z).x, m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.z).y, m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.z).z);
                    }
#else
                    if (IsPerspectiveMode() == true)
                    {
                        //Gl.glEdgeFlag(Gl.GL_TRUE); -> 상관없음
                        //Gl.glFrontFace(Gl.GL_CW); -> 관계없음
                    }
                    if (bStl == true)
                    {
#if false

                        //Gl.glEnableClientState(Gl.GL_VERTEX_ARRAY);
                        //Gl.glVertexPointer(3, Gl.GL_FLOAT, 0, (IntPtr)m_lstOjwAse[nIndex_Ase].Data_Get());
                        //Gl.glDrawArrays(uiType, 0, m_lstOjwAse[nIndex_Ase].Data_GetCnt());

                        //for (int i = 0; i < m_lstOjwAse[nIndex_Ase].Data_GetCnt(); i++)
                        //    Gl.glVertex3f(m_lstOjwAse[nIndex_Ase].Data_Get(i).x, m_lstOjwAse[nIndex_Ase].Data_Get(i).y, m_lstOjwAse[nIndex_Ase].Data_Get(i).z);
#else
                        //SVector3D_t[] pSVec = m_lstOjwAse[nIndex_Ase].Data_Get();
                        //foreach (SVector3D_t SVec in pSVec) Gl.glVertex3f(SVec.x, SVec.y, SVec.z);

                        Gl.glPushMatrix();
                        bool bStart = true;
                        foreach (SVector4D_t SVec in m_lstOjwAse[nIndex_Ase].Data_Get())
                        {
                            if (SVec.w != 0)
                            {
                                if (bStart == false)
                                {
                                    Gl.glPopMatrix();
                                    Gl.glPushMatrix();
                                }
                                else bStart = false;
                            }
                            Gl.glVertex3f(SVec.x, SVec.y, SVec.z);                            
                        }
                        Gl.glPopMatrix();
#endif
                        
                        //for (int i = 0; i < pSVec.Length; i += 3)
                        //{
                        //    //Gl.glBegin(uiType);
                        //    Gl.glVertex3f(pSVec[i].x, pSVec[i].y, pSVec[i].z);
                        //    Gl.glVertex3f(pSVec[i + 1].x, pSVec[i + 1].y, pSVec[i + 1].z);
                        //    Gl.glVertex3f(pSVec[i + 2].x, pSVec[i + 2].y, pSVec[i + 2].z);
                        //    //Gl.glEnd();// end drawing
                        //}
                        //Gl.glFrontFace(Gl.GL_CCW);
                    }
                    else
                    {
#if true
                        Gl.glPushMatrix();
                        for (int i = 0; i < m_lstOjwAse[nIndex_Ase].Face_GetCnt(); i++)
                        {
                            if (m_lstOjwAse[nIndex_Ase].Data_Get(i).w != 0)
                            {
                                if (i != 0)
                                {
                                    Gl.glPopMatrix();
                                    Gl.glPushMatrix();
                                }
                            }
                            Gl.glVertex3f(m_lstOjwAse[nIndex_Ase].Data_Get(m_lstOjwAse[nIndex_Ase].Face_Get(i).x).x, m_lstOjwAse[nIndex_Ase].Data_Get(m_lstOjwAse[nIndex_Ase].Face_Get(i).x).y, m_lstOjwAse[nIndex_Ase].Data_Get(m_lstOjwAse[nIndex_Ase].Face_Get(i).x).z);
                            Gl.glVertex3f(m_lstOjwAse[nIndex_Ase].Data_Get(m_lstOjwAse[nIndex_Ase].Face_Get(i).y).x, m_lstOjwAse[nIndex_Ase].Data_Get(m_lstOjwAse[nIndex_Ase].Face_Get(i).y).y, m_lstOjwAse[nIndex_Ase].Data_Get(m_lstOjwAse[nIndex_Ase].Face_Get(i).y).z);
                            Gl.glVertex3f(m_lstOjwAse[nIndex_Ase].Data_Get(m_lstOjwAse[nIndex_Ase].Face_Get(i).z).x, m_lstOjwAse[nIndex_Ase].Data_Get(m_lstOjwAse[nIndex_Ase].Face_Get(i).z).y, m_lstOjwAse[nIndex_Ase].Data_Get(m_lstOjwAse[nIndex_Ase].Face_Get(i).z).z);
                        }
                        Gl.glPopMatrix();
#else
                        SPoint3D_t[] pSData = m_lstOjwAse[nIndex_Ase].Face_Get();
                        foreach (SPoint3D_t SPnt in pSData)
                        {
#if false
                            SVector3D_t SVtx_x = m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.x);
                            SVector3D_t SVtx_y = m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.y);
                            SVector3D_t SVtx_z = m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.z);
                            //Gl.glBegin(uiType);
                            Gl.glVertex3f(SVtx_x.x, SVtx_x.y, SVtx_x.z);
                            Gl.glVertex3f(SVtx_y.x, SVtx_y.y, SVtx_y.z);
                            Gl.glVertex3f(SVtx_z.x, SVtx_z.y, SVtx_z.z);
                            //Gl.glEnd();// end drawing
#else                            
                            Gl.glVertex3f(m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.x).x, m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.x).y, m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.x).z);
                            Gl.glVertex3f(m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.y).x, m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.y).y, m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.y).z);
                            Gl.glVertex3f(m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.z).x, m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.z).y, m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.z).z);                          
#endif
                        }
#endif
                    }
                    //Gl.glEdgeFlag(Gl.GL_TRUE);
#endif
                    //CMessage.Write("[" + CConvert.IntToStr(nIndex_Ase) + "]" + CConvert.IntToStr(CTmr.GetTick()));
#else
                    //CTimer CTmr = new CTimer();
                    //CTmr.Set();
                    int nCnt = m_lstOjwAse[nIndex_Ase].Face_GetCnt();
                    for (int i = 0; i < nCnt; i++)
                    {
#if true
                        SPoint3D_t SPnt = m_lstOjwAse[nIndex_Ase].Face_Get(i);
                        SVector3D_t SVtx_x = m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.x);
                        SVector3D_t SVtx_y = m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.y);
                        SVector3D_t SVtx_z = m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.z);
                        
                        Gl.glVertex3f(SVtx_x.x, SVtx_x.y, SVtx_x.z);
                        Gl.glVertex3f(SVtx_y.x, SVtx_y.y, SVtx_y.z);
                        Gl.glVertex3f(SVtx_z.x, SVtx_z.y, SVtx_z.z);
#else
                        Gl.glVertex3f(m_lstOjwAse[nIndex_Ase].Data_Get(m_lstOjwAse[nIndex_Ase].Face_Get(i).x).x, m_lstOjwAse[nIndex_Ase].Data_Get(m_lstOjwAse[nIndex_Ase].Face_Get(i).x).y, m_lstOjwAse[nIndex_Ase].Data_Get(m_lstOjwAse[nIndex_Ase].Face_Get(i).x).z);
                        Gl.glVertex3f(m_lstOjwAse[nIndex_Ase].Data_Get(m_lstOjwAse[nIndex_Ase].Face_Get(i).y).x, m_lstOjwAse[nIndex_Ase].Data_Get(m_lstOjwAse[nIndex_Ase].Face_Get(i).y).y, m_lstOjwAse[nIndex_Ase].Data_Get(m_lstOjwAse[nIndex_Ase].Face_Get(i).y).z);
                        Gl.glVertex3f(m_lstOjwAse[nIndex_Ase].Data_Get(m_lstOjwAse[nIndex_Ase].Face_Get(i).z).x, m_lstOjwAse[nIndex_Ase].Data_Get(m_lstOjwAse[nIndex_Ase].Face_Get(i).z).y, m_lstOjwAse[nIndex_Ase].Data_Get(m_lstOjwAse[nIndex_Ase].Face_Get(i).z).z);
#endif
                    }
                    //CMessage.Write("[" + CConvert.IntToStr(nIndex_Ase) + "]" + CConvert.IntToStr(CTmr.GetTick()));
#endif
#endif
                    //Gl.glEdgeFlag(Gl.GL_TRUE);  
                    Gl.glEnd();// end drawing the cube

                    //if (bStl == true) Gl.glFrontFace(Gl.GL_CW);
                    Gl.glFrontFace(m_nCWMode);//
                    Gl.glPopMatrix(); // setlight2()
                    Gl.glPopMatrix();
                }
                #endregion File(by Name)
                #endregion OjwAse_Outside
                // Copy Data Modeling(Kor: 모델링데이타 복사)
                public void OjwFileOpen_3D_OBJ(int nCnt_Obj, int nCnt_Ase, COjwAse[] pObjAse)
                {
                    m_nCnt_Obj = nCnt_Obj;
                    m_nCnt_Ase = nCnt_Ase;
                    m_nCnt_Obj_Ase = nCnt_Obj + nCnt_Ase;

                    for (int i = 0; i < pObjAse.Length; i++) m_lstOjwAse.Add(pObjAse[i]);
                }
                // ASE 3D Modeling data #0
                #region Ojw3D_ASE_0
                public int m_nCnt_Obj_Ase = 0; // The number of loading ASE file(Kor: ASE 파일의 로딩 갯수)
                public int m_nCnt_Obj = 0;
                public int m_nCnt_Ase = 0;
                public void OjwFileOpen_3D_OBJ(String strFileName)
                {
                    //SetCursor(IDC_APPSTARTING);
                    //this.Cursor = System.Windows.Forms.Cursors.WaitCursor;
                    try
                    {
                        const int nHide = 10;
                        FileInfo f = new FileInfo(strFileName);
                        StreamReader fs = f.OpenText();
                        float[] afPos = new float[3] { 0, 0, 0 };
                        float[] afPos2 = new float[3];
                        bool bStartPos = true;
                        int nTemp = 0;
                        while (true)
                        {
                            String str = fs.ReadLine();
                            if (str == null) break;
                            if (str.IndexOf("mtllib") == 0)
                            {
                                // New model
                                COjwAse CAse = new COjwAse();
                                CAse.Data_Clear();
                                CAse.Data_Type_Set(0);
                                m_lstOjwAse.Add(CAse);
                                //m_lstModel.Add(Ojw.CFile.GetTitle(strFileName));
                                m_lstModel.Add(Ojw.CFile.GetName(strFileName));
                                m_nCnt_Obj_Ase++;
                                m_nCnt_Obj++;
                            }

                            //if (str.IndexOf("vt") == 0) break;

                            if (str.IndexOf("v ") == 0)
                            {

                                if (nTemp == 0)
                                {
                                    str = str.Substring(2, str.Length - 2);
                                    str = str.Trim();
                                    int nPos1 = str.IndexOf(' ');
                                    afPos2[0] = CConvert.StrToFloat(str.Substring(0, nPos1));
                                    str = str.Substring((nPos1 + 1), str.Length - (nPos1 + 1));
                                    nPos1 = str.IndexOf(' ');
                                    afPos2[2] = CConvert.StrToFloat(str.Substring(0, nPos1));
                                    str = str.Substring((nPos1 + 1), str.Length - (nPos1 + 1));
                                    afPos2[1] = CConvert.StrToFloat(str);

                                    if (bStartPos == true)
                                    {
                                        bStartPos = false;
                                        afPos[0] = 0;// afPos2[0];
                                        afPos[1] = 0;//afPos2[1];
                                        afPos[2] = 0;//afPos2[2];
                                    }

                                    m_lstOjwAse[m_nCnt_Obj_Ase - 1].Data_Add(afPos2[0] - afPos[0], afPos2[1] - afPos[1], afPos2[2] - afPos[2]);
                                }

                                nTemp++;
                                if (nTemp >= nHide) nTemp = 0;
                            }

                            if (str.IndexOf("f ") == 0)
                            {

                                if (nTemp == 0)
                                {
                                    int[] anPos = new int[3];
                                    str = str.Substring(2, str.Length - 2);
                                    str = str.Trim();
                                    int nPos0 = 0;// str.IndexOf(' ');
                                    int nPos1 = str.IndexOf('/') - nPos0;
                                    anPos[0] = CConvert.StrToInt(str.Substring(nPos0, nPos1));
                                    str = str.Substring((nPos1 + 1), str.Length - (nPos1 + 1));
                                    nPos1 = str.IndexOf('/');
                                    anPos[2] = CConvert.StrToInt(str.Substring(nPos0, nPos1));
                                    str = str.Substring((nPos1 + 1), str.Length - (nPos1 + 1));
                                    nPos1 = str.IndexOf(' ');
                                    anPos[1] = CConvert.StrToInt(str.Substring(nPos0, nPos1)); //CConvert.StrToFloat(str);
                                    
                                    if (bStartPos == true)
                                    {
                                        bStartPos = false;
                                        Array.Clear(afPos, 0, afPos.Length);
                                    }
                                    m_lstOjwAse[m_nCnt_Obj_Ase - 1].Face_Add(anPos[0], anPos[1], anPos[2]);
                                }

                                nTemp++;
                                if (nTemp >= nHide) nTemp = 0;
                            }
                        }
                        //SVector3D_t SVec = m_lstOjwAse[m_nCnt_Obj_Ase - 1].Data_Get(0);
                        //m_lstOjwAse[m_nCnt_Obj_Ase - 1].Data_Add(SVec.x, SVec.y, SVec.z);
                        fs.Close();
                    }
                    catch //(Exception e)
                    {
                        //MessageBox.Show(e.ToString());
                        m_nCnt_Obj_Ase = 0;
                        m_nCnt_Obj = 0;
                        m_nCnt_Ase = 0;
                    }
                    //SetCursor(IDC_ARROW);
                    //this.Cursor = System.Windows.Forms.Cursors.Default;
                }
                #region STL & Dat
                public bool OjwFileOpen_3D_Dat(String strFileName)
                {
                    int nTmp = 0;
                    String strName = "";
                    int nTmpAll = 0;
                    try
                    {
                        string header;
                        //FileInfo f = new FileInfo(strFileName);
                        //FileStream fs_Ascii = f.OpenRead();
                        //long lHeaderSize = fs_Ascii.Length;
                        //byte[] byteData = new byte[lHeaderSize];
                        
                        #region Moved by opening the file into memory(Kor: 파일을 열어서 메모리로 옮김)
                        //fs_Ascii.Read(byteData, 0, (int)lHeaderSize);
                        //fs_Ascii.Close();
                        #endregion Moved by opening the file into memory(Kor: 파일을 열어서 메모리로 옮김)
                        
                        using (var fs = new BinaryReader(File.OpenRead(strFileName), Encoding.ASCII))
                        {
                            header = Ojw.CFile.GetName(strFileName);//Encoding.ASCII.GetString(fs.ReadBytes(80));
                            int nTrash = 16 // ID
                                       + 4 // Version
                                       + 4; // Object Count
                                ///////// object // Object 1개만 읽어보자.
                            int nTrash2 = 32 // Name
                                       + 260 // FileName
                                       + 4 // Type
                                       + 4; // vertex Format

                            byte[] byteData = fs.ReadBytes(nTrash + nTrash2);


                            uint unCount = fs.ReadUInt32();  // primitive 갯수
                            uint unStructSize = fs.ReadUInt32(); // 정점의 크기

                            nTmpAll = (int)unCount;
                            strName = header;

                            COjwAse CAse = new COjwAse();
                            CAse.Data_Clear();
                            CAse.Data_Type_Set(1);
                            m_lstOjwAse.Add(CAse);
                            m_lstModel.Add(Ojw.CFile.GetName(strFileName)); // Add a Model Name
                            m_nCnt_Obj_Ase++;
                            m_nCnt_Ase++;

                            //float fA, fB, fC;
                            byte byTmp0;//, byTmp1;

                            float[] afPos = new float[3];
                            Array.Clear(afPos, 0, afPos.Length);

                            int _x = 0;
                            int _y = 2;
                            int _z = 1;
                            float[] afTmp = new float[3];
                            for (int i = 0; i < nTmpAll; i++)
                            {
                                nTmp++;
                                int nMax = 3;//fs.ReadInt32();//3;
                                //int nTmp2 = fs.ReadInt32();
                                for (int j = 0; j < nMax; j++)
                                {
                                    afTmp[_x] = fs.ReadSingle();
                                    //uint A = fs.ReadUInt32();
                                    afTmp[_y] = fs.ReadSingle();
                                    //uint B = fs.ReadUInt32();
                                    afTmp[_z] = -fs.ReadSingle();
                                    //uint C = fs.ReadUInt32();

                                    //#region Face


                                    //float fA = fs.ReadSingle();
                                    //float fB = fs.ReadSingle();
                                    //float fC = fs.ReadSingle();
                                    //uint A = fs.ReadUInt32();
                                    //uint B = fs.ReadUInt32();
                                    //uint C = fs.ReadUInt32();
                                    //#endregion Face

                                    if (i == 0) // normal
                                    {
                                        afPos[_x] = 0;// afTmp[_x]; //0;// fA; //0;//fA;
                                        afPos[_y] = 0;// afTmp[_y]; //0;// fC; //0;//fB;
                                        afPos[_z] = 0;// afTmp[_z];
                                        //m_lstOjwAse[m_nCnt_Obj_Ase - 1].Data_Add(fA - afPos[0], fB - afPos[1], fC - afPos[2]);
                                        //continue;
                                    }
                                    else
                                    {
                                        //if ((i == 0) && (j == 1))// First data
                                        //{
                                        //    afPos[_x] = afTmp[_x]; //0;// fA; //0;//fA;
                                        //    afPos[_y] = afTmp[_y]; //0;// fC; //0;//fB;
                                        //    afPos[_z] = afTmp[_z]; //0;// fB; //0;//fC;
                                        //}
                                        //else
                                        //{
                                            //m_lstOjwAse[m_nCnt_Obj_Ase - 1].Face_Add(A - (int)afPos[0], B - (int)afPos[1], C - (int)afPos[2]);

                                            //m_lstOjwAse[m_nCnt_Obj_Ase - 1].Data_Add(fA - afPos[0], fB - afPos[1], fC - afPos[2]);
                                            //m_lstOjwAse[m_nCnt_Obj_Ase - 1].Data_Add(afTmp[_x] - afPos[_x], afTmp[_y] - afPos[_y], afTmp[_z] - afPos[_z]);
                                            m_lstOjwAse[m_nCnt_Obj_Ase - 1].Data_Add(afTmp[_x] - afPos[_x], afTmp[_y] - afPos[_y], afTmp[_z] - afPos[_z]);
                                            //m_lstOjwAse[m_nCnt_Obj_Ase - 1].Data_Add(fA - afPos[0], fC - afPos[2], fB - afPos[1]);
                                            //m_lstOjwAse[m_nCnt_Obj_Ase - 1].Face_Add((int)fA - (int)afPos[0], (int)fB - (int)afPos[1], (int)fC - (int)afPos[2]);
                                            //m_lstOjwAse[m_nCnt_Obj_Ase - 1].Face_Add((int)fA - (int)afPos[0], (int)fB - (int)afPos[1], (int)fC - (int)afPos[2]);

                                            //Ojw.CMessage.Write("Test - {0}, {1}, {2}", fA, fB, fC);

                                            // put the actual data.(Kor: 실제의 데이타를 넣자.)
                                            //m_lstOjwAse[m_nCnt_Obj_Ase - 1].Face_Add((int)fA - (int)afPos[_x], (int)fB - (int)afPos[_y], (int)fC - (int)afPos[_z]);
                                        //}
                                    }
                                    // unused
                                    for (int k = 0; k < (unStructSize - 12); k++) byTmp0 = fs.ReadByte();
                                }
                                
                                //for (int k = 0; k < 4; k++) byTmp0 = fs.ReadByte();
                                //nTmp2 = fs.ReadInt32();
                                //nTmp2 = fs.ReadInt32();
                                //byTmp1 = fs.ReadByte();
                            }
                        }
                        return true;
                    }
                    catch(Exception e)
                    {
                        m_nCnt_Obj_Ase = 0;
                        MessageBox.Show(nTmp.ToString() + "/" + nTmpAll.ToString() + " : " + strName + "=>" + e.ToString());
                        return false;
                    }
                }
                public bool OjwFileOpen_3D_STL_Old(String strFileName)
                {
                    return OjwFileOpen_3D_STL(strFileName, true);
                }
                public bool OjwFileOpen_3D_STL(String strFileName)
                {
                    int nOld = strFileName.LastIndexOf('*');
                    if (nOld == strFileName.Length - 1)
                    {
                        strFileName = strFileName.Substring(0, strFileName.Length - 1);
                        return OjwFileOpen_3D_STL(strFileName, true);
                    }                    
                    return OjwFileOpen_3D_STL(strFileName, false);
                }
                public bool OjwFileOpen_3D_STL(String strFileName, bool bSub_InitPoint)
                {
                    int nTmp = 0;
                    String strName = "";
                    int nTmpAll = 0;
                    try
                    {
                        string header;
                        //STLTriangle[] mesh;

                        // stl(solid ascii)
                        FileInfo f = new FileInfo(strFileName);
                        FileStream fs_Ascii = f.OpenRead();
                        long lHeaderSize = fs_Ascii.Length;
                        byte[] byteData = new byte[lHeaderSize];
                        
                        #region Moved by opening the file into memory(Kor: 파일을 열어서 메모리로 옮김)
                        fs_Ascii.Read(byteData, 0, (int)lHeaderSize);//byteData.Length); // for Check 11 bytes in header
                        fs_Ascii.Close();
                        #endregion Moved by opening the file into memory(Kor: 파일을 열어서 메모리로 옮김)
                        if (Encoding.ASCII.GetString(byteData, 0, 80).IndexOf("solid ascii") >= 0)
                        {
                            Ojw.CMessage.Write("solid ascii");
                            float[] afData = new float[3];
                            float[] afPos = new float[3];
                            String[] pstrSplit = Encoding.ASCII.GetString(byteData, 0, (int)lHeaderSize).Split('\n');
                            bool bFirst = true;
                            bool bFirstIndex = true;

                            COjwAse CAse = new COjwAse();
                            CAse.Data_Clear();
                            CAse.Data_Type_Set(1);
                            m_lstOjwAse.Add(CAse);
                            m_lstModel.Add(Ojw.CFile.GetName(strFileName)); // Add a Model Name
                            m_nCnt_Obj_Ase++;
                            m_nCnt_Ase++;

                            foreach (string strLine in pstrSplit)
                            {
                                int nIndex = strLine.IndexOf("vertex");
                                if (nIndex >= 0)
                                {
                                    String[] pstrItems = strLine.Substring(nIndex + 6).Split(' ');
                                    int nPos = 0;
                                    foreach (string strItem in pstrItems)
                                    {
                                        if (strItem.Length > 0)
                                            afData[nPos++] = Ojw.CConvert.StrToFloat(strItem);
                                    }
                                    if (bFirst)
                                    {
                                        bFirst = false;
                                        if (bSub_InitPoint)
                                        {
                                            afPos[0] = afData[0]; //0;//fA;
                                            afPos[1] = afData[1]; //0;//fB;
                                            afPos[2] = afData[2]; //0;//fC;
                                        }
                                        else
                                        {
                                            afPos[0] = 0;
                                            afPos[1] = 0;
                                            afPos[2] = 0;
                                        }
                                        
                                    }
                                    else
                                    {
                                        if (bFirstIndex == true)
                                        {
                                            m_lstOjwAse[m_nCnt_Obj_Ase - 1].Data_Add_First(afData[0] - afPos[0], afData[2] - afPos[2], afData[1] - afPos[1]);
                                        }
                                        else 
                                            m_lstOjwAse[m_nCnt_Obj_Ase - 1].Data_Add(afData[0] - afPos[0], afData[2] - afPos[2], afData[1] - afPos[1]);
                                    }
                                }
                            }
                            pstrSplit = null;
                        }
                        else
                        {
                            using (var fs = new BinaryReader(File.OpenRead(strFileName), Encoding.ASCII))
                            {
                                header = Encoding.ASCII.GetString(fs.ReadBytes(80));
                                var unCount = fs.ReadUInt32();

                                nTmpAll = (int)unCount;
                                strName = header;
                                //mesh = br.BaseStream.ReadUnmanagedStructRange<STLTriangle>((int)triCount);

                                COjwAse CAse = new COjwAse();
                                CAse.Data_Clear();
                                CAse.Data_Type_Set(1);
                                m_lstOjwAse.Add(CAse);
                                m_lstModel.Add(Ojw.CFile.GetName(strFileName)); // Add a Model Name
                                m_nCnt_Obj_Ase++;
                                m_nCnt_Ase++;

                                //float fA, fB, fC;
                                byte byTmp0, byTmp1;

                                float[] afPos = new float[3];
                                Array.Clear(afPos, 0, afPos.Length);

                                int _x = 0;
                                int _y = 1;
                                int _z = 2;
                                float[] afTmp = new float[3];
                                for (int i = 0; i < nTmpAll; i++)
                                {
                                    nTmp++;
                                    int nMax = 4;
                                    for (int j = 0; j < nMax; j++)
                                    {
                                        afTmp[_x] = fs.ReadSingle();
                                        afTmp[_y] = fs.ReadSingle();
                                        afTmp[_z] = fs.ReadSingle();

                                        if (j == 0) // normal
                                        {                                            
                                            //m_lstOjwAse[m_nCnt_Obj_Ase - 1].Data_Add(fA - afPos[0], fB - afPos[1], fC - afPos[2]);
                                            continue;
                                        }
                                        else
                                        {
                                            if ((i == 0) && (j == 1))// First data
                                            {

                                                if (bSub_InitPoint)
                                                {
                                                    afPos[_x] = afTmp[_x]; //0;// fA; //0;//fA;
                                                    afPos[_y] = afTmp[_y]; //0;// fC; //0;//fB;
                                                    afPos[_z] = afTmp[_z]; //0;// fB; //0;//fC;
                                                }
                                                else
                                                {
                                                    afPos[_x] = 0;
                                                    afPos[_y] = 0;
                                                    afPos[_z] = 0;
                                                }

                                                //afPos[_x] = 0;// afTmp[_x]; //0;// fA; //0;//fA;
                                                //afPos[_y] = 0;// afTmp[_y]; //0;// fC; //0;//fB;
                                                //afPos[_z] = 0;// afTmp[_z]; //0;// fB; //0;//fC;
                                            }
                                            //m_lstOjwAse[m_nCnt_Obj_Ase - 1].Data_Add(fA - afPos[0], fB - afPos[1], fC - afPos[2]);
                                            m_lstOjwAse[m_nCnt_Obj_Ase - 1].Data_Add(afTmp[_x] - afPos[_x], afTmp[_y] - afPos[_y], afTmp[_z] - afPos[_z]);
                                            //m_lstOjwAse[m_nCnt_Obj_Ase - 1].Data_Add(fA - afPos[0], fC - afPos[2], fB - afPos[1]);
                                            //m_lstOjwAse[m_nCnt_Obj_Ase - 1].Face_Add((int)fA - (int)afPos[0], (int)fB - (int)afPos[1], (int)fC - (int)afPos[2]);
                                            //m_lstOjwAse[m_nCnt_Obj_Ase - 1].Face_Add((int)fA - (int)afPos[0], (int)fB - (int)afPos[1], (int)fC - (int)afPos[2]);
                                        }
                                    }
                                    // unused
                                    byTmp0 = fs.ReadByte();
                                    byTmp1 = fs.ReadByte();
                                    //if ((byTmp0 != 0) || (byTmp1 != 0))
                                    //    Ojw.CMessage.Write("{0}, {1}", byTmp0, byTmp1);
                                }
                            }
                        }
                        return true;
                    }
                    catch(Exception e)
                    {
                        m_nCnt_Obj_Ase = 0;
                        MessageBox.Show(nTmp.ToString() + "/" + nTmpAll.ToString() + " : " + strName + "=>" + e.ToString());
                        return false;
                    }
                }

                public bool OjwFileOpen_3D_SSTL(String strFileName)
                {
                    int nTmp = 0;
                    String strName = "";
                    try
                    {
                        string header;
                        using (var fs = new BinaryReader(File.OpenRead(strFileName), Encoding.ASCII))
                        {
                            header = Ojw.CFile.GetName(strFileName);

                            int nDir = fs.ReadInt32();
                            int nCount = fs.ReadInt32(); 

                            strName = header;

                            COjwAse CAse = new COjwAse();
                            CAse.Data_Clear();
                            CAse.Data_Type_Set(1);
                            m_lstOjwAse.Add(CAse);
                            m_lstModel.Add(Ojw.CFile.GetName(strFileName)); // Add a Model Name
                            m_nCnt_Obj_Ase++;
                            m_nCnt_Ase++;

                            //float fA, fB, fC;
                            //byte byTmp0;//, byTmp1;

                            float[] afPos = new float[3];
                            Array.Clear(afPos, 0, afPos.Length);

                            int _x = 0;
                            int _y = 1;
                            int _z = 2;
                            float[] afTmp = new float[3];
                            for (int i = 0; i < nCount; i++)
                            {
                                nTmp++;
                                
                                afTmp[_x] = fs.ReadSingle();
                                afTmp[_y] = fs.ReadSingle();
                                afTmp[_z] = fs.ReadSingle();
                                
                                //if (i == 0) // normal
                                //{
                                //    afPos[_x] = 0;
                                //    afPos[_y] = 0;
                                //    afPos[_z] = 0;                                    
                                //}
                                //else
                                {
                                    m_lstOjwAse[m_nCnt_Obj_Ase - 1].Data_Add(afTmp[_x] - afPos[_x], afTmp[_y] - afPos[_y], afTmp[_z] - afPos[_z]);
                                }
                            }
                        }
                        return true;
                    }
                    catch (Exception e)
                    {
                        m_nCnt_Obj_Ase = 0;
                        //MessageBox.Show(nTmp.ToString() + "/" + nTmpAll.ToString() + " : " + strName + "=>" + e.ToString());
                        return false;
                    }
                }
                #endregion STL
                public bool OjwFileOpen_3D_ASE(String strFileName)
                {
                    //SetCursor(IDC_APPSTARTING);
                    try
                    {
                        const int nHide = 1; // 10;
                        FileInfo f = new FileInfo(strFileName);
                        if (f.Exists == false) return false;

                        StreamReader fs = f.OpenText();
                        bool bOk = false;
                        bool bOk_Face = false;
                        float[] afPos = new float[3];
                        float[] afPos2 = new float[3];
                        int nTemp = 0;
                        bool bStart = false;
                        while (true)
                        {
                            String str = fs.ReadLine();
                            if (str == null) break;

                            if (bStart == false)
                            {
                                if (str.IndexOf("*GEOMOBJECT") >= 0) bStart = true;
                            }
                            else
                            {
                                // Do not load 2'st data
                                if (str.IndexOf("*GEOMOBJECT") >= 0) break;
                            }

                            //if (str.IndexOf("*MESH_FACE_LIST") >= 0) break;

                            if ((bStart == true) && (str.IndexOf("*TM_POS") >= 0))
                            {
#if false
                                str = str.Trim();
                                int nPos0 = str.IndexOf(' ');
                                int nPos1 = str.IndexOf('\t') - nPos0;
                                afPos[0] = CConvert.StrToFloat(str.Substring(nPos0, nPos1));
                                str = str.Substring((nPos1 + 1 + nPos0), str.Length - (nPos1 + 1 + nPos0));
                                nPos1 = str.IndexOf('\t');
                                afPos[2] = CConvert.StrToFloat(str.Substring(0, nPos1));
                                str = str.Substring((nPos1 + 1), str.Length - (nPos1 + 1));
                                afPos[1] = CConvert.StrToFloat(str);
#else
                                //StringBuilder strb = new StringBuilder(str.Trim());
                                str = str.Trim();
                                int nPos0 = str.IndexOf(' ');
                                int nPos1 = str.IndexOf('\t') - nPos0;
                                afPos[0] = CConvert.StrToFloat(str.Substring(nPos0, nPos1));
                                str = str.Substring((nPos1 + 1 + nPos0), str.Length - (nPos1 + 1 + nPos0));
                                nPos1 = str.IndexOf('\t');
                                afPos[2] = CConvert.StrToFloat(str.Substring(0, nPos1));
                                afPos[1] = CConvert.StrToFloat(str.Substring((nPos1 + 1), str.Length - (nPos1 + 1)));

#endif
                                // Add a new model
                                COjwAse CAse = new COjwAse();
                                CAse.Data_Clear();
                                CAse.Data_Type_Set(1);
                                m_lstOjwAse.Add(CAse);
                                //m_lstModel.Add(Ojw.CFile.GetTitle(strFileName)); // Add a Model Name
                                m_lstModel.Add(Ojw.CFile.GetName(strFileName));
                                m_nCnt_Obj_Ase++;
                                m_nCnt_Ase++;

                                Array.Clear(afPos, 0, afPos.Length);
                                //afPos[0] = 0;
                                //afPos[1] = 0;
                                //afPos[2] = 0;                     
                            }

                            if (str.IndexOf("*MESH_VERTEX_LIST") >= 0)
                            {
                                bOk = true;
                                continue;
                            }
                            else if (str.IndexOf("*MESH_FACE_LIST") >= 0)
                            {
                                bOk_Face = true;
                                continue;
                            }


                            if (bOk == true)
                            {
                                if (str.IndexOf("}") >= 0) bOk = false;
                                else
                                {
                                    if (nTemp == 0)
                                    {
                                        // read in the order of [x, z, y](Kor: x, z, y의 순으로 읽음)
                                        str = str.Trim();
                                        int nPos0 = str.IndexOf(' ');
                                        int nPos1 = str.IndexOf('\t') - nPos0;
                                        int nIndex = CConvert.StrToInt(str.Substring(nPos0, nPos1));
                                        str = str.Substring((nPos1 + 1 + nPos0), str.Length - (nPos1 + 1 + nPos0));
                                        nPos1 = str.IndexOf('\t');
                                        afPos2[0] = CConvert.StrToFloat(str.Substring(0, nPos1));
                                        str = str.Substring(nPos1 + 1, str.Length - (nPos1 + 1));
                                        nPos1 = str.IndexOf('\t');
                                        afPos2[2] = CConvert.StrToFloat(str.Substring(0, nPos1));
                                        str = str.Substring(nPos1 + 1, str.Length - (nPos1 + 1));
                                        afPos2[1] = CConvert.StrToFloat(str);


                                        // put the actual data.(Kor: 실제의 데이타를 넣자.)
                                        //m_lstOjwAse[m_nCnt_Obj_Ase - 1].Data_Add(afPos2[0] - afPos[0], afPos2[1] - afPos[1], afPos2[2] - afPos[2]);
                                        m_lstOjwAse[m_nCnt_Obj_Ase - 1].Data_Add((afPos2[0] - afPos[0]), (afPos2[1] - afPos[2]), -(afPos2[2] - afPos[1]));
                                    }

                                    nTemp++;
                                    if (nTemp >= nHide) nTemp = 0;
                                }


                                //if (str.IndexOf("*MESH_FACE_LIST") >= 0) bOk = false;
                            }
                            else if (bOk_Face == true)
                            {
                                if (str.IndexOf("}") >= 0) bOk_Face = false;
                                else
                                {
                                    if (nTemp == 0)
                                    {
                                        // read in the order of [x, z, y](Kor: x, z, y의 순으로 읽음)
                                        str = str.Trim();
                                        int nPos0 = str.IndexOf(' ');
                                        int nPos1 = str.IndexOf(":") - nPos0;
                                        int nIndex = CConvert.StrToInt(str.Substring(nPos0, nPos1));
                                        nPos0 = str.IndexOf("A:") + 2;
                                        nPos1 = str.IndexOf("B:") - nPos0;
                                        int A = CConvert.StrToInt(str.Substring(nPos0, nPos1));
                                        nPos0 = str.IndexOf("B:") + 2;
                                        nPos1 = str.IndexOf("C:") - nPos0;
                                        int B = CConvert.StrToInt(str.Substring(nPos0, nPos1));
                                        nPos0 = str.IndexOf("C:") + 2;
                                        nPos1 = str.IndexOf("AB:") - nPos0;
                                        int C = CConvert.StrToInt(str.Substring(nPos0, nPos1));
                                        //str = str.Substring((nPos1 + 1 + nPos0), str.Length - (nPos1 + 1 + nPos0));
                                        //nPos1 = str.IndexOf("C:");
                                        //int A = CConvert.StrToInt(str.Substring(0, nPos1));
                                        //str = str.Substring(nPos1 + 1, str.Length - (nPos1 + 1));
                                        //nPos1 = str.IndexOf("AB:");
                                        //int B = CConvert.StrToInt(str.Substring(0, nPos1));

                                        //nPos1 = str.IndexOf("AB:");
                                        //str = str.Substring(nPos1 + 1, str.Length - (nPos1 + 1));
                                        //int C = CConvert.StrToInt(str);

                                        // put the actual data.(Kor: 실제의 데이타를 넣자.)
                                        m_lstOjwAse[m_nCnt_Obj_Ase - 1].Face_Add(A - (int)afPos[0], B - (int)afPos[1], C - (int)afPos[2]);
                                    }

                                    nTemp++;
                                    if (nTemp >= nHide) nTemp = 0;
                                }
                            }
                        }
                        //SVector3D_t SVec = m_lstOjwAse[m_nCnt_Obj_Ase - 1].Data_Get(0);
                        //m_lstOjwAse[m_nCnt_Obj_Ase - 1].Data_Add(SVec.x, SVec.y, SVec.z);
                        fs.Close();

                        return true;
                    }
                    catch
                    {
                        m_nCnt_Obj_Ase = 0;
                        return false;
                    }
                    //SetCursor(IDC_ARROW);
                }
#if false       
        public void OjwBox_Outside(bool bFill, Color color,
                            float fW, float fH, float fD,            // Size 기입
                            float fOffsetPan, float fOffsetTilt, float fOffsetSwing,   // 회전할 축
                            float fOffsetX, float fOffsetY, float fOffsetZ // 임의의 그려질 위치
                        )
        {
            m_fColor[0] = ((float)(color.R) / 255.0f);  // R
            m_fColor[1] = ((float)(color.G) / 255.0f);  // G
            m_fColor[2] = ((float)(color.B) / 255.0f);  // B
            Gl.glColor3fv(m_fColor); // Color with an array of floats
            //float fX1 = 0;
            //float fX2 = fW * m_fScale;// fX / 2.0f;
            //float fY1 = 0;// fY / 2.0f;
            //float fY2 = fH * m_fScale; ;// / 2.0f;
            //float fZ1 = 0;
            //float fZ2 = (fD * m_fScale); 
            float fX1 = -fW * m_fScale / 2.0f;
            float fX2 = fW * m_fScale / 2.0f;// fX / 2.0f;
            float fY1 = 0;// fY / 2.0f;
            float fY2 = -fH * m_fScale; // / 2.0f;
            float fZ1 = -fD * m_fScale / 2.0f;
            float fZ2 = fD * m_fScale / 2.0f;
            // x2 -> direction : right(Kor: 증분방향 : 오른쪽)
            // Y2 -> direction : Up(Kor: 증분방향 : 위쪽)
            // Z2 -> direction : The inside of the screen(Kor: 증분방향 : 화면의 안쪽)
            // Criteria screen : See picture below(Kor: 기준화면 : 밑 그림 참조)
            // 0, 0, 0 -> State in the middle of the screen as a starting point and went inside by a factor of 5
            // Kor: 0, 0, 0 -> 화면의 가운데를 시작점으로 하고 안쪽으로 5만큼 들어간 상태
            /*
                000000000
              0 0 ★  0 0
            000000000   0
            0   0   0   0
            0   000000000  
            0 0     0 0
            000000000  
            ( 중심위치 )
            */

            uint uiType = (bFill == true) ? Gl.GL_QUADS : Gl.GL_LINE_LOOP;//Gl.GL_LINE_LOOP;// Gl.GL_QUADS;//

            SVector3D_t[] aSPos = new SVector3D_t[24];
            int i = 0;
            // Front Face		
            aSPos[i].x = fX1; aSPos[i].y = fY2; aSPos[i].z = fZ2; i++;// Bottom Left Of The Texture and Quad
            aSPos[i].x = fX2; aSPos[i].y = fY2; aSPos[i].z = fZ2; i++;// Bottom Right Of The Texture and Quad
            aSPos[i].x = fX2; aSPos[i].y = fY1; aSPos[i].z = fZ2; i++;// Top Right Of The Texture and Quad
            aSPos[i].x = fX1; aSPos[i].y = fY1; aSPos[i].z = fZ2; i++;// Top Left Of The Texture and Quad

            // Back Face			
            aSPos[i].x = fX1; aSPos[i].y = fY2; aSPos[i].z = fZ1; i++;// Bottom Right Of The Texture and Quad
            aSPos[i].x = fX1; aSPos[i].y = fY1; aSPos[i].z = fZ1; i++;// Top Right Of The Texture and Quad
            aSPos[i].x = fX2; aSPos[i].y = fY1; aSPos[i].z = fZ1; i++;// Top Left Of The Texture and Quad
            aSPos[i].x = fX2; aSPos[i].y = fY2; aSPos[i].z = fZ1; i++;// Bottom Left Of The Texture and Quad

            // Top Face		
            aSPos[i].x = fX1; aSPos[i].y = fY1; aSPos[i].z = fZ1; i++;// Top Left Of The Texture and Quad
            aSPos[i].x = fX1; aSPos[i].y = fY1; aSPos[i].z = fZ2; i++;// Bottom Left Of The Texture and Quad
            aSPos[i].x = fX2; aSPos[i].y = fY1; aSPos[i].z = fZ2; i++;// Bottom Right Of The Texture and Quad
            aSPos[i].x = fX2; aSPos[i].y = fY1; aSPos[i].z = fZ1; i++;// Top Right Of The Texture and Quad

            // Bottom Face		
            aSPos[i].x = fX1; aSPos[i].y = fY2; aSPos[i].z = fZ1; i++;// Top Right Of The Texture and Quad
            aSPos[i].x = fX2; aSPos[i].y = fY2; aSPos[i].z = fZ1; i++;// Top Left Of The Texture and Quad
            aSPos[i].x = fX2; aSPos[i].y = fY2; aSPos[i].z = fZ2; i++;// Bottom Left Of The Texture and Quad
            aSPos[i].x = fX1; aSPos[i].y = fY2; aSPos[i].z = fZ2; i++;// Bottom Right Of The Texture and Quad

            // Right Face		
            aSPos[i].x = fX2; aSPos[i].y = fY2; aSPos[i].z = fZ1; i++;// Bottom Right Of The Texture and Quad
            aSPos[i].x = fX2; aSPos[i].y = fY1; aSPos[i].z = fZ1; i++;// Top Right Of The Texture and Quad
            aSPos[i].x = fX2; aSPos[i].y = fY1; aSPos[i].z = fZ2; i++;// Top Left Of The Texture and Quad
            aSPos[i].x = fX2; aSPos[i].y = fY2; aSPos[i].z = fZ2; i++;// Bottom Left Of The Texture and Quad
            // Left Face				
            aSPos[i].x = fX1; aSPos[i].y = fY2; aSPos[i].z = fZ1; i++;// Bottom Left Of The Texture and Quad
            aSPos[i].x = fX1; aSPos[i].y = fY2; aSPos[i].z = fZ2; i++;// Bottom Right Of The Texture and Quad
            aSPos[i].x = fX1; aSPos[i].y = fY1; aSPos[i].z = fZ2; i++;// Top Right Of The Texture and Quad
            aSPos[i].x = fX1; aSPos[i].y = fY1; aSPos[i].z = fZ1; i++;// Top Left Of The Texture and Quad
            int nCnt = i;

            for (i = 0; i < nCnt; i++)
            {
                // 좌표 회전
                Rotation(fOffsetTilt, fOffsetPan, fOffsetSwing, ref aSPos[i].x, ref aSPos[i].y, ref aSPos[i].z);

                // 좌표 이동
                aSPos[i].x += fOffsetX * m_fScale;
                aSPos[i].y += fOffsetY * m_fScale;
                aSPos[i].z += fOffsetZ * m_fScale;
            }
            i = 0;

            float[] afObject = new float[4] { (float)(color.R), (float)(color.G), (float)(color.B), 1.0f };

            Gl.glBegin(uiType);

            Gl.glMaterialfv(Gl.GL_FRONT, Gl.GL_DIFFUSE, afObject);//물체 특성할당

            // Front Face
            Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;			// Bottom Left Of The Texture and Quad
            Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Right Of The Texture and Quad
            Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Right Of The Texture and Quad
            Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Left Of The Texture and Quad
            // Back Face
            Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Right Of The Texture and Quad
            Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Right Of The Texture and Quad
            Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Left Of The Texture and Quad
            Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Left Of The Texture and Quad
            // Top Face
            Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Left Of The Texture and Quad
            Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Left Of The Texture and Quad
            Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Right Of The Texture and Quad
            Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Right Of The Texture and Quad
            // Bottom Face
            Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Right Of The Texture and Quad
            Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Left Of The Texture and Quad
            Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Left Of The Texture and Quad
            Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Right Of The Texture and Quad
            // Right Face
            Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Right Of The Texture and Quad
            Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Right Of The Texture and Quad
            Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Left Of The Texture and Quad
            Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Left Of The Texture and Quad
            // Left Face
            Gl.glTexCoord2f(0.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Left Of The Texture and Quad
            Gl.glTexCoord2f(1.0f, 0.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Bottom Right Of The Texture and Quad
            Gl.glTexCoord2f(1.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Right Of The Texture and Quad
            Gl.glTexCoord2f(0.0f, 1.0f); Gl.glVertex3f(aSPos[i].x, aSPos[i].y, aSPos[i].z); i++;				// Top Left Of The Texture and Quad

            Gl.glEnd();// end drawing the cube	
        }
#endif
                #endregion Ojw3D_ASE_0

                #region Convert Stl To Sstl
                public bool OjwFileConvert_STL_to_SSTL(String strFileName)
                {
                    bool bRet = false;
                    int nTmp = 0;
                    String strName = "";
                    int nTmpAll = 0;

                    COjwAse CAse = new COjwAse();
                    CAse.Data_Clear();
                    CAse.Data_Type_Set(1);

                    try
                    {
                        string header;
                        FileInfo f = new FileInfo(strFileName);
                        FileStream fs_Ascii = f.OpenRead();
                        long lHeaderSize = fs_Ascii.Length;
                        byte[] byteData = new byte[lHeaderSize];

                        #region Moved by opening the file into memory(Kor: 파일을 열어서 메모리로 옮김)
                        fs_Ascii.Read(byteData, 0, (int)lHeaderSize);//byteData.Length); // for Check 11 bytes in header
                        fs_Ascii.Close();
                        #endregion Moved by opening the file into memory(Kor: 파일을 열어서 메모리로 옮김)
                        if (Encoding.ASCII.GetString(byteData, 0, 80).IndexOf("solid ascii") >= 0)
                        {
                            Ojw.CMessage.Write("solid ascii");
                            float[] afData = new float[3];
                            float[] afPos = new float[3];
                            String[] pstrSplit = Encoding.ASCII.GetString(byteData, 0, (int)lHeaderSize).Split('\n');
                            bool bFirst = true;


                            foreach (string strLine in pstrSplit)
                            {
                                int nIndex = strLine.IndexOf("vertex");
                                if (nIndex >= 0)
                                {
                                    String[] pstrItems = strLine.Substring(nIndex + 6).Split(' ');
                                    int nPos = 0;
                                    foreach (string strItem in pstrItems)
                                    {
                                        if (strItem.Length > 0)
                                            afData[nPos++] = Ojw.CConvert.StrToFloat(strItem);
                                    }
                                    if (bFirst)
                                    {
                                        bFirst = false;
                                        afPos[0] = afData[0];
                                        afPos[1] = afData[1];
                                        afPos[2] = afData[2];
                                    }
                                    else CAse.Data_Add(afData[0] - afPos[0], afData[1] - afPos[1], afData[2] - afPos[2]);
                                }
                            }
                            pstrSplit = null;
                        }
                        else
                        {
                            using (var fs = new BinaryReader(File.OpenRead(strFileName), Encoding.ASCII))
                            {
                                header = Encoding.ASCII.GetString(fs.ReadBytes(80));
                                var unCount = fs.ReadUInt32();

                                nTmpAll = (int)unCount;
                                strName = header;
                                
                                //float fA, fB, fC;
                                byte byTmp0, byTmp1;

                                float[] afPos = new float[3];
                                Array.Clear(afPos, 0, afPos.Length);

                                int _x = 0;
                                int _y = 1;
                                int _z = 2;
                                float[] afTmp = new float[3];
                                for (int i = 0; i < nTmpAll; i++)
                                {
                                    nTmp++;
                                    int nMax = 4;
                                    for (int j = 0; j < nMax; j++)
                                    {
                                        afTmp[_x] = fs.ReadSingle();
                                        afTmp[_y] = fs.ReadSingle();
                                        afTmp[_z] = fs.ReadSingle();

                                        if (j == 0) // normal
                                        {
                                            continue;
                                        }
                                        else
                                        {
                                            if ((i == 0) && (j == 1))// First data
                                            {
                                                afPos[_x] = afTmp[_x]; 
                                                afPos[_y] = afTmp[_y];
                                                afPos[_z] = afTmp[_z];
                                            }
                                            CAse.Data_Add(afTmp[_x] - afPos[_x], afTmp[_y] - afPos[_y], afTmp[_z] - afPos[_z]);
                                        }
                                    }
                                    // unused
                                    byTmp0 = fs.ReadByte();
                                    byTmp1 = fs.ReadByte();
                                }
                            }
                        }
                        bRet = true;
                    }
                    catch (Exception e)
                    {
                        MessageBox.Show(nTmp.ToString() + "/" + nTmpAll.ToString() + " : " + strName + "=>" + e.ToString());
                        bRet = false;
                    }

                    if (bRet == true)
                    {
                        // Write File
                        strFileName = Ojw.CConvert.ChangeString(strFileName.ToLower(), ".stl", ".sstl");
                        FileInfo fw = new FileInfo(strFileName);
                        FileStream fws = fw.Create();

                        try
                        {
                            #region Save SSTL
                            // 스트림 버퍼를 비운다.
                            fws.Flush();

                            byte[] pbyte;

                            // Dir
                            pbyte = BitConverter.GetBytes((int)1); fws.Write(pbyte, 0, 4);// 0 : CW , 1 : CCW
                            // Size
                            int nCnt = CAse.Data_GetCnt();
                            pbyte = BitConverter.GetBytes(nCnt); fws.Write(pbyte, 0, 4);

                            bool bInverse = false;
                            DialogResult dlgRet = MessageBox.Show("Do you want to make it upside down?", "save CCW", MessageBoxButtons.OKCancel, MessageBoxIcon.Warning);
                            if (dlgRet == DialogResult.OK)
                            {
                                bInverse = true;
                            }

                            SVector4D_t SVec;
                            for (int i = 0; i < nCnt; i++)
                            {
#if false
                                int nPos = ((bInverse == true) ? 3 * ((int)Math.Round(i / 3 + 0.6, 0)) - (i % 3) - 1 : i);
#else
                                int nPos = ((bInverse == true) ? nCnt - i - 1 : i);
#endif
                                SVec = CAse.Data_Get(nPos);
                                pbyte = BitConverter.GetBytes((float)SVec.x); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)SVec.y); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)SVec.z); fws.Write(pbyte, 0, 4);
                            }

                            //foreach (SVector3D_t SVec in CAse.Data_Get())
                            //{
                            //    pbyte = BitConverter.GetBytes((float)SVec.x); fws.Write(pbyte, 0, 4);
                            //    pbyte = BitConverter.GetBytes((float)SVec.y); fws.Write(pbyte, 0, 4);
                            //    pbyte = BitConverter.GetBytes((float)SVec.z); fws.Write(pbyte, 0, 4);
                            //}
                            pbyte = null;

                            fws.Close();
                            fw = null;
                            Ojw.CMessage.Write("File Convert Ok");
                            MessageBox.Show("File Convert Ok");
                            #endregion Save SSTL

                            bRet = true;
                        }
                        catch
                        {
                            //Message("File save error");
                            fws.Close();
                            fw = null;
                            bRet = false;
                        }
                    }
                    return bRet;
                }
                #endregion Convert Stl To Sstl

                #region Convert Ase To Sstl
                public bool OjwFileConvert_ASE_to_SSTL(String strFileName)
                {
                    bool bRet = false;
                    
                    // Add a new model
                    COjwAse CAse = new COjwAse();
                    CAse.Data_Clear();
                    CAse.Data_Type_Set(1);

                    try
                    {
                        const int nHide = 1; // 10;
                        FileInfo f = new FileInfo(strFileName);
                        if (f.Exists == false) return false;

                        StreamReader fs = f.OpenText();
                        bool bOk = false;
                        bool bOk_Face = false;
                        float[] afPos = new float[3];
                        float[] afPos2 = new float[3];
                        int nTemp = 0;
                        bool bStart = false;
                        while (true)
                        {
                            String str = fs.ReadLine();
                            if (str == null) break;

                            if (bStart == false)
                            {
                                if (str.IndexOf("*GEOMOBJECT") >= 0) bStart = true;
                            }
                            else
                            {
                                // Do not load 2'st data
                                if (str.IndexOf("*GEOMOBJECT") >= 0) break;
                            }

                            //if (str.IndexOf("*MESH_FACE_LIST") >= 0) break;

                            if ((bStart == true) && (str.IndexOf("*TM_POS") >= 0))
                            {
                                str = str.Trim();
                                int nPos0 = str.IndexOf(' ');
                                int nPos1 = str.IndexOf('\t') - nPos0;
                                afPos[0] = CConvert.StrToFloat(str.Substring(nPos0, nPos1));
                                str = str.Substring((nPos1 + 1 + nPos0), str.Length - (nPos1 + 1 + nPos0));
                                nPos1 = str.IndexOf('\t');
                                afPos[2] = CConvert.StrToFloat(str.Substring(0, nPos1));
                                afPos[1] = CConvert.StrToFloat(str.Substring((nPos1 + 1), str.Length - (nPos1 + 1)));

                                Array.Clear(afPos, 0, afPos.Length);
                            }

                            if (str.IndexOf("*MESH_VERTEX_LIST") >= 0)
                            {
                                bOk = true;
                                continue;
                            }
                            else if (str.IndexOf("*MESH_FACE_LIST") >= 0)
                            {
                                bOk_Face = true;
                                continue;
                            }


                            if (bOk == true)
                            {
                                if (str.IndexOf("}") >= 0) bOk = false;
                                else
                                {
                                    if (nTemp == 0)
                                    {
                                        // read in the order of [x, z, y](Kor: x, z, y의 순으로 읽음)
                                        str = str.Trim();
                                        int nPos0 = str.IndexOf(' ');
                                        int nPos1 = str.IndexOf('\t') - nPos0;
                                        int nIndex = CConvert.StrToInt(str.Substring(nPos0, nPos1));
                                        str = str.Substring((nPos1 + 1 + nPos0), str.Length - (nPos1 + 1 + nPos0));
                                        nPos1 = str.IndexOf('\t');
                                        afPos2[0] = CConvert.StrToFloat(str.Substring(0, nPos1));
                                        str = str.Substring(nPos1 + 1, str.Length - (nPos1 + 1));
                                        nPos1 = str.IndexOf('\t');
                                        afPos2[2] = CConvert.StrToFloat(str.Substring(0, nPos1));
                                        str = str.Substring(nPos1 + 1, str.Length - (nPos1 + 1));
                                        afPos2[1] = CConvert.StrToFloat(str);
                                        
                                        // put the actual data.(Kor: 실제의 데이타를 넣자.)
                                        CAse.Data_Add((afPos2[0] - afPos[0]), (afPos2[1] - afPos[2]), -(afPos2[2] - afPos[1]));
                                    }

                                    nTemp++;
                                    if (nTemp >= nHide) nTemp = 0;
                                }
                            }
                            else if (bOk_Face == true)
                            {
                                if (str.IndexOf("}") >= 0) bOk_Face = false;
                                else
                                {
                                    if (nTemp == 0)
                                    {
                                        // read in the order of [x, z, y](Kor: x, z, y의 순으로 읽음)
                                        str = str.Trim();
                                        int nPos0 = str.IndexOf(' ');
                                        int nPos1 = str.IndexOf(":") - nPos0;
                                        int nIndex = CConvert.StrToInt(str.Substring(nPos0, nPos1));
                                        nPos0 = str.IndexOf("A:") + 2;
                                        nPos1 = str.IndexOf("B:") - nPos0;
                                        int A = CConvert.StrToInt(str.Substring(nPos0, nPos1));
                                        nPos0 = str.IndexOf("B:") + 2;
                                        nPos1 = str.IndexOf("C:") - nPos0;
                                        int B = CConvert.StrToInt(str.Substring(nPos0, nPos1));
                                        nPos0 = str.IndexOf("C:") + 2;
                                        nPos1 = str.IndexOf("AB:") - nPos0;
                                        int C = CConvert.StrToInt(str.Substring(nPos0, nPos1));
                                        // put the actual data.(Kor: 실제의 데이타를 넣자.)
                                        CAse.Face_Add(A - (int)afPos[0], B - (int)afPos[1], C - (int)afPos[2]);
                                    }

                                    nTemp++;
                                    if (nTemp >= nHide) nTemp = 0;
                                }
                            }
                        }
                        fs.Close();

                        bRet = true;
                    }
                    catch
                    {
                        bRet = false;
                    }


                    if (bRet == true)
                    {
                        // Write File
                        FileInfo fw = new FileInfo(Ojw.CConvert.ChangeString(strFileName.ToLower(), ".ase", ".sstl"));
                        FileStream fws = fw.Create();

                        try
                        {
#if false
                            // 스트림 버퍼를 비운다.
                            fws.Flush();

                            byte[] pbyte;

                            // Dir
                            pbyte = BitConverter.GetBytes((int)1); fws.Write(pbyte, 0, 4);// 0 : CW , 1 : CCW
                            // Size
                            pbyte = BitConverter.GetBytes((int)CAse.Face_GetCnt() * 3); fws.Write(pbyte, 0, 4);

                            for (int i = 0; i < CAse.Face_GetCnt(); i++)
                            {
                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(i).x).x); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(i).x).y); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(i).x).z); fws.Write(pbyte, 0, 4);

                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(i).y).x); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(i).y).y); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(i).y).z); fws.Write(pbyte, 0, 4);

                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(i).z).x); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(i).z).y); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(i).z).z); fws.Write(pbyte, 0, 4);
                            }
                            pbyte = null;

                            fws.Close();
                            fw = null;
                            Ojw.CMessage.Write("File Convert Ok");
                            MessageBox.Show("File Convert Ok");
#else
                            #region Save SSTL
                            // 스트림 버퍼를 비운다.
                            fws.Flush();

                            byte[] pbyte;

                            // Dir
                            pbyte = BitConverter.GetBytes((int)1); fws.Write(pbyte, 0, 4);// 0 : CW , 1 : CCW
                            // Size
                            int nCnt = CAse.Face_GetCnt();
                            pbyte = BitConverter.GetBytes(nCnt * 3); fws.Write(pbyte, 0, 4);

                            bool bInverse = false;
                            DialogResult dlgRet = MessageBox.Show("Do you want to make it upside down?", "save CCW", MessageBoxButtons.OKCancel, MessageBoxIcon.Warning);
                            if (dlgRet == DialogResult.OK)
                            {
                                bInverse = true;
                            }

                            for (int i = 0; i < nCnt; i++)
                            {
                                int nPos = ((bInverse == true) ? nCnt - i - 1 : i);
                                //SVec = CAse.Data_Get(nPos);
                                //pbyte = BitConverter.GetBytes((float)SVec.x); fws.Write(pbyte, 0, 4);
                                //pbyte = BitConverter.GetBytes((float)SVec.y); fws.Write(pbyte, 0, 4);
                                //pbyte = BitConverter.GetBytes((float)SVec.z); fws.Write(pbyte, 0, 4);


                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(nPos).x).x); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(nPos).x).y); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(nPos).x).z); fws.Write(pbyte, 0, 4);

                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(nPos).y).x); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(nPos).y).y); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(nPos).y).z); fws.Write(pbyte, 0, 4);

                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(nPos).z).x); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(nPos).z).y); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(nPos).z).z); fws.Write(pbyte, 0, 4);
                            }
                            pbyte = null;

                            fws.Close();
                            fw = null;
                            Ojw.CMessage.Write("File Convert Ok");
                            MessageBox.Show("File Convert Ok");
                            #endregion Save SSTL
#endif
                            bRet = true;
                        }
                        catch
                        {
                            fws.Close();
                            fw = null;
                            bRet = false;
                        }
                    }
                    return bRet;
                }
                #endregion Convert Ase To Sstl

                #region Convert Obj To Sstl
                public bool OjwFileConvert_OBJ_to_SSTL(String strFileName)
                {
                    bool bRet = false;
                    
                    // New model
                    COjwAse CAse = new COjwAse();
                    CAse.Data_Clear();
                    CAse.Data_Type_Set(0);

                    try
                    {
                        const int nHide = 10;
                        FileInfo f = new FileInfo(strFileName);
                        StreamReader fs = f.OpenText();
                        float[] afPos = new float[3] { 0, 0, 0 };
                        float[] afPos2 = new float[3];
                        bool bStartPos = true;
                        int nTemp = 0;
                        while (true)
                        {
                            String str = fs.ReadLine();
                            if (str == null) break;
                            if (str.IndexOf("mtllib") == 0)
                            {
                                // Start
                            }

                            if (str.IndexOf("v ") == 0)
                            {

                                if (nTemp == 0)
                                {
                                    str = str.Substring(2, str.Length - 2);
                                    str = str.Trim();
                                    int nPos1 = str.IndexOf(' ');
                                    afPos2[0] = CConvert.StrToFloat(str.Substring(0, nPos1));
                                    str = str.Substring((nPos1 + 1), str.Length - (nPos1 + 1));
                                    nPos1 = str.IndexOf(' ');
                                    afPos2[2] = CConvert.StrToFloat(str.Substring(0, nPos1));
                                    str = str.Substring((nPos1 + 1), str.Length - (nPos1 + 1));
                                    afPos2[1] = CConvert.StrToFloat(str);

                                    if (bStartPos == true)
                                    {
                                        bStartPos = false;
                                        afPos[0] = 0;
                                        afPos[1] = 0;
                                        afPos[2] = 0;
                                    }

                                    CAse.Data_Add(afPos2[0] - afPos[0], afPos2[1] - afPos[1], afPos2[2] - afPos[2]);
                                }

                                nTemp++;
                                if (nTemp >= nHide) nTemp = 0;
                            }

                            if (str.IndexOf("f ") == 0)
                            {

                                if (nTemp == 0)
                                {
                                    int[] anPos = new int[3];
                                    str = str.Substring(2, str.Length - 2);
                                    str = str.Trim();
                                    int nPos0 = 0;// str.IndexOf(' ');
                                    int nPos1 = str.IndexOf('/') - nPos0;
                                    anPos[0] = CConvert.StrToInt(str.Substring(nPos0, nPos1));
                                    str = str.Substring((nPos1 + 1), str.Length - (nPos1 + 1));
                                    nPos1 = str.IndexOf('/');
                                    anPos[2] = CConvert.StrToInt(str.Substring(nPos0, nPos1));
                                    str = str.Substring((nPos1 + 1), str.Length - (nPos1 + 1));
                                    nPos1 = str.IndexOf(' ');
                                    anPos[1] = CConvert.StrToInt(str.Substring(nPos0, nPos1)); //CConvert.StrToFloat(str);

                                    if (bStartPos == true)
                                    {
                                        bStartPos = false;
                                        Array.Clear(afPos, 0, afPos.Length);
                                    }
                                    CAse.Face_Add(anPos[0], anPos[1], anPos[2]);
                                }

                                nTemp++;
                                if (nTemp >= nHide) nTemp = 0;
                            }
                        }
                        fs.Close();
                        bRet = true;
                    }
                    catch
                    {
                        bRet = false;
                    }

                    if (bRet == true)
                    {
                        // Write File
                        FileInfo fw = new FileInfo(Ojw.CConvert.ChangeString(strFileName.ToLower(), ".obj", ".sstl"));
                        FileStream fws = fw.Create();

                        try
                        {
#if false
                            // 스트림 버퍼를 비운다.
                            fws.Flush();

                            byte[] pbyte;

                            // Dir
                            pbyte = BitConverter.GetBytes((int)1); fws.Write(pbyte, 0, 4);// 0 : CW , 1 : CCW
                            // Size
                            pbyte = BitConverter.GetBytes((int)CAse.Face_GetCnt() * 3); fws.Write(pbyte, 0, 4);

                            for (int i = 0; i < CAse.Face_GetCnt(); i++)
                            {
                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(i).x).x); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(i).x).y); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(i).x).z); fws.Write(pbyte, 0, 4);

                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(i).y).x); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(i).y).y); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(i).y).z); fws.Write(pbyte, 0, 4);

                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(i).z).x); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(i).z).y); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(i).z).z); fws.Write(pbyte, 0, 4);
                            }
                            pbyte = null;

                            fws.Close();
                            fw = null;
                            Ojw.CMessage.Write("File Convert Ok");
                            MessageBox.Show("File Convert Ok");
#else
                            #region Save SSTL
                            // 스트림 버퍼를 비운다.
                            fws.Flush();

                            byte[] pbyte;

                            // Dir
                            pbyte = BitConverter.GetBytes((int)1); fws.Write(pbyte, 0, 4);// 0 : CW , 1 : CCW
                            // Size
                            int nCnt = CAse.Face_GetCnt();
                            pbyte = BitConverter.GetBytes(nCnt * 3); fws.Write(pbyte, 0, 4);

                            bool bInverse = false;
                            DialogResult dlgRet = MessageBox.Show("Do you want to make it upside down?", "save CCW", MessageBoxButtons.OKCancel, MessageBoxIcon.Warning);
                            if (dlgRet == DialogResult.OK)
                            {
                                bInverse = true;
                            }

                            for (int i = 0; i < nCnt; i++)
                            {
                                int nPos = ((bInverse == true) ? nCnt - i - 1 : i);
                                //SVec = CAse.Data_Get(nPos);
                                //pbyte = BitConverter.GetBytes((float)SVec.x); fws.Write(pbyte, 0, 4);
                                //pbyte = BitConverter.GetBytes((float)SVec.y); fws.Write(pbyte, 0, 4);
                                //pbyte = BitConverter.GetBytes((float)SVec.z); fws.Write(pbyte, 0, 4);


                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(nPos).x).x); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(nPos).x).y); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(nPos).x).z); fws.Write(pbyte, 0, 4);

                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(nPos).y).x); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(nPos).y).y); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(nPos).y).z); fws.Write(pbyte, 0, 4);

                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(nPos).z).x); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(nPos).z).y); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)CAse.Data_Get(CAse.Face_Get(nPos).z).z); fws.Write(pbyte, 0, 4);
                            }
                            pbyte = null;

                            fws.Close();
                            fw = null;
                            Ojw.CMessage.Write("File Convert Ok");
                            MessageBox.Show("File Convert Ok");
                            #endregion Save SSTL
#endif
                            bRet = true;
                        }
                        catch
                        {
                            fws.Close();
                            fw = null;
                            bRet = false;
                        }
                    }
                    return bRet;
                }
                #endregion Convert Obj To Sstl

                #region Convert Dat To Sstl
                public bool OjwFileConvert_DAT_to_SSTL(String strFileName)
                {
                    bool bRet = false;
                    int nTmp = 0;
                    String strName = "";
                    int nTmpAll = 0;

                    COjwAse CAse = new COjwAse();
                    CAse.Data_Clear();
                    CAse.Data_Type_Set(1);

                    try
                    {
                        string header;

                        using (var fs = new BinaryReader(File.OpenRead(strFileName), Encoding.ASCII))
                        {
                            header = Ojw.CFile.GetName(strFileName);//Encoding.ASCII.GetString(fs.ReadBytes(80));
                            int nTrash = 16 // ID
                                       + 4 // Version
                                       + 4; // Object Count
                            ///////// object // Object 1개만 읽어보자.
                            int nTrash2 = 32 // Name
                                       + 260 // FileName
                                       + 4 // Type
                                       + 4; // vertex Format

                            byte[] bytesData = fs.ReadBytes(nTrash + nTrash2);

                            Ojw.CMessage.Write2("\r\n====================\r\n");
                            foreach (byte byData in bytesData) Ojw.CMessage.Write2("0x{0},", Ojw.CConvert.IntToHex(byData));
                            Ojw.CMessage.Write2("\r\n====================\r\n");
                            

                            uint unCount = fs.ReadUInt32();  // primitive 갯수
                            uint unStructSize = fs.ReadUInt32(); // 정점의 크기

                            nTmpAll = (int)unCount;
                            strName = header;
                                                        
                            //float fA, fB, fC;
                            byte byTmp0;

                            float[] afPos = new float[3];
                            Array.Clear(afPos, 0, afPos.Length);

                            int _x = 0;
                            int _y = 2;
                            int _z = 1;
                            float[] afTmp = new float[3];
                            for (int i = 0; i < nTmpAll; i++)
                            {
                                nTmp++;
                                int nMax = 3;
                                for (int j = 0; j < nMax; j++)
                                {
                                    afTmp[_x] = fs.ReadSingle();
                                    afTmp[_y] = fs.ReadSingle();
                                    afTmp[_z] = -fs.ReadSingle();
                                    
                                    if (i == 0) // normal
                                    {
                                        afPos[_x] = 0;
                                        afPos[_y] = 0;
                                        afPos[_z] = 0;
                                    }
                                    else
                                    {
                                        CAse.Data_Add(afTmp[_x] - afPos[_x], afTmp[_y] - afPos[_y], afTmp[_z] - afPos[_z]);
                                    }
                                    // unused
                                    for (int k = 0; k < (unStructSize - 12); k++) byTmp0 = fs.ReadByte();
                                }
                            }
                        }
                        bRet = true;
                    }
                    catch (Exception e)
                    {
                        //MessageBox.Show(nTmp.ToString() + "/" + nTmpAll.ToString() + " : " + strName + "=>" + e.ToString());
                        bRet = false;
                    }
                    if (bRet == true)
                    {
                        // Write File
                        strFileName = Ojw.CConvert.ChangeString(strFileName.ToLower(), ".dat", ".sstl");
                        FileInfo fw = new FileInfo(strFileName);
                        FileStream fws = fw.Create();

                        try
                        {
#if false
                            // 스트림 버퍼를 비운다.
                            fws.Flush();

                            byte[] pbyte;

                            // Dir
                            pbyte = BitConverter.GetBytes((int)1); fws.Write(pbyte, 0, 4);// 0 : CW , 1 : CCW
                            // Size
                            pbyte = BitConverter.GetBytes((int)CAse.Data_GetCnt()); fws.Write(pbyte, 0, 4);

                            foreach (SVector3D_t SVec in CAse.Data_Get())
                            {
                                pbyte = BitConverter.GetBytes((float)SVec.x); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)SVec.y); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)SVec.z); fws.Write(pbyte, 0, 4);
                            }
                            pbyte = null;

                            fws.Close();
                            fw = null;
                            Ojw.CMessage.Write("File Convert Ok");
                            MessageBox.Show("File Convert Ok");
#else
                            #region Save SSTL
                            // 스트림 버퍼를 비운다.
                            fws.Flush();

                            byte[] pbyte;

                            // Dir
                            pbyte = BitConverter.GetBytes((int)1); fws.Write(pbyte, 0, 4);// 0 : CW , 1 : CCW
                            // Size
                            int nCnt = CAse.Data_GetCnt();
                            pbyte = BitConverter.GetBytes(nCnt); fws.Write(pbyte, 0, 4);

                            bool bInverse = false;
                            DialogResult dlgRet = MessageBox.Show("Do you want to make it upside down?", "save CCW", MessageBoxButtons.OKCancel, MessageBoxIcon.Warning);
                            if (dlgRet == DialogResult.OK)
                            {
                                bInverse = true;
                            }

                            SVector4D_t SVec;
                            for (int i = 0; i < nCnt; i++)
                            {
#if false
                                int nPos = ((bInverse == true) ? 3 * ((int)Math.Round(i / 3 + 0.6, 0)) - (i % 3) - 1 : i);//nCnt - i - 1 : i);
#else
                                int nPos = ((bInverse == true) ? nCnt - i - 1 : i);
#endif
                                SVec = CAse.Data_Get(nPos);
                                pbyte = BitConverter.GetBytes((float)SVec.x); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)SVec.y); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)SVec.z); fws.Write(pbyte, 0, 4);
                            }

                            pbyte = null;

                            fws.Close();
                            fw = null;
                            Ojw.CMessage.Write("File Convert Ok");
                            MessageBox.Show("File Convert Ok");
                            #endregion Save SSTL
#endif
                            bRet = true;
                        }
                        catch
                        {
                            //Message("File save error");
                            fws.Close();
                            fw = null;
                            bRet = false;
                        }
                    }
                    return bRet;
                }
                #endregion Convert Dat To Sstl

                #region Stl to Dat
                #region Convert Stl To Sstl
                public bool OjwFileConvert_STL_to_Dat(String strFileName)
                {
                    bool bRet = false;
                    int nTmp = 0;
                    String strName = "";
                    int nTmpAll = 0;

                    COjwAse CAse = new COjwAse();
                    CAse.Data_Clear();
                    CAse.Data_Type_Set(1);
                    #region Make Memory Data
                    try
                    {
                        int _x = 0;
                        int _y = 1;// 1;
                        int _z = 2;// 2;

                        string header;
                        FileInfo f = new FileInfo(strFileName);
                        FileStream fs_Ascii = f.OpenRead();
                        long lHeaderSize = fs_Ascii.Length;
                        byte[] byteData = new byte[lHeaderSize];

                        #region Moved by opening the file into memory(Kor: 파일을 열어서 메모리로 옮김)
                        fs_Ascii.Read(byteData, 0, (int)lHeaderSize);; // for Check 11 bytes in header
                        fs_Ascii.Close();
                        #endregion Moved by opening the file into memory(Kor: 파일을 열어서 메모리로 옮김)
                        if (Encoding.ASCII.GetString(byteData, 0, 80).IndexOf("solid ascii") >= 0)
                        {
                            Ojw.CMessage.Write("solid ascii");
                            float[] afData = new float[3];
                            float[] afPos = new float[3];
                            String[] pstrSplit = Encoding.ASCII.GetString(byteData, 0, (int)lHeaderSize).Split('\n');
                            bool bFirst = true;


                            foreach (string strLine in pstrSplit)
                            {
                                int nIndex = strLine.IndexOf("vertex");
                                if (nIndex >= 0)
                                {
                                    String[] pstrItems = strLine.Substring(nIndex + 6).Split(' ');
                                    int nPos = 0;
                                    foreach (string strItem in pstrItems)
                                    {
                                        if (strItem.Length > 0)
                                            afData[nPos++] = Ojw.CConvert.StrToFloat(strItem);
                                    }
                                    if (bFirst)
                                    {
                                        bFirst = false;
                                        afPos[_x] = afData[0];
                                        afPos[_y] = afData[1];
                                        afPos[_z] = afData[2];
                                    }
                                    else CAse.Data_Add(afData[0] - afPos[0], afData[1] - afPos[1], afData[2] - afPos[2]);
                                }
                            }
                            pstrSplit = null;
                        }
                        else
                        {
                            using (var fs = new BinaryReader(File.OpenRead(strFileName), Encoding.ASCII))
                            {
                                header = Encoding.ASCII.GetString(fs.ReadBytes(80));
                                var unCount = fs.ReadUInt32();

                                nTmpAll = (int)unCount;
                                strName = header;

                                //float fA, fB, fC;
                                byte byTmp0, byTmp1;

                                float[] afPos = new float[3];
                                Array.Clear(afPos, 0, afPos.Length);

                                float[] afTmp = new float[3];
                                for (int i = 0; i < nTmpAll; i++)
                                {
                                    nTmp++;
                                    int nMax = 4;
                                    for (int j = 0; j < nMax; j++)
                                    {
                                        afTmp[_x] = fs.ReadSingle();
                                        afTmp[_y] = fs.ReadSingle();
                                        afTmp[_z] = fs.ReadSingle();

                                        if (j == 0) // normal
                                        {
                                            continue;
                                        }
                                        else
                                        {
                                            if ((i == 0) && (j == 1))// First data
                                            {
                                                afPos[_x] = afTmp[_x];
                                                afPos[_y] = afTmp[_y];
                                                afPos[_z] = afTmp[_z];
                                            }
                                            CAse.Data_Add(afTmp[_x] - afPos[_x], afTmp[_y] - afPos[_y], afTmp[_z] - afPos[_z]);
                                        }
                                    }
                                    // unused
                                    byTmp0 = fs.ReadByte();
                                    byTmp1 = fs.ReadByte();
                                }
                            }
                        }
                        bRet = true;
                    }
                    catch (Exception e)
                    {
                        MessageBox.Show(nTmp.ToString() + "/" + nTmpAll.ToString() + " : " + strName + "=>" + e.ToString());
                        bRet = false;
                    }
                    #endregion Make Memory Data

                    if (bRet == true)
                    {
                        // Write File
                        strFileName = Ojw.CConvert.ChangeString(strFileName.ToLower(), ".stl", ".dat");
                        FileInfo fw = new FileInfo(strFileName);
                        FileStream fws = fw.Create();

                        try
                        {
                            #region Save Dat
                            // 스트림 버퍼를 비운다.
                            fws.Flush();

                            byte[] pbyte;

                            // Dir
                            pbyte = BitConverter.GetBytes((int)1); //fws.Write(pbyte, 0, 4);// 0 : CW , 1 : CCW
                            // Size
                            int nCnt = CAse.Data_GetCnt();
                            pbyte = BitConverter.GetBytes(nCnt); //fws.Write(pbyte, 0, 4);

                            bool bInverse = false;
                            DialogResult dlgRet = MessageBox.Show("Do you want to make it upside down?", "save CCW", MessageBoxButtons.OKCancel, MessageBoxIcon.Warning);
                            if (dlgRet == DialogResult.OK)
                            {
                                bInverse = true;
                            }

                            // Header(GUID) - 16 bytes
                            fws.WriteByte(0xb9); fws.WriteByte(0x8d); fws.WriteByte(0x38); fws.WriteByte(0xa7); fws.WriteByte(0x69); 
                            fws.WriteByte(0x4d); fws.WriteByte(0x84); fws.WriteByte(0x41); fws.WriteByte(0x95); fws.WriteByte(0x31);
                            fws.WriteByte(0xcb); fws.WriteByte(0xe3); fws.WriteByte(0x49); fws.WriteByte(0x0d); fws.WriteByte(0xb9); 
                            fws.WriteByte(0x7f);

                            // Header(Ver) - 4 bytes
                            fws.WriteByte(0x00); fws.WriteByte(0x01); fws.WriteByte(0x00); fws.WriteByte(0x00);
                            
                            // Header(Object Count) - 4 bytes
                            fws.WriteByte(0x01); fws.WriteByte(0x00); fws.WriteByte(0x00); fws.WriteByte(0x00);
                            
                            

                            pbyte = Ojw.CConvert.StrToBytes("test");
                            for (int i = 0; i < 32; i++)
                            {
                                if (i < pbyte.Length) fws.WriteByte(pbyte[i]);
                                else fws.WriteByte(0xfe);
                            }

                            // Texture file name
                            for (int i = 0; i < 260; i++) fws.WriteByte(0x00);

                            // Primitive type
                            fws.WriteByte(0x04); fws.WriteByte(0x00); fws.WriteByte(0x00); fws.WriteByte(0x00); // D3DPT_TRIANGLELIST

                            // vertex format
                            fws.WriteByte(0x12); fws.WriteByte(0x00); fws.WriteByte(0x00); fws.WriteByte(0x00);

                            // Primitive Count
                            //pbyte = BitConverter.GetBytes(nCnt); fws.Write(pbyte, 0, 4);
                            pbyte = BitConverter.GetBytes(24); fws.Write(pbyte, 0, 4);
                            fws.Write(pbyte, 0, 4);

                            SVector4D_t SVec;
                            for (int i = 0; i < nCnt; i++)
                            {
#if false
                                int nMul = 3;
                                int nPos = ((bInverse == true) ? nMul * ((int)Math.Round(i / nMul + 0.6, 0)) - (i % nMul) - 1 : i);
#else
                                int nPos = ((bInverse == true) ? nCnt - i - 1 : i);
#endif
                                SVec = CAse.Data_Get(nPos);
                                pbyte = BitConverter.GetBytes((float)SVec.x); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)SVec.y); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)SVec.z); fws.Write(pbyte, 0, 4);

                                // Unused
                                pbyte = BitConverter.GetBytes((float)0.0f); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)0.0f); fws.Write(pbyte, 0, 4);
                                pbyte = BitConverter.GetBytes((float)0.0f); fws.Write(pbyte, 0, 4);
                            }

                            pbyte = null;

                            fws.Close();
                            fw = null;
                            Ojw.CMessage.Write("File Convert Ok");
                            MessageBox.Show("File Convert Ok");
                            #endregion Save Dat

                            bRet = true;
                        }
                        catch
                        {
                            //Message("File save error");
                            fws.Close();
                            fw = null;
                            bRet = false;
                        }
                    }
                    return bRet;
                }
                #endregion Convert Stl To Sstl
                #endregion Str to Dat

                #region OjwLine / OjwLines
                public void OjwPoint(Color color, float fAlpha, float fX, float fY, float fZ,
                                    float fOffsetPan, float fOffsetTilt, float fOffsetSwing,    // Rotate(Offset)
                                    float fOffsetX, float fOffsetY, float fOffsetZ              // Translate(Offset)
                                    )
                {
                    m_fColor[0] = ((float)(color.R) / 255.0f);  // R
                    m_fColor[1] = ((float)(color.G) / 255.0f);  // G
                    m_fColor[2] = ((float)(color.B) / 255.0f);  // B
                    m_fColor[3] = fAlpha;
                    Gl.glColor4fv(m_fColor); // Color with an array of floats
                                        
                    Gl.glPushMatrix();
                    OjwTranslate(fOffsetX, fOffsetY, fOffsetZ);
                    OjwRotation(fOffsetPan, fOffsetTilt, fOffsetSwing);

                    int uiType = Gl.GL_POINTS;// (bFill == true) ? Gl.GL_POLYGON : Gl.GL_LINE_LOOP;//Gl.GL_LINE_LOOP;// Gl.GL_QUADS;//

                    Gl.glBegin(uiType);

                    Gl.glVertex3f(fX, fY, fZ);

                    Gl.glEnd();

                    Gl.glPopMatrix();                    
                }
                public void OjwLine(Color color, float fAlpha, float fX0, float fY0, float fZ0, float fX1, float fY1, float fZ1,
                                    float fOffsetPan, float fOffsetTilt, float fOffsetSwing,    // Rotate(Offset)
                                    float fOffsetX, float fOffsetY, float fOffsetZ              // Translate(Offset)
                                    )
                {
                    m_fColor[0] = ((float)(color.R) / 255.0f);  // R
                    m_fColor[1] = ((float)(color.G) / 255.0f);  // G
                    m_fColor[2] = ((float)(color.B) / 255.0f);  // B
                    m_fColor[3] = fAlpha;
                    Gl.glColor4fv(m_fColor); // Color with an array of floats
                                        
                    Gl.glPushMatrix();
                    OjwTranslate(fOffsetX, fOffsetY, fOffsetZ);
                    OjwRotation(fOffsetPan, fOffsetTilt, fOffsetSwing);

                    int uiType = Gl.GL_LINES;// (bFill == true) ? Gl.GL_POLYGON : Gl.GL_LINE_LOOP;//Gl.GL_LINE_LOOP;// Gl.GL_QUADS;//

                    Gl.glBegin(uiType);

                    Gl.glVertex3f(fX0, fY0, fZ0);
                    Gl.glVertex3f(fX1, fY1, fZ1);

                    Gl.glEnd();

                    Gl.glPopMatrix();                    
                }
                public void OjwPoints(Color color, float fAlpha, List<SVector3D_t> lstLines,
                                       float fOffsetPan, float fOffsetTilt, float fOffsetSwing,    // Rotate(Offset)
                                       float fOffsetX, float fOffsetY, float fOffsetZ              // Translate(Offset)
                                       )
                {
                    m_fColor[0] = ((float)(color.R) / 255.0f);  // R
                    m_fColor[1] = ((float)(color.G) / 255.0f);  // G
                    m_fColor[2] = ((float)(color.B) / 255.0f);  // B
                    m_fColor[3] = fAlpha;
                    Gl.glColor4fv(m_fColor); // Color with an array of floats

                    Gl.glPushMatrix();
                    OjwTranslate(fOffsetX, fOffsetY, fOffsetZ);
                    OjwRotation(fOffsetPan, fOffsetTilt, fOffsetSwing);

                    
                    Gl.glBegin(Gl.GL_POINTS);

                    for (int i = 1; i < lstLines.Count; i++)
                    {
                        Gl.glVertex3f(lstLines[i - 1].x, lstLines[i - 1].y, lstLines[i - 1].z);
                        Gl.glVertex3f(lstLines[i].x, lstLines[i].y, lstLines[i].z);
                    }

                    Gl.glEnd();

                    Gl.glPopMatrix();
                }
                public void OjwLines(bool bFill, Color color, float fAlpha, List<SVector3D_t> lstLines,
                                        float fOffsetPan, float fOffsetTilt, float fOffsetSwing,    // Rotate(Offset)
                                        float fOffsetX, float fOffsetY, float fOffsetZ              // Translate(Offset)
                                        )
                {
                    m_fColor[0] = ((float)(color.R) / 255.0f);  // R
                    m_fColor[1] = ((float)(color.G) / 255.0f);  // G
                    m_fColor[2] = ((float)(color.B) / 255.0f);  // B
                    m_fColor[3] = fAlpha;
                    Gl.glColor4fv(m_fColor); // Color with an array of floats

                    Gl.glPushMatrix();
                    OjwTranslate(fOffsetX, fOffsetY, fOffsetZ);
                    OjwRotation(fOffsetPan, fOffsetTilt, fOffsetSwing);

                    if (bFill == true)
                    {
                        Gl.glBegin(Gl.GL_POLYGON);
                        foreach (SVector3D_t Points in lstLines) Gl.glVertex3f(Points.x, Points.y, Points.z);
                        Gl.glEnd();
                    }
                    else
                    {
                        Gl.glBegin(Gl.GL_LINES);

                        for (int i = 1; i < lstLines.Count; i++)
                        {
                            Gl.glVertex3f(lstLines[i - 1].x, lstLines[i - 1].y, lstLines[i - 1].z);
                            Gl.glVertex3f(lstLines[i].x, lstLines[i].y, lstLines[i].z);
                        }

                        Gl.glEnd();
                    }

                    Gl.glPopMatrix();
                }
                #endregion OjwLine / OjwLines
            
                public int CalcAngle2Evd(int nAxis, float fValue)
                {
                    try
                    {
                        fValue *= ((m_CHeader.pSMotorInfo[nAxis].nMotorDir == 0) ? 1.0f : -1.0f);
                        int nData = 0;
                        //if (GetCmd_Flag_Mode(nAxis) != 0)   // Speed Control
                        //{
                        //    nData = (int)Math.Round(fValue);
                        //}
                        //else
                        //{
                        // Position Control
                        nData = (int)Math.Round(((float)m_CHeader.pSMotorInfo[nAxis].nMechMove * fValue) / m_CHeader.pSMotorInfo[nAxis].fMechAngle);
                        nData = nData + m_CHeader.pSMotorInfo[nAxis].nCenter_Evd;
                        //}

                        return nData;
                    }
                    catch
                    {
                        return 0;
                    }
                }
                public int CalcAngle2Evd_Raw(int nAxis, float fValue)
                {
                    try
                    {
                        fValue *= ((m_CHeader.pSMotorInfo[nAxis].nMotorDir == 0) ? 1.0f : -1.0f);
                        int nData = 0;
                        //if (GetCmd_Flag_Mode(nAxis) != 0)   // Speed Control
                        //{
                        //    nData = (int)Math.Round(fValue);
                        //}
                        //else
                        //{
                        // Position Control
                        nData = (int)Math.Round(((float)m_CHeader.pSMotorInfo[nAxis].nMechMove * fValue) / m_CHeader.pSMotorInfo[nAxis].fMechAngle);
                        //nData = nData + m_CHeader.pSMotorInfo[nAxis].nCenter_Evd;
                        //}

                        return nData;
                    }
                    catch
                    {
                        return 0;
                    }
                }
                public float CalcEvd2Angle(int nAxis, int nValue)
                {
                    try
                    {
                        float fValue = ((m_CHeader.pSMotorInfo[nAxis].nMotorDir == 0) ? 1.0f : -1.0f);
                        // 1024:333.3 = pulse:angle
                        float fValue2 = 0.0f;
                        //if (GetCmd_Flag_Mode(nAxis) != 0)   // Speed Control
                        //    fValue2 = (float)nValue * fValue;
                        //else                                // Position Control
                        fValue2 = (float)(((m_CHeader.pSMotorInfo[nAxis].fMechAngle * ((float)(nValue - (int)m_CHeader.pSMotorInfo[nAxis].nCenter_Evd))) / (float)m_CHeader.pSMotorInfo[nAxis].nMechMove) * fValue);
                        return fValue2;// At the end, be multiplied by the sign variable.(Kor: 마지막에 부호변수를 곱함)
                    }
                    catch
                    {
                        return 0.0f;
                    }
                }




                #endregion Collection functions of OpenGL actually draw(Kor: OpenGL을 실제로 그리는 함수 모음)

                public COjwDispAll OjwDispAll = new COjwDispAll();
                public COjwDispAll OjwDispAll_User = new COjwDispAll();
                public bool CopyDispAllClassFrom(COjwDispAll OjwDispAllSource)
                {
                    if (OjwDispAllSource != null)
                    {
                        OjwDispAll.DeleteAll();
                        if (OjwDispAllSource.GetCount() > 0)
                        {
                            for (int i = 0; i < OjwDispAllSource.GetCount(); i++)
                            {
                                OjwDispAll.AddData(OjwDispAllSource.GetData(i));
                            }
                        }
                    }
                    else OjwDispAll = OjwDispAllSource;
                    return false;
                }
            
                #region User Part
                private COjwDisp m_CDisp = new COjwDisp();
                private int m_nUserIndex = 0;
                private String AxisCheck(COjwDisp CDisp)
                {
                    if (CDisp.nAxisMoveType >= 0)
                    {
                        string strTmpCaption = "(";
                        strTmpCaption += ((CDisp.nAxisMoveType == 0) ? "[P]," : "P,");
                        strTmpCaption += ((CDisp.nAxisMoveType == 1) ? "[T]," : "T,");
                        strTmpCaption += ((CDisp.nAxisMoveType == 2) ? "[S]" : "S");
                        //strTmpCaption += ") - 축번호 : Axis" + Ojw.CConvert.IntToStr(CDisp.nName) + ((CDisp.nName < 0) ? "<동작 축 설정에 이상발견(-). 확인요망>" : "");
                        strTmpCaption += ") - Axis Number : Axis" + CConvert.IntToStr(CDisp.nName) + ((CDisp.nName < 0) ? "<Found over operation axis settings(-). Check it.>" : "");
                                
                        return strTmpCaption;
                    }
                    else
                    {
                        return String.Empty;
                    }
                }
                public void Convert_CDisp_To_String()
                {
                    Convert_CDisp_To_String(OjwVirtualDisp, ref m_CHeader.strDrawModel);
                }
                public void Convert_CDisp_To_String(COjwDisp CDisp, ref COjwDesignerHeader CHeader)
                {
                    Convert_CDisp_To_String(OjwVirtualDisp, ref CHeader.strDrawModel);
                }
                public void Convert_CDisp_To_String(COjwDisp CDisp, ref String strResult) // Convert Object To StringModelData for drawing
                {
                    String strAxisCheck = AxisCheck(CDisp);
                    String strData = ClassToString(CDisp) + (((CDisp.strCaption.Length > 0) || (strAxisCheck.Length > 0)) ? " // " : "") +
                            ((CDisp.strCaption.Length > 0) ? CDisp.strCaption : "") +
                            ((strAxisCheck.Length > 0) ? strAxisCheck : "");

                    strResult += strData + "\r\n";
#if false
                    //// 초기화
                    //User_Clear();

                    ////InterPret_DrawMessage(false);

                    //int nMotorCnt = 0;
                    //String strError = String.Empty;
                    //bool bRet = CompileDesign(m_CHeader.strDrawModel, out nMotorCnt, out strError);
                    //if (bRet == true)
                    //{
                    //    Ojw.CMessage.Write_Error(strError);
                    //}
#endif
                }
                public int User_GetCnt() { return OjwDispAll_User.GetCount(); }
                public void User_Clear() { m_nUserIndex = 0; OjwDispAll_User.DeleteAll(); }
                public void User_Add_Ex(COjwDisp CDisp) { m_nUserIndex = User_GetCnt(); OjwDispAll_User.AddData(CDisp.Clone()); }
                public void User_Add() { m_nUserIndex = User_GetCnt(); OjwDispAll_User.AddData(m_CDisp.Clone()); m_CDisp.InitData(); }
                public void User_Delete(int nIndex) { m_nUserIndex = 0; OjwDispAll_User.DeleteData(nIndex); m_CDisp.InitData(); }
                public void User_Delete() { OjwDispAll_User.DeleteData(m_nUserIndex); m_nUserIndex = 0; m_CDisp.InitData(); }
                //public COjwDisp User_Get(int nIndex) { m_nUserIndex = nIndex; m_CDisp = OjwDispAll_User.GetData(nIndex % OjwDispAll_User.GetCount()); return m_CDisp; }
                public COjwDisp User_Get(int nIndex) { m_nUserIndex = nIndex; return OjwDispAll_User.GetData(nIndex % OjwDispAll_User.GetCount()); }
                public int User_Get_Index() { return m_nUserIndex; }
                public bool User_Set(int nIndex, COjwDisp CDisp) { m_nUserIndex = nIndex; return OjwDispAll_User.SetData((nIndex % OjwDispAll_User.GetCount()), CDisp); }
                public bool User_Set() { return User_Set(m_nUserIndex, m_CDisp); }

                #region Set
                // Determine the internal handle, if (value < 0) then "No ID" => In other words, when determining the name of the OpenGL picking
                // Kor: 내부적 핸들을 결정, 단, 0보다 작으면(-) ID 없음. => 즉, OpenGL 의 픽킹 시 이름을 결정
                public void User_Set_AxisName(int nValue) { m_CDisp.nName = nValue; }
                public void User_Set_Alpha(float fValue) { m_CDisp.fAlpha = fValue; }            
                public void User_Set_Color(Color cValue) { m_CDisp.cColor = cValue; }
                public void User_Set_Model(String strValue) { m_CDisp.strDispObject = strValue; CheckObjectModelFile(strValue); } // Recording the type of data to be drawn Modeling(Kor: 그려질 모델링 데이타의 종류를 기록 - 사각형, 원형, 구, ...)
                public void User_Set_Fill(bool bValue) { m_CDisp.bFilled = bValue; }    // Determining the populate the attributes of the picture(Kor: 그림의 속을 채울지를 결정)
                public void User_Set_fMul_3DAngle(float fValue) { m_CDisp.fMulti = fValue; }
                public void User_Set_Init(bool bValue) { m_CDisp.bInit = bValue; }

                //private List<SVertex3D_t> lstPoints = new List<SVertex3D_t>();
                public void User_Set_Points_Clear() { m_CDisp.Points.Clear(); }
                public void User_Set_Points_Add(SVector3D_t SVect) { m_CDisp.Points.Add(SVect); }
                public void User_Set_Points_Add(float fX, float fY, float fZ) { m_CDisp.Points.Add(new SVector3D_t(fX, fY, fZ)); }

                public void User_Set_Width_Or_Radius(float fValue) { m_CDisp.fWidth_Or_Radius = fValue; }
                public void User_Set_Height_Or_Depth(float fValue) { m_CDisp.fHeight_Or_Depth = fValue; }
                public void User_Set_Depth_Or_Cnt(float fValue) { m_CDisp.fDepth_Or_Cnt = fValue; }
                public void User_Set_Thickness(float fValue) { m_CDisp.fThickness = fValue; }
                public void User_Set_Gap(float fValue) { m_CDisp.fGap = fValue; }
                public void User_Set_Caption(String strValue) { m_CDisp.strCaption = strValue; }
                public void User_Set_AxisMoveType(int nValue) { m_CDisp.nAxisMoveType = nValue; }
                public void User_Set_Dir(int nValue) { m_CDisp.nDir = nValue; }
                public void User_Set_Angle(float fValue) { m_CDisp.fAngle = fValue; }
                public void User_Set_Angle_Offset(string strValue) { m_CDisp.strAngle_Offset = strValue; }
                public void User_Set_Offset_Translation(float fX, float fY, float fZ) { m_CDisp.SOffset_Trans.x = fX; m_CDisp.SOffset_Trans.y = fY; m_CDisp.SOffset_Trans.z = fZ; }
                public void User_Set_Offset_Rotation(float fPan, float fTilt, float fSwing) { m_CDisp.SOffset_Rot.pan = fPan; m_CDisp.SOffset_Rot.tilt = fTilt; m_CDisp.SOffset_Rot.swing = fSwing; }
                public void User_Set_Translation(int nIndex, float fX, float fY, float fZ) { if ((nIndex >= 0) && (nIndex < m_CDisp.afTrans.Length)) { m_CDisp.afTrans[nIndex].x = fX; m_CDisp.afTrans[nIndex].y = fY; m_CDisp.afTrans[nIndex].z = fZ; } }
                public void User_Set_Rotation(int nIndex, float fPan, float fTilt, float fSwing) { if ((nIndex >= 0) && (nIndex < m_CDisp.afRot.Length)) { m_CDisp.afRot[nIndex].pan = fPan; m_CDisp.afRot[nIndex].tilt = fTilt; m_CDisp.afRot[nIndex].swing = fSwing; } }
                public void User_Set_nPickGroup_A(int nValue) { m_CDisp.nPickGroup_A = nValue; }
                public void User_Set_nPickGroup_B(int nValue) { m_CDisp.nPickGroup_B = nValue; }
                public void User_Set_nPickGroup_C(int nValue) { m_CDisp.nPickGroup_C = nValue; }
                public void User_Set_nInverseKinematicsNumber(int nValue) { m_CDisp.nInverseKinematicsNumber = nValue; }
                public void User_Set_nInverseKinematicsNumber_AfterCalc(int nValue) { m_CDisp.nInverseKinematicsNumber_AfterCalc = nValue; }
                public void User_Set_fScale_Serve0(float fValue) { m_CDisp.fScale_Serve0 = fValue; }
                public void User_Set_fScale_Serve1(float fValue) { m_CDisp.fScale_Serve1 = fValue; }
                public void User_Set_nMotorType(int nValue) { m_CDisp.nMotorType = nValue; }
                public void User_Set_nMotorControl_MousePoint(int nValue) { m_CDisp.nMotorControl_MousePoint = nValue; }
                public void User_Set_strPickGroup_Comment(String strValue) { m_CDisp.strPickGroup_Comment = strValue; }
                #endregion Set

                #region Get
                // Determine the internal handle, if (value < 0) then "No ID" => In other words, when determining the name of the OpenGL picking
                // Kor: 내부적 핸들을 결정, 단, 0보다 작으면(-) ID 없음. => 즉, OpenGL 의 픽킹 시 이름을 결정
                public int User_Get_AxisName() { return m_CDisp.nName; }
                public Color User_Get_Color() { return m_CDisp.cColor; }
                public String User_Get_DispObject() { return m_CDisp.strDispObject; }
                public String User_Get_Model() { return m_CDisp.strDispObject; }
                public bool User_Get_Fill() { return m_CDisp.bFilled; }
                public float User_Get_fMul_3DAngle() { return m_CDisp.fMulti; }
                public bool User_Get_Init() { return m_CDisp.bInit; }

                public float User_Get_Width_Or_Radius() { return m_CDisp.fWidth_Or_Radius; }
                public float User_Get_Height_Or_Depth() { return m_CDisp.fHeight_Or_Depth; }
                public float User_Get_Depth_Or_Cnt() { return m_CDisp.fDepth_Or_Cnt; }
                public float User_Get_Thickness() { return m_CDisp.fThickness; }
                public float User_Get_Gap() { return m_CDisp.fGap; }
                public String User_Get_Caption() { return m_CDisp.strCaption; }
                public int User_Get_AxisMoveType() { return m_CDisp.nAxisMoveType; }
                public int User_Get_Dir() { return m_CDisp.nDir; }
                public float User_Get_Angle() { return m_CDisp.fAngle; }
                public string User_Get_Angle_Offset() { return m_CDisp.strAngle_Offset; }
                public SVector3D_t User_Get_Offset_Translation() { return m_CDisp.SOffset_Trans; }
                public SAngle3D_t User_Get_Offset_Rotation() { return m_CDisp.SOffset_Rot; }
                public SVector3D_t User_Get_Translation(int nIndex) { return m_CDisp.afTrans[nIndex % m_CDisp.afTrans.Length]; }
                public SAngle3D_t User_Get_Rotation(int nIndex) { return m_CDisp.afRot[nIndex % m_CDisp.afRot.Length]; }
                public int User_Get_nPickGroup_A() { return m_CDisp.nPickGroup_A; }
                public int User_Get_nPickGroup_B() { return m_CDisp.nPickGroup_B; }
                public int User_Get_nPickGroup_C() { return m_CDisp.nPickGroup_C; }
                public int User_Get_nInverseKinematicsNumber() { return m_CDisp.nInverseKinematicsNumber; }
                public float User_Get_fScale_Serve0() { return m_CDisp.fScale_Serve0; }
                public float User_Get_fScale_Serve1() { return m_CDisp.fScale_Serve1; }
                public int User_Get_nMotorType() { return m_CDisp.nMotorType; }
                public int User_Get_nMotorControl_MousePoint() { return m_CDisp.nMotorControl_MousePoint; }
                public String User_Get_strPickGroup_Comment() { return m_CDisp.strPickGroup_Comment; }
                #endregion Get
                #endregion User Part

                #region Header
                #region Set
                public void SetHeader_bDisplay_Axis(bool bValue) { m_CHeader.bDisplay_Axis = bValue; }
                public void SetHeader_bDisplay_Invisible(bool bValue) { m_CHeader.bDisplay_Invisible = bValue; }
                public void SetHeader_bDisplay_Light(bool bValue) { m_CHeader.bDisplay_Light = bValue; }
                public void SetHeader_cBackColor(Color cValue) { m_CHeader.cBackColor = cValue; }
                public void SetHeader_fInitScale(float fValue) { m_CHeader.fInitScale = fValue; }
                public void SetHeader_nModelNum(int nValue) { m_CHeader.nModelNum = nValue; }
                public void SetHeader_strModelNum(String strValue) { m_CHeader.strModelNum = strValue; }
                public void SetHeader_nMotorCnt(int nValue) { m_CHeader.nMotorCnt = nValue; }
                public void SetHeader_nVersion(int nValue) { m_CHeader.nVersion = nValue; }
                public void SetHeader_nWheelCounter_2(int nValue) { m_CHeader.nWheelCounter_2 = nValue; }
                public void SetHeader_nWheelCounter_3(int nValue) { m_CHeader.nWheelCounter_3 = nValue; }
                public void SetHeader_nWheelCounter_4(int nValue) { m_CHeader.nWheelCounter_4 = nValue; }
                //public CDhParamAll[] SetHeader_pDhParamAll() { m_CHeader.pDhParamAll = bValue; } //
                //public int[] SetHeader_pnSecret() { m_CHeader.pnSecret = bValue; }
                //public int[] SetHeader_pnType() { m_CHeader.pnType = bValue; }
                //public SEncryption_t[] GetHeader_pSEncryptInverseKinematics_encryption() { m_CHeader.pSEncryptInverseKinematics_encryption = bValue; }
                //public SEncryption_t[] GetHeader_pSEncryptKinematics_encryption() { m_CHeader.pSEncryptKinematics_encryption = bValue; }
                public void SetHeader_pSMotorInfo(int nAxis, SMotorInfo_t value) { m_CHeader.pSMotorInfo[nAxis] = value; }
                //public SOjwCode_t[] GetHeader_pSOjwCode() { m_CHeader.pSOjwCode = bValue; }
                //public String[] GetHeader_pstrGroupName() { m_CHeader.pstrGroupName = bValue; }
                //public String[] GetHeader_pstrInverseKinematics() { m_CHeader.pstrInverseKinematics = bValue; }
                //public String[] GetHeader_pstrKinematics() { m_CHeader.pstrKinematics = bValue; }
                public void SetHeader_SInitAngle(SAngle3D_t SValue) { m_CHeader.SInitAngle = SValue; }
                public void SetHeader_SInitPos(SVector3D_t SValue) { m_CHeader.SInitPos = SValue; }
                public void SetHeader_strComment(String strValue) { m_CHeader.strComment = strValue; }
                public void SetHeader_strDrawModel(String strValue) { m_CHeader.strDrawModel = strValue; }
                public void AddHeader_strDrawModel(String strValue)
                {
#if false
                    String str = CConvert.RemoveChar((String)m_CHeader.strDrawModel.Clone(), ' ');
                    //if (str.Length > 2)
                    if ((str.Length > 0) && ((str.Length - 1) == str.IndexOf('\n')))
                        m_CHeader.strDrawModel += "\r\n";

                    m_CHeader.strDrawModel += strValue;       
#else
                    String strDraw = String.Empty;
                    foreach (String strItem in m_rtxtDraw.Lines) strDraw += strItem + "\r\n";
                    strDraw += strValue; // 마지막 줄에 추가
                    m_CHeader.strDrawModel = strDraw;
#endif
                }
                public void InsertHeader_strDrawModel(int nLine, String strValue)
                {
                    String strDraw = String.Empty;
                    int nPos = 0;
                    foreach (String strItem in m_rtxtDraw.Lines)
                    {
                        if (nPos != 0) strDraw += "\r\n";
                        if (nLine == nPos++) strDraw += strValue;
                        else strDraw += strItem;
                    }
                    m_CHeader.strDrawModel = strDraw;
                }
                public void SetTitle_strTitle(String strValue) { m_CHeader.strTitle = strValue; }
                public void SetHeader_strModelName(String strValue) { m_CHeader.strModelName = strValue; }
                public void SetHeader_strVersion(String strValue) { m_CHeader.strVersion = strValue; }
                #endregion Set
                #region Get
                public COjwDesignerHeader GetHeader() { return m_CHeader; }
                public bool GetHeader_bDisplay_Axis() { return m_CHeader.bDisplay_Axis; }
                public bool GetHeader_bDisplay_Invisible() { return m_CHeader.bDisplay_Invisible; }
                public bool GetHeader_bDisplay_Light() { return m_CHeader.bDisplay_Light; }
                public Color GetHeader_cBackColor() { return m_CHeader.cBackColor; }
                public float GetHeader_fInitScale() { return m_CHeader.fInitScale; }
                public int GetHeader_nModelNum() { return m_CHeader.nModelNum; }
                public String GetHeader_strModelNum() { return m_CHeader.strModelNum; }
                public int GetHeader_nMotorCnt() { return m_CHeader.nMotorCnt; }
                public int GetHeader_nVersion() { return m_CHeader.nVersion; }
                public int GetHeader_nWheelCounter_2() { return m_CHeader.nWheelCounter_2; }
                public int GetHeader_nWheelCounter_3() { return m_CHeader.nWheelCounter_3; }
                public int GetHeader_nWheelCounter_4() { return m_CHeader.nWheelCounter_4; }
                public CDhParamAll[] GetHeader_pDhParamAll() { return m_CHeader.pDhParamAll; } //
                public int[] GetHeader_pnSecret() { return m_CHeader.pnSecret; }
                public int[] GetHeader_pnType() { return m_CHeader.pnType; }
                public bool[] GetHeader_pbPython() { return m_CHeader.pbPython; }
                public SEncryption_t[] GetHeader_pSEncryptInverseKinematics_encryption() { return m_CHeader.pSEncryptInverseKinematics_encryption; }
                public SEncryption_t[] GetHeader_pSEncryptKinematics_encryption() { return m_CHeader.pSEncryptKinematics_encryption; }
                public SMotorInfo_t[] GetHeader_pSMotorInfo() { return m_CHeader.pSMotorInfo; }
                public SMotorInfo_t GetHeader_pSMotorInfo(int nAxis) { return m_CHeader.pSMotorInfo[nAxis]; }
                public SOjwCode_t[] GetHeader_pSOjwCode() { return m_CHeader.pSOjwCode; }
                public String[] GetHeader_pstrGroupName() { return m_CHeader.pstrGroupName; }
                public String[] GetHeader_pstrInverseKinematics() { return m_CHeader.pstrInverseKinematics; }
                public String[] GetHeader_pstrKinematics() { return m_CHeader.pstrKinematics; }
                public SAngle3D_t GetHeader_SInitAngle() { return m_CHeader.SInitAngle; }
                public SVector3D_t GetHeader_SInitPos() { return m_CHeader.SInitPos; }
                public String GetHeader_strComment() { return m_CHeader.strComment; }
                public String GetHeader_strDrawModel() { return m_CHeader.strDrawModel; }
                public String GetHeader_strModelName() { return m_CHeader.strModelName; }
                public String GetHeader_strTitle() { return m_CHeader.strTitle; }
                public String GetHeader_strVersion() { return m_CHeader.strVersion; }
                #endregion Get
                #endregion Header

                public bool CompileDesign()
                {
                    String strError = String.Empty;
                    return CompileDesign(m_CHeader.strDrawModel, out m_CHeader.nMotorCnt, out m_CHeader.anMotorIDs, out strError);
                }
                private string m_strAseFilePath = "\\";
                public void SetAseFile_Path(String strPath)
                {
                    m_strAseFilePath = ("\\" + strPath.Trim('\\') + "\\");
                }//("\\" + strPath.Trim('\\') + "\\"); }
                public string GetAseFile_Path() { return m_strAseFilePath; }
                private int m_nSeq_Compile = 0;
                private int m_nSeq_Compile_Back = 0;
                private int[] m_pnName_List = null; 
                public bool CompileDesign(String strDraw, out int nMotorCount, out int [] anMotorIDs, out String strError)
                {
                    List<int> lstnMotors = new List<int>();
                    lstnMotors.Clear();

                    bool bRet = true;
                    strError = "";
                    nMotorCount = 0;

                    OjwDispAll.DeleteAll();
                    COjwDisp[] pCDisp;
                    TextBox txtDraw = new TextBox();
                    txtDraw.Text = strDraw;
                    TextBox_To_CodeString(txtDraw, out pCDisp);
                    txtDraw = null;
                    if (pCDisp != null)
                    {
                        bool bDuplication = false;
                        bool bInsufficient = false;
                        int nName_Max = 0;
                        int nName_Cnt = 0;
                        m_pnName_List = new int[1];
                        //int[] pnName_List = new int[1];
                        for (int i = 0; i < pCDisp.Length; i++)
                        {
                            // if you never had loaded ase files, you need to load it in here
                            if (pCDisp[i].strDispObject.Length > 0)
                            {
                                if (pCDisp[i].strDispObject.IndexOf('#') < 0)
                                {
                                    if (OjwAse_GetIndex(pCDisp[i].strDispObject) < 0)
                                    {
                                        //this.Cursor = System.Windows.Forms.Cursors.WaitCursor;
                                        String strFile = pCDisp[i].strDispObject;
                                        if ((strFile.IndexOf('?') >= 0) || (strFile.IndexOf('/') >= 0))
                                        //if ((strFile.IndexOf('?') >= 0) || (strFile.IndexOf('/') >= 0) || (strFile.IndexOf('!') >= 0))
                                        {
                                            strFile = strFile.Substring(1);
                                        }
#if _CHANGE_DEFAULT_FROM_ASE_TO_DAT
                                        String strFileName = Application.StartupPath.Trim('\\') + GetAseFile_Path() + strFile + ((strFile.IndexOf('.') < 0) ? ".dat" : "");
#else
                                        String strFileName = Application.StartupPath.Trim('\\') + GetAseFile_Path() + strFile + ((strFile.IndexOf('.') < 0) ? ".ase" : "");
#endif
                                        FileInfo f;
                                        int nOld = strFileName.LastIndexOf('*');
                                        //MessageBox.Show(strFileName + "," + strFileName.Length.ToString() + ',' + nOld.ToString());
                                        if (nOld == strFileName.Length - 1) f = new FileInfo(strFileName.Substring(0, strFileName.Length - 1));
                                        else f = new FileInfo(strFileName);
                                        if (f.Exists == true)
                                        {
                                            if (CFile.GetExe(strFileName).ToUpper() == "ASE")
                                                OjwFileOpen_3D_ASE(strFileName);
                                            else if (CFile.GetExe(strFileName).ToUpper() == "SSTL")
                                                OjwFileOpen_3D_SSTL(strFileName);
                                            else if ((CFile.GetExe(strFileName).ToUpper() == "STL") || (CFile.GetExe(strFileName).ToUpper() == "STL*"))
                                                OjwFileOpen_3D_STL(strFileName);                                            
                                            else if (CFile.GetExe(strFileName).ToUpper() == "DAT")
                                                OjwFileOpen_3D_Dat(strFileName);
                                            else if (CFile.GetExe(strFileName).ToUpper() == "OBJ")
                                                OjwFileOpen_3D_OBJ(strFileName);

                                        }

                                        //this.Cursor = System.Windows.Forms.Cursors.Default;
                                    }
                                }
                            }

                            if (pCDisp[i].nName >= 0)
                            {
                                bDuplication = false;
                                for (int j = 0; j < nName_Cnt; j++)
                                {
                                    if (pCDisp[i].nName == m_pnName_List[j]) bDuplication = true; // Find duplicates(Kor: 중복 발견)                            
                                }
                                if (bDuplication == false)
                                {
                                    Array.Resize<int>(ref m_pnName_List, nName_Cnt + 1);
                                    m_pnName_List[nName_Cnt++] = pCDisp[i].nName;
                                }
                                if (lstnMotors.Exists(x => x == pCDisp[i].nName) == false)
                                {
                                    lstnMotors.Add(pCDisp[i].nName);
                                }
                                if (pCDisp[i].nName > nName_Max)
                                {
                                    //lstnMotors.Add(pCDisp[i].nName);
                                    nName_Max = pCDisp[i].nName;    // Check the number of the entire motor.(Kor: 전체 모터의 갯수를 파악)
                                }
                            }
                            OjwDispAll.AddData(pCDisp[i]);
                        }
                        if (nName_Cnt != (nName_Max + 1)) bInsufficient = true;                 // The number of motor error(The number of motor inconsistency)(Kor: 모터의 갯수가 모자람 (모터의 Max Number 와 갯수가 불일치))

                        //// 
#if false
#if false
                        nMotorCount = nName_Cnt;
#else
                        if (nName_Cnt != nName_Max + 1)
                        {
                            if (MessageBox.Show(String.Format("Motor Count [{0}] != nTop motor Number + 1 [{1}], Do you want to change your motor count?", nName_Cnt, nName_Max + 1), "Motor Count", MessageBoxButtons.YesNo) == DialogResult.Yes)
                            {
                                string strMotor = (nName_Max + 1).ToString();
                                if (Ojw.CInputBox.Show("Input your new motor Count", String.Format("nName_Cnt={0}, nName_Max + 1={1}", nName_Cnt, nName_Max + 1), ref strMotor) == DialogResult.OK)
                                    nMotorCount = Ojw.CConvert.StrToInt(strMotor);
                                else nMotorCount = nName_Cnt;
                            }
                            else nMotorCount = nName_Cnt;
                        }
                        else nMotorCount = nName_Cnt;
#endif
#else
                        //nMotorCount = nName_Max + 1;
#endif
                        //if ((bInsufficient == true) || (bDuplication == true))
                        if (bInsufficient == true)
                        {
                            //bRet = false; // 모터개수 맞지 않을 경우 에러
                            //strError = "[Warning] 모터의 번호 확인요망" + ((bInsufficient == true) ? ", 갯수 모자름" : "") + ((bDuplication == true) ? ", 모터 번호 중복 발견" : "");
                            //strError = "[Warning] 모터의 번호 확인요망" + ((bInsufficient == true) ? ", 갯수 모자름" : "");
                            strError = "[Warning] Check the motor ID" + ((bInsufficient == true) ? ", The number of the motor is not consistent." : "");
                        }
                        else strError = "The number of motor coincide.";
                        //else strError = "모터 갯수 이상없음";

                        m_strNoLoaded_ModelingFile = String.Empty;
                        // 컴파일 운영시 카운터 증가
                        m_nSeq_Compile_Back = m_nSeq_Compile;
                        m_nSeq_Compile++;
                    }
                    pCDisp = null;
                    lstnMotors.Sort();
                    anMotorIDs = lstnMotors.ToArray();
                    nMotorCount = lstnMotors.Count;


                    GenerateMotionID();

                    Make_GroupInfo();

                    // 컴파일 이벤트 발생
                    Event_Compile.RunEvent();

                    return bRet;
                }
                //public bool CompileDesign(String strDraw, out int nMotorCount, out String strError)
                //{
                //    int[] anMotors;
                //    return CompileDesign(strDraw, out nMotorCount, out anMotors, out strError);
                //}
                //public bool CompileDesign(String strDraw, out COjwDispAll CDispAll, out int nMotorCount, out String strError)
                //{
                //    int [] anMotors;
                //    return CompileDesign(strDraw, out CDispAll, out nMotorCount, out anMotors, out strError);
                //}
                public bool CompileDesign(String strDraw, out COjwDispAll CDispAll, out int nMotorCount, out int [] anMotorIDs, out String strError)
                {
                    List<int> lstnMotors = new List<int>();
                    lstnMotors.Clear();
                    bool bRet = true;
                    strError = "";
                    nMotorCount = 0;
                    CDispAll = new COjwDispAll();
                    CDispAll.DeleteAll();
                    COjwDisp[] pCDisp;
                    TextBox txtDraw = new TextBox();
                    txtDraw.Text = strDraw;
                    TextBox_To_CodeString(txtDraw, out pCDisp);
                    txtDraw = null;
                    if (pCDisp != null)
                    {
                        bool bDuplication = false;
                        bool bInsufficient = false;
                        int nName_Max = 0;
                        int nName_Cnt = 0;
                        m_pnName_List = new int[1];
                        //int[] pnName_List = new int[1];
                        for (int i = 0; i < pCDisp.Length; i++)
                        {
                            // if you never had loaded ase files, you need to load it in here
                            if (pCDisp[i].strDispObject.Length > 0)
                            {
                                if (pCDisp[i].strDispObject.IndexOf('#') < 0)
                                {
                                    if (OjwAse_GetIndex(pCDisp[i].strDispObject) < 0)
                                    {
                                        //this.Cursor = System.Windows.Forms.Cursors.WaitCursor;
                                        String strFile = pCDisp[i].strDispObject;
                                        if ((strFile.IndexOf('?') >= 0) || (strFile.IndexOf('/') >= 0))
                                        //if ((strFile.IndexOf('?') >= 0) || (strFile.IndexOf('/') >= 0) || (strFile.IndexOf('!') >= 0))
                                        {
                                            strFile = strFile.Substring(1);
                                        }
#if _CHANGE_DEFAULT_FROM_ASE_TO_DAT
                                        String strFileName = Application.StartupPath.Trim('\\') + GetAseFile_Path() + strFile + ((strFile.IndexOf('.') < 0) ? ".dat" : "");
#else
                                        String strFileName = Application.StartupPath.Trim('\\') + GetAseFile_Path() + strFile + ((strFile.IndexOf('.') < 0) ? ".ase" : "");
#endif
                                        FileInfo f;
                                        int nOld = strFileName.LastIndexOf('*');
                                        //MessageBox.Show(strFileName + "," + strFileName.Length.ToString() + ',' + nOld.ToString());
                                        if (nOld == strFileName.Length - 1) f = new FileInfo(strFileName.Substring(0, strFileName.Length - 1));
                                        else f = new FileInfo(strFileName);
                                        if (f.Exists == true)
                                        {
                                            if (CFile.GetExe(strFileName).ToUpper() == "ASE")
                                                OjwFileOpen_3D_ASE(strFileName);
                                            else if (CFile.GetExe(strFileName).ToUpper() == "SSTL")
                                                OjwFileOpen_3D_SSTL(strFileName);
                                            else if ((CFile.GetExe(strFileName).ToUpper() == "STL") || (CFile.GetExe(strFileName).ToUpper() == "STL*"))
                                                OjwFileOpen_3D_STL(strFileName);                                                                             
                                            else if (CFile.GetExe(strFileName).ToUpper() == "DAT")
                                                OjwFileOpen_3D_Dat(strFileName);
                                            else if (CFile.GetExe(strFileName).ToUpper() == "OBJ")
                                                OjwFileOpen_3D_OBJ(strFileName);

                                        }

                                        //this.Cursor = System.Windows.Forms.Cursors.Default;
                                    }
                                }
                            }

                            if (pCDisp[i].nName >= 0)
                            {
                                bDuplication = false;
                                for (int j = 0; j < nName_Cnt; j++)
                                {
                                    if (pCDisp[i].nName == m_pnName_List[j]) bDuplication = true; // Find duplicates(Kor: 중복 발견)                            
                                }
                                if (bDuplication == false)
                                {
                                    Array.Resize<int>(ref m_pnName_List, nName_Cnt + 1);
                                    m_pnName_List[nName_Cnt++] = pCDisp[i].nName;
                                }
                                if (lstnMotors.Exists(x => x == pCDisp[i].nName) == false)
                                {
                                    lstnMotors.Add(pCDisp[i].nName);
                                }
                                if (pCDisp[i].nName > nName_Max)
                                {
                                    nName_Max = pCDisp[i].nName;    // Check the number of the entire motor.(Kor: 전체 모터의 갯수를 파악)
                                }
                            }
                            CDispAll.AddData(pCDisp[i]);
                        }
                        if (nName_Cnt != (nName_Max + 1)) bInsufficient = true;                 // The number of motor error(The number of motor inconsistency)(Kor: 모터의 갯수가 모자람 (모터의 Max Number 와 갯수가 불일치))

                        //// 
#if false
#if false
                        nMotorCount = nName_Cnt;
#else
                        if (nName_Cnt != nName_Max + 1)
                        {
                            if (MessageBox.Show(String.Format("Motor Count [{0}] != nTop motor Number + 1 [{1}], Do you want to change your motor count?", nName_Cnt, nName_Max + 1), "Motor Count", MessageBoxButtons.YesNo) == DialogResult.Yes)
                            {
                                string strMotor = (nName_Max + 1).ToString();
                                if (Ojw.CInputBox.Show("Input your new motor Count", String.Format("nName_Cnt={0}, nName_Max + 1={1}", nName_Cnt, nName_Max + 1), ref strMotor) == DialogResult.OK)
                                    nMotorCount = Ojw.CConvert.StrToInt(strMotor);
                                else nMotorCount = nName_Cnt;
                            }
                            else nMotorCount = nName_Cnt;
                        }
                        else nMotorCount = nName_Cnt;
#endif
#else
                        //nMotorCount = nName_Cnt; //nMotorCount = nName_Max + 1;
                        nMotorCount = nName_Max + 1;
#endif
                        //if ((bInsufficient == true) || (bDuplication == true))
                        if (bInsufficient == true)
                        {
                            //bRet = false; // 모터개수 맞지 않을 경우 에러
                            //strError = "[Warning] 모터의 번호 확인요망" + ((bInsufficient == true) ? ", 갯수 모자름" : "") + ((bDuplication == true) ? ", 모터 번호 중복 발견" : "");
                            //strError = "[Warning] 모터의 번호 확인요망" + ((bInsufficient == true) ? ", 갯수 모자름" : "");
                            strError = "[Warning] Check the motor ID" + ((bInsufficient == true) ? ", The number of the motor is not consistent." : "");
                        }
                        else strError = "The number of motor coincide.";
                        //else strError = "모터 갯수 이상없음";

                        m_strNoLoaded_ModelingFile = String.Empty;
                        // 컴파일 운영시 카운터 증가
                        m_nSeq_Compile_Back = m_nSeq_Compile;
                        m_nSeq_Compile++;
                    }
                    pCDisp = null;
                    anMotorIDs = lstnMotors.ToArray();


                    GenerateMotionID();


                    // 컴파일 이벤트 발생
                    Event_Compile.RunEvent();

                    return bRet;
                }
                //}
            #endregion CsGL Class / The actual drawing and initialization functions are all based here.(Kor: CsGL Class / 실제 그리기 및 초기화(즉, Main) 함수 모음)
            private void GenerateMotionID()
            {
                #region Motor ID Arrange
                List<int> lstIDs = new List<int>();
                lstIDs.Clear();
                int nAxis, nIndex;
                m_lstIDs_Motion.Clear();
                for (nIndex = 0; nIndex < m_CHeader.nMotorCnt; nIndex++)
                {
                    nAxis = m_CHeader.anMotorIDs[nIndex];
                    if ((m_CHeader.pSMotorInfo[nAxis].nMotor_Enable < 0) || (m_CHeader.pSMotorInfo[nAxis].nMotor_Enable > 1)) continue;
                    int nID = m_CHeader.pSMotorInfo[nAxis].nMotionEditor_Index;
                    if (nID != 0)
                    {
                        m_lstIDs_Motion.Add(nID);
                    }
                    else lstIDs.Add(nAxis);
                }
                bool bSet = false;
                do
                {
                    bSet = false;
                    int nValue;
                    int nValue2;
                    for (nIndex = 1; nIndex < m_lstIDs_Motion.Count; nIndex++)
                    {
                        int nID = m_lstIDs_Motion[nIndex - 1];
                        nValue = m_CHeader.pSMotorInfo[nID].nMotionEditor_Index;
                        int nID2 = m_lstIDs_Motion[nIndex];
                        nValue2 = m_CHeader.pSMotorInfo[nID2].nMotionEditor_Index;
                        if (nValue > nValue2)
                        {
                            m_lstIDs_Motion[nIndex - 1] = m_lstIDs_Motion[nIndex];
                            m_lstIDs_Motion[nIndex] = nID;
                            bSet = true;
                        }
                    }
                }
                while (bSet);
                m_lstIDs_Motion.AddRange(lstIDs);
                #endregion Motor ID Arrange
            }
            public void SetFunctionNumber(int nNum)
            {
                //m_CHeader.nDefaultFunctionNumber = m_CPropAll.nMain_DefaultFunctionNum = m_nFunctionNumber = nNum;
                m_CHeader.nDefaultFunctionNumber = m_CPropAll.nMain_DefaultFunctionNum = nNum;
            }
            public int GetFunctionNumber() { return m_CHeader.nDefaultFunctionNumber; }// m_nFunctionNumber; }

            public class COjwFileList
            {
                private int m_nCnt;
                private String[] m_pstrFileList;
                private int[] m_pnModelNumber;
                private String[] m_pstrModelName;
                #region Init/Resize
                public COjwFileList()
                {
                    Init(0);
                }
                public COjwFileList(int nCnt)
                {
                    Init(nCnt);
                }
                public void Init()
                {
                    Init(0);
                }
                public void Init(int nCnt)
                {

                    m_nCnt = nCnt;
                    if (nCnt == 0)
                    {
                        m_pstrFileList = null;
                        m_pnModelNumber = null;
                        m_pstrModelName = null;
                    }
                    else
                    {
                        m_pstrFileList = new String[nCnt];
                        m_pnModelNumber = new int[nCnt];
                        m_pstrModelName = new String[nCnt];
                    }
                }
                private void Resize(int nCnt)
                {
                    if (nCnt > 0)
                    {
                        if (nCnt != m_nCnt)
                        {
                            Array.Resize<String>(ref m_pstrFileList, nCnt);
                            Array.Resize<int>(ref m_pnModelNumber, nCnt);
                            Array.Resize<String>(ref m_pstrModelName, nCnt);
                            m_nCnt = nCnt;
                        }
                    }
                }
                #endregion Init/Resize
                #region use
                public bool Add(FileInfo fileInfo)
                {
                    FileStream fs = null;
                    int nCnt = m_nCnt;
                    try
                    {
                        int i = m_nCnt++;
                        Array.Resize<String>(ref m_pstrFileList, m_nCnt);
                        Array.Resize<int>(ref m_pnModelNumber, m_nCnt);
                        Array.Resize<String>(ref m_pstrModelName, m_nCnt);
                        m_pstrFileList[i] = fileInfo.FullName;


                        FileInfo f = new FileInfo(fileInfo.FullName);
                        fs = f.OpenRead();

                        byte[] byteData = new byte[fs.Length];

                        #region Moved by opening the file into memory(Kor: 파일을 열어서 메모리로 옮김)
                        fs.Read(byteData, 0, byteData.Length);
                        fs.Close();
                        #endregion Moved by opening the file into memory(Kor: 파일을 열어서 메모리로 옮김)

                        int nPos = 6;   // for header 'HMT1.1' (Kor: 앞의 6개는 'HMT1.1' 에 할당)

                        #region Model type ( 2 Bytes )
                        m_pnModelNumber[i] = (int)(short)(BitConverter.ToInt16(byteData, nPos));
                        nPos += 2;
                        #endregion Model type  ( 2 Bytes )

                        #region Title ( 21 Bytes )
                        m_pstrModelName[i] = Encoding.Default.GetString(byteData, nPos, 21);
                        //nPos += 21;
                        #endregion Title ( 21 Bytes )

                        byteData = null;

                        return true;
                    }
                    catch
                    {
                        m_nCnt = nCnt;
                        if (fs != null) fs.Close();
                        return false;
                    }
                }
                public int Get_Size()
                {
                    return m_nCnt;
                }
                public bool IsValid(int nIndex)
                {
                    if ((nIndex >= 0) && (nIndex < m_nCnt))
                    {
                        if (m_pstrFileList != null)
                        {
                            if (m_pstrFileList.Length >= m_nCnt)
                            {
                                if (m_pnModelNumber != null)
                                {
                                    if (m_pnModelNumber.Length >= m_nCnt)
                                    {
                                        if (m_pstrModelName != null)
                                        {
                                            if (m_pstrModelName.Length >= m_nCnt) return true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return false;
                }

                #region Find information as stored procedure(Kor: 저장된 순서대로 정보찾기)
                public String Get_FileName(int nIndex)
                {
                    if (IsValid(nIndex) == true)
                    {
                        return m_pstrFileList[nIndex];
                    }
                    return null;
                }
                public int Get_Model_Number(int nIndex)
                {
                    if (IsValid(nIndex) == true)
                    {
                        return m_pnModelNumber[nIndex];
                    }
                    return -1;
                }
                public String Get_Model_Name(int nIndex)
                {
                    if (IsValid(nIndex) == true)
                    {
                        return m_pstrModelName[nIndex];
                    }
                    return null;
                }
                #endregion Find information as stored procedure(Kor: 저장된 순서대로 정보찾기)

                #region Find information to Model Number(Kor: Model Number로 정보찾기)
                public String Get_FileName_by_Model_Number(int nModelNumber)
                {
                    int nCnt = Get_Size();
                    int nNum;
                    for (int i = 0; i < nCnt; i++)
                    {
                        nNum = Get_Model_Number(i);
                        if (nNum == nModelNumber)
                        {
                            return Get_FileName(i);
                        }
                    }
                    return null;
                }
                public String Get_Model_Name_by_Model_Number(int nModelNumber)
                {
                    int nCnt = Get_Size();
                    int nNum;
                    for (int i = 0; i < nCnt; i++)
                    {
                        nNum = Get_Model_Number(i);
                        if (nNum == nModelNumber)
                        {
                            return Get_Model_Name(i);
                        }
                    }
                    return null;
                }
                #endregion Find information to Model Number(Kor: Model Number로 정보찾기)

                #region Find information to Model Name(Kor: Model Name으로 정보찾기)
                public String Get_FileName_by_Model_Name(String strModelName)
                {
                    int nCnt = Get_Size();
                    String strTmp;
                    for (int i = 0; i < nCnt; i++)
                    {
                        strTmp = Get_Model_Name(i);
                        if (strTmp == strModelName)
                        {
                            return Get_FileName(i);
                        }
                    }
                    return null;
                }
                public int Get_Model_Number_by_Model_Name(String strModelName)
                {
                    int nCnt = Get_Size();
                    String strTmp;
                    for (int i = 0; i < nCnt; i++)
                    {
                        strTmp = Get_Model_Name(i);
                        if (strTmp == strModelName)
                        {
                            return Get_Model_Number(i);
                        }
                    }
                    return -1;
                }
                #endregion Find information to Model Name(Kor: Model Name으로 정보찾기)

                #endregion use
                //public void Add(
            }


            #region Json
            public bool Json_Export(string strFileName)
            {
                string strTitle = m_CHeader.strTitle;//m_CHeader.strModelName;

                List<string> lstGuide = new List<string>();
                lstGuide.Clear();
                int nID;
                List<int> lstGroupIndex = new List<int>();
                lstGroupIndex.Clear();
                if (m_CHeader.anMotorIDs == null)
                {
                    return false;
                }
                for (int i = 0; i < m_CHeader.anMotorIDs.Length; i++)
                {
                    nID = m_CHeader.anMotorIDs[i];
                    // OnGuide_Name
                    lstGuide.Add(m_CHeader.pSMotorInfo[nID].strNickName);
                    // OnGuide_ID
                    lstGuide.Add(Ojw.CConvert.IntToStr(nID));
                    // OnGuide_Event
                    lstGuide.Add(Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[nID].nGuide_Event));
                    // OnGuide_AxisType
                    lstGuide.Add(Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[nID].nGuide_AxisType));
                    // OnGuide_RingColorType
                    lstGuide.Add(Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[nID].nGuide_RingColorType));
                    // OnGuide_RingSize
                    lstGuide.Add(Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[nID].fGuide_RingSize));
                    // OnGuide_RingThick
                    lstGuide.Add(Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[nID].fGuide_RingThick));
                    // OnGuide_RingDir(1[F],-1[B])
                    lstGuide.Add(Ojw.CConvert.IntToStr(m_CHeader.pSMotorInfo[nID].nGuide_RingDir));
                    // OnGuide_3D_Scale
                    lstGuide.Add(Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[nID].fGuide_3D_Scale));
                    // OnGuide_3D_Alpha
                    lstGuide.Add(Ojw.CConvert.FloatToStr(m_CHeader.pSMotorInfo[nID].fGuide_3D_Alpha));
                    // OnGuide_Pos(x/y/z,p/t/s)
                    lstGuide.Add(String.Format("{0},{1},{2},{3},{4},{5}",
                        m_CHeader.pSMotorInfo[nID].afGuide_Pos[0],
                        m_CHeader.pSMotorInfo[nID].afGuide_Pos[1],
                        m_CHeader.pSMotorInfo[nID].afGuide_Pos[2],
                        m_CHeader.pSMotorInfo[nID].afGuide_Pos[3],
                        m_CHeader.pSMotorInfo[nID].afGuide_Pos[4],
                        m_CHeader.pSMotorInfo[nID].afGuide_Pos[5]));
                    // OnGuide_Off_IDs(Axis...x/y/z/p/t/s)
                    lstGuide.Add(String.Format("{0},{1},{2},{3},{4},{5}",
                        m_CHeader.pSMotorInfo[nID].anGuide_Off_IDs[0],
                        m_CHeader.pSMotorInfo[nID].anGuide_Off_IDs[1],
                        m_CHeader.pSMotorInfo[nID].anGuide_Off_IDs[2],
                        m_CHeader.pSMotorInfo[nID].anGuide_Off_IDs[3],
                        m_CHeader.pSMotorInfo[nID].anGuide_Off_IDs[4],
                        m_CHeader.pSMotorInfo[nID].anGuide_Off_IDs[5]));
                    // OnGuide_Off_Dir(Axis...x/y/z/p/t/s)
                    lstGuide.Add(String.Format("{0},{1},{2},{3},{4},{5}",
                        m_CHeader.pSMotorInfo[nID].anGuide_Off_Dir[0],
                        m_CHeader.pSMotorInfo[nID].anGuide_Off_Dir[1],
                        m_CHeader.pSMotorInfo[nID].anGuide_Off_Dir[2],
                        m_CHeader.pSMotorInfo[nID].anGuide_Off_Dir[3],
                        m_CHeader.pSMotorInfo[nID].anGuide_Off_Dir[4],
                        m_CHeader.pSMotorInfo[nID].anGuide_Off_Dir[5]));

                    //int nGroupIndex = m_CHeader.pSMotorInfo[nID].nGroupNumber
                    //if (lstGroupIndex.IndexOf(
                }
                
                bool bStart = true;
                List<string> lstGroupName = new List<string>();
                lstGroupName.Clear();
                string str = string.Empty;
                for (int i = 0; i < m_CHeader.lstGroupInfo.Count; i++)
                {
                    lstGroupName.Add(Ojw.CConvert.IntToStr(m_CHeader.lstGroupInfo[i].nNumber));
                    lstGroupName.Add(m_CHeader.lstGroupInfo[i].strName);
                    bStart = true;
                    str = string.Empty;
                    for (int j = 0; j < m_CHeader.anMotorIDs.Length; j++)
                    {
                        nID = m_CHeader.anMotorIDs[j];
                        if (m_CHeader.pSMotorInfo[nID].nGroupNumber == m_CHeader.lstGroupInfo[i].nNumber)
                        {
                            if (bStart == true) bStart = false;
                            else str += ",";
                            //nID = m_CHeader.anMotorIDs[j];
                            str += Ojw.CConvert.IntToStr(nID);
                        }
                    }
                    lstGroupName.Add(str);
                }
                return File_MakeJson(strTitle, strFileName, lstGuide.ToArray(), lstGroupName.ToArray());
            }
            private bool File_MakeJson(string strTitle, string strFileName, string[] astrGuide, string[] astrGroupName)
            {
                #region Json File
                FileInfo f = new FileInfo(strFileName);
                FileStream fs = f.Create();
                try
                {
                    //string strVersion = m_CHeader.strVersion;

                    // 스트림 버퍼를 비운다.
                    fs.Flush();
                    byte[] byteBuffer;
                    // Start
                    byteBuffer = CConvert.StrToBytes_UTF8("{\r\n"); fs.Write(byteBuffer, 0, byteBuffer.Length);

                    //m_CHeader.nMotorCnt
                    byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\"Design\" : \"{0}\",\r\n", m_CHeader.nModelNum)); fs.Write(byteBuffer, 0, byteBuffer.Length);

                    string strVersion = _STR_EXT_VERSION;//"01.00.00";
                    byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\"Design_Version\" : \"{0}\",\r\n", strVersion)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                    //string strName = Ojw.CConvert.RemoveChar(((strTitle == "") ? m_CHeader.strModelName : strTitle), '\0');
                    string strName = Ojw.CConvert.RemoveChar(m_CHeader.strModelName, '\0');
                    byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\"Robot\" : \"{0}\",\r\n", strName)); fs.Write(byteBuffer, 0, byteBuffer.Length);

                    // 새롭게 추가(Title)
                    string strTitle2 = Ojw.CConvert.RemoveChar(((strTitle == "") ? m_CHeader.strTitle : strTitle), '\0');
                    byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\"Title\" : \"{0}\",\r\n", strTitle2)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                    
                    // 새롭게 추가
                    int nScanningQr = m_CHeader.SJson.nQr;
                    byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\"ScanningQr(1:Qr,0:Ble)\" : \"{0}\",\r\n", nScanningQr)); fs.Write(byteBuffer, 0, byteBuffer.Length);

                    string str3D_Position = String.Format("{0},{1},{2},{3},{4},{5}",
                        m_CHeader.SJson.afScene_Position[0],
                        m_CHeader.SJson.afScene_Position[1],
                        m_CHeader.SJson.afScene_Position[2],
                        m_CHeader.SJson.afScene_Position[3],
                        m_CHeader.SJson.afScene_Position[4],
                        m_CHeader.SJson.afScene_Position[5]);
                    byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\"Scene_Position\" : \"{0}\",\r\n", str3D_Position)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                    //float fX, fY, fZ;
                    //float fP, fT, fS;
                    //GetPos_Display(out fX, out fY, out fZ);
                    //GetAngle_Display(out fP, out fT, out fS);
                    //str3D_Position = string.Format("{0},{1},{2},{3},{4},{5}", fX, fY, fZ, fP, fT, fS);
                    str3D_Position = String.Format("{0},{1},{2},{3},{4},{5}",
                        m_CHeader.SJson.afCamera_Position[0],
                        m_CHeader.SJson.afCamera_Position[1],
                        m_CHeader.SJson.afCamera_Position[2],
                        m_CHeader.SJson.afCamera_Position[3],
                        m_CHeader.SJson.afCamera_Position[4],
                        m_CHeader.SJson.afCamera_Position[5]);
                    byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\"Camera_Position\" : \"{0}\",\r\n", str3D_Position)); fs.Write(byteBuffer, 0, byteBuffer.Length);

                    //fX = 0.0f; fY = 72.0f; fZ = 0.0f;
                    //fP = 0.0f; fT = 0.0f; fS = 0.0f;
                    //str3D_Position = string.Format("{0},{1},{2},{3},{4},{5}", fX, fY, fZ, fP, fT, fS);
                    str3D_Position = String.Format("{0},{1},{2},{3},{4},{5}",
                        m_CHeader.SJson.afRobot_Position[0],
                        m_CHeader.SJson.afRobot_Position[1],
                        m_CHeader.SJson.afRobot_Position[2],
                        m_CHeader.SJson.afRobot_Position[3],
                        m_CHeader.SJson.afRobot_Position[4],
                        m_CHeader.SJson.afRobot_Position[5]);
                    byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\"Robot_Position\" : \"{0}\",\r\n", str3D_Position)); fs.Write(byteBuffer, 0, byteBuffer.Length);

                    string strArg0, strArg1;
                    strArg0 = "Robot_Scale"; strArg1 = Ojw.CConvert.FloatToStr(m_CHeader.SJson.fRobot_Scale);// "1.0"; 
                    strArg1 = Ojw.CConvert.RemoveChar(strArg1, '\0');
                    byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                    
                    ///////////////////////////
                    strArg0 = "BackColor"; strArg1 = "0x" + CConvert.IntToHex(m_CHeader.SJson.cBackColor.ToArgb());//CConvert.IntToHex(GetBackColor().ToArgb()); // m_CHeader.SJson.cBackColor -> 안쓴다.
                    strArg1 = Ojw.CConvert.RemoveChar(strArg1, '\0');
                    byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                    ///////////////////////////

                    strArg0 = "BackColor_Edit"; strArg1 = "0x" + CConvert.IntToHex(m_CHeader.SJson.cBackColor_Edit.ToArgb()); 
                    strArg1 = Ojw.CConvert.RemoveChar(strArg1, '\0');
                    byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);

                    strArg0 = "PlaneColor"; strArg1 = "0x" + CConvert.IntToHex(m_CHeader.SJson.cPlaneColor.ToArgb()); 
                    strArg1 = Ojw.CConvert.RemoveChar(strArg1, '\0');
                    byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);

                    strArg0 = "IsWireFrame"; strArg1 = (m_CHeader.SJson.IsWireFrame == true) ? "1" : "0";
                    strArg1 = Ojw.CConvert.RemoveChar(strArg1, '\0');
                    byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);

                    strArg0 = "BleName"; strArg1 = m_CHeader.SJson.strBleName;// "RB-100";
                    strArg1 = Ojw.CConvert.RemoveChar(strArg1, '\0');
                    byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);

                    strArg0 = "Address_Motion"; strArg1 = "0x" + CConvert.IntToHex(m_CHeader.SJson.nAddress_Motion); //"0xE2000";
                    strArg1 = Ojw.CConvert.RemoveChar(strArg1, '\0');
                    byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);

                    strArg0 = "Address_Control"; strArg1 = CConvert.IntToStr(m_CHeader.SJson.nAddress_Control); //"66";
                    strArg1 = Ojw.CConvert.RemoveChar(strArg1, '\0');
                    byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                    ////
                    // Guide_Group
                    #region Guide_Group
                    byteBuffer = CConvert.StrToBytes_UTF8("\t\"Guide_Group\" : [\r\n"); fs.Write(byteBuffer, 0, byteBuffer.Length);
                    int nItemCount = 13;
                    for (int i = 0; i < astrGuide.Length; i += nItemCount)
                    {
                        int j = i;
                        byteBuffer = CConvert.StrToBytes_UTF8("\t\t{\r\n"); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        ////
                        strArg0 = "OnGuide_Name";
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, Ojw.CConvert.RemoveChar(astrGuide[j++], '\0'))); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "OnGuide_ID";
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, astrGuide[j++])); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "OnGuide_Event";
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, astrGuide[j++])); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "OnGuide_AxisType";
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, astrGuide[j++])); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "OnGuide_RingColorType";
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, astrGuide[j++])); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "OnGuide_RingSize";
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, astrGuide[j++])); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "OnGuide_RingThick";
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, astrGuide[j++])); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "OnGuide_RingDir(1[F],-1[B])";
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, astrGuide[j++])); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "OnGuide_3D_Scale";
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, astrGuide[j++])); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "OnGuide_3D_Alpha";
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, astrGuide[j++])); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "OnGuide_Pos(x/y/z,p/t/s)";
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, astrGuide[j++])); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "OnGuide_Off_IDs(Axis...x/y/z/p/t/s)";
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, astrGuide[j++])); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "OnGuide_Off_Dir(Axis...x/y/z/p/t/s)";
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\"\r\n", strArg0, astrGuide[j++])); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        ////
                        if (j < astrGuide.Length - 1) { byteBuffer = CConvert.StrToBytes_UTF8("\t\t},\r\n"); }
                        else { byteBuffer = CConvert.StrToBytes_UTF8("\t\t}\r\n"); }
                        fs.Write(byteBuffer, 0, byteBuffer.Length);
                    }
                    byteBuffer = CConvert.StrToBytes_UTF8("\t],\r\n"); fs.Write(byteBuffer, 0, byteBuffer.Length);
                    #endregion Guide_Group

                    // GroupName
                    #region GroupName
                    byteBuffer = CConvert.StrToBytes_UTF8("\t\"GroupName\" : [\r\n"); fs.Write(byteBuffer, 0, byteBuffer.Length);
                    nItemCount = 3;
                    for (int i = 0; i < astrGroupName.Length; i += nItemCount)
                    {
                        int j = i;
                        byteBuffer = CConvert.StrToBytes_UTF8("\t\t{\r\n"); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        ////
                        strArg0 = "Number";
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, astrGroupName[j++])); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "Name";
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, Ojw.CConvert.RemoveChar(astrGroupName[j++], '\0'))); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "IDs";
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\"\r\n", strArg0, astrGroupName[j++])); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        ////
                        if (j < astrGroupName.Length - 1) { byteBuffer = CConvert.StrToBytes_UTF8("\t\t},\r\n"); }
                        else { byteBuffer = CConvert.StrToBytes_UTF8("\t\t}\r\n"); }
                        fs.Write(byteBuffer, 0, byteBuffer.Length);
                    }
                    byteBuffer = CConvert.StrToBytes_UTF8("\t],\r\n"); fs.Write(byteBuffer, 0, byteBuffer.Length);
                    #endregion GroupName

                    // Draw
                    #region Draw
                    byteBuffer = CConvert.StrToBytes_UTF8("\t\"Draw\" : [\r\n"); fs.Write(byteBuffer, 0, byteBuffer.Length);
                    nItemCount = 27;
                    string[] astrDrawLines = CConvert.RemoveChar(
                                                CConvert.RemoveChar(
                                                    CConvert.RemoveChar(m_CHeader.strDrawModel, '\r'), '['
                                                    ), ']'
                                            ).Split('\n');
                    List<string> lstDrawLines = new List<string>();
                    for (int i = 0; i < astrDrawLines.Length; i++)
                    {
                        string strDrawLine = CConvert.RemoveChar(
                                                CConvert.RemoveChar(
                                                    CConvert.RemoveCaption(astrDrawLines[i], true, true), '\r'
                                                    ), '\n'
                                                );
                        if (strDrawLine.Length < 10) continue;
                        lstDrawLines.Add(strDrawLine);
                    }
                    List<int> lstIDs_In_3D = new List<int>();
                    List<int> lstGroupA_In_3D = new List<int>();
                    lstIDs_In_3D.Clear();
                    lstGroupA_In_3D.Clear();
                    for (int i = 0; i < lstDrawLines.Count; i++)
                    {
                        int j = 0;
                        int nID = -1;
                        int nGroupA = -1;
                        string[] astrDraw = lstDrawLines[i].Split(',');
                        if (astrDraw.Length < 10) continue;
                        byteBuffer = CConvert.StrToBytes_UTF8("\t\t{\r\n"); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        ////

                        strArg0 = "Caption"; strArg1 = ((astrDraw[astrDraw.Length - 1].Length > 0) ? astrDraw[astrDraw.Length - 1] : "");
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);

                        strArg0 = "Axis"; strArg1 = astrDraw[j++];
                        nID = CConvert.StrToInt(strArg1);

                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "Color"; strArg1 = astrDraw[j++];
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "Alpha"; strArg1 = astrDraw[j++];
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "Object"; strArg1 = astrDraw[j++];
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "Fill"; strArg1 = astrDraw[j++];
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "Multi"; strArg1 = astrDraw[j++];
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "Init"; strArg1 = astrDraw[j++];
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "W/h/d/t/gap"; strArg1 = String.Format("{0},{1},{2},{3},{4}", astrDraw[j + 0], astrDraw[j + 1], astrDraw[j + 2], astrDraw[j + 3], astrDraw[j + 4]); j += 5;
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);

                        strArg0 = "AxisMotorType"; strArg1 = astrDraw[j++];
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "Dir"; strArg1 = astrDraw[j++];
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "Angle"; strArg1 = astrDraw[j++];
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "Angle_Offset"; strArg1 = astrDraw[j++];
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);

                        strArg0 = "Offset(x/y/z,p/t/s)"; strArg1 = String.Format("{0},{1},{2},{3},{4},{5}", astrDraw[j + 0], astrDraw[j + 1], astrDraw[j + 2], astrDraw[j + 3], astrDraw[j + 4], astrDraw[j + 5]); j += 6;
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "Move0(x/y/z,p/t/s)"; strArg1 = strArg1 = String.Format("{0},{1},{2},{3},{4},{5}", astrDraw[j + 0], astrDraw[j + 1], astrDraw[j + 2], astrDraw[j + 3], astrDraw[j + 4], astrDraw[j + 5]); j += 6;
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "Move1(x/y/z,p/t/s)"; strArg1 = strArg1 = String.Format("{0},{1},{2},{3},{4},{5}", astrDraw[j + 0], astrDraw[j + 1], astrDraw[j + 2], astrDraw[j + 3], astrDraw[j + 4], astrDraw[j + 5]); j += 6;
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "Move2(x/y/z,p/t/s)"; strArg1 = String.Format("{0},{1},{2},{3},{4},{5}", astrDraw[j + 0], astrDraw[j + 1], astrDraw[j + 2], astrDraw[j + 3], astrDraw[j + 4], astrDraw[j + 5]); j += 6;
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "MoveReserve0(x/y/z,p/t/s)"; strArg1 = String.Format("{0},{1},{2},{3},{4},{5}", astrDraw[j + 0], astrDraw[j + 1], astrDraw[j + 2], astrDraw[j + 3], astrDraw[j + 4], astrDraw[j + 5]); j += 6;
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "MoveReserve1(x/y/z,p/t/s)"; strArg1 = String.Format("{0},{1},{2},{3},{4},{5}", astrDraw[j + 0], astrDraw[j + 1], astrDraw[j + 2], astrDraw[j + 3], astrDraw[j + 4], astrDraw[j + 5]); j += 6;
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);

                        strArg0 = "Group"; strArg1 = astrDraw[j++]; // GroupA
                        nGroupA = CConvert.StrToInt(strArg1);

                        if (nID >= 0)
                        {
                            int nIndex = lstIDs_In_3D.FindIndex(item => item == nID);
                            if (nIndex < 0)
                            {
                                lstIDs_In_3D.Add(nID);
                                lstGroupA_In_3D.Add(nID);
                            }
                            else
                            {
                                if (nGroupA > 0)
                                    lstGroupA_In_3D[nIndex] = nGroupA;
                            }
                        }


                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "TargetMotor"; strArg1 = astrDraw[j++];
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "GroupC"; strArg1 = astrDraw[j++];
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "FunctionNumber"; strArg1 = astrDraw[j++];
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "Scale_Serve0"; strArg1 = astrDraw[j++];
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "Scale_Serve1"; strArg1 = astrDraw[j++];
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "MotorType"; strArg1 = astrDraw[j++];
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "MotorControl_MousePoint"; strArg1 = astrDraw[j++];
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\"\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        ////
                        if (i < lstDrawLines.Count - 1) { byteBuffer = CConvert.StrToBytes_UTF8("\t\t},\r\n"); }
                        else { byteBuffer = CConvert.StrToBytes_UTF8("\t\t}\r\n"); }

                        fs.Write(byteBuffer, 0, byteBuffer.Length);
                    }
                    byteBuffer = CConvert.StrToBytes_UTF8("\t],\r\n"); fs.Write(byteBuffer, 0, byteBuffer.Length);
                    #endregion Draw
#if true
                    // Motor_Setting
                    #region Motor_Setting
                    byteBuffer = CConvert.StrToBytes_UTF8("\t\"Motor_Setting\" : [\r\n"); fs.Write(byteBuffer, 0, byteBuffer.Length);
                    nItemCount = 13;
                    List<int> lstIDs = new List<int>();
                    lstIDs.Clear();
                    for (int j = 0; j < lstIDs_In_3D.Count; j++)
                    {
                        int i = lstIDs_In_3D[j];
                        // 0: Dontcare, 1: Enable, -1: Disable => 이게 Disable 이면 모터 표시를 죽인다.
                        if (m_CHeader.pSMotorInfo[i].nMotor_Enable < 0) continue;
                        lstIDs.Add(i);
                    }
                    lstIDs.Sort();
                    for (int j = 0; j < lstIDs.Count; j++)
                    {
                        int i = lstIDs[j];
                        byteBuffer = CConvert.StrToBytes_UTF8("\t\t{\r\n"); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        ////
                        strArg0 = "ID"; strArg1 = CConvert.IntToStr(m_CHeader.pSMotorInfo[i].nMotorID);
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "Mirror"; strArg1 = CConvert.IntToStr(m_CHeader.pSMotorInfo[i].nAxis_Mirror);
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "LimitDn"; strArg1 = CConvert.FloatToStr(m_CHeader.pSMotorInfo[i].fLimit_Down);
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "LimitUp"; strArg1 = CConvert.FloatToStr(m_CHeader.pSMotorInfo[i].fLimit_Up);
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "InitAngle"; strArg1 = CConvert.FloatToStr(m_CHeader.pSMotorInfo[i].fInitAngle);
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "InitAngle2"; strArg1 = CConvert.FloatToStr(m_CHeader.pSMotorInfo[i].fInitAngle2);
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "Mech_Center"; strArg1 = CConvert.IntToStr(m_CHeader.pSMotorInfo[i].nCenter_Evd);
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "Mech_Move"; strArg1 = CConvert.IntToStr(m_CHeader.pSMotorInfo[i].nMechMove);
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "Mech_Angle"; strArg1 = CConvert.FloatToStr(m_CHeader.pSMotorInfo[i].fMechAngle);
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        /*float fMulti = (float)((m_CHeader.pSMotorInfo[i].fGearRatio != 0) ? m_CHeader.pSMotorInfo[i].fGearRatio : 1.0f) *
                            (float)((m_CHeader.pSMotorInfo[i].nMotorDir == 0) ? 1f : -1f);*/
                        float fMulti =
                            (float)((m_CHeader.pSMotorInfo[i].fGearRatio != 0) ? m_CHeader.pSMotorInfo[i].fGearRatio : 1.0f) *
                            (float)((m_CHeader.pSMotorInfo[i].nMotorDir == 0) ? 1 : -1);
                        strArg0 = "Multi"; strArg1 = CConvert.FloatToStr(fMulti);
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "ControlType[0-p,1-v]"; strArg1 = CConvert.IntToStr(m_CHeader.pSMotorInfo[i].nMotorControlType);
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        strArg0 = "Hw"; strArg1 = CConvert.IntToStr(m_CHeader.pSMotorInfo[i].nHwMotor_Key);
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\",\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);

                        int nIndex = m_CHeader.pSMotorInfo[i].nGroupNumber;// lstIDs_In_3D.FindIndex(item => item == m_CHeader.pSMotorInfo[i].nMotorID);
                        //int nIndex = lstIDs_In_3D.FindIndex(item => item == m_CHeader.pSMotorInfo[i].nMotorID);
                        int nVal = ((nIndex >= 0) ? nIndex : 0);
                        strArg0 = "GroupA"; strArg1 = CConvert.IntToStr(nVal);
                        byteBuffer = CConvert.StrToBytes_UTF8(String.Format("\t\t\t\"{0}\" : \"{1}\"\r\n", strArg0, strArg1)); fs.Write(byteBuffer, 0, byteBuffer.Length);
                        ////
                        if (j < lstIDs.Count - 1) { byteBuffer = CConvert.StrToBytes_UTF8("\t\t},\r\n"); }
                        else { byteBuffer = CConvert.StrToBytes_UTF8("\t\t}\r\n"); }
                        fs.Write(byteBuffer, 0, byteBuffer.Length);
                    }
                    //byteBuffer = CConvert.StrToBytes_UTF8("\t],\r\n"); fs.Write(byteBuffer, 0, byteBuffer.Length);
                    byteBuffer = CConvert.StrToBytes_UTF8("\t]\r\n"); fs.Write(byteBuffer, 0, byteBuffer.Length);
                    #endregion Motor_Setting
#endif

                    // End
                    byteBuffer = CConvert.StrToBytes_UTF8("}\r\n"); fs.Write(byteBuffer, 0, byteBuffer.Length);

                    fs.Close(); f = null;
                    return true;
                }
                catch
                {
                    //Message("파일 저장 에러");
                    fs.Close(); f = null;
                    return false;
                }
                #endregion Json File
            }
            #endregion Json


            #region Designer class(COjwDesignerHeader)

            #region Version - Version Designer History header file(Kor: 디자이너 헤더 파일의 버전 기록)
            public static String _STR_EXT = "ojw"; // OpenJigWare File

            public static String _STR_EXT_VERSION = "01.08.00"; // Title 항목 헤더에 추가
            //public static String _STR_EXT_VERSION = "01.07.00"; // Json 생성기능 추가
            //public static String _STR_EXT_VERSION = "01.06.00"; // stl 모델파일 초기점 기준이동기능 삭제, 기존 파일로드할때 파일로드 시 특이점 들어가게 수정
            //public static String _STR_EXT_VERSION = "01.05.00"; // m_lstMotorsEn 추가
            //public static String _STR_EXT_VERSION = "01.04.00"; // Dynamixel 모델 추가
            //public static String _STR_EXT_VERSION = "01.03.00"; // Python 기능 추가
            //public static String _STR_EXT_VERSION = "01.02.00"; // Center_Evd, MechMove 의 값 16비트에서 32비트로 변경
            //public static String _STR_EXT_VERSION = "01.01.00";
            //public static String _STR_EXT_VERSION = "01.00.00";
            #endregion Version - Version Designer History header file(Kor: 디자이너 헤더 파일의 버전 기록)

            public String m_strVersion = "";
            public static int _CNT_FILEOPEN = 0;
            public int Get_File_List(String strPath, out COjwFileList CFileList)
            {
                int nRet = 0;
                CFileList = null;
                try
                {
                    CFileList = new COjwFileList();
                    DirectoryInfo dirInfo = new DirectoryInfo(strPath);
                    if (dirInfo.Exists == true)
                    {
                        //int nCnt = 0;
                        //int i = 0;
                        CFileList.Init();
                        foreach (FileInfo fileInfo in dirInfo.GetFiles("*.ojw"))
                        {
                            CFileList.Add(fileInfo);
                        }
                        nRet = CFileList.Get_Size();
                    }
                    return nRet;
                }
                catch
                {
                    return nRet;
                }
            }
            bool m_bFileOpening = false;
            private int m_nSeq_FileOpened = 0;
            //private int m_nSeq_FileOpened_Back = 0;
            private string m_strDesignFileName = String.Empty;
            public string GetFileName() { return m_strDesignFileName; }
            private bool m_bNoBuild_MotionEditor = false;
            public void SetMotionEditor_NoBuild() // 한번만 Set 된다.
            {
                m_bNoBuild_MotionEditor = true;
            }
            public bool FileOpen(String strFileName)
            {
                bool bRet = FileOpen(strFileName, out m_CHeader);
                if (bRet == true)
                {
                    m_bModelOpened = true;

                    int nMotorCount = m_CHeader.nMotorCnt;
                    String strError = "";

                    #region Compile
                    // Forward
                    CheckForward();
                    // Inverse
                    CheckInverse();
                    #endregion Compile

                    m_rtxtDraw.Text = GetHeader_strDrawModel();
                    int nWidth = (IsGridInit() == true) ? GetWidth_GridItem() : 70;
                    if (m_bNoBuild_MotionEditor == false) GridMotionEditor_Init(nWidth, 999, false);
                    m_bNoBuild_MotionEditor = false; // 한번만 Set되는것
                    StringListToGrid(); // 현재는 사용 안하지만 그래도 일단 넣고 계속 테스트...

                    //if (m_cmbDh.Items.Count < 512)
                    //{
                    //    m_cmbDh.Items.Clear();
                    //    for (int j = 0; j < 512; j++)
                    //    {
                    //        m_cmbDh.Items.Add(j.ToString());
                    //    }
                    //}
                    m_cmbDh.SelectedIndex = 0;
                    cmbDhRefresh(m_cmbDh.SelectedIndex);

                    m_nSeq_FileOpened++;

                    if (m_CMotor != null)
                    {
                        for (int i = 0; i < nMotorCount; i++)
                        {
                            m_CMotor.SetParam_Axis(i, m_CHeader.pSMotorInfo[i].nMotorID, m_CHeader.pSMotorInfo[i].nMotorDir, m_CHeader.pSMotorInfo[i].fLimit_Up, m_CHeader.pSMotorInfo[i].fLimit_Down, (float)m_CHeader.pSMotorInfo[i].nCenter_Evd, (float)m_CHeader.pSMotorInfo[i].nMechMove, m_CHeader.pSMotorInfo[i].fMechAngle);
                        }
                    }
                    if (m_CMotor2 != null)
                    {
                        for (int i = 0; i < nMotorCount; i++)
                        {
                            m_CMotor2.SetParam(
                                i, 
                                m_CHeader.pSMotorInfo[i].nMotorID, 
                                m_CHeader.pSMotorInfo[i].nMotorDir, 
                                m_CHeader.pSMotorInfo[i].fLimit_Up, 
                                m_CHeader.pSMotorInfo[i].fLimit_Down, 
                                (float)m_CHeader.pSMotorInfo[i].nCenter_Evd,
                                0.0f, // Dislay
                                (float)m_CHeader.pSMotorInfo[i].nMechMove, 
                                m_CHeader.pSMotorInfo[i].fMechAngle
                                );
                        }
                    }
#if !_MONSTER_LIB
                    if (m_CRobotis != null)
                    {
                        for (int i = 0; i < nMotorCount; i++)
                        {
                            if (m_CHeader.pSMotorInfo[i].nHwMotor_Index > 0)
                            {
                                m_CRobotis.SetParam(m_CHeader.pSMotorInfo[i].nHwMotor_Index);
                            }
                        }
                        for (int i = 0; i < nMotorCount; i++)
                        {
                            m_CRobotis.SetParam(
                                       i,
                                       m_CHeader.pSMotorInfo[i].nMotorID,
                                       m_CHeader.pSMotorInfo[i].nMotorDir,
                                       m_CHeader.pSMotorInfo[i].fLimit_Up,
                                       m_CHeader.pSMotorInfo[i].fLimit_Down,
                                       (float)m_CHeader.pSMotorInfo[i].nCenter_Evd,
                                       0.0f, // Dislay
                                       (float)m_CHeader.pSMotorInfo[i].nMechMove,
                                       m_CHeader.pSMotorInfo[i].fMechAngle
                                       );
                            
                            int nTmp;
                            float fEvd, fTmp, fMechMove, fAngle;
                            m_CRobotis.GetParam(
                                       i,
                                       out m_CHeader.pSMotorInfo[i].nMotorID,
                                       out m_CHeader.pSMotorInfo[i].nMotorDir,
                                       out m_CHeader.pSMotorInfo[i].fLimit_Up,
                                       out m_CHeader.pSMotorInfo[i].fLimit_Down,
                                       out fEvd,//m_CHeader.pSMotorInfo[i].nCenter_Evd,
                                       out fTmp, // Dislay
                                       out fMechMove,//m_CHeader.pSMotorInfo[i].nMechMove,
                                       out fAngle//m_CHeader.pSMotorInfo[i].fMechAngle
                                       );
                            m_CHeader.pSMotorInfo[i].nCenter_Evd = (int)fEvd;
                            m_CHeader.pSMotorInfo[i].nMechMove = (int)fMechMove;
                            m_CHeader.pSMotorInfo[i].fMechAngle = fAngle;
                        }
                    }
                    if (m_CMonster != null) m_CMonster.SetHeader(m_CHeader);
#else
                    if (m_CMonster != null) 
                        if (m_CMonster.IsOpen() == true) 
                            m_CMonster.Set3DHeader(m_CHeader);
#endif

                    


                    if (m_bProb_Virtual == true)
                    {
                        // 새로 추가
                        string strTitle = CConvert.RemoveChar(m_CHeader.strTitle, '\0');
                        Prop_Set_Main_Title((strTitle.Length > 0) ? m_CHeader.strTitle : "");
                        Prop_Set_Main_ModelNum(m_CHeader.nModelNum);
                        Prop_Set_Main_ModelName(m_CHeader.strModelName);

                        Prop_Set_Main_BackColor(m_CHeader.cBackColor);
                        Prop_Update_VirtualObject();
                    }
                    SetBackColor(m_CHeader.cBackColor);
                    SetAngle_Display(m_CHeader.SInitAngle.pan, m_CHeader.SInitAngle.tilt, m_CHeader.SInitAngle.swing);
                    SetPos_Display(m_CHeader.SInitPos.x, m_CHeader.SInitPos.y, m_CHeader.SInitPos.z);
                    SetScale(m_CHeader.fInitScale);

                    m_strDesignFileName = strFileName;

                    bool bCompile = CompileDesign(m_CHeader.strDrawModel, out m_CHeader.nMotorCnt, out m_CHeader.anMotorIDs, out strError);
                    //if (m_CMonster != null) m_CMonster.Set3DHeader(m_CHeader);
                    return bCompile;
                    //int[] anMotorIDs;
                    //return CompileDesign(m_CHeader.strDrawModel, out nMotorCount, out anMotorIDs, out strError);
                }
                return false;
            }

            public SGroupInfo_t Get_GroupInfo(int nGroupNumber)
            {
                for (int i = 0; i < m_CHeader.lstGroupInfo.Count; i++)
                {
                    if (m_CHeader.lstGroupInfo[i].nNumber == nGroupNumber) return m_CHeader.lstGroupInfo[i];
                }
                SGroupInfo_t SGroup = new SGroupInfo_t();
                SGroup.nNumber = -1;
                return SGroup;
            }
            public SGroupInfo_t Get_GroupInfo(string strGroupName)
            {
                for (int i = 0; i < m_CHeader.lstGroupInfo.Count; i++)
                {
                    if (m_CHeader.lstGroupInfo[i].strName == strGroupName) return m_CHeader.lstGroupInfo[i];
                }
                SGroupInfo_t SGroup = new SGroupInfo_t();
                SGroup.nNumber = -1;
                return SGroup;
            }
            private void Make_GroupInfo()
            {
                if (m_CHeader.anMotorIDs == null) return;
                List<int> lstGroupNumber = new List<int>();
                lstGroupNumber.Clear();
                int nID, nGroup;
                List<SGroupInfo_t> lstGroupInfo = new List<SGroupInfo_t>();
                lstGroupInfo.Clear();
                for (int i = 0; i < m_CHeader.anMotorIDs.Length; i++)
                {
                    nID = m_CHeader.anMotorIDs[i];
                    nGroup = m_CHeader.pSMotorInfo[nID].nGroupNumber;
                    if (nGroup > 0)
                    {
                        if (lstGroupNumber.IndexOf(nGroup) < 0)
                        {
                            lstGroupNumber.Add(nGroup);

                            SGroupInfo_t SGroup = Get_GroupInfo(nGroup);
                            if (SGroup.nNumber >= 0)
                            {

                            }
                            else
                            {
                                SGroup.nNumber = nGroup;
                                SGroup.strName = "";
                            }
                            lstGroupInfo.Add(SGroup);
                        }
                    }
                }
                m_CHeader.lstGroupInfo.Clear();
                m_CHeader.lstGroupInfo.AddRange(lstGroupInfo);
            }

            #region openfiledialog OLE 호출을 수행하려면 현재 스레드를 STA(단일 스레드 아파트) 모드로 설정해야 합니다. 표시된 STAThreadAttribute가 Main 함수에 있는지 확인하십시오. 이 예외는 디버거가 프로세스에 연결된 경우에만 발생합니다. 에러 발생시 해결법
            // 출처 : https://blogs.msdn.microsoft.com/smondal/2010/09/08/current-thread-must-be-set-to-single-thread-apartment-sta-mode-before-ole-calls-can-be-made/
             /* STAShowDialog takes a FileDialog and shows it on a background STA thread and returns the results.
             * Usage:
             *   OpenFileDialog d = new OpenFileDialog();
             *   DialogResult ret = STAShowDialog(d);
             *   if (ret == DialogResult.OK)
             *      MessageBox.Show(d.FileName);
             */
            private DialogResult STAShowDialog(FileDialog dialog)
            {
                DialogState state = new DialogState();
                state.dialog = dialog;
                System.Threading.Thread t = new System.Threading.Thread(state.ThreadProcShowDialog);
                t.SetApartmentState(System.Threading.ApartmentState.STA);
                t.Start();
                t.Join();
                return state.result;
            }
             /* Helper class to hold state and return value in order to call FileDialog.ShowDialog on a background thread.
             * Usage:
             *   DialogState state = new DialogState();
             *   state.dialog = // <any class that derives from FileDialog>
             *   System.Threading.Thread t = new System.Threading.Thread(state.ThreadProcShowDialog);
             *   t.SetApartmentState(System.Threading.ApartmentState.STA);
             *   t.Start();
             *   t.Join();
             *   return state.result;
             */
            public class DialogState
            {
                public DialogResult result;
                public FileDialog dialog;
 
                public void ThreadProcShowDialog()
                {
                    result = dialog.ShowDialog();
                }
            }
            #endregion openfiledialog OLE 호출을 수행하려면 현재 스레드를 STA(단일 스레드 아파트) 모드로 설정해야 합니다. 표시된 STAThreadAttribute가 Main 함수에 있는지 확인하십시오. 이 예외는 디버거가 프로세스에 연결된 경우에만 발생합니다. 에러 발생시 해결법

            public void SetFilePath_Design(string strPath)
            {
                // 디자인 파일 오픈 경로 설정
                m_strDesignerFilePath = strPath;
            }
            public string GetFilePath_Design() { return m_strDesignerFilePath; }
            public bool FileOpen()
            {
                OpenFileDialog ofdDesign = new OpenFileDialog();

                //SetAseFile_Path("ase"); // set ase file path

                ofdDesign.FileName = "*." + _STR_EXT;
                ofdDesign.InitialDirectory = m_strDesignerFilePath;
                ofdDesign.Filter = "Design File(*." + _STR_EXT + ")|*." + _STR_EXT;

                ofdDesign.DefaultExt = _STR_EXT;

                DialogResult ret = STAShowDialog(ofdDesign);
                //if (ofdDesign.ShowDialog() == DialogResult.OK)
                if (ret == DialogResult.OK)
                {
                    String fileName = ofdDesign.FileName;
                    if (FileOpen(fileName) == false)
                    {
                        Ojw.CMessage.Write_Error("It's not a our Modeling File.");
                    }
                    else
                    {
                        Ojw.CMessage.Write("Design File - " + fileName + "(v" + m_strVersion + ")");
                        if (IsDrawRText() == true)
                        {
                            //Ojw.CMessage.Write2(m_rtxtDraw, m_CHeader.strDrawModel);
                            m_rtxtDraw.Text = GetHeader_strDrawModel();
                            StringListToGrid();
                        }
                        #region DH
                        //cmbDhRefresh(0);
                        #endregion DH

                        //cmbVersion.SelectedIndex = m_C3d.m_strVersion - 11;
                        float[] afData = new float[3];
                        GetPos_Display(out afData[0], out afData[1], out afData[2]);
                        //int i = 0;
                        //txtDisplay_X.Text = Ojw.CConvert.FloatToStr(afData[i++]);
                        //txtDisplay_Y.Text = Ojw.CConvert.FloatToStr(afData[i++]);
                        //txtDisplay_Z.Text = Ojw.CConvert.FloatToStr(afData[i++]);
                        GetAngle_Display(out afData[0], out afData[1], out afData[2]);
                        //i = 0;                                    

                        m_strDesignerFilePath = Ojw.CFile.GetPath(fileName);
                        m_strDesignFileName = fileName;
                        return true;
                    }
                }
                return false;
            }
            public void FileClose()
            {
                m_CHeader.strDrawModel = String.Empty;
                CompileDesign();
                //StringListToGrid();
                m_lstDraw.Clear();
                if (m_CGridMotionEditor != null) m_CGridMotionEditor.Delete();

                if (m_CProperty_Selected != null) m_CProperty_Selected.Destroy();
                m_CDisp_Selected = null;
                m_panelSelected = null;
                

                m_lstModel.Clear();

            }
            private int m_nCnt_Forward = 0;
            private int m_nCnt_Inverse = 0;
            private List<int> lstForward = new List<int>();
            private List<int> lstInverse = new List<int>();
            public int[] GetForward_Numbers() { return lstForward.ToArray(); }
            public int[] GetInverse_Numbers() { return lstInverse.ToArray(); }
            public void GetCount_Kinematics(out int Forward, out int Inverse)
            {
                Forward = m_nCnt_Forward;
                Inverse = m_nCnt_Inverse;
            }
            public void CheckForward()
            {
                int nPos = 0;
                m_nCnt_Forward = 0;
                lstForward.Clear();
                foreach (String strItem in m_CHeader.pstrKinematics)
                {
                    if (strItem != null)
                    {
                        if (strItem.Length > 0)
                        {
                            CKinematics.CForward.MakeDhParam(strItem, out m_CHeader.pDhParamAll[nPos]);
                            m_nCnt_Forward++;
                            lstForward.Add(nPos);
                        }
                    }
                    nPos++;
                }
            }
            public void CheckInverse()
            {
                int nPos = 0;
                int nCnt_InverseKinematics = 0;
                m_nCnt_Inverse = 0;
                lstInverse.Clear();
                foreach (String strItem in m_CHeader.pstrInverseKinematics)
                {
                    if (strItem != null)
                    {
                        if (strItem.Length > 0)
                        {
                            CKinematics.CInverse.Compile(((m_CHeader.pbPython[nPos] == true) ? "!": string.Empty) + strItem, out m_CHeader.pSOjwCode[nPos]);                            
                            m_nCnt_Inverse++;
                            lstInverse.Add(nPos);
                        }
                    }
                    if (m_CHeader.pSOjwCode[nPos].nMotor_Max > 0) nCnt_InverseKinematics++;
                    nPos++;
                }
                m_nCnt_InverseKinematics = nCnt_InverseKinematics;
            }
            private int m_nCnt_InverseKinematics = 0;
            public void FileSave(String strFileName, COjwDesignerHeader CHeader)
            {
                //int nVersion = 
                if (strFileName == "")
                {
                    Ojw.CMessage.Write_Error("File Save Error - Null FileName");
                    return;
                }

                FileInfo f = new FileInfo(strFileName);
                FileStream fs = f.Create();

                try
                {
                    int i, j;
                    byte[] byteData, byteData2;

                    String strVerstion = _STR_EXT.ToUpper() + _STR_EXT_VERSION.ToUpper(); // save a new released version(Kor: 최신버전 저장)
                    // Empty the stream buffer.(Kor: 스트림 버퍼를 비운다.)
                    fs.Flush();

                    #region Set a identification code(Kor: 식별코드 부여) // OJW1.0.0 ( 11 Bytes )
                    if ((_STR_EXT.Length != 3) || (_STR_EXT_VERSION.Length != 8))
                    {
                        Ojw.CMessage.Write_Error("Incorrect File Version");
                        fs.Close();
                        return;
                    }
                    for (i = 0; i < (_STR_EXT.Length + _STR_EXT_VERSION.Length); i++) fs.WriteByte((byte)(strVerstion[i]));

                    #endregion Set a identification code(Kor: 식별코드 부여) // OJW1.0.0 ( 11 Bytes )

                    #region From Version 1.1.0(_STR_EXT_VERSION = "01.01.00")( 4 Bytes )
                    //01.03.00
                    int nVersion =
                        Ojw.CConvert.StrToInt(_STR_EXT_VERSION.Substring(0, 2)) * 100 * 100 +
                        Ojw.CConvert.StrToInt(_STR_EXT_VERSION.Substring(3, 2)) * 100 +
                        Ojw.CConvert.StrToInt(_STR_EXT_VERSION.Substring(6, 2));
                    #endregion From Version 1.1.0(_STR_EXT_VERSION = "01.01.00")( 4 Bytes )

                    #region Default Function
                    byteData = BitConverter.GetBytes((int)CHeader.nDefaultFunctionNumber);
                    fs.Write(byteData, 0, 4);
                    byteData = null;
                    #endregion Default Function
                    
                    #region Model number ( 2 Bytes )
                    byteData = BitConverter.GetBytes((short)CHeader.nModelNum);
                    fs.Write(byteData, 0, 2);
                    byteData = null;
                    #endregion Model number ( 2 Bytes )


                    //////////// 추가항목
                    #region Json Title  ( 21 Bytes )
                    if (nVersion >= 010800)
                    {
                        // Name
                        byteData = Encoding.Default.GetBytes(CHeader.strTitle);
                        for (i = 0; i < 20; i++)
                        {
                            if (i < byteData.Length) fs.WriteByte(byteData[i]);
                            else fs.WriteByte(0);
                        }
                        // Additional terminating null character(Kor: 널 종료문자 추가)
                        fs.WriteByte(0);
                        byteData = null;
                    }
                    #endregion Json Title ( 21 Bytes )

                    #region Title  ( 21 Bytes )
                    // Name
                    //byteData = Encoding.Default.GetBytes(m_CHeader.strModelName);
                    byteData = Encoding.Default.GetBytes(CHeader.strModelName);
                    for (i = 0; i < 20; i++)
                    {
                        if (i < byteData.Length) fs.WriteByte(byteData[i]);
                        else fs.WriteByte(0);
                    }
                    // Additional terminating null character(Kor: 널 종료문자 추가)
                    fs.WriteByte(0);
                    byteData = null;
                    #endregion Title ( 21 Bytes )

                    #region BackColor - Screen Background Color ( 4 Bytes )
                    byteData = BitConverter.GetBytes((int)GetBackColor().ToArgb());
                    fs.Write(byteData, 0, 4);
                    byteData = null;
                    #endregion BackColor - Screen Background Color ( 4 Bytes )

                    #region Number of motors ( 2 Bytes )
                    byteData = BitConverter.GetBytes((short)CHeader.nMotorCnt);
                    fs.Write(byteData, 0, 2);
                    byteData = null;
                    #endregion Number of motors ( 2 Bytes )

                    #region The initial angle
                    #region The initial angle - Pan ( 4 Bytes )
                    byteData = BitConverter.GetBytes((float)GetPan());
                    fs.Write(byteData, 0, 4);
                    byteData = null;
                    #endregion The initial angle - Pan ( 4 Bytes )

                    #region The initial angle - Tilt ( 4 Bytes )
                    byteData = BitConverter.GetBytes((float)GetTilt());
                    fs.Write(byteData, 0, 4);
                    byteData = null;
                    #endregion The initial angle - Tilt ( 4 Bytes )

                    #region The initial angle - Swing ( 4 Bytes )
                    byteData = BitConverter.GetBytes((float)GetSwing());
                    fs.Write(byteData, 0, 4);
                    byteData = null;
                    #endregion The initial angle - Swing ( 4 Bytes )
                    #endregion The initial angle

                    #region The initial position
                    float fX, fY, fZ;
                    GetPos_Display(out fX, out fY, out fZ);
                    #region The initial position - x ( 4 Bytes )
                    byteData = BitConverter.GetBytes(fX);
                    fs.Write(byteData, 0, 4);
                    byteData = null;
                    #endregion The initial position - x ( 4 Bytes )

                    #region The initial position - y ( 4 Bytes )
                    byteData = BitConverter.GetBytes(fY);
                    fs.Write(byteData, 0, 4);
                    byteData = null;
                    #endregion The initial position - y ( 4 Bytes )

                    #region The initial position - z ( 4 Bytes )
                    byteData = BitConverter.GetBytes(fZ);
                    fs.Write(byteData, 0, 4);
                    byteData = null;
                    #endregion The initial position - z ( 4 Bytes )
                    #endregion The initial position

                    #region The initial Scale - 100% = 1.0 ( 4 Bytes )
                    byteData = BitConverter.GetBytes((float)GetScale());
                    fs.Write(byteData, 0, 4);
                    byteData = null;
                    #endregion The initial Scale - 100% = 1.0 ( 4 Bytes )


                    #region 2 Wheel Counter ( 1 Bytes )

                    fs.WriteByte((byte)(CHeader.nWheelCounter_2 & 0xff));
                    #endregion 2 Wheel Counter ( 1 Bytes )

                    #region 3 Wheel Counter ( 1 Bytes )
                    fs.WriteByte((byte)(CHeader.nWheelCounter_3 & 0xff));
                    #endregion 3 Wheel Counter ( 1 Bytes )

                    #region 4 Wheel Counter ( 1 Bytes )
                    fs.WriteByte((byte)(CHeader.nWheelCounter_4 & 0xff));
                    #endregion 4 Wheel Counter ( 1 Bytes )

                    for (i = 0; i < 256; i++)
                    {
                        #region Axis Info

                        #region Motor ID ( 2 Bytes )
                        byteData = BitConverter.GetBytes((short)(m_CHeader.pSMotorInfo[i].nMotorID));
                        fs.Write(byteData, 0, 2);
                        byteData = null;
                        #endregion Motor ID ( 2 Bytes )

                        #region [Motor Direction] Direction - 0 - Forward, 1 - Inverse ( 2 Bytes )
                        byteData = BitConverter.GetBytes((short)(m_CHeader.pSMotorInfo[i].nMotorDir));
                        fs.Write(byteData, 0, 2);
                        byteData = null;
                        #endregion [Motor Direction] Direction - 0 - Forward, 1 - Inverse ( 2 Bytes )

                        #region Max Angle(+) ( 4 Bytes )
                        byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].fLimit_Up);
                        fs.Write(byteData, 0, 4);
                        byteData = null;
                        #endregion Max Angle(+) ( 4 Bytes )
                        #region Min Angle(-) ( 4 Bytes )
                        byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].fLimit_Down);
                        fs.Write(byteData, 0, 4);
                        byteData = null;
                        #endregion Min Angle(-) ( 4 Bytes )

                        #region Center Position - Evd ( 2 Bytes )
                        byteData = BitConverter.GetBytes((int)m_CHeader.pSMotorInfo[i].nCenter_Evd);
                        //fs.Write(byteData, 0, 2);  -> "01.02.00" 에서 4바이트로 변경
                        fs.Write(byteData, 0, 4);
                        byteData = null;
                        #endregion Center Position - Evd ( 2 Bytes )

                        #region Mech Move - maximum Evd value( 2 Bytes )
                        byteData = BitConverter.GetBytes((int)m_CHeader.pSMotorInfo[i].nMechMove);
                        //fs.Write(byteData, 0, 2);  -> "01.02.00" 에서 4바이트로 변경
                        fs.Write(byteData, 0, 4);
                        byteData = null;
                        #endregion Mech Move - maximum Evd value ( 2 Bytes )
                        #region Mech Angle - Angle of Mech Mov [ The maximum pulse corresponding to the angle value(Kor: 최대치 펄스에 해당하는 각도값 (분주각))]( 4 Bytes )
                        byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].fMechAngle);
                        fs.Write(byteData, 0, 4);
                        byteData = null;
                        #endregion Mech Angle - Angle of Mech Mov [ The maximum pulse corresponding to the angle value(Kor: 최대치 펄스에 해당하는 각도값 (분주각))]( 4 Bytes )

                        #region Init Angle - Used for the initial position of the data in an arbitrary position( 4 Bytes )(Kor: 데이타의 초기자세를 임의의 자세로 하기 위해 사용( 4 Bytes ))
                        byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].fInitAngle);
                        fs.Write(byteData, 0, 4);
                        byteData = null;
                        byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].fInitAngle2);
                        fs.Write(byteData, 0, 4);
                        byteData = null;
                        #endregion Init Angle - Used for the initial position of the data in an arbitrary position( 4 Bytes )(Kor: 데이타의 초기자세를 임의의 자세로 하기 위해 사용( 4 Bytes ))

                        #region Interference axis number(Kor: 간섭 축 번호) ( 2 Bytes )
                        byteData = BitConverter.GetBytes((short)(m_CHeader.pSMotorInfo[i].nInterference_Axis));
                        fs.Write(byteData, 0, 2);
                        byteData = null;
                        #endregion Interference axis number(Kor: 간섭 축 번호) ( 2 Bytes )
                        #region Axis Width ( 4 Bytes )
                        byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].fW);
                        fs.Write(byteData, 0, 4);
                        byteData = null;
                        #endregion Axis Width ( 4 Bytes )
                        #region Interference axis Width ( 4 Bytes )
                        byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].fInterference_W);
                        fs.Write(byteData, 0, 4);
                        byteData = null;
                        #endregion Interference axis Width ( 4 Bytes )

                        #region Axis Side(Right) ( 4 Bytes )
                        byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].fPos_Right);
                        fs.Write(byteData, 0, 4);
                        byteData = null;
                        #endregion Axis Side(Right) ( 4 Bytes )
                        #region Axis Side(Left) ( 4 Bytes )
                        byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].fPos_Left);
                        fs.Write(byteData, 0, 4);
                        byteData = null;
                        #endregion Axis Side(Left) ( 4 Bytes )
                        #region Interference axis Front ( 4 Bytes )
                        byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].fInterference_Pos_Front);
                        fs.Write(byteData, 0, 4);
                        byteData = null;
                        #endregion Interference axis Front ( 4 Bytes )
                        #region Interference axis Rear ( 4 Bytes )
                        byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].fInterference_Pos_Rear);
                        fs.Write(byteData, 0, 4);
                        byteData = null;
                        #endregion Interference axis Rear ( 4 Bytes )

                        #region NickName  ( 32 Bytes )
                        if (m_CHeader.pSMotorInfo[i].strNickName != null) byteData = Encoding.Default.GetBytes(m_CHeader.pSMotorInfo[i].strNickName);
                        else
                        {
                            byteData = new byte[32];
                            Array.Clear(byteData, 0, 32);
                        }
                        for (j = 0; j < 31; j++)
                        {
                            if (j < byteData.Length) fs.WriteByte(byteData[j]);
                            else fs.WriteByte(0);
                        }
                        // Additional terminating null character(Kor: 널 종료문자 추가)
                        fs.WriteByte(0);
                        byteData = null;
                        #endregion NickName  ( 32 Bytes )

                        #region Group Number ( 2 Bytes )
                        byteData = BitConverter.GetBytes((int)m_CHeader.pSMotorInfo[i].nGroupNumber);
                        fs.Write(byteData, 0, 2);
                        byteData = null;
                        #endregion Group Number ( 2 Bytes )

                        #region Mirror axis number ( 2 Bytes )
                        byteData = BitConverter.GetBytes((short)(m_CHeader.pSMotorInfo[i].nAxis_Mirror));
                        fs.Write(byteData, 0, 2);
                        byteData = null;
                        #endregion Mirror axis number ( 2 Bytes )

                        #region motor control type ( 2 Bytes )
                        byteData = BitConverter.GetBytes((short)(m_CHeader.pSMotorInfo[i].nMotorControlType));
                        fs.Write(byteData, 0, 2);
                        byteData = null;
                        #endregion motor control type ( 2 Bytes )

                        #endregion Axis Info

                        #region 추가 - version 10400
                        if (nVersion >= 10400)
                        {                            
                            /////////// 추가
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].fRpm); fs.Write(byteData, 0, 4); byteData = null; // fRpm : // 기본 rpm 단위(0.229);

                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nLimitRpm_Raw); fs.Write(byteData, 0, 4); byteData = null; //415);
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nProtocolVersion); fs.Write(byteData, 0, 4); byteData = null; //2); // Version 2(0 해도 동일)
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nHwMotor_Index); fs.Write(byteData, 0, 4); byteData = null;  // 0 : None, 1 : xl-320, 2 : xl_430(Default), 3 - ax-12
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nHwMotor_Key); fs.Write(byteData, 0, 4); byteData = null; //1060); // 0번지에 모델번호 1060, XM430_W210 : 1030, XM430_W350 : 1020
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nAddr_Max); fs.Write(byteData, 0, 4); byteData = null;//146);
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nAddr_Torq); fs.Write(byteData, 0, 4); byteData = null;//64);
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nAddr_Led); fs.Write(byteData, 0, 4); byteData = null;//65);
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nAddr_Mode); fs.Write(byteData, 0, 4); byteData = null;//10); // 430 -> 10 address    [0 : 전류, 1 : 속도, 3(default) : 관절(위치제어), 4 : 확장위치제어(멀티턴:-256 ~ 256회전), 5 : 전류기반 위치제어, 16 : pwm 제어(voltage control mode)]
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nAddr_Speed); fs.Write(byteData, 0, 4); byteData = null;//104); // 430 -> 104 4 bytes
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nAddr_Speed_Size); fs.Write(byteData, 0, 4); byteData = null;//4);
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nAddr_Pos_Speed); fs.Write(byteData, 0, 4); byteData = null;//112); // 430 -> 112 4 bytes
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nAddr_Pos_Speed_Size); fs.Write(byteData, 0, 4); byteData = null;//4);
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nAddr_Pos); fs.Write(byteData, 0, 4); byteData = null;//116); // 430 -> 116 4 bytes
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nAddr_Pos_Size); fs.Write(byteData, 0, 4); byteData = null;//4);
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nSerialType); fs.Write(byteData, 0, 4); byteData = null;  // 0 : Default, 1 : Second ... (동시에 2개 이상의 시리얼에 연결된 경우 사용)

                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nMotorEnable_For_RPTask); fs.Write(byteData, 0, 4); byteData = null;
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nMotor_Enable); fs.Write(byteData, 0, 4); byteData = null;
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nMotionEditor_Index); fs.Write(byteData, 0, 4); byteData = null; // 0 이면 사용 안함. 1 부터 사용, 0 이상인 경우 여기의 인덱스를 우선적으로 적용, 하나를 세팅했으면 반드시 다른 하나도 세팅할 것
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nMotor_HightSpec); fs.Write(byteData, 0, 4); byteData = null; 
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nReserve_4); fs.Write(byteData, 0, 4); byteData = null; 
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nReserve_5); fs.Write(byteData, 0, 4); byteData = null; 
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nReserve_6); fs.Write(byteData, 0, 4); byteData = null; 
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nReserve_7); fs.Write(byteData, 0, 4); byteData = null; 
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nReserve_8); fs.Write(byteData, 0, 4); byteData = null; 
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nReserve_9); fs.Write(byteData, 0, 4); byteData = null;

                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].fGearRatio); fs.Write(byteData, 0, 4); byteData = null;
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].fRobotisConvertingVar); fs.Write(byteData, 0, 4); byteData = null; 
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].fReserve_2); fs.Write(byteData, 0, 4); byteData = null; 
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].fReserve_3); fs.Write(byteData, 0, 4); byteData = null; 
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].fReserve_4); fs.Write(byteData, 0, 4); byteData = null; 
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].fReserve_5); fs.Write(byteData, 0, 4); byteData = null; 
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].fReserve_6); fs.Write(byteData, 0, 4); byteData = null; 
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].fReserve_7); fs.Write(byteData, 0, 4); byteData = null; 
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].fReserve_8); fs.Write(byteData, 0, 4); byteData = null; 
                            byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].fReserve_9); fs.Write(byteData, 0, 4); byteData = null;

                            if (nVersion >= 10700)
                            {
                                byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nGuide_Event); fs.Write(byteData, 0, 4); byteData = null;
                                byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nGuide_AxisType); fs.Write(byteData, 0, 4); byteData = null;
                                byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nGuide_RingColorType); fs.Write(byteData, 0, 4); byteData = null;
                                byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].fGuide_RingSize); fs.Write(byteData, 0, 4); byteData = null;
                                byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].fGuide_RingThick); fs.Write(byteData, 0, 4); byteData = null;
                                if (m_CHeader.pSMotorInfo[i].nGuide_RingDir == 0) m_CHeader.pSMotorInfo[i].nGuide_RingDir = 1;
                                byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].nGuide_RingDir); fs.Write(byteData, 0, 4); byteData = null;
                                byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].fGuide_3D_Scale); fs.Write(byteData, 0, 4); byteData = null;
                                byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].fGuide_3D_Alpha); fs.Write(byteData, 0, 4); byteData = null;

                                if (m_CHeader.pSMotorInfo[i].afGuide_Pos == null)
                                {
                                    m_CHeader.pSMotorInfo[i].afGuide_Pos = new float[6];
                                    m_CHeader.pSMotorInfo[i].anGuide_Off_IDs = new int[6];
                                    m_CHeader.pSMotorInfo[i].anGuide_Off_Dir = new int[6];
                                    Array.Clear(m_CHeader.pSMotorInfo[i].afGuide_Pos, 0, m_CHeader.pSMotorInfo[i].afGuide_Pos.Length);
                                    Array.Clear(m_CHeader.pSMotorInfo[i].anGuide_Off_IDs, 0, m_CHeader.pSMotorInfo[i].anGuide_Off_IDs.Length);
                                    Array.Clear(m_CHeader.pSMotorInfo[i].anGuide_Off_Dir, 0, m_CHeader.pSMotorInfo[i].anGuide_Off_Dir.Length);
                                }
                                for (int nGuide = 0; nGuide < 6; nGuide++) { byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].afGuide_Pos[nGuide]); fs.Write(byteData, 0, 4); byteData = null; }
                                for (int nGuide = 0; nGuide < 6; nGuide++) { byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].anGuide_Off_IDs[nGuide]); fs.Write(byteData, 0, 4); byteData = null; }
                                for (int nGuide = 0; nGuide < 6; nGuide++) { byteData = BitConverter.GetBytes(m_CHeader.pSMotorInfo[i].anGuide_Off_Dir[nGuide]); fs.Write(byteData, 0, 4); byteData = null; }
                            }
                        }
                        #endregion 추가 - version 10400
                    }
                    #region Set the separation code(Kor: 구분 코드 부여) // HE - Header End ( 2 Bytes )
                    fs.WriteByte((byte)('H'));  // Header 
                    fs.WriteByte((byte)('E'));  // End
                    #endregion Set the separation code(Kor: 구분 코드 부여) // HE - Header End ( 2 Bytes )

                    for (i = 0; i < 512; i++)
                    {
                        #region Encrypetion

                        #region Secret
                        fs.WriteByte((byte)(m_CHeader.pnSecret[i] & 0xff));
                        #endregion Secret
                        #region Type - Wheel or not
                        fs.WriteByte((byte)(m_CHeader.pnType[i] & 0xff));
                        #endregion Type - Wheel or not

                        if (nVersion >= 010300) fs.WriteByte((byte)(Ojw.CConvert.BoolToInt(m_CHeader.pbPython[i]) & 0xff));

                        #endregion Encrypetion

                        #region Char - GroupName
                        byteData = Encoding.Default.GetBytes(m_CHeader.pstrGroupName[i]); // The name of the group that are listed in the string(Kor: 스트링으로 적혀있는 해당 그룹의 이름)
                        #region Char Size - Forward ( 2 Bytes )
                        byteData2 = BitConverter.GetBytes((short)(byteData.Length));
                        fs.Write(byteData2, 0, 2);
                        byteData2 = null;
                        #endregion Char Size - Forward ( 2 Bytes )
                        for (j = 0; j < byteData.Length; j++) fs.WriteByte(byteData[j]);
                        byteData = null;
                        #endregion Char - GroupName

                        #region Kinematics/InverseKinematics String
                        #region Char - Forward

                        bool bSecret = (m_CHeader.pnSecret[i] > 0) ? true : false;
                        if (bSecret == false) byteData = Encoding.Default.GetBytes(m_CHeader.pstrKinematics[i]);
                        else
                        {
                            byteData = Encoding.Default.GetBytes(m_CHeader.pstrKinematics[i]);
                            byteData = CEncryption.Encryption(bSecret, byteData);
                        }

                        #region Char Size - Forward ( 2 Bytes )
                        byteData2 = BitConverter.GetBytes((short)(byteData.Length));
                        fs.Write(byteData2, 0, 2);
                        byteData2 = null;
                        #endregion Char Size - Forward ( 2 Bytes )
                        for (j = 0; j < byteData.Length; j++) fs.WriteByte(byteData[j]);
                        byteData = null;
                        #endregion Char - Forward

                        #region Char - Inverse
                        if (bSecret == false) byteData = Encoding.Default.GetBytes(m_CHeader.pstrInverseKinematics[i]);
                        else
                        {
                            byteData = Encoding.Default.GetBytes(m_CHeader.pstrInverseKinematics[i]);
                            byteData = CEncryption.Encryption(bSecret, byteData);
                        }
                        #region Char Size - Inverse ( 2 Bytes )
                        byteData2 = BitConverter.GetBytes((short)(byteData.Length));
                        fs.Write(byteData2, 0, 2);
                        byteData2 = null;
                        #endregion Char Size - Inverse ( 2 Bytes )
                        for (j = 0; j < byteData.Length; j++) fs.WriteByte(byteData[j]);
                        byteData = null;
                        #endregion Char - Inverse
                        #endregion Kinematics/InverseKinematics String
                    }
                    #region Set the separation code(Kor: 구분 코드 부여) // KE - Kinematics End ( 2 Bytes )
                    fs.WriteByte((byte)('K'));  // Kinematics 
                    fs.WriteByte((byte)('E'));  // End
                    #endregion Set the separation code(Kor: 구분 코드 부여) // HE - Kinematics End ( 2 Bytes )

                    #region actual design string(Kor: 실 디자인 스트링)

                    #region Char - actual design string(Kor: 실 디자인 스트링)
                    byteData = Encoding.Default.GetBytes(CHeader.strDrawModel);
                    #region Char Size - actual design string(Kor: 실 디자인 스트링) ( 2 Bytes )
                    byteData2 = BitConverter.GetBytes((ushort)(byteData.Length));
                    fs.Write(byteData2, 0, 2);
                    byteData2 = null;
                    #endregion Char Size - actual design string(Kor: 실 디자인 스트링) ( 2 Bytes )

                    for (j = 0; j < byteData.Length; j++) fs.WriteByte(byteData[j]);
                    byteData = null;
                    #endregion Char - actual design string(Kor: 실 디자인 스트링)
                    #endregion actual design string(Kor: 실 디자인 스트링)

                    #region Comment String
                    #region Char - Comment
                    if (CHeader.strComment == null)
                    {
                        #region Char Size - Comment ( 2 Bytes )
                        byteData2 = BitConverter.GetBytes((short)(0));
                        fs.Write(byteData2, 0, 2);
                        byteData2 = null;
                        #endregion Char Size - Comment ( 2 Bytes )
                    }
                    else
                    {
                        byteData = Encoding.Default.GetBytes(CHeader.strComment);
                        #region Char Size - Comment ( 2 Bytes )
                        byteData2 = BitConverter.GetBytes((short)(byteData.Length));
                        fs.Write(byteData2, 0, 2);
                        byteData2 = null;
                        #endregion Char Size - Comment ( 2 Bytes )
                        for (j = 0; j < CHeader.strComment.Length; j++) fs.WriteByte(byteData[j]);
                        byteData = null;
                    }
                    #endregion Char - Comment
                    #endregion Comment String

                    #region Set the separation code(Kor: 구분 코드 부여) // FE - File End ( 2 Bytes )
                    fs.WriteByte((byte)('F'));  // File 
                    fs.WriteByte((byte)('E'));  // End
                    #endregion Set the separation code(Kor: 구분 코드 부여) // HE - File End ( 2 Bytes )
                    
                    if (nVersion >= 10500)
                    {
                        byteData = BitConverter.GetBytes(m_lstMotorsEn.Count); fs.Write(byteData, 0, 4); byteData = null;
                        for (i = 0; i < m_lstMotorsEn.Count; i++)
                        {
                            byteData = BitConverter.GetBytes(m_lstMotorsEn[i]); fs.Write(byteData, 0, 4); byteData = null;
                        }
                    }

                    #region GroupInfo
                    if (nVersion >= 10700)
                    {
                        #region GroupInfo - List Count
                        byteData2 = BitConverter.GetBytes((short)(m_CHeader.lstGroupInfo.Count));
                        fs.Write(byteData2, 0, 2);
                        #endregion GroupInfo - List Count

                        for (int k = 0; k < m_CHeader.lstGroupInfo.Count; k++)
                        {
                            // GroupNumber
                            byteData2 = BitConverter.GetBytes((short)(m_CHeader.lstGroupInfo[k].nNumber));
                            fs.Write(byteData2, 0, 2);
                            byteData2 = null;

                            // GroupName
                            byteData = Encoding.Default.GetBytes(m_CHeader.lstGroupInfo[k].strName);

                            // GroupName(Size)
                            byteData2 = BitConverter.GetBytes((short)(byteData.Length));
                            fs.Write(byteData2, 0, 2);
                            byteData2 = null;

                            // GroupName(String)
                            for (j = 0; j < byteData.Length; j++) fs.WriteByte(byteData[j]);
                            byteData = null;
                        }

                        byteData = BitConverter.GetBytes((short)(m_CHeader.SJson.nQr)); fs.Write(byteData, 0, 2);
                        for (int k = 0; k < 6; k++)
                        {
                            byteData = BitConverter.GetBytes(m_CHeader.SJson.afScene_Position[k]);
                            fs.Write(byteData, 0, 4);
                            byteData = null;
                        }
                        for (int k = 0; k < 6; k++)
                        {
                            byteData = BitConverter.GetBytes(m_CHeader.SJson.afCamera_Position[k]);
                            fs.Write(byteData, 0, 4);
                            byteData = null;
                        }
                        for (int k = 0; k < 6; k++)
                        {
                            byteData = BitConverter.GetBytes(m_CHeader.SJson.afRobot_Position[k]);
                            fs.Write(byteData, 0, 4);
                            byteData = null;
                        }
                        byteData = BitConverter.GetBytes(m_CHeader.SJson.fRobot_Scale);
                        fs.Write(byteData, 0, 4);
                        byteData = null;

                        byteData = BitConverter.GetBytes((int)m_CHeader.SJson.cBackColor.ToArgb());
                        fs.Write(byteData, 0, 4);
                        byteData = null;
                        byteData = BitConverter.GetBytes((int)m_CHeader.SJson.cBackColor_Edit.ToArgb());
                        fs.Write(byteData, 0, 4);
                        byteData = null;

                        byteData = BitConverter.GetBytes((int)m_CHeader.SJson.cPlaneColor.ToArgb());
                        fs.Write(byteData, 0, 4);
                        byteData = null;

                        byteData = BitConverter.GetBytes((short)(m_CHeader.SJson.IsWireFrame == true ? 1 : 0)); fs.Write(byteData, 0, 2);


                        // strBleName
                        byteData = Encoding.Default.GetBytes(m_CHeader.SJson.strBleName);
                        // strBleName(Size)
                        byteData2 = BitConverter.GetBytes((short)(byteData.Length));
                        fs.Write(byteData2, 0, 2);
                        byteData2 = null;
                        // strBleName(String)
                        for (j = 0; j < byteData.Length; j++) fs.WriteByte(byteData[j]);
                        byteData = null;


                        byteData = BitConverter.GetBytes((int)m_CHeader.SJson.nAddress_Motion);
                        fs.Write(byteData, 0, 4);
                        byteData = null;

                        byteData = BitConverter.GetBytes((int)m_CHeader.SJson.nAddress_Control);
                        fs.Write(byteData, 0, 4);
                        byteData = null;


                        //[2]m_CHeader.SJson.nQr = 0; // 1: Qr, 0: Ble
                        //[4...]m_CHeader.SJson.afScene_Position = new float[6] { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f };
                        //[4...]m_CHeader.SJson.afCamera_Position = new float[6] { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f };
                        //[4...]m_CHeader.SJson.afRobot_Position = new float[6] { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f };
                        //[4]m_CHeader.SJson.fRobot_Scale = 0.0f;
                        //[4]m_CHeader.SJson.cBackColor = Color.Black;
                        //[4]m_CHeader.SJson.cBackColor_Edit = Color.Black;
                        //[4]m_CHeader.SJson.cPlaneColor = Color.Black;
                        //[2]m_CHeader.SJson.IsWireFrame = false;
                        //[2, - ]m_CHeader.SJson.strBleName = "";
                        //[4]m_CHeader.SJson.nAddress_Motion = 0x12170000;
                        //[4]m_CHeader.SJson.nAddress_Control = 66;
                    }
                    #endregion GroupInfo



                    fs.Close();

                    //if (m_bAutoSaved == false) Modify(false);

                    byteData = null;
                    byteData2 = null;

                    //////////////////////////////
                    // Memory available for Dh(Kor: Dh 를 위한 메모리 확보)
                    m_CHeader.pDhParamAll = new CDhParamAll[512];
                    int nCnt_InverseKinematics = 0;
                    for (i = 0; i < 512; i++)
                    {
                        if (m_CHeader.pstrKinematics[i] != null)
                        {
                            if (m_CHeader.pstrKinematics[i].Length > 0)
                            {
                                // Forward
                                Ojw.CKinematics.CForward.MakeDhParam(m_CHeader.pstrKinematics[i], out m_CHeader.pDhParamAll[i]);
                                // Inverse
                                bool bError = Ojw.CKinematics.CInverse.Compile(((m_CHeader.pbPython[i] == true) ? "!" : string.Empty) + m_CHeader.pstrInverseKinematics[i], out m_CHeader.pSOjwCode[i]);

                                /////////////
                                if (m_CHeader.pSOjwCode[i].nMotor_Max > 0) nCnt_InverseKinematics++;
                            }
                        }
                    }
                }
                catch
                {
                    //Message("File save error");
                    fs.Close();
                }
            }
            public bool FileOpen_Without_Event(String strFileName, out COjwDesignerHeader CHeader)
            {
                m_bFileOpening = true;
                bool bFileOpened = true;
                bool bCheckOldStl = false;
                CHeader = null;
                string strVersion = String.Empty;
                try
                {
                    int i;

                    FileInfo f = new FileInfo(strFileName);
                    FileStream fs = f.OpenRead();

                    byte[] byteData = new byte[fs.Length];
                    string strFileName2 = "";
                    string strData = "";

                    #region Moved by opening the file into memory(Kor: 파일을 열어서 메모리로 옮김)
                    fs.Read(byteData, 0, byteData.Length);
                    strFileName2 = f.Name;
                    fs.Close();
                    #endregion Moved by opening the file into memory(Kor: 파일을 열어서 메모리로 옮김)

                    #region separation code - OJW1.0 ( (_STR_EXT.Length + _STR_EXT_VERSION.Length) Bytes )
                    String strTmp = String.Empty;
                    for (i = 0; i < (_STR_EXT.Length + _STR_EXT_VERSION.Length); i++) strTmp += ((char)byteData[i]).ToString().ToUpper();
                   
                    strData = (_STR_EXT.ToUpper() + _STR_EXT_VERSION.ToUpper());
                    #endregion separation code - OJW1.0 ( (_STR_EXT.Length + _STR_EXT_VERSION.Length) Bytes )
                    COjwDesignerHeader CDesignHeder = new COjwDesignerHeader();
                    #region OjwVersion
#if _DHF_FILE
                    if ((strTmp[0] == 'D') & (strTmp[1] == 'H') & (strTmp[2] == 'F'))
                    {
                        strVersion += (char)byteData[3];
                        strVersion += (char)byteData[4];
                        strVersion += (char)byteData[5];

                        // In version 1.1, there is a second position(Kor: 1.1 버전에서는 2번째 자세가 없다.)
                        bool bNoSecondPos = false;
                        bool bNoAxisMirror = false;
                        int nVersion = 11;

                        if (strTmp.Substring(0, 6) == "DHF1.1") nVersion = 11;
                        else if (strTmp.Substring(0, 6) == "DHF1.2") nVersion = 12;
                        else if (strTmp.Substring(0, 6) == "DHF1.3") nVersion = 13;
                        else if (strTmp.Substring(0, 6) == "DHF1.4") nVersion = 14;

                        CDesignHeder.strVersion = strTmp.Substring(0, 6);
                        CDesignHeder.nVersion = nVersion;

                        bCheckOldStl = true;

                        if (nVersion < 12)
                        {
                            bNoSecondPos = true;
                            bNoAxisMirror = true;
                        }
                        else if (nVersion == 12)
                        {
                            bNoAxisMirror = true;
                        }

                        int nPos = 6;   // 'HMT1.1'

                        #region From Version 1.1.0(_STR_EXT_VERSION = "01.01.00")( 4 Bytes )
                        CDesignHeder.nDefaultFunctionNumber = -1;// no use it in DHF
                        #endregion From Version 1.1.0(_STR_EXT_VERSION = "01.01.00")( 4 Bytes )

                        #region Model type ( 2 Bytes )
                        CDesignHeder.nModelNum = (int)(short)(BitConverter.ToInt16(byteData, nPos));
                        nPos += 2;
                        #endregion Model type ( 2 Bytes )

                        #region Title ( 21 Bytes )
                        CDesignHeder.strModelName = Encoding.Default.GetString(byteData, nPos, 21);
                        nPos += 21;
                        #endregion Title ( 21 Bytes )

                        #region BackColor - Background color ( 4 Bytes)
                        CDesignHeder.cBackColor = Color.FromArgb(BitConverter.ToInt32(byteData, nPos));
                        nPos += 4;
                        #endregion BackColor - Background color ( 4 Bytes)

                        #region Number of the motor ( 2 Bytes )
                        CDesignHeder.nMotorCnt = (int)(short)(BitConverter.ToInt16(byteData, nPos));
                        nPos += 2;
                        #endregion Number of the motor ( 2 Bytes )
                        #region initial angle
                        #region initial angle - Pan ( 4 Bytes )
                        CDesignHeder.SInitAngle.pan = BitConverter.ToSingle(byteData, nPos);
                        nPos += 4;
                        #endregion initial angle - Pan ( 4 Bytes )
                        #region initial angle - Tilt ( 4 Bytes )
                        CDesignHeder.SInitAngle.tilt = BitConverter.ToSingle(byteData, nPos);
                        nPos += 4;
                        #endregion initial angle - Tilt ( 4 Bytes )
                        #region initial angle - Swing ( 4 Bytes )
                        CDesignHeder.SInitAngle.swing = BitConverter.ToSingle(byteData, nPos);
                        nPos += 4;
                        #endregion initial angle - Swing ( 4 Bytes )
                        #endregion initial angle
                        #region Init position
                        #region Init position - x ( 4 Bytes )
                        CDesignHeder.SInitPos.x = BitConverter.ToSingle(byteData, nPos);
                        nPos += 4;
                        #endregion Init position - x ( 4 Bytes )
                        #region Init position - y ( 4 Bytes )
                        CDesignHeder.SInitPos.y = BitConverter.ToSingle(byteData, nPos);
                        nPos += 4;
                        #endregion Init position - y ( 4 Bytes )
                        #region Init position - z ( 4 Bytes )
                        CDesignHeder.SInitPos.z = BitConverter.ToSingle(byteData, nPos);
                        nPos += 4;
                        #endregion Init position - z ( 4 Bytes )
                        #endregion Init position

                        #region Init Scale - 100% = 1.0 ( 4 Bytes )
                        CDesignHeder.fInitScale = BitConverter.ToSingle(byteData, nPos);
                        nPos += 4;
                        #endregion Init Scale - 100% = 1.0 ( 4 Bytes )

                        if (nVersion >= 14)
                        {
                            #region 2 Wheel Counter ( 1 Bytes )
                            CDesignHeder.nWheelCounter_2 = (int)byteData[nPos++];
                            #endregion 2 Wheel Counter ( 1 Bytes )

                            #region 3 Wheel Counter ( 1 Bytes )
                            CDesignHeder.nWheelCounter_3 = (int)byteData[nPos++];
                            #endregion 3 Wheel Counter ( 1 Bytes )

                            #region 4 Wheel Counter ( 1 Bytes )
                            CDesignHeder.nWheelCounter_4 = (int)byteData[nPos++];
                            #endregion 4 Wheel Counter ( 1 Bytes )
                        }

                        for (i = 0; i < 256; i++)
                        {
                            #region Axis MotorInfo

                            #region Motor ID ( 2 Byte )
                            CDesignHeder.pSMotorInfo[i].nMotorID = (int)(short)BitConverter.ToInt16(byteData, nPos);
                            nPos += 2;
                            #endregion Motor ID ( 2 Byte )

                            #region Direction - 0 - Forward, 1 - Inverse ( 2 Bytes )
                            CDesignHeder.pSMotorInfo[i].nMotorDir = (int)(short)BitConverter.ToInt16(byteData, nPos);
                            nPos += 2;
                            #endregion Direction - 0 - Forward, 1 - Inverse ( 2 Bytes )

                            #region Max Angle (+) ( 4 Bytes )
                            CDesignHeder.pSMotorInfo[i].fLimit_Up = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion Max Angle (+) ( 4 Bytes )

                            #region Min Angle (-) ( 4 Bytes )
                            CDesignHeder.pSMotorInfo[i].fLimit_Down = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion Min Angle (-) ( 4 Bytes )

                            #region Center Position - Evd ( 2 Bytes )
                            CDesignHeder.pSMotorInfo[i].nCenter_Evd = BitConverter.ToInt16(byteData, nPos);
                            nPos += 2;
                            #endregion Center Position - Evd ( 2 Bytes )

                            #region Mech Move - Maximum pulse Evd ( 2 Bytes )
                            CDesignHeder.pSMotorInfo[i].nMechMove = BitConverter.ToInt16(byteData, nPos);
                            nPos += 2;
                            #endregion Mech Move - Maximum pulse Evd ( 2 Bytes )

                            #region Mech Angle - Angle of Mech Mov [ The maximum pulse corresponding to the angle value(Kor: 최대치 펄스에 해당하는 각도값 (분주각))]( 4 Bytes )
                            CDesignHeder.pSMotorInfo[i].fMechAngle = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion Mech Angle - Angle of Mech Mov [ The maximum pulse corresponding to the angle value(Kor: 최대치 펄스에 해당하는 각도값 (분주각))]( 4 Bytes )

                            #region Init Angle - Used for the initial position of the data in an arbitrary position( 4 Bytes )(Kor: 데이타의 초기자세를 임의의 자세로 하기 위해 사용( 4 Bytes ))
                            CDesignHeder.pSMotorInfo[i].fInitAngle = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            if (bNoSecondPos == false)
                            {
                                CDesignHeder.pSMotorInfo[i].fInitAngle2 = BitConverter.ToSingle(byteData, nPos);
                                nPos += 4;
                            }
                            #endregion Init Angle - Used for the initial position of the data in an arbitrary position( 4 Bytes )(Kor: 데이타의 초기자세를 임의의 자세로 하기 위해 사용( 4 Bytes ))

                            #region Interference axis number(Kor: 간섭 축 번호) ( 2 Bytes )
                            CDesignHeder.pSMotorInfo[i].nInterference_Axis = BitConverter.ToInt16(byteData, nPos);
                            nPos += 2;
                            #endregion Interference axis number(Kor: 간섭 축 번호) ( 2 Bytes )

                            #region axis Width ( 4 Bytes )
                            CDesignHeder.pSMotorInfo[i].fW = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion axis Width ( 4 Bytes )

                            #region Interference axis Width ( 4 Bytes )
                            CDesignHeder.pSMotorInfo[i].fInterference_W = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion Interference axis Width ( 4 Bytes )

                            #region axis Side ( Right ) ( 4 Bytes )
                            CDesignHeder.pSMotorInfo[i].fPos_Right = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion axis Side ( Right ) ( 4 Bytes )

                            #region axis Side ( Left) ( 4 Bytes )
                            CDesignHeder.pSMotorInfo[i].fPos_Left = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion axis Side ( Left) ( 4 Bytes )

                            #region Interference axis ( Front ) ( 4 Bytes )
                            CDesignHeder.pSMotorInfo[i].fInterference_Pos_Front = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion Interference axis ( Front ) ( 4 Bytes )

                            #region Interference axis ( Rear ) ( 4 Bytes )
                            CDesignHeder.pSMotorInfo[i].fInterference_Pos_Rear = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion Interference axis ( Rear ) ( 4 Bytes )

                            #region NickName ( 32 Bytes )
                            CDesignHeder.pSMotorInfo[i].strNickName = Encoding.Default.GetString(byteData, nPos, 32);
                            nPos += 32;
                            #endregion NickName ( 32 Bytes )

                            #region Group Number ( 2 Bytes )
                            CDesignHeder.pSMotorInfo[i].nGroupNumber = BitConverter.ToInt16(byteData, nPos);
                            nPos += 2;
                            #endregion Group Number ( 2 Bytes )

                            #region mirroring axis number ( 2 Bytes )
                            if (bNoAxisMirror == false)
                            {
                                CDesignHeder.pSMotorInfo[i].nAxis_Mirror = BitConverter.ToInt16(byteData, nPos);
                                nPos += 2;
                            }
                            #endregion mirroring axis number ( 2 Bytes )
                            #region V1.4
                            #region Motor control type ( 2 Bytes )
                            if (nVersion >= 14)
                            {
                                CDesignHeder.pSMotorInfo[i].nMotorControlType = BitConverter.ToInt16(byteData, nPos);
                                nPos += 2;
                            }
                            #endregion mirroring axis number ( 2 Bytes )
                            #endregion V1.4

                            #endregion Axis MotorInfo
                        }

                        #region set the separation code [ HE - Header End ( 2 Bytes ) ]
                        strData = "";
                        strData += (char)(byteData[nPos++]);
                        strData += (char)(byteData[nPos++]);
                        if (strData != "HE") bFileOpened = false;
                        #endregion set the separation code [ HE - Header End ( 2 Bytes ) ]

                        int nSize_GroupName;
                        int nSize_0;
                        int nSize_1;
                        for (i = 0; i < 512; i++)
                        {
                            #region V1.4
                            if (nVersion >= 14)
                            {
                                #region Secret Mode
                                // Verify that the encryption code -> If this is the encryption code is set to '1'.
                                // Kor: // 암호화 코드인지 확인 -> 암호화 코드라면 '1'
                                CDesignHeder.pnSecret[i] = (int)(byte)(byteData[nPos++]);
                                #endregion Secret Mode
                                #region Type
                                // check formulas Control Type -> If the wheel-type control '1', if the position type control '0'
                                // Kor: 수식 제어타입 확인 -> 바퀴형 제어라면 '1', 위치형 제어라면 '0'
                                CDesignHeder.pnType[i] = (int)(byte)(byteData[nPos++]);
                                #endregion Type
                            }
                            #endregion V1.4

                            #region GroupName String

                            #region Size - Kinematics ( 2 Bytes )
                            nSize_GroupName = (int)(short)(BitConverter.ToInt16(byteData, nPos));
                            nPos += 2;
                            #endregion Size - Kinematics ( 2 Bytes )

                            #region String - Kinematics
                            CDesignHeder.pstrGroupName[i] = Encoding.Default.GetString(byteData, nPos, nSize_GroupName);
                            nPos += nSize_GroupName;
                            #endregion String - Kinematics

                            #endregion GroupName String

                            #region Kinematics/InverseKinematics String
                            #region Size - Kinematics ( 2 Bytes )
                            nSize_0 = (int)(short)(BitConverter.ToInt16(byteData, nPos));
                            nPos += 2;
                            #endregion Size - Kinematics ( 2 Bytes )

                            #region String - Kinematics
                            //CDesignHeder.pstrKinematics[i] = "";
                            //for (int j = 0; j < nSize_0; j++) CDesignHeder.pstrKinematics[i] += (char)(byteData[nPos++]);
                            CDesignHeder.pstrKinematics[i] = Encoding.Default.GetString(byteData, nPos, nSize_0);
                            // Since then loads the data may be encrypted.(Kor: 암호화 데이터일 수도 있으므로 로딩)
                            CDesignHeder.pSEncryptKinematics_encryption[i].byteEncryption = new byte[nSize_0];
                            Array.Copy(byteData, nPos, CDesignHeder.pSEncryptKinematics_encryption[i].byteEncryption, 0, nSize_0);

                            nPos += nSize_0;
                            #endregion String - Kinematics

                            #region Size - InverseKinematics ( 2 Bytes )
                            nSize_1 = (int)(short)(int)(short)(BitConverter.ToInt16(byteData, nPos));
                            nPos += 2;
                            #endregion Size - InverseKinematics ( 2 Bytes )

                            #region String - InverseKinematics
                            CDesignHeder.pstrInverseKinematics[i] = Encoding.Default.GetString(byteData, nPos, nSize_1);
                            // Since then loads the data may be encrypted.(Kor: 암호화 데이터일 수도 있으므로 로딩)
                            CDesignHeder.pSEncryptInverseKinematics_encryption[i].byteEncryption = new byte[nSize_1];
                            Array.Copy(byteData, nPos, CDesignHeder.pSEncryptInverseKinematics_encryption[i].byteEncryption, 0, nSize_1);

                            nPos += nSize_1;
                            #endregion String - InverseKinematics
                            #endregion Kinematics/InverseKinematics String
                        }

                        #region set the separation code [ KE - Kinematics End ( 2 Bytes ) ]
                        strData = "";
                        strData += (char)(byteData[nPos++]);
                        strData += (char)(byteData[nPos++]);
                        if (strData != "KE") bFileOpened = false;
                        #endregion set the separation code [ KE - Kinematics End ( 2 Bytes ) ]

                        #region Actual design string
                        #region Size - Actual design string ( 2 Bytes )
                        nSize_0 = (int)(ushort)(BitConverter.ToUInt16(byteData, nPos));
                        nPos += 2;
                        #endregion Size - Actual design string ( 2 Bytes )

                        #region String - Actual design string
                        //CDesignHeder.strDrawModel = "";
                        CDesignHeder.strDrawModel = Encoding.Default.GetString(byteData, nPos, nSize_0);//CConvert.RemoveChar(Encoding.Default.GetString(byteData, nPos, nSize_0), '\r');
                        nPos += nSize_0;
                        // Dhf -> Ojw(Convert)
                        String[] pstrLine = CDesignHeder.strDrawModel.Split('\n');
                        int nCnt = 0;
                        StringBuilder sbAll = new StringBuilder();

#if _USING_DOTNET_3_5
                        sbAll.Remove(0, sbAll.Length);
#elif _USING_DOTNET_2_0
                        sbAll.Remove(0, sbAll.Length);
#else
                        sbAll.Clear(); // Dotnet 4.0 이상에서만 사용
#endif
                        foreach (string strLine in pstrLine)
                        {
                            String[] pstrTmp = strLine.Split(',');
                            //if (pstrTmp.Length > 10)
                            //{
                            nCnt = 0;
                            bool bCaption = false;
                            int nModelPosition = 2;
                            foreach (string strItem in pstrTmp)
                            {
                                if (strItem.IndexOf("//") >= 0)
                                {
                                    bCaption = true;
                                }
                                else if (bCaption == false)
                                {
                                    if (nCnt++ == nModelPosition)
                                    {
                                        sbAll.Append("1.0,");
                                        int nData = CConvert.StrToInt(strItem);
                                        if (nData >= 0x1000) sbAll.Append(CConvert.IntToStr(nData - 0x1000));
                                        else sbAll.Append("#" + CConvert.RemoveChar(strItem, ' '));
                                    }
                                }
                                if (nCnt != (nModelPosition + 1)) { sbAll.Append(CConvert.RemoveChar(strItem, ' ')); }
                                else nCnt++;
                                // ojw5014 - ,(콤마) 붙는거 해결할 것.
                                if (strItem.IndexOf('\r') < 0) sbAll.Append(',');
                                else sbAll.Append("\n");
                            }
                            //}
                        }
                        CDesignHeder.strDrawModel = sbAll.ToString();
                        if (bCheckOldStl)
                        {
                            CDesignHeder.strDrawModel = Ojw.CConvert.ChangeString(CDesignHeder.strDrawModel.ToLower(), ".stl", ".stl*");
                        }
                        // Set a new version
                        CDesignHeder.strVersion = _STR_EXT.ToUpper() + C3d._STR_EXT_VERSION.ToUpper();
                        #endregion String - Actual design string
                        #endregion Actual design string


                        #region Comment
                        #region Size - Comment ( 2 Bytes )
                        nSize_0 = (int)(short)(int)(short)(BitConverter.ToInt16(byteData, nPos));
                        nPos += 2;
                        #endregion Size - Comment ( 2 Bytes )

                        #region String - Comment
                        CDesignHeder.strComment = Encoding.Default.GetString(byteData, nPos, nSize_0);
                        nPos += nSize_0;
                        #endregion String - Comment
                        #endregion Comment

                        #region set the separation code [ FE - File End ( 2 Bytes ) ]
                        strData = "";
                        strData += (char)(byteData[nPos++]);
                        strData += (char)(byteData[nPos++]);
                        if (strData != "FE") bFileOpened = false;
                        #endregion set the separation code [ FE - File End ( 2 Bytes ) ]

                        //fs.Close();
                        //bFileOpened = true;


                    }
                    else
#endif // _DHF_FILE
#if true
                        if ((strTmp[0] == 'O') & (strTmp[1] == 'J') & (strTmp[2] == 'W'))//(strTmp == strData) 
                        {
                            int nVersion = 0;// 010000; // 01.00.00
                            for (i = 3; i < (_STR_EXT.Length + _STR_EXT_VERSION.Length); i++)
                            {
                                strVersion += (char)byteData[i];
                                if ((char)byteData[i] != '.')
                                {
                                    nVersion = nVersion * 10 + (int)(byteData[i] - 0x30);
                                }
                            }

                            CDesignHeder.strVersion = strTmp;
                            CDesignHeder.nVersion = nVersion;

                            int nPos = (_STR_EXT.Length + _STR_EXT_VERSION.Length);   // 앞의 (_STR_EXT.Length + _STR_EXT_VERSION.Length)개는 'OJW01.00.00' 에 할당

                            #region From Version 1.1.0(_STR_EXT_VERSION = "01.01.00")( 4 Bytes )
                            if (nVersion > 010000)
                            {
                                CDesignHeder.nDefaultFunctionNumber = (int)(BitConverter.ToInt32(byteData, nPos));
                                //SetFunctionNumber(CDesignHeder.nDefaultFunctionNumber);                                
                                //Prop_Set_Main_DefaultFunctionNum(CDesignHeder.nDefaultFunctionNumber);
                                nPos += 4;
                            }

                            if (nVersion < 010600)
                            {
                                bCheckOldStl = true;
                            }
                            bool bJason = false;
                            if (nVersion >= 010700)
                            {
                                bJason = true;
                            }
                            #endregion From Version 1.1.0(_STR_EXT_VERSION = "01.01.00")( 4 Bytes )

                            #region Model type ( 2 Bytes )
                            CDesignHeder.nModelNum = (int)(short)(BitConverter.ToInt16(byteData, nPos));
                            nPos += 2;
                            #endregion Model type ( 2 Bytes )

                            //////////// 추가항목
                            #region Json Title  ( 21 Bytes )
                            if (nVersion >= 010800)
                            {
                                CDesignHeder.strTitle = Encoding.Default.GetString(byteData, nPos, 21);
                                nPos += 21;
                            }
                            #endregion Json Title  ( 21 Bytes )
                            //////////// 추가항목

                            #region Title ( 21 Bytes )
                            CDesignHeder.strModelName = Encoding.Default.GetString(byteData, nPos, 21);
                            nPos += 21;
                            #endregion Title ( 21 Bytes )

                            #region BackColor - background color ( 4 Bytes)
                            CDesignHeder.cBackColor = Color.FromArgb(BitConverter.ToInt32(byteData, nPos));
                            nPos += 4;
                            #endregion BackColor - background color ( 4 Bytes)

                            #region Num. of Motor ( 2 Bytes )
                            CDesignHeder.nMotorCnt = (int)(short)(BitConverter.ToInt16(byteData, nPos));
                            nPos += 2;
                            #endregion Num. of Motor ( 2 Bytes )
                            #region Init Angle
                            #region Init Angle - Pan ( 4 Bytes )
                            CDesignHeder.SInitAngle.pan = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion Init Angle - Pan ( 4 Bytes )
                            #region Init Angle - Tilt ( 4 Bytes )
                            CDesignHeder.SInitAngle.tilt = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion Init Angle - Tilt ( 4 Bytes )
                            #region Init Angle - Swing ( 4 Bytes )
                            CDesignHeder.SInitAngle.swing = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion Init Angle - Swing ( 4 Bytes )
                            #endregion Init Angle
                            #region Init Position
                            #region Init Position - x ( 4 Bytes )
                            CDesignHeder.SInitPos.x = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion Init Position - x ( 4 Bytes )
                            #region Init Position - y ( 4 Bytes )
                            CDesignHeder.SInitPos.y = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion Init Position - y ( 4 Bytes )
                            #region Init Position - z ( 4 Bytes )
                            CDesignHeder.SInitPos.z = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion Init Position - z ( 4 Bytes )
                            #endregion Init Position

                            #region Init Scale - 100% = 1.0 ( 4 Bytes )
                            CDesignHeder.fInitScale = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion Init Scale - 100% = 1.0 ( 4 Bytes )

                            #region 2 Wheel Counter ( 1 Bytes )
                            CDesignHeder.nWheelCounter_2 = (int)byteData[nPos++];
                            #endregion 2 Wheel Counter ( 1 Bytes )

                            #region 3 Wheel Counter ( 1 Bytes )
                            CDesignHeder.nWheelCounter_3 = (int)byteData[nPos++];
                            #endregion 3 Wheel Counter ( 1 Bytes )

                            #region 4 Wheel Counter ( 1 Bytes )
                            CDesignHeder.nWheelCounter_4 = (int)byteData[nPos++];
                            #endregion 4 Wheel Counter ( 1 Bytes )

                            for (i = 0; i < 256; i++)
                            {
                                #region Axis MotorInfo

                                #region Motor ID ( 2 Byte )
                                CDesignHeder.pSMotorInfo[i].nMotorID = (int)(short)BitConverter.ToInt16(byteData, nPos);
                                nPos += 2;
                                #endregion Motor ID ( 2 Byte )

                                #region Direction - 0 - Forward, 1 - Inverse ( 2 Bytes )
                                CDesignHeder.pSMotorInfo[i].nMotorDir = (int)(short)BitConverter.ToInt16(byteData, nPos);
                                nPos += 2;
                                #endregion Direction - 0 - Forward, 1 - Inverse ( 2 Bytes )

                                #region Max Angle (+) ( 4 Bytes )
                                CDesignHeder.pSMotorInfo[i].fLimit_Up = BitConverter.ToSingle(byteData, nPos);
                                nPos += 4;
                                #endregion Max Angle (+) ( 4 Bytes )

                                #region Min Angle (-) ( 4 Bytes )
                                CDesignHeder.pSMotorInfo[i].fLimit_Down = BitConverter.ToSingle(byteData, nPos);
                                nPos += 4;
                                #endregion Min Angle (-) ( 4 Bytes )

                                if (nVersion < 010200)
                                {
                                    #region Center Position - Evd ( 2 Bytes )
                                    CDesignHeder.pSMotorInfo[i].nCenter_Evd = BitConverter.ToInt16(byteData, nPos);
                                    nPos += 2;
                                    #endregion Center Position - Evd ( 2 Bytes )

                                    #region Mech Move - Maximum Pulse value(Evd)(Kor: 최대치 펄스값 Evd)( 2 Bytes )
                                    CDesignHeder.pSMotorInfo[i].nMechMove = BitConverter.ToInt16(byteData, nPos);
                                    nPos += 2;
                                    #endregion Mech Move - Maximum Pulse value(Evd)(Kor: 최대치 펄스값 Evd)( 2 Bytes )
                                }
                                else
                                {
                                    #region Center Position - Evd ( 4 Bytes )
                                    CDesignHeder.pSMotorInfo[i].nCenter_Evd = BitConverter.ToInt32(byteData, nPos);
                                    nPos += 4;
                                    #endregion Center Position - Evd ( 4 Bytes )

                                    #region Mech Move - Maximum Pulse value(Evd)(Kor: 최대치 펄스값 Evd)( 4 Bytes )
                                    CDesignHeder.pSMotorInfo[i].nMechMove = BitConverter.ToInt32(byteData, nPos);
                                    nPos += 4;
                                    #endregion Mech Move - Maximum Pulse value(Evd)(Kor: 최대치 펄스값 Evd)( 4 Bytes )
                                }
                                #region Mech Angle - Angle of Mech Mov [ The maximum pulse corresponding to the angle value(Kor: 최대치 펄스에 해당하는 각도값 (분주각))]( 4 Bytes )
                                CDesignHeder.pSMotorInfo[i].fMechAngle = BitConverter.ToSingle(byteData, nPos);
                                nPos += 4;
                                #endregion Mech Angle - Angle of Mech Mov [ The maximum pulse corresponding to the angle value(Kor: 최대치 펄스에 해당하는 각도값 (분주각))]( 4 Bytes )

                                #region Init Angle - Used for the initial position of the data in an arbitrary position( 4 Bytes )(Kor: 데이타의 초기자세를 임의의 자세로 하기 위해 사용( 4 Bytes ))
                                // First Posture
                                CDesignHeder.pSMotorInfo[i].fInitAngle = BitConverter.ToSingle(byteData, nPos);
                                nPos += 4;
                                // Second Posture
                                CDesignHeder.pSMotorInfo[i].fInitAngle2 = BitConverter.ToSingle(byteData, nPos);
                                nPos += 4;
                                #endregion Init Angle - Used for the initial position of the data in an arbitrary position( 4 Bytes )(Kor: 데이타의 초기자세를 임의의 자세로 하기 위해 사용( 4 Bytes ))

                                #region Interference axis number(Kor: 간섭 축 번호) ( 2 Bytes )
                                CDesignHeder.pSMotorInfo[i].nInterference_Axis = BitConverter.ToInt16(byteData, nPos);
                                nPos += 2;
                                #endregion Interference axis number(Kor: 간섭 축 번호) ( 2 Bytes )

                                #region axis Width ( 4 Bytes )
                                CDesignHeder.pSMotorInfo[i].fW = BitConverter.ToSingle(byteData, nPos);
                                nPos += 4;
                                #endregion axis Width ( 4 Bytes )

                                #region Interference axis Width ( 4 Bytes )
                                CDesignHeder.pSMotorInfo[i].fInterference_W = BitConverter.ToSingle(byteData, nPos);
                                nPos += 4;
                                #endregion Interference axis Width ( 4 Bytes )

                                #region Axis Side ( Right ) ( 4 Bytes )
                                CDesignHeder.pSMotorInfo[i].fPos_Right = BitConverter.ToSingle(byteData, nPos);
                                nPos += 4;
                                #endregion Axis Side ( Right ) ( 4 Bytes )

                                #region Axis Side ( Left) ( 4 Bytes )
                                CDesignHeder.pSMotorInfo[i].fPos_Left = BitConverter.ToSingle(byteData, nPos);
                                nPos += 4;
                                #endregion Axis Side ( Left) ( 4 Bytes )

                                #region Interference axis ( Front ) ( 4 Bytes )
                                CDesignHeder.pSMotorInfo[i].fInterference_Pos_Front = BitConverter.ToSingle(byteData, nPos);
                                nPos += 4;
                                #endregion Interference axis ( Front ) ( 4 Bytes )

                                #region Interference axis ( Rear ) ( 4 Bytes )
                                CDesignHeder.pSMotorInfo[i].fInterference_Pos_Rear = BitConverter.ToSingle(byteData, nPos);
                                nPos += 4;
                                #endregion Interference axis ( Rear ) ( 4 Bytes )

                                #region NickName ( 32 Bytes )
                                CDesignHeder.pSMotorInfo[i].strNickName = Encoding.Default.GetString(byteData, nPos, 32);
                                nPos += 32;
                                #endregion NickName ( 32 Bytes )

                                #region Group Number ( 2 Bytes )
                                CDesignHeder.pSMotorInfo[i].nGroupNumber = BitConverter.ToInt16(byteData, nPos);
                                nPos += 2;
                                #endregion Group Number ( 2 Bytes )

                                #region mirroring axis number ( 2 Bytes )
                                CDesignHeder.pSMotorInfo[i].nAxis_Mirror = BitConverter.ToInt16(byteData, nPos);
                                nPos += 2;
                                #endregion mirroring axis number ( 2 Bytes )
                                #region V1.0.0
                                #region Motor control type ( 2 Bytes )
                                CDesignHeder.pSMotorInfo[i].nMotorControlType = BitConverter.ToInt16(byteData, nPos);
                                nPos += 2;
                                #endregion mirroring axis number ( 2 Bytes )
                                #endregion V1.0.0

                                #endregion Axis MotorInfo
                                
                                #region 추가 - version 10400
                                if (nVersion >= 10400)
                                {
                                    /////////// 추가
                                    CDesignHeder.pSMotorInfo[i].fRpm = BitConverter.ToSingle(byteData, nPos); nPos += 4;

                                    CDesignHeder.pSMotorInfo[i].nLimitRpm_Raw = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nProtocolVersion = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nHwMotor_Index = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nHwMotor_Key = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nAddr_Max = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nAddr_Torq = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nAddr_Led = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nAddr_Mode = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nAddr_Speed = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nAddr_Speed_Size = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nAddr_Pos_Speed = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nAddr_Pos_Speed_Size = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nAddr_Pos = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nAddr_Pos_Size = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nSerialType = BitConverter.ToInt32(byteData, nPos); nPos += 4;

                                    CDesignHeder.pSMotorInfo[i].nMotorEnable_For_RPTask = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nMotor_Enable = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nMotionEditor_Index = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nMotor_HightSpec = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nReserve_4 = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nReserve_5 = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nReserve_6 = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nReserve_7 = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nReserve_8 = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nReserve_9 = BitConverter.ToInt32(byteData, nPos); nPos += 4;

                                    CDesignHeder.pSMotorInfo[i].fGearRatio = BitConverter.ToSingle(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].fRobotisConvertingVar = BitConverter.ToSingle(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].fReserve_2 = BitConverter.ToSingle(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].fReserve_3 = BitConverter.ToSingle(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].fReserve_4 = BitConverter.ToSingle(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].fReserve_5 = BitConverter.ToSingle(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].fReserve_6 = BitConverter.ToSingle(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].fReserve_7 = BitConverter.ToSingle(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].fReserve_8 = BitConverter.ToSingle(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].fReserve_9 = BitConverter.ToSingle(byteData, nPos); nPos += 4;

                                    if (CDesignHeder.pSMotorInfo[i].nHwMotor_Index > 0)
                                    {
                                        // 모델명이 지정되어 있다면 앞의것들 무시...
#if !_MONSTER_LIB
                                        m_CRobotis.SetParam(i, CDesignHeder.pSMotorInfo[i].nHwMotor_Index);
#endif
                                        
                                    }

                                    if (bJason == true)
                                    {
                                        CDesignHeder.pSMotorInfo[i].nGuide_Event = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                        CDesignHeder.pSMotorInfo[i].nGuide_AxisType = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                        CDesignHeder.pSMotorInfo[i].nGuide_RingColorType = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                        CDesignHeder.pSMotorInfo[i].fGuide_RingSize = BitConverter.ToSingle(byteData, nPos); nPos += 4;
                                        CDesignHeder.pSMotorInfo[i].fGuide_RingThick = BitConverter.ToSingle(byteData, nPos); nPos += 4;
                                        CDesignHeder.pSMotorInfo[i].nGuide_RingDir = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                        if (CDesignHeder.pSMotorInfo[i].nGuide_RingDir == 0) CDesignHeder.pSMotorInfo[i].nGuide_RingDir = 1;
                                        CDesignHeder.pSMotorInfo[i].fGuide_3D_Scale = BitConverter.ToSingle(byteData, nPos); nPos += 4;
                                        CDesignHeder.pSMotorInfo[i].fGuide_3D_Alpha = BitConverter.ToSingle(byteData, nPos); nPos += 4;

                                        if (CDesignHeder.pSMotorInfo[i].afGuide_Pos == null)
                                        {
                                            CDesignHeder.pSMotorInfo[i].afGuide_Pos = new float[6];
                                            CDesignHeder.pSMotorInfo[i].anGuide_Off_IDs = new int[6];
                                            CDesignHeder.pSMotorInfo[i].anGuide_Off_Dir = new int[6];
                                            Array.Clear(CDesignHeder.pSMotorInfo[i].afGuide_Pos, 0, CDesignHeder.pSMotorInfo[i].afGuide_Pos.Length);
                                            Array.Clear(CDesignHeder.pSMotorInfo[i].anGuide_Off_IDs, 0, CDesignHeder.pSMotorInfo[i].anGuide_Off_IDs.Length);
                                            Array.Clear(CDesignHeder.pSMotorInfo[i].anGuide_Off_Dir, 0, CDesignHeder.pSMotorInfo[i].anGuide_Off_Dir.Length);
                                        }
                                        for (int nGuide = 0; nGuide < 6; nGuide++) { CDesignHeder.pSMotorInfo[i].afGuide_Pos[nGuide] = BitConverter.ToSingle(byteData, nPos); nPos += 4; }
                                        for (int nGuide = 0; nGuide < 6; nGuide++) { CDesignHeder.pSMotorInfo[i].anGuide_Off_IDs[nGuide] = BitConverter.ToInt32(byteData, nPos); nPos += 4; }
                                        for (int nGuide = 0; nGuide < 6; nGuide++) { CDesignHeder.pSMotorInfo[i].anGuide_Off_Dir[nGuide] = BitConverter.ToInt32(byteData, nPos); nPos += 4; }
                                    }
                                }
                                #endregion 추가 - version 10400
                            }

                            m_CMonster.SetHeader(CDesignHeder);

                            #region set the separation code [ HE - Header End ( 2 Bytes ) ]
                            strData = "";
                            strData += (char)(byteData[nPos++]);
                            strData += (char)(byteData[nPos++]);
                            if (strData != "HE") bFileOpened = false;
                            #endregion set the separation code [ HE - Header End ( 2 Bytes ) ]

                            int nSize_GroupName;
                            int nSize_0;
                            int nSize_1;
                            for (i = 0; i < 512; i++)
                            {
                                #region V1.0.0
                                #region Secret Mode
                                // Verify that the encryption code -> If this is the encryption code is set to '1'.
                                // Kor: // 암호화 코드인지 확인 -> 암호화 코드라면 '1'
                                CDesignHeder.pnSecret[i] = (int)(byte)(byteData[nPos++]);
                                #endregion Secret Mode
                                #region Type
                                // check formulas Control Type -> If the wheel-type control '1', if the position type control '0'
                                // Kor: 수식 제어타입 확인 -> 바퀴형 제어라면 '1', 위치형 제어라면 '0'
                                CDesignHeder.pnType[i] = (int)(byte)(byteData[nPos++]);
                                #endregion Type

                                #region Python
                                //01.03.00                                
                                if (nVersion >= 010300) CDesignHeder.pbPython[i] = Ojw.CConvert.IntToBool(byteData[nPos++]);
                                #endregion Python

                                #endregion V1.0.0

                                #region GroupName String

                                #region Size - Kinematics ( 2 Bytes )
                                nSize_GroupName = (int)(short)(BitConverter.ToInt16(byteData, nPos));
                                nPos += 2;
                                #endregion Size - Kinematics ( 2 Bytes )

                                #region String - Kinematics
                                CDesignHeder.pstrGroupName[i] = Encoding.Default.GetString(byteData, nPos, nSize_GroupName);
                                nPos += nSize_GroupName;
                                #endregion String - Kinematics

                                #endregion GroupName String

                                #region Kinematics/InverseKinematics String
                                #region Size - Kinematics ( 2 Bytes )
                                nSize_0 = (int)(short)(BitConverter.ToInt16(byteData, nPos));
                                nPos += 2;
                                #endregion Size - Kinematics ( 2 Bytes )

                                #region String - Kinematics
                                //CDesignHeder.pstrKinematics[i] = "";
                                //for (int j = 0; j < nSize_0; j++) CDesignHeder.pstrKinematics[i] += (char)(byteData[nPos++]);
                                CDesignHeder.pstrKinematics[i] = Encoding.Default.GetString(byteData, nPos, nSize_0);
                                // Since then loads the data may be encrypted.(Kor: 암호화 데이터일 수도 있으므로 로딩)
                                CDesignHeder.pSEncryptKinematics_encryption[i].byteEncryption = new byte[nSize_0];
                                Array.Copy(byteData, nPos, CDesignHeder.pSEncryptKinematics_encryption[i].byteEncryption, 0, nSize_0);

                                nPos += nSize_0;
                                #endregion String - Kinematics

                                #region Size - InverseKinematics ( 2 Bytes )
                                nSize_1 = (int)(short)(int)(short)(BitConverter.ToInt16(byteData, nPos));
                                nPos += 2;
                                #endregion Size - InverseKinematics ( 2 Bytes )

                                #region String - InverseKinematics
                                CDesignHeder.pstrInverseKinematics[i] = Encoding.Default.GetString(byteData, nPos, nSize_1);
                                // Since then loads the data may be encrypted.(Kor: 암호화 데이터일 수도 있으므로 로딩)
                                CDesignHeder.pSEncryptInverseKinematics_encryption[i].byteEncryption = new byte[nSize_1];
                                Array.Copy(byteData, nPos, CDesignHeder.pSEncryptInverseKinematics_encryption[i].byteEncryption, 0, nSize_1);

                                nPos += nSize_1;
                                #endregion String - InverseKinematics
                                #endregion Kinematics/InverseKinematics String
                            }

                            #region set the separation code [ KE - Kinematics End ( 2 Bytes ) ]
                            strData = "";
                            strData += (char)(byteData[nPos++]);
                            strData += (char)(byteData[nPos++]);
                            if (strData != "KE") bFileOpened = false;
                            #endregion set the separation code [ KE - Kinematics End ( 2 Bytes ) ]

                            #region Actual design string
                            #region Size - Actual design string ( 2 Bytes )
                            nSize_0 = (int)(ushort)(BitConverter.ToUInt16(byteData, nPos));
                            nPos += 2;
                            #endregion Size - Actual design string ( 2 Bytes )

                            #region String - Actual design string
                            //CDesignHeder.strDrawModel = "";
                            CDesignHeder.strDrawModel = Encoding.Default.GetString(byteData, nPos, nSize_0);

                            if (bCheckOldStl)
                            {
                                CDesignHeder.strDrawModel = Ojw.CConvert.ChangeString(CDesignHeder.strDrawModel.ToLower(), ".stl", ".stl*");
                            }

                            nPos += nSize_0;
                            #endregion String - Actual design string
                            #endregion Actual design string


                            #region Comment
                                #region Size - Comment ( 2 Bytes )
                                nSize_0 = (int)(short)(int)(short)(BitConverter.ToInt16(byteData, nPos));
                                nPos += 2;
                                #endregion Size - Comment ( 2 Bytes )

                                #region String - Comment
                                CDesignHeder.strComment = Encoding.Default.GetString(byteData, nPos, nSize_0);
                                nPos += nSize_0;
                                #endregion String - Comment
                            #endregion Comment
                                                                                   
                            #region set the separation code [ FE - File End ( 2 Bytes ) ]
                            strData = "";
                            strData += (char)(byteData[nPos++]);
                            strData += (char)(byteData[nPos++]);
                            if (strData != "FE") bFileOpened = false;
                            #endregion set the separation code [ FE - File End ( 2 Bytes ) ]

                            if (nVersion >= 10500)
                            {
                                int nMotCnt = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                m_lstMotorsEn.Clear();
                                for (i = 0; i < nMotCnt; i++)
                                {
                                    m_lstMotorsEn.Add(BitConverter.ToInt32(byteData, nPos));
                                    nPos += 4;
                                }
                            }
                            //Prop_Update_VirtualObject();
                            //Prop_Update_VirtualObject();

                            if (bJason == true)
                            {
                                //if (byteData.Length > nPos + 
                                #region GroupInfo

                                #region Size - GroupInfo ( 2 Bytes )
                                int nCnt = 0;
                                if (byteData.Length > nPos + 2)
                                {
                                    nSize_0 = (int)(short)(int)(short)(BitConverter.ToInt16(byteData, nPos));
                                    nPos += 2;
                                    nCnt = nSize_0;
                                }
                                #endregion Size - GroupInfo ( 2 Bytes )

                                #region Group Info(for ...)
                                for (int nGroup = 0; nGroup < nCnt; nGroup++)
                                {
                                    SGroupInfo_t SGroup = new SGroupInfo_t();
                                    // Number(2 bytes)
                                    SGroup.nNumber = BitConverter.ToInt16(byteData, nPos); nPos += 2;

                                    // string size(2 bytes)
                                    nSize_0 = BitConverter.ToInt16(byteData, nPos); nPos += 2;
                                    SGroup.strName = Encoding.Default.GetString(byteData, nPos, nSize_0);
                                    nPos += nSize_0;
                                    CDesignHeder.lstGroupInfo.Add(SGroup);
                                }
                                #endregion Group Info
                                //CDesignHeder.lstGroupInfo.Clear();

                                CDesignHeder.SJson.nQr = BitConverter.ToInt16(byteData, nPos); nPos += 2;
                                for (int k = 0; k < 6; k++) { CDesignHeder.SJson.afScene_Position[k] = BitConverter.ToSingle(byteData, nPos); nPos += 4; }
                                for (int k = 0; k < 6; k++) { CDesignHeder.SJson.afCamera_Position[k] = BitConverter.ToSingle(byteData, nPos); nPos += 4; }
                                for (int k = 0; k < 6; k++) { CDesignHeder.SJson.afRobot_Position[k] = BitConverter.ToSingle(byteData, nPos); nPos += 4; }

                                CDesignHeder.SJson.fRobot_Scale = BitConverter.ToSingle(byteData, nPos); nPos += 4;
                                CDesignHeder.SJson.cBackColor = Color.FromArgb(BitConverter.ToInt32(byteData, nPos)); nPos += 4;
                                CDesignHeder.SJson.cBackColor_Edit = Color.FromArgb(BitConverter.ToInt32(byteData, nPos)); nPos += 4;
                                CDesignHeder.SJson.cPlaneColor = Color.FromArgb(BitConverter.ToInt32(byteData, nPos)); nPos += 4;
                                int nTmp = BitConverter.ToInt16(byteData, nPos); nPos += 2;
                                CDesignHeder.SJson.IsWireFrame = (nTmp == 0) ? false : true;

                                // string size(2 bytes)
                                nSize_0 = BitConverter.ToInt16(byteData, nPos); nPos += 2;
                                CDesignHeder.SJson.strBleName = Encoding.Default.GetString(byteData, nPos, nSize_0); nPos += nSize_0;

                                CDesignHeder.SJson.nAddress_Motion = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                CDesignHeder.SJson.nAddress_Control = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                
                                #endregion GroupInfo
                            }
                        }
                        else bFileOpened = false;
#endif
                    #endregion OjwVersion
                    ////////////////////////////////////////////////////////////////////////////

                    if (bFileOpened == true)
                    {
                        CHeader = CDesignHeder;
                        CHeader.pDhParamAll = new CDhParamAll[512];

                        CDesignHeder = null;

                        m_bFileOpening = false;
                        return true;
                    }
                    CDesignHeder = null;
                    m_bFileOpening = false;
                    return false;
                }
                catch
                {
                    m_bFileOpening = false;
                    return false;
                }
            }
            public bool FileOpen(String strFileName, out COjwDesignerHeader CHeader)
            {
                m_bFileOpening = true;
                _CNT_FILEOPEN++;
                bool bFileOpened = true;
                bool bCheckOldStl = false;
                CHeader = null;
                m_strVersion = "";
                                
                try
                {
                    for (int nID = 0; nID < _SIZE_MAX_MOT; nID++)
                    {
                        m_pSRot[nID].pan = 0.0f;
                        m_pSRot[nID].tilt = 0.0f;
                        m_pSRot[nID].swing = 0.0f;
                        //m_pSTmrTrack[nID].Set();
                    }
                    
                    int i;//, j;

                    FileInfo f = new FileInfo(strFileName);
                    FileStream fs = f.OpenRead();

                    byte[] byteData = new byte[fs.Length];
                    string strFileName2 = "";
                    string strData = "";

                    #region Moved by opening the file into memory(Kor: 파일을 열어서 메모리로 옮김)
                    fs.Read(byteData, 0, byteData.Length);
                    strFileName2 = f.Name;
                    fs.Close();
                    #endregion Moved by opening the file into memory(Kor: 파일을 열어서 메모리로 옮김)

                    #region separation code - OJW1.0 ( (_STR_EXT.Length + _STR_EXT_VERSION.Length) Bytes )
                    String strTmp = String.Empty;
                    for (i = 0; i < (_STR_EXT.Length + _STR_EXT_VERSION.Length); i++) strTmp += ((char)byteData[i]).ToString().ToUpper();
                    //strTmp = strTmp.ToUpper();

                    strData = (_STR_EXT.ToUpper() + _STR_EXT_VERSION.ToUpper());
                    #endregion separation code - OJW1.0 ( (_STR_EXT.Length + _STR_EXT_VERSION.Length) Bytes )
                    COjwDesignerHeader CDesignHeder = new COjwDesignerHeader();
                    #region OjwVersion
#if _DHF_FILE
                    if ((strTmp[0] == 'D') & (strTmp[1] == 'H') & (strTmp[2] == 'F'))
                    {
                        #region DHF
                        m_strVersion += (char)byteData[3];
                        m_strVersion += (char)byteData[4];
                        m_strVersion += (char)byteData[5];

                        // In version 1.1, there is a second position(Kor: 1.1 버전에서는 2번째 자세가 없다.)
                        bool bNoSecondPos = false;
                        bool bNoAxisMirror = false;
                        int nVersion = 11;

                        if (strTmp.Substring(0, 6) == "DHF1.1") nVersion = 11;
                        else if (strTmp.Substring(0, 6) == "DHF1.2") nVersion = 12;
                        else if (strTmp.Substring(0, 6) == "DHF1.3") nVersion = 13;
                        else if (strTmp.Substring(0, 6) == "DHF1.4") nVersion = 14;

                        CDesignHeder.strVersion = strTmp.Substring(0, 6);
                        CDesignHeder.nVersion = nVersion;

                        bCheckOldStl = true;

                        if (nVersion < 12)
                        {
                            bNoSecondPos = true;
                            bNoAxisMirror = true;
                        }
                        else if (nVersion == 12)
                        {
                            bNoAxisMirror = true;
                        }
                        //else
                        //{
                        //}

                        //if (bMessage == true) OjwMessage("[" + strData + " Binary File Data(" + strTmp + ")] Opened");
                        int nPos = 6;   // 'HMT1.1'

                        #region From Version 1.1.0(_STR_EXT_VERSION = "01.01.00")( 4 Bytes )
                        CDesignHeder.nDefaultFunctionNumber = -1;// no use it in DHF
                        #endregion From Version 1.1.0(_STR_EXT_VERSION = "01.01.00")( 4 Bytes )

                        #region Model type ( 2 Bytes )
                        CDesignHeder.nModelNum = (int)(short)(BitConverter.ToInt16(byteData, nPos));
                        nPos += 2;
                        #endregion Model type ( 2 Bytes )

                        #region Title ( 21 Bytes )
                        CDesignHeder.strModelName = Encoding.Default.GetString(byteData, nPos, 21);
                        nPos += 21;
                        #endregion Title ( 21 Bytes )

                        #region BackColor - Background color ( 4 Bytes)
                        CDesignHeder.cBackColor = Color.FromArgb(BitConverter.ToInt32(byteData, nPos));
                        nPos += 4;
                        #endregion BackColor - Background color ( 4 Bytes)

                        #region Number of the motor ( 2 Bytes )
                        CDesignHeder.nMotorCnt = (int)(short)(BitConverter.ToInt16(byteData, nPos));
                        nPos += 2;
                        #endregion Number of the motor ( 2 Bytes )
                        #region initial angle
                        #region initial angle - Pan ( 4 Bytes )
                        CDesignHeder.SInitAngle.pan = BitConverter.ToSingle(byteData, nPos);
                        nPos += 4;
                        #endregion initial angle - Pan ( 4 Bytes )
                        #region initial angle - Tilt ( 4 Bytes )
                        CDesignHeder.SInitAngle.tilt = BitConverter.ToSingle(byteData, nPos);
                        nPos += 4;
                        #endregion initial angle - Tilt ( 4 Bytes )
                        #region initial angle - Swing ( 4 Bytes )
                        CDesignHeder.SInitAngle.swing = BitConverter.ToSingle(byteData, nPos);
                        nPos += 4;
                        #endregion initial angle - Swing ( 4 Bytes )
                        #endregion initial angle
                        #region Init position
                        #region Init position - x ( 4 Bytes )
                        CDesignHeder.SInitPos.x = BitConverter.ToSingle(byteData, nPos);
                        nPos += 4;
                        #endregion Init position - x ( 4 Bytes )
                        #region Init position - y ( 4 Bytes )
                        CDesignHeder.SInitPos.y = BitConverter.ToSingle(byteData, nPos);
                        nPos += 4;
                        #endregion Init position - y ( 4 Bytes )
                        #region Init position - z ( 4 Bytes )
                        CDesignHeder.SInitPos.z = BitConverter.ToSingle(byteData, nPos);
                        nPos += 4;
                        #endregion Init position - z ( 4 Bytes )
                        #endregion Init position

                        #region Init Scale - 100% = 1.0 ( 4 Bytes )
                        CDesignHeder.fInitScale = BitConverter.ToSingle(byteData, nPos);
                        nPos += 4;
                        #endregion Init Scale - 100% = 1.0 ( 4 Bytes )

                        if (nVersion >= 14)
                        {
                            #region 2 Wheel Counter ( 1 Bytes )
                            CDesignHeder.nWheelCounter_2 = (int)byteData[nPos++];
                            #endregion 2 Wheel Counter ( 1 Bytes )

                            #region 3 Wheel Counter ( 1 Bytes )
                            CDesignHeder.nWheelCounter_3 = (int)byteData[nPos++];
                            #endregion 3 Wheel Counter ( 1 Bytes )

                            #region 4 Wheel Counter ( 1 Bytes )
                            CDesignHeder.nWheelCounter_4 = (int)byteData[nPos++];
                            #endregion 4 Wheel Counter ( 1 Bytes )
                        }

                        for (i = 0; i < 256; i++)
                        {
                            #region Axis MotorInfo

                            #region Motor ID ( 2 Byte )
                            CDesignHeder.pSMotorInfo[i].nMotorID = (int)(short)BitConverter.ToInt16(byteData, nPos);
                            nPos += 2;
                            #endregion Motor ID ( 2 Byte )

                            #region Direction - 0 - Forward, 1 - Inverse ( 2 Bytes )
                            CDesignHeder.pSMotorInfo[i].nMotorDir = (int)(short)BitConverter.ToInt16(byteData, nPos);
                            nPos += 2;
                            #endregion Direction - 0 - Forward, 1 - Inverse ( 2 Bytes )

                            #region Max Angle (+) ( 4 Bytes )
                            CDesignHeder.pSMotorInfo[i].fLimit_Up = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion Max Angle (+) ( 4 Bytes )

                            #region Min Angle (-) ( 4 Bytes )
                            CDesignHeder.pSMotorInfo[i].fLimit_Down = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion Min Angle (-) ( 4 Bytes )

                            #region Center Position - Evd ( 2 Bytes )
                            CDesignHeder.pSMotorInfo[i].nCenter_Evd = BitConverter.ToInt16(byteData, nPos);
                            nPos += 2;
                            #endregion Center Position - Evd ( 2 Bytes )

                            #region Mech Move - Maximum pulse Evd ( 2 Bytes )
                            CDesignHeder.pSMotorInfo[i].nMechMove = BitConverter.ToInt16(byteData, nPos);
                            nPos += 2;
                            #endregion Mech Move - Maximum pulse Evd ( 2 Bytes )

                            #region Mech Angle - Angle of Mech Mov [ The maximum pulse corresponding to the angle value(Kor: 최대치 펄스에 해당하는 각도값 (분주각))]( 4 Bytes )
                            CDesignHeder.pSMotorInfo[i].fMechAngle = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion Mech Angle - Angle of Mech Mov [ The maximum pulse corresponding to the angle value(Kor: 최대치 펄스에 해당하는 각도값 (분주각))]( 4 Bytes )

                            #region Init Angle - Used for the initial position of the data in an arbitrary position( 4 Bytes )(Kor: 데이타의 초기자세를 임의의 자세로 하기 위해 사용( 4 Bytes ))
                            CDesignHeder.pSMotorInfo[i].fInitAngle = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            if (bNoSecondPos == false)
                            {
                                CDesignHeder.pSMotorInfo[i].fInitAngle2 = BitConverter.ToSingle(byteData, nPos);
                                nPos += 4;
                            }
                            #endregion Init Angle - Used for the initial position of the data in an arbitrary position( 4 Bytes )(Kor: 데이타의 초기자세를 임의의 자세로 하기 위해 사용( 4 Bytes ))

                            #region Interference axis number(Kor: 간섭 축 번호) ( 2 Bytes )
                            CDesignHeder.pSMotorInfo[i].nInterference_Axis = BitConverter.ToInt16(byteData, nPos);
                            nPos += 2;
                            #endregion Interference axis number(Kor: 간섭 축 번호) ( 2 Bytes )

                            #region axis Width ( 4 Bytes )
                            CDesignHeder.pSMotorInfo[i].fW = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion axis Width ( 4 Bytes )

                            #region Interference axis Width ( 4 Bytes )
                            CDesignHeder.pSMotorInfo[i].fInterference_W = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion Interference axis Width ( 4 Bytes )

                            #region axis Side ( Right ) ( 4 Bytes )
                            CDesignHeder.pSMotorInfo[i].fPos_Right = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion axis Side ( Right ) ( 4 Bytes )

                            #region axis Side ( Left) ( 4 Bytes )
                            CDesignHeder.pSMotorInfo[i].fPos_Left = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion axis Side ( Left) ( 4 Bytes )

                            #region Interference axis ( Front ) ( 4 Bytes )
                            CDesignHeder.pSMotorInfo[i].fInterference_Pos_Front = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion Interference axis ( Front ) ( 4 Bytes )

                            #region Interference axis ( Rear ) ( 4 Bytes )
                            CDesignHeder.pSMotorInfo[i].fInterference_Pos_Rear = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion Interference axis ( Rear ) ( 4 Bytes )

                            #region NickName ( 32 Bytes )
                            CDesignHeder.pSMotorInfo[i].strNickName = Encoding.Default.GetString(byteData, nPos, 32);
                            nPos += 32;
                            #endregion NickName ( 32 Bytes )

                            #region Group Number ( 2 Bytes )
                            CDesignHeder.pSMotorInfo[i].nGroupNumber = BitConverter.ToInt16(byteData, nPos);
                            nPos += 2;
                            #endregion Group Number ( 2 Bytes )

                            #region mirroring axis number ( 2 Bytes )
                            if (bNoAxisMirror == false)
                            {
                                CDesignHeder.pSMotorInfo[i].nAxis_Mirror = BitConverter.ToInt16(byteData, nPos);
                                nPos += 2;
                            }
                            #endregion mirroring axis number ( 2 Bytes )
                            #region V1.4
                            #region Motor control type ( 2 Bytes )
                            if (nVersion >= 14)
                            {
                                CDesignHeder.pSMotorInfo[i].nMotorControlType = BitConverter.ToInt16(byteData, nPos);
                                nPos += 2;
                            }
                            #endregion mirroring axis number ( 2 Bytes )
                            #endregion V1.4

                            #endregion Axis MotorInfo
                        }

                        #region set the separation code [ HE - Header End ( 2 Bytes ) ]
                        strData = "";
                        strData += (char)(byteData[nPos++]);
                        strData += (char)(byteData[nPos++]);
                        if (strData != "HE") bFileOpened = false;
                        #endregion set the separation code [ HE - Header End ( 2 Bytes ) ]

                        int nSize_GroupName;
                        int nSize_0;
                        int nSize_1;
                        for (i = 0; i < 512; i++)
                        {
                            #region V1.4
                            if (nVersion >= 14)
                            {
                                #region Secret Mode
                                // Verify that the encryption code -> If this is the encryption code is set to '1'.
                                // Kor: // 암호화 코드인지 확인 -> 암호화 코드라면 '1'
                                CDesignHeder.pnSecret[i] = (int)(byte)(byteData[nPos++]);
                                #endregion Secret Mode
                                #region Type
                                // check formulas Control Type -> If the wheel-type control '1', if the position type control '0'
                                // Kor: 수식 제어타입 확인 -> 바퀴형 제어라면 '1', 위치형 제어라면 '0'
                                CDesignHeder.pnType[i] = (int)(byte)(byteData[nPos++]);
                                #endregion Type
                            }
                            #endregion V1.4

                            #region GroupName String

                            #region Size - Kinematics ( 2 Bytes )
                            nSize_GroupName = (int)(short)(BitConverter.ToInt16(byteData, nPos));
                            nPos += 2;
                            #endregion Size - Kinematics ( 2 Bytes )

                            #region String - Kinematics
                            CDesignHeder.pstrGroupName[i] = Encoding.Default.GetString(byteData, nPos, nSize_GroupName);
                            nPos += nSize_GroupName;
                            #endregion String - Kinematics

                            #endregion GroupName String

                            #region Kinematics/InverseKinematics String
                            #region Size - Kinematics ( 2 Bytes )
                            nSize_0 = (int)(short)(BitConverter.ToInt16(byteData, nPos));
                            nPos += 2;
                            #endregion Size - Kinematics ( 2 Bytes )

                            #region String - Kinematics
                            //CDesignHeder.pstrKinematics[i] = "";
                            //for (int j = 0; j < nSize_0; j++) CDesignHeder.pstrKinematics[i] += (char)(byteData[nPos++]);
                            CDesignHeder.pstrKinematics[i] = Encoding.Default.GetString(byteData, nPos, nSize_0);
                            // Since then loads the data may be encrypted.(Kor: 암호화 데이터일 수도 있으므로 로딩)
                            CDesignHeder.pSEncryptKinematics_encryption[i].byteEncryption = new byte[nSize_0];
                            Array.Copy(byteData, nPos, CDesignHeder.pSEncryptKinematics_encryption[i].byteEncryption, 0, nSize_0);

                            nPos += nSize_0;
                            #endregion String - Kinematics

                            #region Size - InverseKinematics ( 2 Bytes )
                            nSize_1 = (int)(short)(int)(short)(BitConverter.ToInt16(byteData, nPos));
                            nPos += 2;
                            #endregion Size - InverseKinematics ( 2 Bytes )

                            #region String - InverseKinematics
                            CDesignHeder.pstrInverseKinematics[i] = Encoding.Default.GetString(byteData, nPos, nSize_1);
                            // Since then loads the data may be encrypted.(Kor: 암호화 데이터일 수도 있으므로 로딩)
                            CDesignHeder.pSEncryptInverseKinematics_encryption[i].byteEncryption = new byte[nSize_1];
                            Array.Copy(byteData, nPos, CDesignHeder.pSEncryptInverseKinematics_encryption[i].byteEncryption, 0, nSize_1);

                            nPos += nSize_1;
                            #endregion String - InverseKinematics
                            #endregion Kinematics/InverseKinematics String
                        }

                        #region set the separation code [ KE - Kinematics End ( 2 Bytes ) ]
                        strData = "";
                        strData += (char)(byteData[nPos++]);
                        strData += (char)(byteData[nPos++]);
                        if (strData != "KE") bFileOpened = false;
                        #endregion set the separation code [ KE - Kinematics End ( 2 Bytes ) ]

                        #region Actual design string
                        #region Size - Actual design string ( 2 Bytes )
                        nSize_0 = (int)(ushort)(BitConverter.ToUInt16(byteData, nPos));
                        nPos += 2;
                        #endregion Size - Actual design string ( 2 Bytes )

                        #region String - Actual design string
                        //CDesignHeder.strDrawModel = "";
                        CDesignHeder.strDrawModel = Encoding.Default.GetString(byteData, nPos, nSize_0);//CConvert.RemoveChar(Encoding.Default.GetString(byteData, nPos, nSize_0), '\r');
                        nPos += nSize_0;
                        // Dhf -> Ojw(Convert)
                        String[] pstrLine = CDesignHeder.strDrawModel.Split('\n');
                        int nCnt = 0;
                        StringBuilder sbAll = new StringBuilder();

#if _USING_DOTNET_3_5
                        sbAll.Remove(0, sbAll.Length);
#elif _USING_DOTNET_2_0
                        sbAll.Remove(0, sbAll.Length);
#else
                        sbAll.Clear(); // Dotnet 4.0 이상에서만 사용
#endif
                        foreach (string strLine in pstrLine)
                        {
                            String[] pstrTmp = strLine.Split(',');
                            //if (pstrTmp.Length > 10)
                            //{
                            nCnt = 0;
                            bool bCaption = false;
                            int nModelPosition = 2;
                            foreach (string strItem in pstrTmp)
                            {
                                if (strItem.IndexOf("//") >= 0)
                                {
                                    bCaption = true;
                                }
                                else if (bCaption == false)
                                {
                                    if (nCnt++ == nModelPosition)
                                    {
                                        sbAll.Append("1.0,");
                                        int nData = CConvert.StrToInt(strItem);
                                        if (nData >= 0x1000) sbAll.Append(CConvert.IntToStr(nData - 0x1000));
                                        else sbAll.Append("#" + CConvert.RemoveChar(strItem, ' '));
                                    }
                                }
                                if (nCnt != (nModelPosition + 1)) { sbAll.Append(CConvert.RemoveChar(strItem, ' ')); }
                                else nCnt++;
                                // ojw5014 - ,(콤마) 붙는거 해결할 것.
                                if (strItem.IndexOf('\r') < 0) sbAll.Append(',');
                                else sbAll.Append("\n");
                            }
                            //}
                        }
                        CDesignHeder.strDrawModel = sbAll.ToString();
                        if (bCheckOldStl)
                        {
                            CDesignHeder.strDrawModel = Ojw.CConvert.ChangeString(CDesignHeder.strDrawModel.ToLower(), ".stl", ".stl*");
                        }
                        // Set a new version
                        CDesignHeder.strVersion = _STR_EXT.ToUpper() + C3d._STR_EXT_VERSION.ToUpper();
                        #endregion String - Actual design string
                        #endregion Actual design string


                        #region Comment
                        #region Size - Comment ( 2 Bytes )
                        nSize_0 = (int)(short)(int)(short)(BitConverter.ToInt16(byteData, nPos));
                        nPos += 2;
                        #endregion Size - Comment ( 2 Bytes )

                        #region String - Comment
                        CDesignHeder.strComment = Encoding.Default.GetString(byteData, nPos, nSize_0);
                        nPos += nSize_0;
                        #endregion String - Comment
                        #endregion Comment

                        #region set the separation code [ FE - File End ( 2 Bytes ) ]
                        strData = "";
                        strData += (char)(byteData[nPos++]);
                        strData += (char)(byteData[nPos++]);
                        if (strData != "FE") bFileOpened = false;
                        #endregion set the separation code [ FE - File End ( 2 Bytes ) ]

                        //fs.Close();
                        //bFileOpened = true;

                        #endregion DHF
                    }
                    else
#endif // _DHF_FILE
#if true
                        if ((strTmp[0] == 'O') & (strTmp[1] == 'J') & (strTmp[2] == 'W'))//(strTmp == strData) 
                        {
                            #region OJW
                            int nVersion = 0;// 010000; // 01.00.00
                            for (i = 3; i < (_STR_EXT.Length + _STR_EXT_VERSION.Length); i++)
                            {
                                m_strVersion += (char)byteData[i];
                                if ((char)byteData[i] != '.')
                                {
                                    nVersion = nVersion * 10 + (int)(byteData[i] - 0x30);
                                }
                            }

                            CDesignHeder.strVersion = strTmp;
                            CDesignHeder.nVersion = nVersion;

                            int nPos = (_STR_EXT.Length + _STR_EXT_VERSION.Length);   // 앞의 (_STR_EXT.Length + _STR_EXT_VERSION.Length)개는 'OJW01.00.00' 에 할당

                            #region From Version 1.1.0(_STR_EXT_VERSION = "01.01.00")( 4 Bytes )
                            if (nVersion > 010000)
                            {
                                CDesignHeder.nDefaultFunctionNumber = (int)(BitConverter.ToInt32(byteData, nPos));
                                //SetFunctionNumber(CDesignHeder.nDefaultFunctionNumber);                                
                                //Prop_Set_Main_DefaultFunctionNum(CDesignHeder.nDefaultFunctionNumber);
                                nPos += 4;
                            }

                            if (nVersion < 010600)
                            {
                                bCheckOldStl = true;
                            }
                            bool bJason = false;
                            if (nVersion >= 010700)
                            {
                                bJason = true;
                            }
                            #endregion From Version 1.1.0(_STR_EXT_VERSION = "01.01.00")( 4 Bytes )

                            #region Model type ( 2 Bytes )
                            CDesignHeder.nModelNum = (int)(short)(BitConverter.ToInt16(byteData, nPos));
                            nPos += 2;
                            #endregion Model type ( 2 Bytes )

                            //////////// 추가항목
                            #region Json Title  ( 21 Bytes )
                            if (nVersion >= 010800)
                            {
                                CDesignHeder.strTitle = Encoding.Default.GetString(byteData, nPos, 21);
                                nPos += 21;
                            }
                            #endregion Json Title  ( 21 Bytes )
                            //////////// 추가항목

                            #region Title ( 21 Bytes )
                            CDesignHeder.strModelName = Encoding.Default.GetString(byteData, nPos, 21);
                            nPos += 21;
                            #endregion Title ( 21 Bytes )

                            #region BackColor - background color ( 4 Bytes)
                            CDesignHeder.cBackColor = Color.FromArgb(BitConverter.ToInt32(byteData, nPos));
                            nPos += 4;
                            #endregion BackColor - background color ( 4 Bytes)

                            #region Num. of Motor ( 2 Bytes )
                            CDesignHeder.nMotorCnt = (int)(short)(BitConverter.ToInt16(byteData, nPos));
                            nPos += 2;
                            #endregion Num. of Motor ( 2 Bytes )
                            #region Init Angle
                            #region Init Angle - Pan ( 4 Bytes )
                            CDesignHeder.SInitAngle.pan = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion Init Angle - Pan ( 4 Bytes )
                            #region Init Angle - Tilt ( 4 Bytes )
                            CDesignHeder.SInitAngle.tilt = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion Init Angle - Tilt ( 4 Bytes )
                            #region Init Angle - Swing ( 4 Bytes )
                            CDesignHeder.SInitAngle.swing = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion Init Angle - Swing ( 4 Bytes )
                            #endregion Init Angle
                            #region Init Position
                            #region Init Position - x ( 4 Bytes )
                            CDesignHeder.SInitPos.x = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion Init Position - x ( 4 Bytes )
                            #region Init Position - y ( 4 Bytes )
                            CDesignHeder.SInitPos.y = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion Init Position - y ( 4 Bytes )
                            #region Init Position - z ( 4 Bytes )
                            CDesignHeder.SInitPos.z = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion Init Position - z ( 4 Bytes )
                            #endregion Init Position

                            #region Init Scale - 100% = 1.0 ( 4 Bytes )
                            CDesignHeder.fInitScale = BitConverter.ToSingle(byteData, nPos);
                            nPos += 4;
                            #endregion Init Scale - 100% = 1.0 ( 4 Bytes )

                            #region 2 Wheel Counter ( 1 Bytes )
                            CDesignHeder.nWheelCounter_2 = (int)byteData[nPos++];
                            #endregion 2 Wheel Counter ( 1 Bytes )

                            #region 3 Wheel Counter ( 1 Bytes )
                            CDesignHeder.nWheelCounter_3 = (int)byteData[nPos++];
                            #endregion 3 Wheel Counter ( 1 Bytes )

                            #region 4 Wheel Counter ( 1 Bytes )
                            CDesignHeder.nWheelCounter_4 = (int)byteData[nPos++];
                            #endregion 4 Wheel Counter ( 1 Bytes )

                            for (i = 0; i < 256; i++)
                            {
                                #region Axis MotorInfo

                                #region Motor ID ( 2 Byte )
                                CDesignHeder.pSMotorInfo[i].nMotorID = (int)(short)BitConverter.ToInt16(byteData, nPos);
                                nPos += 2;
                                #endregion Motor ID ( 2 Byte )

                                #region Direction - 0 - Forward, 1 - Inverse ( 2 Bytes )
                                CDesignHeder.pSMotorInfo[i].nMotorDir = (int)(short)BitConverter.ToInt16(byteData, nPos);
                                nPos += 2;
                                #endregion Direction - 0 - Forward, 1 - Inverse ( 2 Bytes )

                                #region Max Angle (+) ( 4 Bytes )
                                CDesignHeder.pSMotorInfo[i].fLimit_Up = BitConverter.ToSingle(byteData, nPos);
                                nPos += 4;
                                #endregion Max Angle (+) ( 4 Bytes )

                                #region Min Angle (-) ( 4 Bytes )
                                CDesignHeder.pSMotorInfo[i].fLimit_Down = BitConverter.ToSingle(byteData, nPos);
                                nPos += 4;
                                #endregion Min Angle (-) ( 4 Bytes )

                                if (nVersion < 010200)
                                {
                                    #region Center Position - Evd ( 2 Bytes )
                                    CDesignHeder.pSMotorInfo[i].nCenter_Evd = BitConverter.ToInt16(byteData, nPos);
                                    nPos += 2;
                                    #endregion Center Position - Evd ( 2 Bytes )

                                    #region Mech Move - Maximum Pulse value(Evd)(Kor: 최대치 펄스값 Evd)( 2 Bytes )
                                    CDesignHeder.pSMotorInfo[i].nMechMove = BitConverter.ToInt16(byteData, nPos);
                                    nPos += 2;
                                    #endregion Mech Move - Maximum Pulse value(Evd)(Kor: 최대치 펄스값 Evd)( 2 Bytes )
                                }
                                else
                                {
                                    #region Center Position - Evd ( 4 Bytes )
                                    CDesignHeder.pSMotorInfo[i].nCenter_Evd = BitConverter.ToInt32(byteData, nPos);
                                    nPos += 4;
                                    #endregion Center Position - Evd ( 4 Bytes )

                                    #region Mech Move - Maximum Pulse value(Evd)(Kor: 최대치 펄스값 Evd)( 4 Bytes )
                                    CDesignHeder.pSMotorInfo[i].nMechMove = BitConverter.ToInt32(byteData, nPos);
                                    nPos += 4;
                                    #endregion Mech Move - Maximum Pulse value(Evd)(Kor: 최대치 펄스값 Evd)( 4 Bytes )
                                }
                                #region Mech Angle - Angle of Mech Mov [ The maximum pulse corresponding to the angle value(Kor: 최대치 펄스에 해당하는 각도값 (분주각))]( 4 Bytes )
                                CDesignHeder.pSMotorInfo[i].fMechAngle = BitConverter.ToSingle(byteData, nPos);
                                nPos += 4;
                                #endregion Mech Angle - Angle of Mech Mov [ The maximum pulse corresponding to the angle value(Kor: 최대치 펄스에 해당하는 각도값 (분주각))]( 4 Bytes )

                                #region Init Angle - Used for the initial position of the data in an arbitrary position( 4 Bytes )(Kor: 데이타의 초기자세를 임의의 자세로 하기 위해 사용( 4 Bytes ))
                                // First Posture
                                CDesignHeder.pSMotorInfo[i].fInitAngle = BitConverter.ToSingle(byteData, nPos);
                                nPos += 4;
                                // Second Posture
                                CDesignHeder.pSMotorInfo[i].fInitAngle2 = BitConverter.ToSingle(byteData, nPos);
                                nPos += 4;
                                #endregion Init Angle - Used for the initial position of the data in an arbitrary position( 4 Bytes )(Kor: 데이타의 초기자세를 임의의 자세로 하기 위해 사용( 4 Bytes ))

                                #region Interference axis number(Kor: 간섭 축 번호) ( 2 Bytes )
                                CDesignHeder.pSMotorInfo[i].nInterference_Axis = BitConverter.ToInt16(byteData, nPos);
                                nPos += 2;
                                #endregion Interference axis number(Kor: 간섭 축 번호) ( 2 Bytes )

                                #region axis Width ( 4 Bytes )
                                CDesignHeder.pSMotorInfo[i].fW = BitConverter.ToSingle(byteData, nPos);
                                nPos += 4;
                                #endregion axis Width ( 4 Bytes )

                                #region Interference axis Width ( 4 Bytes )
                                CDesignHeder.pSMotorInfo[i].fInterference_W = BitConverter.ToSingle(byteData, nPos);
                                nPos += 4;
                                #endregion Interference axis Width ( 4 Bytes )

                                #region Axis Side ( Right ) ( 4 Bytes )
                                CDesignHeder.pSMotorInfo[i].fPos_Right = BitConverter.ToSingle(byteData, nPos);
                                nPos += 4;
                                #endregion Axis Side ( Right ) ( 4 Bytes )

                                #region Axis Side ( Left) ( 4 Bytes )
                                CDesignHeder.pSMotorInfo[i].fPos_Left = BitConverter.ToSingle(byteData, nPos);
                                nPos += 4;
                                #endregion Axis Side ( Left) ( 4 Bytes )

                                #region Interference axis ( Front ) ( 4 Bytes )
                                CDesignHeder.pSMotorInfo[i].fInterference_Pos_Front = BitConverter.ToSingle(byteData, nPos);
                                nPos += 4;
                                #endregion Interference axis ( Front ) ( 4 Bytes )

                                #region Interference axis ( Rear ) ( 4 Bytes )
                                CDesignHeder.pSMotorInfo[i].fInterference_Pos_Rear = BitConverter.ToSingle(byteData, nPos);
                                nPos += 4;
                                #endregion Interference axis ( Rear ) ( 4 Bytes )

                                #region NickName ( 32 Bytes )
                                CDesignHeder.pSMotorInfo[i].strNickName = Encoding.Default.GetString(byteData, nPos, 32);
                                nPos += 32;
                                #endregion NickName ( 32 Bytes )

                                #region Group Number ( 2 Bytes )
                                CDesignHeder.pSMotorInfo[i].nGroupNumber = BitConverter.ToInt16(byteData, nPos);
                                nPos += 2;
                                #endregion Group Number ( 2 Bytes )

                                #region mirroring axis number ( 2 Bytes )
                                CDesignHeder.pSMotorInfo[i].nAxis_Mirror = BitConverter.ToInt16(byteData, nPos);
                                nPos += 2;
                                #endregion mirroring axis number ( 2 Bytes )
                                #region V1.0.0
                                #region Motor control type ( 2 Bytes )
                                CDesignHeder.pSMotorInfo[i].nMotorControlType = BitConverter.ToInt16(byteData, nPos);
                                nPos += 2;
                                #endregion mirroring axis number ( 2 Bytes )
                                #endregion V1.0.0

                                #endregion Axis MotorInfo

                                #region 추가 - version 10400
                                if (nVersion >= 10400)
                                {
                                    /////////// 추가
                                    CDesignHeder.pSMotorInfo[i].fRpm = BitConverter.ToSingle(byteData, nPos); nPos += 4;

                                    CDesignHeder.pSMotorInfo[i].nLimitRpm_Raw = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nProtocolVersion = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nHwMotor_Index = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    
                                    CDesignHeder.pSMotorInfo[i].nHwMotor_Key = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nAddr_Max = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nAddr_Torq = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nAddr_Led = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nAddr_Mode = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nAddr_Speed = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nAddr_Speed_Size = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nAddr_Pos_Speed = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nAddr_Pos_Speed_Size = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nAddr_Pos = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nAddr_Pos_Size = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nSerialType = BitConverter.ToInt32(byteData, nPos); nPos += 4;

                                    CDesignHeder.pSMotorInfo[i].nMotorEnable_For_RPTask = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nMotor_Enable = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nMotionEditor_Index = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nMotor_HightSpec = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nReserve_4 = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nReserve_5 = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nReserve_6 = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nReserve_7 = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nReserve_8 = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].nReserve_9 = BitConverter.ToInt32(byteData, nPos); nPos += 4;

                                    CDesignHeder.pSMotorInfo[i].fGearRatio = BitConverter.ToSingle(byteData, nPos); nPos += 4; // Gear Ratio
                                    CDesignHeder.pSMotorInfo[i].fRobotisConvertingVar = BitConverter.ToSingle(byteData, nPos); nPos += 4; // Converting Variable for Robotis
                                    CDesignHeder.pSMotorInfo[i].fReserve_2 = BitConverter.ToSingle(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].fReserve_3 = BitConverter.ToSingle(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].fReserve_4 = BitConverter.ToSingle(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].fReserve_5 = BitConverter.ToSingle(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].fReserve_6 = BitConverter.ToSingle(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].fReserve_7 = BitConverter.ToSingle(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].fReserve_8 = BitConverter.ToSingle(byteData, nPos); nPos += 4;
                                    CDesignHeder.pSMotorInfo[i].fReserve_9 = BitConverter.ToSingle(byteData, nPos); nPos += 4;

                                    if (CDesignHeder.pSMotorInfo[i].nHwMotor_Index > 0)
                                    {
                                        // 모델명이 지정되어 있다면 앞의것들 무시...
                                        m_CRobotis.SetParam(i, CDesignHeder.pSMotorInfo[i].nHwMotor_Index);
                                    }

                                    if (bJason == true)
                                    {
                                        CDesignHeder.pSMotorInfo[i].nGuide_Event = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                        CDesignHeder.pSMotorInfo[i].nGuide_AxisType = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                        CDesignHeder.pSMotorInfo[i].nGuide_RingColorType = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                        CDesignHeder.pSMotorInfo[i].fGuide_RingSize = BitConverter.ToSingle(byteData, nPos); nPos += 4;
                                        CDesignHeder.pSMotorInfo[i].fGuide_RingThick = BitConverter.ToSingle(byteData, nPos); nPos += 4;
                                        CDesignHeder.pSMotorInfo[i].nGuide_RingDir = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                        if (CDesignHeder.pSMotorInfo[i].nGuide_RingDir == 0) CDesignHeder.pSMotorInfo[i].nGuide_RingDir = 1;
                                        CDesignHeder.pSMotorInfo[i].fGuide_3D_Scale = BitConverter.ToSingle(byteData, nPos); nPos += 4;
                                        CDesignHeder.pSMotorInfo[i].fGuide_3D_Alpha = BitConverter.ToSingle(byteData, nPos); nPos += 4;

                                        if (CDesignHeder.pSMotorInfo[i].afGuide_Pos == null)
                                        {
                                            CDesignHeder.pSMotorInfo[i].afGuide_Pos = new float[6];
                                            CDesignHeder.pSMotorInfo[i].anGuide_Off_IDs = new int[6];
                                            CDesignHeder.pSMotorInfo[i].anGuide_Off_Dir = new int[6];
                                            Array.Clear(CDesignHeder.pSMotorInfo[i].afGuide_Pos, 0, CDesignHeder.pSMotorInfo[i].afGuide_Pos.Length);
                                            Array.Clear(CDesignHeder.pSMotorInfo[i].anGuide_Off_IDs, 0, CDesignHeder.pSMotorInfo[i].anGuide_Off_IDs.Length);
                                            Array.Clear(CDesignHeder.pSMotorInfo[i].anGuide_Off_Dir, 0, CDesignHeder.pSMotorInfo[i].anGuide_Off_Dir.Length);
                                        }
                                        for (int nGuide = 0; nGuide < 6; nGuide++) { CDesignHeder.pSMotorInfo[i].afGuide_Pos[nGuide] = BitConverter.ToSingle(byteData, nPos); nPos += 4; }
                                        for (int nGuide = 0; nGuide < 6; nGuide++) { CDesignHeder.pSMotorInfo[i].anGuide_Off_IDs[nGuide] = BitConverter.ToInt32(byteData, nPos); nPos += 4; }
                                        for (int nGuide = 0; nGuide < 6; nGuide++) { CDesignHeder.pSMotorInfo[i].anGuide_Off_Dir[nGuide] = BitConverter.ToInt32(byteData, nPos); nPos += 4; }
                                    }

                                }
                                #endregion 추가 - version 10400
                            }

                            #region set the separation code [ HE - Header End ( 2 Bytes ) ]
                            strData = "";
                            strData += (char)(byteData[nPos++]);
                            strData += (char)(byteData[nPos++]);
                            if (strData != "HE") bFileOpened = false;
                            #endregion set the separation code [ HE - Header End ( 2 Bytes ) ]

                            int nSize_GroupName;
                            int nSize_0;
                            int nSize_1;
                            for (i = 0; i < 512; i++)
                            {
                                #region V1.0.0
                                #region Secret Mode
                                // Verify that the encryption code -> If this is the encryption code is set to '1'.
                                // Kor: // 암호화 코드인지 확인 -> 암호화 코드라면 '1'
                                CDesignHeder.pnSecret[i] = (int)(byte)(byteData[nPos++]);
                                #endregion Secret Mode
                                #region Type
                                // check formulas Control Type -> If the wheel-type control '1', if the position type control '0'
                                // Kor: 수식 제어타입 확인 -> 바퀴형 제어라면 '1', 위치형 제어라면 '0'
                                CDesignHeder.pnType[i] = (int)(byte)(byteData[nPos++]);
                                #endregion Type
                                #region Python
                                //01.03.00                                
                                if (nVersion >= 010300) CDesignHeder.pbPython[i] = Ojw.CConvert.IntToBool(byteData[nPos++]);
                                #endregion Python
                                #endregion V1.0.0

                                #region GroupName String

                                #region Size - Kinematics ( 2 Bytes )
                                nSize_GroupName = (int)(short)(BitConverter.ToInt16(byteData, nPos));
                                if (nSize_GroupName < 0) nSize_GroupName = 0;
                                nPos += 2;
                                #endregion Size - Kinematics ( 2 Bytes )

                                #region String - Kinematics
                                CDesignHeder.pstrGroupName[i] = Encoding.Default.GetString(byteData, nPos, nSize_GroupName);
                                nPos += nSize_GroupName;
                                #endregion String - Kinematics

                                #endregion GroupName String

                                #region Kinematics/InverseKinematics String
                                #region Size - Kinematics ( 2 Bytes )
                                nSize_0 = (int)(short)(BitConverter.ToInt16(byteData, nPos));
                                if (nSize_0 < 0) nSize_0 = 0;
                                nPos += 2;
                                #endregion Size - Kinematics ( 2 Bytes )

                                #region String - Kinematics
                                //CDesignHeder.pstrKinematics[i] = "";
                                //for (int j = 0; j < nSize_0; j++) CDesignHeder.pstrKinematics[i] += (char)(byteData[nPos++]);
                                CDesignHeder.pstrKinematics[i] = Encoding.Default.GetString(byteData, nPos, nSize_0);
                                // Since then loads the data may be encrypted.(Kor: 암호화 데이터일 수도 있으므로 로딩)
                                CDesignHeder.pSEncryptKinematics_encryption[i].byteEncryption = new byte[nSize_0];
                                Array.Copy(byteData, nPos, CDesignHeder.pSEncryptKinematics_encryption[i].byteEncryption, 0, nSize_0);

                                nPos += nSize_0;
                                #endregion String - Kinematics

                                #region Size - InverseKinematics ( 2 Bytes )
                                nSize_1 = (int)(short)(int)(short)(BitConverter.ToInt16(byteData, nPos));
                                if (nSize_1 < 0) nSize_1 = 0;
                                nPos += 2;
                                #endregion Size - InverseKinematics ( 2 Bytes )

                                #region String - InverseKinematics
                                CDesignHeder.pstrInverseKinematics[i] = Encoding.Default.GetString(byteData, nPos, nSize_1);
                                // Since then loads the data may be encrypted.(Kor: 암호화 데이터일 수도 있으므로 로딩)
                                CDesignHeder.pSEncryptInverseKinematics_encryption[i].byteEncryption = new byte[nSize_1];
                                Array.Copy(byteData, nPos, CDesignHeder.pSEncryptInverseKinematics_encryption[i].byteEncryption, 0, nSize_1);

                                nPos += nSize_1;
                                #endregion String - InverseKinematics
                                #endregion Kinematics/InverseKinematics String
                            }

                            #region set the separation code [ KE - Kinematics End ( 2 Bytes ) ]
                            strData = "";
                            strData += (char)(byteData[nPos++]);
                            strData += (char)(byteData[nPos++]);
                            if (strData != "KE") bFileOpened = false;
                            #endregion set the separation code [ KE - Kinematics End ( 2 Bytes ) ]

                            #region Actual design string
                            #region Size - Actual design string ( 2 Bytes )
                            nSize_0 = (int)(ushort)(BitConverter.ToUInt16(byteData, nPos));
                            nPos += 2;
                            #endregion Size - Actual design string ( 2 Bytes )

                            #region String - Actual design string
                            //CDesignHeder.strDrawModel = "";
                            CDesignHeder.strDrawModel = Encoding.Default.GetString(byteData, nPos, nSize_0);
                            if (bCheckOldStl)
                            {
                                CDesignHeder.strDrawModel = Ojw.CConvert.ChangeString(CDesignHeder.strDrawModel.ToLower(), ".stl", ".stl*");
                            }
                            nPos += nSize_0;
                            #endregion String - Actual design string
                            #endregion Actual design string


                            #region Comment
                            #region Size - Comment ( 2 Bytes )
                            nSize_0 = (int)(short)(int)(short)(BitConverter.ToInt16(byteData, nPos));
                            nPos += 2;
                            #endregion Size - Comment ( 2 Bytes )

                            #region String - Comment
                            CDesignHeder.strComment = Encoding.Default.GetString(byteData, nPos, nSize_0);
                            nPos += nSize_0;
                            #endregion String - Comment
                            #endregion Comment

                            #region set the separation code [ FE - File End ( 2 Bytes ) ]
                            strData = "";
                            strData += (char)(byteData[nPos++]);
                            strData += (char)(byteData[nPos++]);
                            if (strData != "FE") bFileOpened = false;
                            #endregion set the separation code [ FE - File End ( 2 Bytes ) ]

                            if (nVersion >= 10500)
                            {
                                int nMotCnt = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                m_lstMotorsEn.Clear();
                                for (i = 0; i < nMotCnt; i++)
                                {
                                    m_lstMotorsEn.Add(BitConverter.ToInt32(byteData, nPos));
                                    nPos += 4;
                                }
                            }
                            //Prop_Update_VirtualObject();

                            if (bJason == true)
                            {
                                #region GroupInfo

                                #region Size - GroupInfo ( 2 Bytes )
                                int nCnt = 0;
                                if (byteData.Length > nPos + 2)
                                {
                                    nSize_0 = (int)(short)(int)(short)(BitConverter.ToInt16(byteData, nPos));
                                    nPos += 2;
                                    nCnt = nSize_0;
                                }
                                #endregion Size - GroupInfo ( 2 Bytes )

                                #region Group Info(for ...)
                                for (int nGroup = 0; nGroup < nCnt; nGroup++)
                                {
                                    SGroupInfo_t SGroup = new SGroupInfo_t();
                                    // Number(2 bytes)
                                    SGroup.nNumber = BitConverter.ToInt16(byteData, nPos); nPos += 2;

                                    // string size(2 bytes)
                                    nSize_0 = BitConverter.ToInt16(byteData, nPos); nPos += 2;
                                    SGroup.strName = Encoding.Default.GetString(byteData, nPos, nSize_0);
                                    nPos += nSize_0;
                                    CDesignHeder.lstGroupInfo.Add(SGroup);
                                }
                                #endregion Group Info
                                //CDesignHeder.lstGroupInfo.Clear();

                                CDesignHeder.SJson.nQr = BitConverter.ToInt16(byteData, nPos); nPos += 2;
                                for (int k = 0; k < 6; k++) { CDesignHeder.SJson.afScene_Position[k] = BitConverter.ToSingle(byteData, nPos); nPos += 4; }
                                for (int k = 0; k < 6; k++) { CDesignHeder.SJson.afCamera_Position[k] = BitConverter.ToSingle(byteData, nPos); nPos += 4; }
                                for (int k = 0; k < 6; k++) { CDesignHeder.SJson.afRobot_Position[k] = BitConverter.ToSingle(byteData, nPos); nPos += 4; }

                                CDesignHeder.SJson.fRobot_Scale = BitConverter.ToSingle(byteData, nPos); nPos += 4;
                                CDesignHeder.SJson.cBackColor = Color.FromArgb(BitConverter.ToInt32(byteData, nPos)); nPos += 4;
                                CDesignHeder.SJson.cBackColor_Edit = Color.FromArgb(BitConverter.ToInt32(byteData, nPos)); nPos += 4;
                                CDesignHeder.SJson.cPlaneColor = Color.FromArgb(BitConverter.ToInt32(byteData, nPos)); nPos += 4;
                                int nTmp = BitConverter.ToInt16(byteData, nPos); nPos += 2;
                                CDesignHeder.SJson.IsWireFrame = (nTmp == 0) ? false : true;

                                // string size(2 bytes)
                                nSize_0 = BitConverter.ToInt16(byteData, nPos); nPos += 2;
                                CDesignHeder.SJson.strBleName = Encoding.Default.GetString(byteData, nPos, nSize_0); nPos += nSize_0;

                                CDesignHeder.SJson.nAddress_Motion = BitConverter.ToInt32(byteData, nPos); nPos += 4;
                                CDesignHeder.SJson.nAddress_Control = BitConverter.ToInt32(byteData, nPos); nPos += 4;

                                #endregion GroupInfo
                            }
                            #endregion OJW



                        }
                        else bFileOpened = false;
#endif
                    #endregion OjwVersion
                    ////////////////////////////////////////////////////////////////////////////

                    if (bFileOpened == true)
                    {
                        CHeader = CDesignHeder;
                        CHeader.pDhParamAll = new CDhParamAll[512];

                        CDesignHeder = null;

                        m_bFileOpening = false;

                        InitToolsMotorVar();


                        m_strDesignFileName = strFileName;
                        m_strDesignerFilePath = Ojw.CFile.GetPath(strFileName);
                        // Event Running
                        Event_FileOpen.RunEvent();
                        //m_strDesignFileName
                        

                        int nAxis = 0;
                        foreach (SMotorInfo_t SMotInfo in CHeader.pSMotorInfo)
                        {
                            if (m_CGridMotionEditor != null) m_CGridMotionEditor.Clear_SetType(0); // Default
                            SetData(nAxis++, SMotInfo.fInitAngle);
                        }

                        //m_CMonster.Set3DHeader(CHeader);






                        return true;
                    }

                    m_strVersion = "";
                    CDesignHeder = null;
                    m_bFileOpening = false;
                    return false;
                }
                catch(Exception ex)
                {
                    Ojw.CMessage.Write_Error("Error -> FileOpen(), " + ex.ToString());
                    m_strVersion = "";
                    m_bFileOpening = false;
                    return false;
                }
            }
            //}
            #endregion Designer class(COjwDesignerHeader)


            #region Designer header class(COjwDesignerHeader)
            public class COjwDesignerHeader
            {
                public int nVersion;
                public String strVersion;
                
                public int nDefaultFunctionNumber = -1;

                public int nModelNum = 0;                               // The name of the actual model with the at least 1(Kor: 1 이상의 값을 가지는 실제적인 모델의 이름)
                public String strModelNum = String.Empty;               // 
                public string strModelName = "";

                // Json 때문에 새로 추가
                public string strTitle = "";

                public SAngle3D_t SInitAngle = new SAngle3D_t();        // The default angle facing the screen(Kor: 화면을 바라보는 기본 각도)
                public SVector3D_t SInitPos = new SVector3D_t();        // The default position of the object present in the screen(Kor: 화면내에 존재하는 오브젝트의 기본 위치)

                public float fInitScale = 0.35f;                        // Size ratio in the initial screen(Kor: 초기 화면의 크기 비율)

                public bool bDisplay_Light = true;                      // To use the light(Kor: 빛을 사용할 것인지...)
                public bool bDisplay_Invisible = false;                 // Transparent material, regardless of whether the ball(Kor: 재질과 상관없이 투명하게 볼 것인지...)
                public bool bDisplay_Axis = false;                      // Look what the reference axis(Kor: 기준축을 보일 건지)

                public Color cBackColor = Color.FromArgb(-5658199);     // backgroud color(Kor: 배경 색)

                public SMotorInfo_t[] pSMotorInfo = new SMotorInfo_t[256];          // This limit is necessary because it reflects axes up to 256 axes(Kor: 리미트가 필요한 축은 최대 256축 이므로 이를 반영)
                public List<SGroupInfo_t> lstGroupInfo = new List<SGroupInfo_t>();

                public string[] pstrGroupName = new string[512];          // Group name(Kor: 지정한 그룹의 이름)
                public CDhParamAll[] pDhParamAll = new CDhParamAll[512]; // (0~255 Group)DH Param
                public int[] pnSecret = new int[512];                   // 0: Normal, 1: Secret Letter
                public int[] pnType = new int[512];                     // 0: Normal, 1: Wheel Control Type
                public bool[] pbPython = new bool[512];                   // false: Normal, true: Python code
                public string[] pstrKinematics = new string[512];
                public SEncryption_t[] pSEncryptKinematics_encryption = new SEncryption_t[512];
                public string[] pstrInverseKinematics = new string[512];
                public SEncryption_t[] pSEncryptInverseKinematics_encryption = new SEncryption_t[512];

                public SOjwCode_t[] pSOjwCode = new SOjwCode_t[512];

                // 해당 수식이 적용 될 시작 위치의 Offset(이동 - 회전)
                public SVector3D_t [] pSOffset_Trans = new SVector3D_t[512];
                public SVector3D_t[] pSOffset_Rot = new SVector3D_t[512];

                public string strDrawModel;                                 // String that contains the actual data model(Kor: 실제 모델 데이타가 들어있는 스트링)
                // The number of motors in internal (However, be sure to order 0,1,2, ... must be created in order)
                // Kor: 내부에 들어있는 모터의 갯수 ( 단, 반드시 순서대로 0,1,2,... 순으로 작성해야 한다. )
                public int nMotorCnt;
                public int[] anMotorIDs;

                public string strComment;                               // comment(Kor: 부가설명)

                public int nWheelCounter_2 = 0;                         // The number of 2-wheel wheels(Kor: 2륜 디바이스의 개수)
                public int nWheelCounter_3 = 0;                         // The number of 3-wheel wheels(Kor: 3륜 디바이스의 개수)
                public int nWheelCounter_4 = 0;                         // The number of 4-wheel wheels(Kor: 4륜 디바이스의 개수)
                
                public struct SJson_t
                {
                    public int nQr; // 1: Qr, 0: Ble
                    public float [] afScene_Position;
                    public float [] afCamera_Position;
                    public float [] afRobot_Position;
                    public float fRobot_Scale;
                    public Color cBackColor;
                    public Color cBackColor_Edit;
                    public Color cPlaneColor;
                    public bool IsWireFrame;
                    public string strBleName;
                    public int nAddress_Motion;
                    public int nAddress_Control;
                }
                public SJson_t SJson = new SJson_t();

                public COjwDesignerHeader() // 생성자
                {
                    SInitAngle.pan = -10.0f;
                    SInitAngle.tilt = 10.0f;
                    SInitAngle.swing = 0.0f;

                    SInitPos.x = 0.0f;
                    SInitPos.y = 0.0f;
                    SInitPos.z = 0.0f;

                    pSMotorInfo.Initialize();
                    for (int i = 0; i < 256; i++)
                    {
                        pSMotorInfo[i].nInterference_Axis = -1;

                        // Alloc memory(Kor: 메모리 확보)
                        pDhParamAll[i] = new CDhParamAll();
                        pDhParamAll[i].DeleteAll();

                        pSMotorInfo[i].strNickName = "";

                        pstrGroupName[i] = "";
                        pstrKinematics[i] = "";
                        //pbyteKinematics_encryption
                        pstrInverseKinematics[i] = "";
                        //pbyteInverseKinematics_encryption

                        pSMotorInfo[i].nMotorID = i;
                        pSMotorInfo[i].fMechAngle = 360.0f;// 330.0f;
                        pSMotorInfo[i].nMechMove = 4096;// 1024;
                        pSMotorInfo[i].nCenter_Evd = 2048;// 512;

                        #region 추가기능
                        // 추가
                        pSMotorInfo[i].fRpm = 0.229f; // 기본 rpm 단위
                        pSMotorInfo[i].nLimitRpm_Raw = 415;
                        pSMotorInfo[i].nProtocolVersion = 2; // Version 2(0 해도 동일)
                        pSMotorInfo[i].nHwMotor_Index = 2; // 0 : None, 1 : xl-320, 2 : xl_430(Default), 3 - ax-12
                        pSMotorInfo[i].nHwMotor_Key = 1060; // 0번지에 모델번호 XL430 : 1060, XM430_W210 : 1030, XM430_W350 : 1020
                        pSMotorInfo[i].nAddr_Max = 146;
                        pSMotorInfo[i].nAddr_Torq = 64;
                        pSMotorInfo[i].nAddr_Led = 65;
                        pSMotorInfo[i].nAddr_Mode = 10; // 430 -> 10 address    [0 : 전류, 1 : 속도, 3(default) : 관절(위치제어), 4 : 확장위치제어(멀티턴:-256 ~ 256회전), 5 : 전류기반 위치제어, 16 : pwm 제어(voltage control mode)]
                        pSMotorInfo[i].nAddr_Speed = 104; // 430 -> 104 4 bytes
                        pSMotorInfo[i].nAddr_Speed_Size = 4;
                        pSMotorInfo[i].nAddr_Pos_Speed = 112; // 430 -> 112 4 bytes
                        pSMotorInfo[i].nAddr_Pos_Speed_Size = 4;
                        pSMotorInfo[i].nAddr_Pos = 116; // 430 -> 116 4 bytes
                        pSMotorInfo[i].nAddr_Pos_Size = 4;

                        pSMotorInfo[i].nSerialType = 0;// 0 : Default, 1 : Second ... (동시에 2개 이상의 시리얼에 연결된 경우 사용)

                        pSMotorInfo[i].nMotorEnable_For_RPTask = 0; // -1 인 경우 복사 제외대상(R+Task3 에서...)
                        pSMotorInfo[i].nMotor_Enable = 0;
                        pSMotorInfo[i].nMotionEditor_Index = 0;
                        pSMotorInfo[i].nMotor_HightSpec = 0;
                        pSMotorInfo[i].nReserve_4 = 0;
                        pSMotorInfo[i].nReserve_5 = 0;
                        pSMotorInfo[i].nReserve_6 = 0;
                        pSMotorInfo[i].nReserve_7 = 0;
                        pSMotorInfo[i].nReserve_8 = 0;
                        pSMotorInfo[i].nReserve_9 = 0;
                        pSMotorInfo[i].fGearRatio = 1.0f; // 0 은 기어비 적용 안함
                        pSMotorInfo[i].fRobotisConvertingVar = 1.0f; // 0 은 적용 안함
                        pSMotorInfo[i].fReserve_2 = 0;
                        pSMotorInfo[i].fReserve_3 = 0;
                        pSMotorInfo[i].fReserve_4 = 0;
                        pSMotorInfo[i].fReserve_5 = 0;
                        pSMotorInfo[i].fReserve_6 = 0;
                        pSMotorInfo[i].fReserve_7 = 0;
                        pSMotorInfo[i].fReserve_8 = 0;
                        pSMotorInfo[i].fReserve_9 = 0;
                        #endregion 추가기능

                        
                        pSMotorInfo[i].nGuide_Event = 0;
                        pSMotorInfo[i].nGuide_AxisType = 0;
                        pSMotorInfo[i].nGuide_RingColorType = 0;
                        pSMotorInfo[i].fGuide_RingSize = 60;
                        pSMotorInfo[i].fGuide_RingThick = 25;
                        pSMotorInfo[i].nGuide_RingDir = 1;
                        pSMotorInfo[i].fGuide_3D_Scale = 1.1f;
                        pSMotorInfo[i].fGuide_3D_Alpha = 0.2f;

                        if (pSMotorInfo[i].afGuide_Pos == null)
                        {
                            pSMotorInfo[i].afGuide_Pos = new float[6];
                            pSMotorInfo[i].anGuide_Off_IDs = new int[6];
                            pSMotorInfo[i].anGuide_Off_Dir = new int[6];
                            Array.Clear(pSMotorInfo[i].afGuide_Pos, 0, pSMotorInfo[i].afGuide_Pos.Length);
                            Array.Clear(pSMotorInfo[i].anGuide_Off_IDs, 0, pSMotorInfo[i].anGuide_Off_IDs.Length);
                            Array.Clear(pSMotorInfo[i].anGuide_Off_Dir, 0, pSMotorInfo[i].anGuide_Off_Dir.Length);
                        }
                        for (int nGuide = 0; nGuide < 6; nGuide++) pSMotorInfo[i].afGuide_Pos[nGuide] = 0;
                        for (int nGuide = 0; nGuide < 6; nGuide++) pSMotorInfo[i].anGuide_Off_IDs[nGuide] = 0;
                        for (int nGuide = 0; nGuide < 6; nGuide++) pSMotorInfo[i].anGuide_Off_Dir[nGuide] = 0;
                        
                        pSEncryptKinematics_encryption[i].byteEncryption = new byte[0];
                        pSEncryptInverseKinematics_encryption[i].byteEncryption = new byte[0];
                    }
                    for (int i = 0; i < 256; i++)
                    {
                        pstrGroupName[256 + i] = "";
                        pstrKinematics[256 + i] = "";
                        pstrInverseKinematics[256 + i] = "";
                        pSEncryptKinematics_encryption[256 + i].byteEncryption = new byte[0];
                        pSEncryptInverseKinematics_encryption[256 + i].byteEncryption = new byte[0];
                    }
                    strDrawModel = "";
                    nMotorCnt = 0;
                    nDefaultFunctionNumber = -1; // No Choice

                    SJson.nQr = 0; // 1: Qr, 0: Ble
                    SJson.afScene_Position = new float[6] { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f};
                    SJson.afCamera_Position = new float[6] { 0.0f, 80.0f, 420.0f, 0.0f, 0.0f, 0.0f };
                    SJson.afRobot_Position = new float[6] { 0.0f, 100.0f, 0.0f, 0.0f, 0.0f, 0.0f };
                    SJson.fRobot_Scale = 1.0f;
                    SJson.cBackColor = Color.FromArgb(0xf2faff);
                    SJson.cBackColor_Edit = Color.FromArgb(0xe2eaef);// Color.Black;
                    SJson.cPlaneColor = Color.FromArgb(0x505070);// Color.Black;
                    SJson.IsWireFrame = false;
                    SJson.strBleName = "RB-100";
                    SJson.nAddress_Motion = 0x12170000;
                    SJson.nAddress_Control = 66;
                }
            }
            #endregion Designer header class(COjwDesignerHeader)

            public void GetInfo_Kinematics_Count(out int nForward_Count, out int nInverse_Count) { GetCount_Kinematics(out nForward_Count, out nInverse_Count); }
            public int [] GetInfo_Forward_Numbers() { return GetForward_Numbers(); }
            public int[] GetInfo_Inverse_Numbers() { return GetInverse_Numbers(); }
            public int GetInfo_Forward_Count_Motors(int nIndex) { return GetHeader_pDhParamAll()[nIndex].GetMotors().Length; }
            public int[] GetInfo_Forward_Motors(int nIndex) { return GetHeader_pDhParamAll()[nIndex].GetMotors(); }
            public int GetInfo_Inverse_Count_Motors(int nIndex) { return m_CHeader.pSOjwCode[nIndex].nMotor_Max; }
            public int[] GetInfo_Inverse_Motors(int nIndex) { return m_CHeader.pSOjwCode[nIndex].pnMotor_Number; }
            public string[] GetInfo_Forward_Text_All(int nIndex_Forward) { return m_CHeader.pstrKinematics; }
            public string GetInfo_Forward_Text(int nIndex_Forward) { return m_CHeader.pstrKinematics[nIndex_Forward]; }
            public string[] GetInfo_Inverse_Text_All(int nIndex_Forward) { return m_CHeader.pstrInverseKinematics; }
            public string GetInfo_Inverse_Text(int nIndex_Inverse) { return m_CHeader.pstrInverseKinematics[nIndex_Inverse]; }
            public void GetInfo_Forward_Results(int nIndex_Forward, out string strX, out string strY, out string strZ, out string strX_Dir, out string strY_Dir, out string strZ_Dir)
            {
                string[] pstrRes = Ojw.CKinematics.CForward.Make_XYZString_By_Forward(GetInfo_Forward_Text(nIndex_Forward));
                strX = pstrRes[0];
                strY = pstrRes[1];
                strZ = pstrRes[2];
                strX_Dir = pstrRes[3];
                strY_Dir = pstrRes[4];
                strZ_Dir = pstrRes[5];
            }
            public class COjwDisp
            {
                // 실제 초기화는 InitData() 함수에서 구현
                public COjwDisp()
                {
                    cColor = Color.White;
                    for (int i = 0; i < 5; i++)
                    {
                        afTrans[i].x = 0;
                        afTrans[i].y = 0;
                        afTrans[i].z = 0;

                        afRot[i].pan = 0;
                        afRot[i].tilt = 0;
                        afRot[i].swing = 0;
                    }
                }

                // Only use variables inside the class(Kor: 클래스 내부에서만 사용할 변수)
                private Color color = Color.White;
                public float fAlpha = 1.0f;
                private float[] afColor = new float[3];

                // Determine the internal handle, if (value < 0) then "No ID" => In other words, when determining the name of the OpenGL picking
                // Kor: 내부적 핸들을 결정, 단, 0보다 작으면(-) ID 없음. => 즉, OpenGL 의 픽킹 시 이름을 결정
                public int nName = -1;
                //public int nDispModel = 0;      // Recording the type of data to be drawn Modeling(Kor: 그려질 모델링 데이타의 종류를 기록 - 사각형, 원형, 구, ...)
                public string strDispObject = "#0"; // Recording the type of data to be drawn Modeling(Kor: 그려질 모델링 데이타의 종류를 기록) - User ASE/OBJ 
                public bool bFilled = true;     // Determining the populate the attributes of the picture(Kor: 그림의 속을 채울지를 결정)

                // 
                #region Color Set / Get
                public float fColor_R // To fill in colors(Kor: 속을 채울 색상)
                {
                    get { return afColor[0]; }
                    set
                    {
                        color = Color.FromArgb((int)(((value > 1) || (value < 0)) ? (int)255 : (int)(Math.Round(afColor[0] * 255.0f))), (int)(Math.Round(afColor[1] * 255.0f)), (int)(Math.Round(afColor[2] * 255.0f)));
                        afColor[0] = ((float)(color.R) / 255.0f);  // R
                    }
                }
                public float fColor_G
                {
                    get { return afColor[1]; }
                    set
                    {
                        color = Color.FromArgb((int)(Math.Round(afColor[0] * 255.0f)), (int)(((value > 1) || (value < 0)) ? (int)255 : (int)(Math.Round(afColor[1] * 255.0f))), (int)(Math.Round(afColor[2] * 255.0f)));
                        afColor[1] = ((float)(color.G) / 255.0f);  // G
                    }
                }
                public float fColor_B
                {
                    get { return afColor[2]; }
                    set
                    {
                        color = Color.FromArgb((int)(Math.Round(afColor[0] * 255.0f)), (int)(Math.Round(afColor[1] * 255.0f)), (int)(((value > 1) || (value < 0)) ? (int)255 : (int)(Math.Round(afColor[2] * 255.0f))));
                        afColor[2] = ((float)(color.B) / 255.0f);  // B
                    }
                }
                public Color cColor
                {
                    get { return color; }
                    set
                    {
                        color = value;
                        afColor[0] = ((float)(color.R) / 255.0f);  // R
                        afColor[1] = ((float)(color.G) / 255.0f);  // G
                        afColor[2] = ((float)(color.B) / 255.0f);  // B
                    }
                }
                #endregion Color Set / Get

                public float fMulti = 0; // The index of the texture loading - reserve(Kor: 텍스쳐의 로딩 인덱스( 아직 안씀 )) => 용도변경(fMulti -> 3D 동작각의 배율)

                public bool bInit = false; // Determine whether to re-initialize the position(Kor: 위치를 다시 초기화 할지를 결정)

                public float fWidth_Or_Radius = 10.0f; // Width / radius
                public float fHeight_Or_Depth = 4.0f; // Height / depth
                public float fDepth_Or_Cnt = 10.0f;    // Depth / line count
                public float fThickness = 4.0f;       // thickness
                public float fGap = 0.0f; // If you need to draw a [case] - do not need the another things.(Kor: case 를 그리거나 할 경우 필요 - 나머진 필요 없다.)
#if false
트랙 '?' ~ '/' 까지, ! 는 회전축
<맨 마지막의 '/' 실행 부에서> 
  [Gap] 의 숫자를 - 로 하면 가이드 원통이 나타난다.
  Offset_Trans 로 트랙의 위치 조정
  Offset_Trans 로 트랙의 조립 모양 조정
// Track
[3],-1,1,?track_.stl,1,-1,0,[-410,10,90,39.5,80],[14,1,45,0],[-0.8,-2,-22,0,180,0],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-238,10,0,0,0,0,0,0,0,0,0,0],[2,0,0,[255],[0.35,0.35],[0,0],]
[3],-1,1,?track_.stl,1,-1,0,[-120,10,90,39.5,80],[14,1,45,0],[-0.8,-2,-22,0,180,0],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-238,10,0,0,0,0,0,0,0,0,0,0],[2,0,0,[255],[0.35,0.35],[0,0],]
[0],-1,1,?!track_.stl,1,-1,0,[279.7,10,90,39.5,80],[11,0,0,0],[-0.8,-2,-22,0,180,0],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-238,10,0,0,0,0,0,0,0,0,0,0],[2,0,0,[255],[0.35,0.35],[0,0],]
[3],-1,1,/track_.stl,1,-1,0,[-120,10,90,39.5,80],[14,1,0,0],[-0.8,-2,-22,90,0,0],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-238,10,0,0,0,0,0,0,0,0,0,0],[2,0,0,[255],[0.35,0.35],[0,0],]
#endif
                public string strCaption = ""; // comment

                // Offset
                public SVector3D_t SOffset_Trans = new SVector3D_t();
                public SAngle3D_t SOffset_Rot = new SAngle3D_t();

                // translation / Rotation
                public SVector3D_t[] afTrans = new SVector3D_t[5]; // [3] - T/R : 1st sub-screen conversion(Kor: 1차 서브화면 변환), [4] - T/R : 2st sub-screen conversion(Kor: 2차 서브화면 변환)
                public SAngle3D_t[] afRot = new SAngle3D_t[5];

                // Determining the actual rotation axis(Kor: 실 회전 축 결정)[0 ~ 2(Pan, Tilt, Swing), 3~5(x,y,z), 6(cw), 7(ccw)]
                public int nAxisMoveType;
                public int nDir;       // direction - 0 : forward, 1 : inverse
                public float fAngle; // actual angle value
                public string strAngle_Offset; // angle Offset

                public int nMotorType;  // Motor control type - 0 : Position Control, 1 : Speed Control
                public int nMotorControl_MousePoint; // Direction of the mouse-drag application(Kor: 마우스 드래그 시의 방향 적용) : 0 - x+, 1 - x-, 2 - y+, 3 - y-

                //////////////////////////////
                #region Picking Var
                public int nPickGroup_A;
                public int nPickGroup_B;
                public int nPickGroup_C;

                public int nTextureStatus; // 상황 변수, 이게 1일때 로드하고 로드 후 시스템에서 0으로 만듬
                public string strTexture; // 

                public int nInverseKinematicsNumber;
                public int nInverseKinematicsNumber_AfterCalc;

                public float fScale_Serve0;
                public float fScale_Serve1;

                public string strPickGroup_Comment;
                #endregion Picking

                public List<SVector3D_t> Points = new List<SVector3D_t>();

                public SOjwCode_t SCode;

                //public void InitData()
                //{   
                //    InitData(null);
                //}
                //COjwDispAll m_CTestCDispAll;
                //public void InitData(COjwDispAll CDisps)
                public void InitData()
                {
                    //m_CTestCDispAll = CDisps;
                    SVector3D_t[] pSVector = new SVector3D_t[5];
                    SAngle3D_t[] pSAngle = new SAngle3D_t[5];
                    pSVector.Initialize();
                    pSAngle.Initialize();
                    List<SVector3D_t> tmpPoints = new List<SVector3D_t>();
                    //tmpPoints.Clear();
                    //tmpPoints.Add(new SVector3D_t(0, 0, 0));
                    //tmpPoints.Add(new SVector3D_t(10, 0, 0));
                    //SetData(-1, Color.White, 1.0f, "#0", true, -1, false, 10, 10, 20, 4, 0, "", -1, 0, 0, 0, pSVector[0], pSAngle[0], pSVector, pSAngle, 0, 0, 0, 255, 0.35f, 0.35f, 0, 0, "", tmpPoints);
                    SetData(-1, Color.White, 1.0f, "#7", true, -1, false, 10, 10, 20, 4, 0, "", -1, 0, 0, "", pSVector[0], pSAngle[0], pSVector, pSAngle, 0, 0, 0, 255, -1, 0.35f, 0.35f, 0, 0, "", tmpPoints);
                    pSVector = null;
                    pSAngle = null;

                    Ojw.CKinematics.CInverse.Compile("", out SCode);
                    int nGetCnt = 0;
                    //if (CDisps != null) nGetCnt = CDisps.GetCount();
                    Points.Clear();
                }

                public void SetData(COjwDisp OjwDispData)
                {
                    SetData(OjwDispData.nName, OjwDispData.cColor, OjwDispData.fAlpha, OjwDispData.strDispObject, OjwDispData.bFilled, OjwDispData.fMulti, OjwDispData.bInit, OjwDispData.fWidth_Or_Radius, OjwDispData.fHeight_Or_Depth, OjwDispData.fDepth_Or_Cnt,
                            OjwDispData.fThickness, OjwDispData.fGap, OjwDispData.strCaption,
                            OjwDispData.nAxisMoveType, OjwDispData.nDir, OjwDispData.fAngle, OjwDispData.strAngle_Offset,
                            OjwDispData.SOffset_Trans, OjwDispData.SOffset_Rot, OjwDispData.afTrans, OjwDispData.afRot,
                            OjwDispData.nPickGroup_A, OjwDispData.nPickGroup_B, OjwDispData.nPickGroup_C, OjwDispData.nInverseKinematicsNumber, OjwDispData.nInverseKinematicsNumber_AfterCalc,
                            OjwDispData.fScale_Serve0, OjwDispData.fScale_Serve1,
                            OjwDispData.nMotorType, OjwDispData.nMotorControl_MousePoint,
                            OjwDispData.strPickGroup_Comment,
                            OjwDispData.Points,
                            OjwDispData.SCode
                            );
                }
                public void SetData(int nAxisName, Color cColorData, float fAlphaData, String strDrawObject, bool bFill, float fMultiData, bool bInitialize, float fW, float fH, float fD, float fT, float fGapData, string strMessage,
                                    int nAxisData, int nDirData, float fAngleData, string strAngle_OffsetData,
                                    SVector3D_t SOffset_Translation, SAngle3D_t SOffset_Rotation, SVector3D_t[] afTranslation, SAngle3D_t[] afRotation,
                                    int nObjectPickGroup_A, int nObjectPickGroup_B, int nObjectPickGroup_C, int nObjectPickGroup_InverseKinematics, int nObjectPickGroup_InverseKinematics_AfterCalc,
                                    float fObjectScale_Serve0, float fObjectScale_Serve1,
                                    int nObjectMotorType, int nObjectMotorControl_MousePoint,
                                    String strObjectPickGroup_Comment,
                                    List<SVector3D_t> lstPoints
                                    )
                {
                    SOjwCode_t SCodeData = new SOjwCode_t();
                    SetData(nAxisName, cColorData, fAlphaData, strDrawObject, bFill, fMultiData, bInitialize, fW, fH, fD, fT, fGapData, strMessage,
                                    nAxisData, nDirData, fAngleData, strAngle_OffsetData,
                                    SOffset_Translation, SOffset_Rotation, afTranslation, afRotation,
                                    nObjectPickGroup_A, nObjectPickGroup_B, nObjectPickGroup_C, nObjectPickGroup_InverseKinematics, nObjectPickGroup_InverseKinematics_AfterCalc,
                                    fObjectScale_Serve0, fObjectScale_Serve1,
                                    nObjectMotorType, nObjectMotorControl_MousePoint,
                                    strObjectPickGroup_Comment,
                                    lstPoints,
                                    SCodeData
                                    );
                }
                public void SetData(int nAxisName, Color cColorData, float fAlphaData, String strDrawObject, bool bFill, float fMultiData, bool bInitialize, float fW, float fH, float fD, float fT, float fGapData, string strMessage,
                                    int nAxisData, int nDirData, float fAngleData, string strAngle_OffsetData,
                                    SVector3D_t SOffset_Translation, SAngle3D_t SOffset_Rotation, SVector3D_t[] afTranslation, SAngle3D_t[] afRotation,
                                    int nObjectPickGroup_A, int nObjectPickGroup_B, int nObjectPickGroup_C, int nObjectPickGroup_InverseKinematics, int nObjectPickGroup_InverseKinematics_AfterCalc,
                                    float fObjectScale_Serve0, float fObjectScale_Serve1,
                                    int nObjectMotorType, int nObjectMotorControl_MousePoint,
                                    String strObjectPickGroup_Comment,
                                    List<SVector3D_t> lstPoints,
                                    SOjwCode_t SCodeData
                                    )
                {
                    cColor = cColorData;
                    fAlpha = fAlphaData;
                    // Determine the internal handle, if (value < 0) then "No ID" => In other words, when determining the name of the OpenGL picking
                    // Kor: 내부적 핸들을 결정, 단, 0보다 작으면(-) ID 없음. => 즉, OpenGL 의 픽킹 시 이름을 결정
                    nName = nAxisName;
                    //nDispModel = nModel; // Recording the type of data to be drawn Modeling(Kor: 그려질 모델링 데이타의 종류를 기록 - 사각형, 원형, 구, ...)
                    strDispObject = strDrawObject;
                    bFilled = bFill;   // Determining the populate the attributes of the picture(Kor: 그림의 속을 채울지를 결정)

                    fMulti = fMultiData;

                    bInit = bInitialize;
                    fWidth_Or_Radius = fW;
                    fHeight_Or_Depth = fH;
                    fDepth_Or_Cnt = fD;
                    fThickness = fT;
                    fGap = fGapData;
                    strCaption = strMessage;

                    SOffset_Trans.x = SOffset_Translation.x;
                    SOffset_Trans.y = SOffset_Translation.y;
                    SOffset_Trans.z = SOffset_Translation.z;

                    SOffset_Rot.pan = SOffset_Rotation.pan;
                    SOffset_Rot.tilt = SOffset_Rotation.tilt;
                    SOffset_Rot.swing = SOffset_Rotation.swing;

                    for (int i = 0; i < 5; i++)
                    {
                        afTrans[i].x = afTranslation[i].x;
                        afTrans[i].y = afTranslation[i].y;
                        afTrans[i].z = afTranslation[i].z;

                        afRot[i].pan = afRotation[i].pan;
                        afRot[i].tilt = afRotation[i].tilt;
                        afRot[i].swing = afRotation[i].swing;
                    }

                    nAxisMoveType = nAxisData;
                    nDir = nDirData;
                    fAngle = fAngleData;
                    strAngle_Offset = strAngle_OffsetData;

                    // Picking Data
                    nPickGroup_A = nObjectPickGroup_A;
                    nPickGroup_B = nObjectPickGroup_B;
                    nPickGroup_C = nObjectPickGroup_C;
                    nInverseKinematicsNumber = nObjectPickGroup_InverseKinematics;
                    nInverseKinematicsNumber_AfterCalc = nObjectPickGroup_InverseKinematics_AfterCalc;
                    fScale_Serve0 = fObjectScale_Serve0;
                    fScale_Serve1 = fObjectScale_Serve1;
                    strPickGroup_Comment = strObjectPickGroup_Comment;

                    nMotorType = nObjectMotorType;
                    nMotorControl_MousePoint = nObjectMotorControl_MousePoint;

                    Points = lstPoints;
                    SCode = SCodeData;
                }
                #region Set
                // Determine the internal handle, if (value < 0) then "No ID" => In other words, when determining the name of the OpenGL picking
                // Kor: 내부적 핸들을 결정, 단, 0보다 작으면(-) ID 없음. => 즉, OpenGL 의 픽킹 시 이름을 결정
                public void SetData_AxisName(int nValue) { nName = nValue; }
                public void SetData_Color(Color cValue) { cColor = cValue; }
                public void SetData_DispObject(String strValue) { strDispObject = strValue; } // Recording the type of data to be drawn Modeling(Kor: 그려질 모델링 데이타의 종류를 기록 - 사각형, 원형, 구, ...)
                public void SetData_Fill(bool bValue) { bFilled = bValue; } // Determining the populate the attributes of the picture(Kor: 그림의 속을 채울지를 결정)
                public void SetData_fMul_3DAngle(float fValue) { fMulti = fValue; }
                public void SetData_Init(bool bValue) { bInit = bValue; }

                public void SetData_Width_Or_Radius(float fValue) { fWidth_Or_Radius = fValue; }
                public void SetData_Height_Or_Depth(float fValue) { fHeight_Or_Depth = fValue; }
                public void SetData_Depth_Or_Cnt(float fValue) { fDepth_Or_Cnt = fValue; }
                public void SetData_Thickness(float fValue) { fThickness = fValue; }
                public void SetData_Gap(float fValue) { fGap = fValue; }
                public void SetData_Caption(String strValue) { strCaption = strValue; }
                public void SetData_Axis(int nValue) { nAxisMoveType = nValue; }
                public void SetData_Dir(int nValue) { nDir = nValue; }
                public void SetData_Angle(float fValue) { fAngle = fValue; }
                public void SetData_Angle_Offset(string strValue) { strAngle_Offset = strValue; }
                public void SetData_Offset_Translation(float fX, float fY, float fZ) { SOffset_Trans.x = fX; SOffset_Trans.y = fY; SOffset_Trans.z = fZ; }
                public void SetData_Offset_Rotation(float fPan, float fTilt, float fSwing) { SOffset_Rot.pan = fPan; SOffset_Rot.tilt = fTilt; SOffset_Rot.swing = fSwing; }
                public void SetData_Translation(int nIndex, float fX, float fY, float fZ) { if ((nIndex >= 0) && (nIndex < afTrans.Length)) { afTrans[nIndex].x = fX; afTrans[nIndex].y = fY; afTrans[nIndex].z = fZ; } }
                public void SetData_Rotation(int nIndex, float fPan, float fTilt, float fSwing) { if ((nIndex >= 0) && (nIndex < afRot.Length)) { afRot[nIndex].pan = fPan; afRot[nIndex].tilt = fTilt; afRot[nIndex].swing = fSwing; } }
                public void SetData_nPickGroup_A(int nValue) { nPickGroup_A = nValue; }
                public void SetData_nPickGroup_B(int nValue) { nPickGroup_B = nValue; }
                public void SetData_nPickGroup_C(int nValue) { nPickGroup_C = nValue; }
                public void SetData_nInverseKinematicsNumber(int nValue) { nInverseKinematicsNumber = nValue; }
                public void SetData_nInverseKinematicsNumber_AfterCalc(int nValue) { nInverseKinematicsNumber_AfterCalc = nValue; }
                public void SetData_fScale_Serve0(float fValue) { fScale_Serve0 = fValue; }
                public void SetData_fScale_Serve1(float fValue) { fScale_Serve1 = fValue; }
                public void SetData_nMotorType(int nValue) { nMotorType = nValue; }
                public void SetData_nMotorControl_MousePoint(int nValue) { nMotorControl_MousePoint = nValue; }
                public void SetData_strPickGroup_Comment(String strValue) { strPickGroup_Comment = strValue; }
                #endregion Set

                #region Get
                // Determine the internal handle, if (value < 0) then "No ID" => In other words, when determining the name of the OpenGL picking
                // Kor: 내부적 핸들을 결정, 단, 0보다 작으면(-) ID 없음. => 즉, OpenGL 의 픽킹 시 이름을 결정
                public int GetData_AxisName() { return nName; }
                public Color GetData_Color() { return cColor; }
                public String GetData_DispObject() { return strDispObject; } // Recording the type of data to be drawn Modeling(Kor: 그려질 모델링 데이타의 종류를 기록 - 사각형, 원형, 구, ...)
                public bool GetData_Fill() { return bFilled; } // Determining the populate the attributes of the picture(Kor: 그림의 속을 채울지를 결정)
                public float GetData_fMul_3DAngle() { return fMulti; }
                public bool GetData_Init() { return bInit; }

                public float GetData_Width_Or_Radius() { return fWidth_Or_Radius; }
                public float GetData_Height_Or_Depth() { return fHeight_Or_Depth; }
                public float GetData_Depth_Or_Cnt() { return fDepth_Or_Cnt; }
                public float GetData_Thickness() { return fThickness; }
                public float GetData_Gap() { return fGap; }
                public String GetData_Caption() { return strCaption; }
                public int GetData_Axis() { return nAxisMoveType; }
                public int GetData_Dir() { return nDir; }
                public float GetData_Angle() { return fAngle; }
                public string GetData_Angle_Offset() { return strAngle_Offset; }
                public SVector3D_t GetData_Offset_Translation() { return SOffset_Trans; }
                public SAngle3D_t GetData_Offset_Rotation() { return SOffset_Rot; }
                public SVector3D_t GetData_Translation(int nIndex) { return afTrans[nIndex % afTrans.Length]; }
                public SAngle3D_t GetData_Rotation(int nIndex) { return afRot[nIndex % afRot.Length]; }
                public int GetData_nPickGroup_A() { return nPickGroup_A; }
                public int GetData_nPickGroup_B() { return nPickGroup_B; }
                public int GetData_nPickGroup_C() { return nPickGroup_C; }
                public int GetData_nInverseKinematicsNumber() { return nInverseKinematicsNumber; }
                public int GetData_nInverseKinematicsNumber_AfterCalc() { return nInverseKinematicsNumber_AfterCalc; }
                public float GetData_fScale_Serve0() { return fScale_Serve0; }
                public float GetData_fScale_Serve1() { return fScale_Serve1; }
                public int GetData_nMotorType() { return nMotorType; }
                public int GetData_nMotorControl_MousePoint() { return nMotorControl_MousePoint; }
                public String GetData_strPickGroup_Comment() { return strPickGroup_Comment; }
                #endregion Get

                public COjwDisp Clone()
                {
                    COjwDisp obj = new COjwDisp();
                    obj.cColor = this.cColor;
                    obj.fAlpha = this.fAlpha;
                    // Determine the internal handle, if (value < 0) then "No ID" => In other words, when determining the name of the OpenGL picking
                    // Kor: 내부적 핸들을 결정, 단, 0보다 작으면(-) ID 없음. => 즉, OpenGL 의 픽킹 시 이름을 결정
                    obj.nName = this.nName;
                    obj.strDispObject = (String)this.strDispObject.Clone(); // Recording the type of data to be drawn Modeling(Kor: 그려질 모델링 데이타의 종류를 기록 - 사각형, 원형, 구, ...)
                    obj.bFilled = this.bFilled;   // Determining the populate the attributes of the picture(Kor: 그림의 속을 채울지를 결정)

                    obj.fMulti = this.fMulti;

                    obj.bInit = this.bInit;
                    obj.fWidth_Or_Radius = this.fWidth_Or_Radius;
                    obj.fHeight_Or_Depth = this.fHeight_Or_Depth;
                    obj.fDepth_Or_Cnt = this.fDepth_Or_Cnt;
                    obj.fThickness = this.fThickness;
                    obj.fGap = this.fGap;
                    obj.strCaption = (String)this.strCaption.Clone();

                    obj.SOffset_Trans.x = this.SOffset_Trans.x;
                    obj.SOffset_Trans.y = this.SOffset_Trans.y;
                    obj.SOffset_Trans.z = this.SOffset_Trans.z;

                    obj.SOffset_Rot.pan = this.SOffset_Rot.pan;
                    obj.SOffset_Rot.tilt = this.SOffset_Rot.tilt;
                    obj.SOffset_Rot.swing = this.SOffset_Rot.swing;

                    for (int i = 0; i < 5; i++)
                    {
                        obj.afTrans[i].x = this.afTrans[i].x;
                        obj.afTrans[i].y = this.afTrans[i].y;
                        obj.afTrans[i].z = this.afTrans[i].z;

                        obj.afRot[i].pan = this.afRot[i].pan;
                        obj.afRot[i].tilt = this.afRot[i].tilt;
                        obj.afRot[i].swing = this.afRot[i].swing;
                    }

                    obj.nAxisMoveType = this.nAxisMoveType;
                    obj.nDir = this.nDir;
                    obj.fAngle = this.fAngle;
                    obj.strAngle_Offset = this.strAngle_Offset;

                    // Picking Data
                    obj.nPickGroup_A = this.nPickGroup_A;
                    obj.nPickGroup_B = this.nPickGroup_B;
                    obj.nPickGroup_C = this.nPickGroup_C;
                    obj.nInverseKinematicsNumber = this.nInverseKinematicsNumber;
                    obj.nInverseKinematicsNumber_AfterCalc = this.nInverseKinematicsNumber_AfterCalc;
                    obj.fScale_Serve0 = this.fScale_Serve0;
                    obj.fScale_Serve1 = this.fScale_Serve1;
                    obj.strPickGroup_Comment = (this.strPickGroup_Comment == null) ? "" : (String)this.strPickGroup_Comment.Clone();

                    obj.nMotorType = this.nMotorType;
                    obj.nMotorControl_MousePoint = this.nMotorControl_MousePoint;

                    obj.Points.Clear();
                    obj.SCode.nCnt_Operation = 0;
                    Ojw.CKinematics.CInverse.Compile("", out obj.SCode);
                    for (int i = 0; i < this.Points.Count; i++)
                    {
                        obj.Points.Add(this.Points[i]);
                    }

                    return obj;
                }
            }

            public class COjwDispAll
            {
#if true
                private List<COjwDisp> lstOjwDisp;
                public int GetCount() { return (lstOjwDisp == null) ? 0 : lstOjwDisp.Count; }
                public COjwDisp GetData(int nIndex)
                {
                    if (lstOjwDisp == null) return null;
                    else if ((nIndex >= lstOjwDisp.Count) || (nIndex < 0)) return null;
                    else return lstOjwDisp[nIndex];
                }
                public List<COjwDisp> GetData() // OJW5014_20151012
                {
                    if (lstOjwDisp == null) return null;
                    else return lstOjwDisp;
                }
                public bool SetData(int nIndex, COjwDisp OjwDisp)
                {
                    if ((nIndex >= lstOjwDisp.Count) || (nIndex < 0)) return false;

                    lstOjwDisp[nIndex].SetData(OjwDisp);
                    return true;
                }
                public bool AddData(COjwDisp OjwDisp)
                {
                    if (lstOjwDisp == null) lstOjwDisp = new List<COjwDisp>();
                    lstOjwDisp.Add(OjwDisp);
                    return true;
                }
                public bool DeleteData(int nIndex)
                {
                    if (lstOjwDisp == null) return false;// lstOjwDisp = new List<COjwDisp>();
                    try
                    {
                        lstOjwDisp.RemoveAt(nIndex);
                        return true;
                    }
                    catch
                    {
                        return false;
                    }
                }
                public bool DeleteData(COjwDisp OjwDisp)
                {
                    if (lstOjwDisp == null) return false;
                    try
                    {
                        lstOjwDisp.Remove(OjwDisp);
                        return true;
                    }
                    catch
                    {
                        return false;
                    }
                }
                public void DeleteAll()
                {
                    if (lstOjwDisp != null)
                        lstOjwDisp.Clear();
                }
                public String GetString_PickingComment(int nGroupA, int nGroupB, int nGroupC)
                {
                    string strComment = null;
                    COjwDisp CDisp = new COjwDisp();
                    for (int i = 0; i < GetCount(); i++)
                    {
                        CDisp = GetData(i);
                        if (CDisp != null)
                        {
                            if ((CDisp.nPickGroup_A == nGroupA) && (CDisp.nPickGroup_B == nGroupB) && (CDisp.nPickGroup_C == nGroupC))
                            {
                                strComment = CDisp.strPickGroup_Comment;
                                break;
                            }
                        }
                    }
                    return strComment;
                }
#else
                #region 여기까지
                private COjwDisp[] pOjwDisp;
                public int GetCount() { return (pOjwDisp == null) ? 0 : pOjwDisp.Length; }

                public COjwDisp GetData(int nIndex)
                {
                    if (pOjwDisp == null) return null;
                    else if ((nIndex >= pOjwDisp.Length) || (nIndex < 0)) return null;
                    else return pOjwDisp[nIndex];
                }
                public bool SetData(int nIndex, COjwDisp OjwDisp)
                {
                    if ((nIndex >= pOjwDisp.Length) || (nIndex < 0)) return false;
                    pOjwDisp[nIndex].SetData(OjwDisp);
                    return true;
                }
                public bool AddData(COjwDisp OjwDisp)
                {
                    int nCnt = (pOjwDisp == null) ? 1 : pOjwDisp.Length + 1;
                    Array.Resize(ref pOjwDisp, nCnt);
                    //pOjwDisp[nCnt - 1] = OjwDisp;
                    pOjwDisp[nCnt - 1] = new COjwDisp();
                    pOjwDisp[nCnt - 1].SetData(OjwDisp);

                    return true;
                }
                public void DeleteAll()
                {
                    if (pOjwDisp != null)
                    {
                        for (int i = 0; i < pOjwDisp.Length; i++)
                            pOjwDisp[i] = null;
                        Array.Resize(ref pOjwDisp, 0);
                    }
                }
                public String GetString_PickingComment(int nGroupA, int nGroupB, int nGroupC)
                {
                    string strComment = null;
                    COjwDisp CDisp = new COjwDisp();
                    for (int i = 0; i < GetCount(); i++)
                    {
                        CDisp = GetData(i);
                        if (CDisp != null)
                        {
                            if ((CDisp.nPickGroup_A == nGroupA) && (CDisp.nPickGroup_B == nGroupB) && (CDisp.nPickGroup_C == nGroupC))
                            {
                                strComment = CDisp.strPickGroup_Comment;
                                break;
                            }
                        }
                    }
                    return strComment;
                }
                #endregion 여기까지

                

                

                
#endif
            }

            public class COjwAse
            {
                public int nModel;
                public COjwAse()
                {
                    afPos = new float[3];

                    m_nModelIndex = 0;
                    m_lstModelIndex = new List<int>();

                    m_lstSVec4D = new List<SVector4D_t>();
                    m_lstSSVec4D_Result = new List<SVector4D_t>();
                    m_lstSFace = new List<SPoint3D_t>();
                    m_nCnt = 0;
                    m_nCnt_Result = 0;
                    m_nCnt_Face = 0;
                    nModel = 0;
                }
                private int m_nCnt;
                private int m_nCnt_Result;
                public float[] afPos;
                private int m_nModelIndex;
                private List<int> m_lstModelIndex;
                private List<SVector4D_t> m_lstSVec4D;
                private List<SVector4D_t> m_lstSSVec4D_Result;
                //private SVector3D_t[] SVec3D;
                //private SVector3D_t[] SVec3D_Result;
                //private SPoint3D_t[] SFace;
                private List<SPoint3D_t> m_lstSFace;// = new List<SPoint3D_t>();
                private int m_nCnt_Face;

                public void Data_Type_Set(int nOBJ_ASE)
                {
                    nModel = nOBJ_ASE;
                }
                public int Data_Get_Type() { return nModel; }


#if false
                    SVector3D_t[] aSPos = new SVector3D_t[m_lstOjwAse[nIndex_Ase].Face_GetCnt() * 3];

                    int nPos = 0;

                    int nPos2;
                    SPoint3D_t[] pSData = m_lstOjwAse[nIndex_Ase].Face_Get();
                    foreach (SPoint3D_t SPnt in pSData)
                    {
                        nPos2 = nPos * 3;
                        aSPos[nPos2] = m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.x);
                        aSPos[nPos2 + 1] = m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.y);
                        aSPos[nPos2 + 2] = m_lstOjwAse[nIndex_Ase].Data_Get(SPnt.z);
                        nPos++;
                    }
#endif

                public void Data_Clear()
                {
                    m_nModelIndex = 0;
                    m_lstModelIndex.Clear();
                    m_lstSVec4D.Clear();// SVec3D = null;
                    m_lstSSVec4D_Result.Clear();// = null;
                    m_lstSFace.Clear();
                    m_nCnt = 0;
                    m_nCnt_Result = 0;
                    m_nCnt_Face = 0;
                }
                public int Data_GetCnt()
                {
                    return m_nCnt;
                }
                public int Data_Add(float fX, float fY, float fZ, float fW)
                {
                    try
                    {
                        m_lstModelIndex.Add(m_nModelIndex);
                        m_lstSVec4D.Add(new SVector4D_t(fX, fY, fZ, fW));
                        m_nCnt = m_lstSVec4D.Count;
                    }
                    catch (Exception e)
                    {
                        MessageBox.Show(e.ToString());
                    }
                    return m_nCnt;
                }
                public int Data_Add(float fX, float fY, float fZ)
                {
                    try
                    {
#if false
                        m_nCnt = (SVec3D == null) ? 1 : m_nCnt + 1;
                        Array.Resize(ref SVec3D, m_nCnt);
                        SVec3D[m_nCnt - 1] = new SVector3D_t();
                        SVec3D[m_nCnt - 1].x = fX;
                        SVec3D[m_nCnt - 1].y = fY;
                        SVec3D[m_nCnt - 1].z = fZ;
#else
                        m_lstModelIndex.Add(m_nModelIndex);
                        m_lstSVec4D.Add(new SVector4D_t(fX, fY, fZ, 0));
                        m_nCnt = m_lstSVec4D.Count;
#endif
                    }
                    catch (Exception e)
                    {
                        MessageBox.Show(e.ToString());
                    }
                    return m_nCnt;
                }
                public int Data_Add_First(float fX, float fY, float fZ, float fW)
                {
                    try
                    {
                        m_lstModelIndex.Add(++m_nModelIndex);
                        m_lstSVec4D.Add(new SVector4D_t(fX, fY, fZ, fW));
                        m_nCnt = m_lstSVec4D.Count;
                    }
                    catch (Exception e)
                    {
                        MessageBox.Show(e.ToString());
                    }
                    return m_nCnt;
                }
                public int Data_Add_First(float fX, float fY, float fZ)
                {
                    try
                    {
#if false
                        m_nCnt = (SVec3D == null) ? 1 : m_nCnt + 1;
                        Array.Resize(ref SVec3D, m_nCnt);
                        SVec3D[m_nCnt - 1] = new SVector3D_t();
                        SVec3D[m_nCnt - 1].x = fX;
                        SVec3D[m_nCnt - 1].y = fY;
                        SVec3D[m_nCnt - 1].z = fZ;
#else
                        m_lstModelIndex.Add(++m_nModelIndex);
                        m_lstSVec4D.Add(new SVector4D_t(fX, fY, fZ, 0));
                        m_nCnt = m_lstSVec4D.Count;
#endif
                    }
                    catch (Exception e)
                    {
                        MessageBox.Show(e.ToString());
                    }
                    return m_nCnt;
                }
                public int Data_Get_ModelIndex(int nIndex) { return m_lstModelIndex[nIndex]; }
                public SVector4D_t Data_Get(int nIndex)
                {
                    //if ((nIndex >= 0) && (nIndex < m_nCnt))
                    return m_lstSVec4D[nIndex];
                    //return m_lstSVec3D[0];
                }
                public SVector4D_t[] Data_Get()
                {
                    return m_lstSVec4D.ToArray();
                }
                //public SVector3D_t[] Data_Get()
                //{
                //    return m_lstSVec3D.ToArray();
                //}
                public void Data_Set(int nIndex, float fX, float fY, float fZ, float fW)
                {
                    if ((nIndex >= 0) && (nIndex < m_nCnt))
                    {
                        m_lstSVec4D[nIndex] = (new SVector4D_t(fX, fY, fZ, fW));
                    }
                }
                public void Data_Set(int nIndex, float fX, float fY, float fZ)
                {
                    if ((nIndex >= 0) && (nIndex < m_nCnt))
                    {
                        m_lstSVec4D[nIndex] = (new SVector4D_t(fX, fY, fZ, 0));
                    }
                }

                public void DataResult_Clear()
                {
                    m_lstSSVec4D_Result.Clear();// = null;
                    m_nCnt_Result = 0;
                }
                public int DataResult_GetCnt()
                {
                    return m_nCnt_Result;
                }
                public int DataResult_Add(float fX, float fY, float fZ)
                {
                    try
                    {
                        m_lstSSVec4D_Result[m_nCnt_Result - 1] = (new SVector4D_t(fX, fY, fZ, 0));
                        m_nCnt_Result = m_lstSSVec4D_Result.Count;
                    }
                    catch (Exception e)
                    {
                        MessageBox.Show(e.ToString());
                    }
                    return m_nCnt_Result;
                }
                public int DataResult_Add(float fX, float fY, float fZ, float fW)
                {
                    try
                    {
                        m_lstSSVec4D_Result[m_nCnt_Result - 1] = (new SVector4D_t(fX, fY, fZ, fW));
                        m_nCnt_Result = m_lstSSVec4D_Result.Count;
                    }
                    catch (Exception e)
                    {
                        MessageBox.Show(e.ToString());
                    }
                    return m_nCnt_Result;
                }
                public SVector4D_t[] DataResult_Get() { return m_lstSSVec4D_Result.ToArray(); }
                public SVector4D_t DataResult_Get(int nIndex)
                {
                    if ((nIndex >= 0) && (nIndex < m_nCnt_Result))
                        return m_lstSSVec4D_Result[nIndex];
                    return m_lstSSVec4D_Result[0];
                }
                public void DataResult_Set(int nIndex, float fX, float fY, float fZ)
                {
                    if ((nIndex >= 0) && (nIndex < m_nCnt_Result))
                    {
                        m_lstSSVec4D_Result[nIndex] = (new SVector4D_t(fX, fY, fZ, 0));
                    }
                }
                public void DataResult_Set(int nIndex, float fX, float fY, float fZ, float fW)
                {
                    if ((nIndex >= 0) && (nIndex < m_nCnt_Result))
                    {
                        m_lstSSVec4D_Result[nIndex] = (new SVector4D_t(fX, fY, fZ, fW));
                    }
                }


                public int Face_GetCnt()
                {
                    return m_nCnt_Face;
                }

                public int Face_Add(int A, int B, int C)
                {
                    try
                    {
                        m_lstSFace.Add(new SPoint3D_t(A, B, C));
                        m_nCnt_Face = m_lstSFace.Count;
                    }
                    catch (Exception e)
                    {
                        MessageBox.Show(e.ToString());
                    }
                    return m_nCnt_Face;
                }
                public SPoint3D_t[] Face_Get() { return m_lstSFace.ToArray(); }
                public SPoint3D_t Face_Get(int nIndex) { return m_lstSFace[nIndex]; }
                public void Face_Get(int nIndex, out int A, out int B, out int C)
                {
                    if ((nIndex >= 0) && (nIndex < m_nCnt_Face))
                    {
                        //return SFace[nIndex];
                        A = m_lstSFace[nIndex].x;
                        B = m_lstSFace[nIndex].y;
                        C = m_lstSFace[nIndex].z;
                        return;
                    }
                    A = B = C = 0;
                    //return SVec3D[0];
                }
                public void Face_Set(int nIndex, int A, int B, int C)
                {
                    if ((nIndex >= 0) && (nIndex < m_nCnt_Face))
                    {
                        SPoint3D_t SPnt = new SPoint3D_t(A, B, C);
                        m_lstSFace[nIndex] = SPnt;
                    }
                }
                public void Face_Set(int nIndex, SPoint3D_t SPnt)
                {
                    if ((nIndex >= 0) && (nIndex < m_nCnt_Face))
                    {
                        m_lstSFace[nIndex] = SPnt;
                    }
                }
            }
        }
    }
}
